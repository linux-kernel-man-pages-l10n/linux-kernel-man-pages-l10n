# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-04-02 18:52+0300\n"
"PO-Revision-Date: 2019-04-02 15:53+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Belarusian (Belarus) (http://www.transifex.com/kruvalig/man-pages/language/be_BY/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: be_BY\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

#. type: TH
#: man-pages/man7/bpf-helpers.7:31
#, no-wrap
msgid "BPF-HELPERS"
msgstr ""

#. type: TH
#: man-pages/man7/bpf-helpers.7:31
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: man-pages/man7/bpf-helpers.7:31
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man7/bpf-helpers.7:31
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: man-pages/man7/bpf-helpers.7:32
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:34
msgid "BPF-HELPERS - list of eBPF helper functions"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:42
msgid ""
"\\e$1 \\en[an-margin] level \\en[rst2man-indent-level] level margin: \\en"
"[rst2man-indent\\en[rst2man-indent-level]] \\en[rst2man-indent0] \\en"
"[rst2man-indent1] \\en[rst2man-indent2]"
msgstr ""

#. type: SH
#: man-pages/man7/bpf-helpers.7:58
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:67
msgid ""
"The extended Berkeley Packet Filter (eBPF) subsystem consists in programs "
"written in a pseudo-assembly language, then attached to one of the several "
"kernel hooks and run in reaction of specific events. This framework differs "
"from the older, \"classic\" BPF (or \"cBPF\") in several aspects, one of "
"them being the ability to call special functions (or \"helpers\") from "
"within a program.  These functions are restricted to a white-list of helpers"
" defined in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:74
msgid ""
"These helpers are used by eBPF programs to interact with the system, or with"
" the context in which they work. For instance, they can be used to print "
"debugging messages, to get the time since the system was booted, to interact"
" with eBPF maps, or to manipulate network packets. Since there are several "
"eBPF program types, and that they do not run in the same context, each "
"program type can only call a subset of those helpers."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:76
msgid ""
"Due to eBPF conventions, a helper can not have more than five arguments."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:80
msgid ""
"Internally, eBPF programs call directly into the compiled helper functions "
"without requiring any foreign-function interface. As a result, calling "
"helpers introduces no overhead, thus offering excellent performance."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:84
msgid ""
"This document is an attempt to list and document the helpers available to "
"eBPF developers. They are sorted by chronological order (the oldest helpers "
"in the kernel at the top)."
msgstr ""

#. type: SH
#: man-pages/man7/bpf-helpers.7:84
#, no-wrap
msgid "HELPERS"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:86
#, no-wrap
msgid ""
"B<void *bpf_map_lookup_elem(struct bpf_map *>I<map>B<, const void "
"*>I<key>B<)>"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:89 man-pages/man7/bpf-helpers.7:100
#: man-pages/man7/bpf-helpers.7:126 man-pages/man7/bpf-helpers.7:136
#: man-pages/man7/bpf-helpers.7:150 man-pages/man7/bpf-helpers.7:161
#: man-pages/man7/bpf-helpers.7:171 man-pages/man7/bpf-helpers.7:250
#: man-pages/man7/bpf-helpers.7:266 man-pages/man7/bpf-helpers.7:279
#: man-pages/man7/bpf-helpers.7:299 man-pages/man7/bpf-helpers.7:328
#: man-pages/man7/bpf-helpers.7:364 man-pages/man7/bpf-helpers.7:399
#: man-pages/man7/bpf-helpers.7:445 man-pages/man7/bpf-helpers.7:460
#: man-pages/man7/bpf-helpers.7:490 man-pages/man7/bpf-helpers.7:510
#: man-pages/man7/bpf-helpers.7:526 man-pages/man7/bpf-helpers.7:586
#: man-pages/man7/bpf-helpers.7:638 man-pages/man7/bpf-helpers.7:670
#: man-pages/man7/bpf-helpers.7:696 man-pages/man7/bpf-helpers.7:724
#: man-pages/man7/bpf-helpers.7:777 man-pages/man7/bpf-helpers.7:798
#: man-pages/man7/bpf-helpers.7:854 man-pages/man7/bpf-helpers.7:889
#: man-pages/man7/bpf-helpers.7:911 man-pages/man7/bpf-helpers.7:925
#: man-pages/man7/bpf-helpers.7:955 man-pages/man7/bpf-helpers.7:990
#: man-pages/man7/bpf-helpers.7:1009 man-pages/man7/bpf-helpers.7:1036
#: man-pages/man7/bpf-helpers.7:1059 man-pages/man7/bpf-helpers.7:1079
#: man-pages/man7/bpf-helpers.7:1107 man-pages/man7/bpf-helpers.7:1147
#: man-pages/man7/bpf-helpers.7:1163 man-pages/man7/bpf-helpers.7:1174
#: man-pages/man7/bpf-helpers.7:1189 man-pages/man7/bpf-helpers.7:1214
#: man-pages/man7/bpf-helpers.7:1233 man-pages/man7/bpf-helpers.7:1284
#: man-pages/man7/bpf-helpers.7:1301 man-pages/man7/bpf-helpers.7:1312
#: man-pages/man7/bpf-helpers.7:1334 man-pages/man7/bpf-helpers.7:1344
#: man-pages/man7/bpf-helpers.7:1375 man-pages/man7/bpf-helpers.7:1402
#: man-pages/man7/bpf-helpers.7:1425 man-pages/man7/bpf-helpers.7:1440
#: man-pages/man7/bpf-helpers.7:1467 man-pages/man7/bpf-helpers.7:1500
#: man-pages/man7/bpf-helpers.7:1559 man-pages/man7/bpf-helpers.7:1574
#: man-pages/man7/bpf-helpers.7:1601 man-pages/man7/bpf-helpers.7:1629
#: man-pages/man7/bpf-helpers.7:1679 man-pages/man7/bpf-helpers.7:1697
#: man-pages/man7/bpf-helpers.7:1737 man-pages/man7/bpf-helpers.7:1758
#: man-pages/man7/bpf-helpers.7:1792 man-pages/man7/bpf-helpers.7:1813
#: man-pages/man7/bpf-helpers.7:1831 man-pages/man7/bpf-helpers.7:1851
#: man-pages/man7/bpf-helpers.7:1897 man-pages/man7/bpf-helpers.7:1926
#: man-pages/man7/bpf-helpers.7:1969 man-pages/man7/bpf-helpers.7:1996
#: man-pages/man7/bpf-helpers.7:2014 man-pages/man7/bpf-helpers.7:2032
#: man-pages/man7/bpf-helpers.7:2063 man-pages/man7/bpf-helpers.7:2082
#: man-pages/man7/bpf-helpers.7:2102 man-pages/man7/bpf-helpers.7:2140
#: man-pages/man7/bpf-helpers.7:2169 man-pages/man7/bpf-helpers.7:2191
#: man-pages/man7/bpf-helpers.7:2211 man-pages/man7/bpf-helpers.7:2241
#: man-pages/man7/bpf-helpers.7:2263 man-pages/man7/bpf-helpers.7:2276
#: man-pages/man7/bpf-helpers.7:2319 man-pages/man7/bpf-helpers.7:2362
#: man-pages/man7/bpf-helpers.7:2374 man-pages/man7/bpf-helpers.7:2384
#: man-pages/man7/bpf-helpers.7:2394 man-pages/man7/bpf-helpers.7:2414
#: man-pages/man7/bpf-helpers.7:2430
#, no-wrap
msgid "B<Description>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:92
msgid "Perform a lookup in I<map> for an entry associated to I<key>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:92 man-pages/man7/bpf-helpers.7:119
#: man-pages/man7/bpf-helpers.7:129 man-pages/man7/bpf-helpers.7:143
#: man-pages/man7/bpf-helpers.7:154 man-pages/man7/bpf-helpers.7:164
#: man-pages/man7/bpf-helpers.7:242 man-pages/man7/bpf-helpers.7:259
#: man-pages/man7/bpf-helpers.7:272 man-pages/man7/bpf-helpers.7:292
#: man-pages/man7/bpf-helpers.7:321 man-pages/man7/bpf-helpers.7:357
#: man-pages/man7/bpf-helpers.7:392 man-pages/man7/bpf-helpers.7:420
#: man-pages/man7/bpf-helpers.7:427 man-pages/man7/bpf-helpers.7:437
#: man-pages/man7/bpf-helpers.7:453 man-pages/man7/bpf-helpers.7:483
#: man-pages/man7/bpf-helpers.7:503 man-pages/man7/bpf-helpers.7:519
#: man-pages/man7/bpf-helpers.7:579 man-pages/man7/bpf-helpers.7:631
#: man-pages/man7/bpf-helpers.7:662 man-pages/man7/bpf-helpers.7:686
#: man-pages/man7/bpf-helpers.7:716 man-pages/man7/bpf-helpers.7:770
#: man-pages/man7/bpf-helpers.7:791 man-pages/man7/bpf-helpers.7:846
#: man-pages/man7/bpf-helpers.7:881 man-pages/man7/bpf-helpers.7:904
#: man-pages/man7/bpf-helpers.7:918 man-pages/man7/bpf-helpers.7:948
#: man-pages/man7/bpf-helpers.7:983 man-pages/man7/bpf-helpers.7:994
#: man-pages/man7/bpf-helpers.7:1022 man-pages/man7/bpf-helpers.7:1029
#: man-pages/man7/bpf-helpers.7:1052 man-pages/man7/bpf-helpers.7:1064
#: man-pages/man7/bpf-helpers.7:1100 man-pages/man7/bpf-helpers.7:1140
#: man-pages/man7/bpf-helpers.7:1155 man-pages/man7/bpf-helpers.7:1182
#: man-pages/man7/bpf-helpers.7:1207 man-pages/man7/bpf-helpers.7:1226
#: man-pages/man7/bpf-helpers.7:1275 man-pages/man7/bpf-helpers.7:1293
#: man-pages/man7/bpf-helpers.7:1305 man-pages/man7/bpf-helpers.7:1316
#: man-pages/man7/bpf-helpers.7:1323 man-pages/man7/bpf-helpers.7:1338
#: man-pages/man7/bpf-helpers.7:1368 man-pages/man7/bpf-helpers.7:1395
#: man-pages/man7/bpf-helpers.7:1418 man-pages/man7/bpf-helpers.7:1433
#: man-pages/man7/bpf-helpers.7:1460 man-pages/man7/bpf-helpers.7:1493
#: man-pages/man7/bpf-helpers.7:1552 man-pages/man7/bpf-helpers.7:1567
#: man-pages/man7/bpf-helpers.7:1594 man-pages/man7/bpf-helpers.7:1623
#: man-pages/man7/bpf-helpers.7:1669 man-pages/man7/bpf-helpers.7:1690
#: man-pages/man7/bpf-helpers.7:1731 man-pages/man7/bpf-helpers.7:1752
#: man-pages/man7/bpf-helpers.7:1785 man-pages/man7/bpf-helpers.7:1806
#: man-pages/man7/bpf-helpers.7:1824 man-pages/man7/bpf-helpers.7:1844
#: man-pages/man7/bpf-helpers.7:1889 man-pages/man7/bpf-helpers.7:1919
#: man-pages/man7/bpf-helpers.7:1954 man-pages/man7/bpf-helpers.7:1989
#: man-pages/man7/bpf-helpers.7:2007 man-pages/man7/bpf-helpers.7:2025
#: man-pages/man7/bpf-helpers.7:2056 man-pages/man7/bpf-helpers.7:2075
#: man-pages/man7/bpf-helpers.7:2095 man-pages/man7/bpf-helpers.7:2133
#: man-pages/man7/bpf-helpers.7:2163 man-pages/man7/bpf-helpers.7:2185
#: man-pages/man7/bpf-helpers.7:2204 man-pages/man7/bpf-helpers.7:2226
#: man-pages/man7/bpf-helpers.7:2233 man-pages/man7/bpf-helpers.7:2256
#: man-pages/man7/bpf-helpers.7:2269 man-pages/man7/bpf-helpers.7:2310
#: man-pages/man7/bpf-helpers.7:2353 man-pages/man7/bpf-helpers.7:2367
#: man-pages/man7/bpf-helpers.7:2377 man-pages/man7/bpf-helpers.7:2387
#: man-pages/man7/bpf-helpers.7:2407 man-pages/man7/bpf-helpers.7:2423
#: man-pages/man7/bpf-helpers.7:2441
#, no-wrap
msgid "B<Return>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:96
msgid "Map value associated to I<key>, or B<NULL> if no entry was found."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:97
#, no-wrap
msgid ""
"B<int bpf_map_update_elem(struct bpf_map *>I<map>B<, const void *>I<key>B<, "
"const void *>I<value>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:104
msgid ""
"Add or update the value of the entry associated to I<key> in I<map> with "
"I<value>\\&. I<flags> is one of:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:105 man-pages/man7/bpf-helpers.7:1446
#: man-pages/man7/bpf-helpers.7:1975
#, no-wrap
msgid "B<BPF_NOEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:108 man-pages/man7/bpf-helpers.7:1449
#: man-pages/man7/bpf-helpers.7:1978
msgid "The entry for I<key> must not exist in the map."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:108 man-pages/man7/bpf-helpers.7:1449
#: man-pages/man7/bpf-helpers.7:1978
#, no-wrap
msgid "B<BPF_EXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:111 man-pages/man7/bpf-helpers.7:1452
#: man-pages/man7/bpf-helpers.7:1981
msgid "The entry for I<key> must already exist in the map."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:111 man-pages/man7/bpf-helpers.7:1452
#: man-pages/man7/bpf-helpers.7:1981
#, no-wrap
msgid "B<BPF_ANY>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:114 man-pages/man7/bpf-helpers.7:1455
#: man-pages/man7/bpf-helpers.7:1984
msgid "No condition on the existence of the entry for I<key>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:119
msgid ""
"Flag value B<BPF_NOEXIST> cannot be used for maps of types "
"B<BPF_MAP_TYPE_ARRAY> or B<BPF_MAP_TYPE_PERCPU_ARRAY> (all elements always "
"exist), the helper would return an error."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:122 man-pages/man7/bpf-helpers.7:132
#: man-pages/man7/bpf-helpers.7:146 man-pages/man7/bpf-helpers.7:157
#: man-pages/man7/bpf-helpers.7:295 man-pages/man7/bpf-helpers.7:324
#: man-pages/man7/bpf-helpers.7:360 man-pages/man7/bpf-helpers.7:395
#: man-pages/man7/bpf-helpers.7:423 man-pages/man7/bpf-helpers.7:456
#: man-pages/man7/bpf-helpers.7:506 man-pages/man7/bpf-helpers.7:522
#: man-pages/man7/bpf-helpers.7:582 man-pages/man7/bpf-helpers.7:634
#: man-pages/man7/bpf-helpers.7:773 man-pages/man7/bpf-helpers.7:794
#: man-pages/man7/bpf-helpers.7:921 man-pages/man7/bpf-helpers.7:951
#: man-pages/man7/bpf-helpers.7:986 man-pages/man7/bpf-helpers.7:1055
#: man-pages/man7/bpf-helpers.7:1103 man-pages/man7/bpf-helpers.7:1143
#: man-pages/man7/bpf-helpers.7:1210 man-pages/man7/bpf-helpers.7:1229
#: man-pages/man7/bpf-helpers.7:1371 man-pages/man7/bpf-helpers.7:1398
#: man-pages/man7/bpf-helpers.7:1463 man-pages/man7/bpf-helpers.7:1496
#: man-pages/man7/bpf-helpers.7:1555 man-pages/man7/bpf-helpers.7:1570
#: man-pages/man7/bpf-helpers.7:1597 man-pages/man7/bpf-helpers.7:1788
#: man-pages/man7/bpf-helpers.7:1809 man-pages/man7/bpf-helpers.7:1827
#: man-pages/man7/bpf-helpers.7:1847 man-pages/man7/bpf-helpers.7:1922
#: man-pages/man7/bpf-helpers.7:1992 man-pages/man7/bpf-helpers.7:2059
#: man-pages/man7/bpf-helpers.7:2078 man-pages/man7/bpf-helpers.7:2098
#: man-pages/man7/bpf-helpers.7:2136 man-pages/man7/bpf-helpers.7:2272
#: man-pages/man7/bpf-helpers.7:2370 man-pages/man7/bpf-helpers.7:2380
#: man-pages/man7/bpf-helpers.7:2390 man-pages/man7/bpf-helpers.7:2410
#: man-pages/man7/bpf-helpers.7:2426
msgid "0 on success, or a negative error in case of failure."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:123
#, no-wrap
msgid ""
"B<int bpf_map_delete_elem(struct bpf_map *>I<map>B<, const void *>I<key>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:129
msgid "Delete entry with I<key> from I<map>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:133
#, no-wrap
msgid ""
"B<int bpf_map_push_elem(struct bpf_map *>I<map>B<, const void *>I<value>B<, "
"u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:139
msgid "Push an element I<value> in I<map>\\&. I<flags> is one of:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:143
msgid ""
"B<BPF_EXIST> If the queue/stack is full, the oldest element is removed to "
"make room for this."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:147
#, no-wrap
msgid ""
"B<int bpf_probe_read(void *>I<dst>B<, u32 >I<size>B<, const void "
"*>I<src>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:154
msgid ""
"For tracing programs, safely attempt to read I<size> bytes from address "
"I<src> and store the data in I<dst>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:158
#, no-wrap
msgid "B<u64 bpf_ktime_get_ns(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:164
msgid "Return the time elapsed since system boot, in nanoseconds."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:167
msgid "Current I<ktime>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:168
#, no-wrap
msgid ""
"B<int bpf_trace_printk(const char *>I<fmt>B<, u32 >I<fmt_size>B<, ...)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:179
msgid ""
"This helper is a \"printk()-like\" facility for debugging. It prints a "
"message defined by format I<fmt> (of size I<fmt_size>)  to file "
"I</sys/kernel/debug/tracing/trace> from DebugFS, if available. It can take "
"up to three additional B<u64> arguments (as an eBPF helpers, the total "
"number of arguments is limited to five)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:186
msgid ""
"Each time the helper is called, it appends a line to the trace.  The format "
"of the trace is customizable, and the exact output one will get depends on "
"the options set in I</sys/kernel/debug/tracing/trace_options> (see also the "
"I<README> file under the same directory). However, it usually defaults to "
"something like:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:192
#, no-wrap
msgid ""
"telnet-470   [001] .N.. 419421.045894: 0x00000001: E<lt>formatted msgE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:198
msgid "In the above:"
msgstr ""

#. type: IP
#: man-pages/man7/bpf-helpers.7:201 man-pages/man7/bpf-helpers.7:203
#: man-pages/man7/bpf-helpers.7:205 man-pages/man7/bpf-helpers.7:208
#: man-pages/man7/bpf-helpers.7:215 man-pages/man7/bpf-helpers.7:217
#: man-pages/man7/bpf-helpers.7:220 man-pages/man7/bpf-helpers.7:763
#: man-pages/man7/bpf-helpers.7:765 man-pages/man7/bpf-helpers.7:767
#: man-pages/man7/bpf-helpers.7:865 man-pages/man7/bpf-helpers.7:868
#: man-pages/man7/bpf-helpers.7:871 man-pages/man7/bpf-helpers.7:998
#: man-pages/man7/bpf-helpers.7:1000 man-pages/man7/bpf-helpers.7:1002
#: man-pages/man7/bpf-helpers.7:1068 man-pages/man7/bpf-helpers.7:1070
#: man-pages/man7/bpf-helpers.7:1072 man-pages/man7/bpf-helpers.7:1355
#: man-pages/man7/bpf-helpers.7:1359 man-pages/man7/bpf-helpers.7:1363
#: man-pages/man7/bpf-helpers.7:1365 man-pages/man7/bpf-helpers.7:1382
#: man-pages/man7/bpf-helpers.7:1586 man-pages/man7/bpf-helpers.7:1589
#: man-pages/man7/bpf-helpers.7:1591 man-pages/man7/bpf-helpers.7:1647
#: man-pages/man7/bpf-helpers.7:1649 man-pages/man7/bpf-helpers.7:1651
#: man-pages/man7/bpf-helpers.7:1658 man-pages/man7/bpf-helpers.7:1660
#: man-pages/man7/bpf-helpers.7:1662 man-pages/man7/bpf-helpers.7:1664
#: man-pages/man7/bpf-helpers.7:1666 man-pages/man7/bpf-helpers.7:1704
#: man-pages/man7/bpf-helpers.7:1708 man-pages/man7/bpf-helpers.7:1957
#: man-pages/man7/bpf-helpers.7:1959 man-pages/man7/bpf-helpers.7:1961
#: man-pages/man7/bpf-helpers.7:2450 man-pages/man7/bpf-helpers.7:2452
#: man-pages/man7/bpf-helpers.7:2488 man-pages/man7/bpf-helpers.7:2492
#: man-pages/man7/bpf-helpers.7:2495 man-pages/man7/bpf-helpers.7:2498
#: man-pages/man7/bpf-helpers.7:2501
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:203
msgid "B<telnet> is the name of the current task."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:205
msgid "B<470> is the PID of the current task."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:208
msgid "B<001> is the CPU number on which the task is running."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:215
msgid ""
"In B<\\&.N..>, each character refers to a set of options (whether irqs are "
"enabled, scheduling options, whether hard/softirqs are running, level of "
"preempt_disabled respectively). B<N> means that B<TIF_NEED_RESCHED> and "
"B<PREEMPT_NEED_RESCHED> are set."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:217
msgid "B<419421.045894> is a timestamp."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:220
msgid ""
"B<0x00000001> is a fake value used by BPF for the instruction pointer "
"register."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:223
msgid "B<E<lt>formatted msgE<gt>> is the message formatted with I<fmt>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:234
msgid ""
"The conversion specifiers supported by I<fmt> are similar, but more limited "
"than for printk(). They are B<%d>, B<%i>, B<%u>, B<%x>, B<%ld>, B<%li>, "
"B<%lu>, B<%lx>, B<%lld>, B<%lli>, B<%llu>, B<%llx>, B<%p>, B<%s>\\&. No "
"modifier (size of field, padding with zeroes, etc.) is available, and the "
"helper will return B<-EINVAL> (but print nothing) if it encounters an "
"unknown specifier."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:242
msgid ""
"Also, note that B<bpf_trace_printk>() is slow, and should only be used for "
"debugging purposes. For this reason, a notice bloc (spanning several lines) "
"is printed to kernel logs and states that the helper should not be used "
"\"for production use\" the first time this helper is used (or more "
"precisely, when B<trace_printk>() buffers are allocated). For passing values"
" to user space, perf events should be preferred."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:246
msgid ""
"The number of bytes written to the buffer, or a negative error in case of "
"failure."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:247
#, no-wrap
msgid "B<u32 bpf_get_prandom_u32(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:253
msgid "Get a pseudo-random number."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:259
msgid ""
"From a security point of view, this helper uses its own pseudo-random "
"internal state, and cannot be used to infer the seed of other random "
"functions in the kernel. However, it is essential to note that the generator"
" used by the helper is not cryptographically secure."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:262
msgid "A random 32-bit unsigned value."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:263
#, no-wrap
msgid "B<u32 bpf_get_smp_processor_id(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:272
msgid ""
"Get the SMP (symmetric multiprocessing) processor id. Note that all programs"
" run with preemption disabled, which means that the SMP processor id is "
"stable during all the execution of the program."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:275
msgid "The SMP id of the processor running the program."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:276
#, no-wrap
msgid ""
"B<int bpf_skb_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, const"
" void *>I<from>B<, u32 >I<len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:286
msgid ""
"Store I<len> bytes from address I<from> into the packet associated to "
"I<skb>, at I<offset>\\&. I<flags> are a combination of "
"B<BPF_F_RECOMPUTE_CSUM> (automatically recompute the checksum for the packet"
" after storing the bytes) and B<BPF_F_INVALIDATE_HASH> (set "
"I<skb>B<-E<gt>hash>, I<skb>B<-E<gt>swhash> and I<skb>B<-E<gt>l4hash> to 0)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:292 man-pages/man7/bpf-helpers.7:321
#: man-pages/man7/bpf-helpers.7:357 man-pages/man7/bpf-helpers.7:420
#: man-pages/man7/bpf-helpers.7:503 man-pages/man7/bpf-helpers.7:519
#: man-pages/man7/bpf-helpers.7:948 man-pages/man7/bpf-helpers.7:1100
#: man-pages/man7/bpf-helpers.7:1140 man-pages/man7/bpf-helpers.7:1207
#: man-pages/man7/bpf-helpers.7:1226 man-pages/man7/bpf-helpers.7:1395
#: man-pages/man7/bpf-helpers.7:1493 man-pages/man7/bpf-helpers.7:1782
#: man-pages/man7/bpf-helpers.7:1824 man-pages/man7/bpf-helpers.7:2056
#: man-pages/man7/bpf-helpers.7:2075 man-pages/man7/bpf-helpers.7:2095
#: man-pages/man7/bpf-helpers.7:2133
msgid ""
"A call to this helper is susceptible to change the underlaying packet "
"buffer. Therefore, at load time, all checks on pointers previously done by "
"the verifier are invalidated and must be performed again, if the helper is "
"used in combination with direct packet access."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:296
#, no-wrap
msgid ""
"B<int bpf_l3_csum_replace(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, u64 "
">I<from>B<, u64 >I<to>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:310
msgid ""
"Recompute the layer 3 (e.g. IP) checksum for the packet associated to "
"I<skb>\\&. Computation is incremental, so the helper must know the former "
"value of the header field that was modified (I<from>), the new value of this"
" field (I<to>), and the number of bytes (2 or 4) for this field, stored in "
"I<size>\\&.  Alternatively, it is possible to store the difference between "
"the previous and the new values of the header field in I<to>, by setting "
"I<from> and I<size> to 0. For both methods, I<offset> indicates the location"
" of the IP checksum within the packet."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:315 man-pages/man7/bpf-helpers.7:351
msgid ""
"This helper works in combination with B<bpf_csum_diff>(), which does not "
"update the checksum in-place, but offers more flexibility and can handle "
"sizes larger than 2 or 4 for the checksum to update."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:325
#, no-wrap
msgid ""
"B<int bpf_l4_csum_replace(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, u64 "
">I<from>B<, u64 >I<to>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:346
msgid ""
"Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the packet "
"associated to I<skb>\\&. Computation is incremental, so the helper must know"
" the former value of the header field that was modified (I<from>), the new "
"value of this field (I<to>), and the number of bytes (2 or 4) for this "
"field, stored on the lowest four bits of I<flags>\\&. Alternatively, it is "
"possible to store the difference between the previous and the new values of "
"the header field in I<to>, by setting I<from> and the four lowest bits of "
"I<flags> to 0. For both methods, I<offset> indicates the location of the IP "
"checksum within the packet. In addition to the size of the field, I<flags> "
"can be added (bitwise OR) actual flags. With B<BPF_F_MARK_MANGLED_0>, a null"
" checksum is left untouched (unless B<BPF_F_MARK_ENFORCE> is added as well),"
" and for updates resulting in a null checksum the value is set to "
"B<CSUM_MANGLED_0> instead. Flag B<BPF_F_PSEUDO_HDR> indicates the checksum "
"is to be computed against a pseudo-header."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:361
#, no-wrap
msgid ""
"B<int bpf_tail_call(void *>I<ctx>B<, struct bpf_map *>I<prog_array_map>B<, "
"u32 >I<index>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:375
msgid ""
"This special helper is used to trigger a \"tail call\", or in other words, "
"to jump into another eBPF program. The same stack frame is used (but values "
"on stack and in registers for the caller are not accessible to the callee). "
"This mechanism allows for program chaining, either for raising the maximum "
"number of available eBPF instructions, or to execute given programs in "
"conditional blocks. For security reasons, there is an upper limit to the "
"number of successive tail calls that can be performed."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:380
msgid ""
"Upon call of this helper, the program attempts to jump into a program "
"referenced at index I<index> in I<prog_array_map>, a special map of type "
"B<BPF_MAP_TYPE_PROG_ARRAY>, and passes I<ctx>, a pointer to the context."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:392
msgid ""
"If the call succeeds, the kernel immediately runs the first instruction of "
"the new program. This is not a function call, and it never returns to the "
"previous program. If the call fails, then the helper has no effect, and the "
"caller continues to run its subsequent instructions. A call can fail if the "
"destination program for the jump does not exist (i.e. I<index> is superior "
"to the number of entries in I<prog_array_map>), or if the maximum number of "
"tail calls has been reached for this chain of programs. This limit is "
"defined in the kernel by the macro B<MAX_TAIL_CALL_CNT> (not accessible to "
"user space), which is currently set to 32."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:396
#, no-wrap
msgid ""
"B<int bpf_clone_redirect(struct sk_buff *>I<skb>B<, u32 >I<ifindex>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:407
msgid ""
"Clone and redirect the packet associated to I<skb> to another net device of "
"index I<ifindex>\\&. Both ingress and egress interfaces can be used for "
"redirection. The B<BPF_F_INGRESS> value in I<flags> is used to make the "
"distinction (ingress path is selected if the flag is present, egress path "
"otherwise).  This is the only flag supported for now."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:414
msgid ""
"In comparison with B<bpf_redirect>() helper, B<bpf_clone_redirect>() has the"
" associated cost of duplicating the packet buffer, but this can be executed "
"out of the eBPF program. Conversely, B<bpf_redirect>() is more efficient, "
"but it is handled through an action code where the redirection happens only "
"after the eBPF program has returned."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:424
#, no-wrap
msgid "B<u64 bpf_get_current_pid_tgid(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:433
msgid ""
"A 64-bit integer containing the current tgid and pid, and created as such: "
"I<current_task>B<-E<gt>tgid E<lt>E<lt> 32 |> I<current_task>B<-E<gt>pid>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:434
#, no-wrap
msgid "B<u64 bpf_get_current_uid_gid(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:441
msgid ""
"A 64-bit integer containing the current GID and UID, and created as such: "
"I<current_gid> B<E<lt>E<lt> 32 |> I<current_uid>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:442
#, no-wrap
msgid "B<int bpf_get_current_comm(char *>I<buf>B<, u32 >I<size_of_buf>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:453
msgid ""
"Copy the B<comm> attribute of the current task into I<buf> of "
"I<size_of_buf>\\&. The B<comm> attribute contains the name of the executable"
" (excluding the path) for the current task. The I<size_of_buf> must be "
"strictly positive. On success, the helper makes sure that the I<buf> is NUL-"
"terminated. On failure, it is filled with zeroes."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:457
#, no-wrap
msgid "B<u32 bpf_get_cgroup_classid(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:464
msgid ""
"Retrieve the classid for the current task, i.e. for the net_cls cgroup to "
"which I<skb> belongs."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:466
msgid "This helper can be used on TC egress path, but not on ingress."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:472
msgid ""
"The net_cls cgroup provides an interface to tag network packets based on a "
"user-provided identifier for all traffic coming from the tasks belonging to "
"the related cgroup. See also the related kernel documentation, available "
"from the Linux sources in file I<Documentation/cgroup-v1/net_cls.txt>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:479
msgid ""
"The Linux kernel has two versions for cgroups: there are cgroups v1 and "
"cgroups v2. Both are available to users, who can use a mixture of them, but "
"note that the net_cls cgroup is for cgroup v1 only. This makes it "
"incompatible with BPF programs run on cgroups, which is a cgroup-v2-only "
"feature (a socket can only hold data for one version of cgroups at a time)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:483
msgid ""
"This helper is only available is the kernel was compiled with the "
"B<CONFIG_CGROUP_NET_CLASSID> configuration option set to \"B<y>\" or to "
"\"B<m>\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:486
msgid "The classid, or 0 for the default unconfigured classid."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:487
#, no-wrap
msgid ""
"B<int bpf_skb_vlan_push(struct sk_buff *>I<skb>B<, __be16 >I<vlan_proto>B<, "
"u16 >I<vlan_tci>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:497
msgid ""
"Push a I<vlan_tci> (VLAN tag control information) of protocol I<vlan_proto> "
"to the packet associated to I<skb>, then update the checksum. Note that if "
"I<vlan_proto> is different from B<ETH_P_8021Q> and B<ETH_P_8021AD>, it is "
"considered to be B<ETH_P_8021Q>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:507
#, no-wrap
msgid "B<int bpf_skb_vlan_pop(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:513
msgid "Pop a VLAN header from the packet associated to I<skb>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:523
#, no-wrap
msgid ""
"B<int bpf_skb_get_tunnel_key(struct sk_buff *>I<skb>B<, struct "
"bpf_tunnel_key *>I<key>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:534
msgid ""
"Get tunnel metadata. This helper takes a pointer I<key> to an empty B<struct"
" bpf_tunnel_key> of B<size>, that will be filled with tunnel metadata for "
"the packet associated to I<skb>\\&.  The I<flags> can be set to "
"B<BPF_F_TUNINFO_IPV6>, which indicates that the tunnel is based on IPv6 "
"protocol instead of IPv4."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:545
msgid ""
"The B<struct bpf_tunnel_key> is an object that generalizes the principal "
"parameters used by various tunneling protocols into a single struct. This "
"way, it can be used to easily make a decision based on the contents of the "
"encapsulation header, \"summarized\" in this struct. In particular, it holds"
" the IP address of the remote end (IPv4 or IPv6, depending on the case)  in "
"I<key>B<-E<gt>remote_ipv4> or I<key>B<-E<gt>remote_ipv6>\\&. Also, this "
"struct exposes the I<key>B<-E<gt>tunnel_id>, which is generally mapped to a "
"VNI (Virtual Network Identifier), making it programmable together with the "
"B<bpf_skb_set_tunnel_key>() helper."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:550
msgid ""
"Let\\(aqs imagine that the following code is part of a program attached to "
"the TC ingress interface, on one end of a GRE tunnel, and is supposed to "
"filter out all messages coming from remote ends with IPv4 address other than"
" 10.0.0.1:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:557
#, no-wrap
msgid ""
"int ret;\n"
"struct bpf_tunnel_key key = {};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:561
#, no-wrap
msgid ""
"ret = bpf_skb_get_tunnel_key(skb, &key, sizeof(key), 0);\n"
"if (ret E<lt> 0)\n"
"        return TC_ACT_SHOT;     // drop packet\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:564
#, no-wrap
msgid ""
"if (key.remote_ipv4 != 0x0a000001)\n"
"        return TC_ACT_SHOT;     // drop packet\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:566
#, no-wrap
msgid "return TC_ACT_OK;               // accept packet\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:576
msgid ""
"This interface can also be used with all encapsulation devices that can "
"operate in \"collect metadata\" mode: instead of having one network device "
"per specific configuration, the \"collect metadata\" mode only requires a "
"single device where the configuration can be extracted from this helper."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:579
msgid ""
"This can be used together with various tunnels such as VXLan, Geneve, GRE or"
" IP in IP (IPIP)."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:583
#, no-wrap
msgid ""
"B<int bpf_skb_set_tunnel_key(struct sk_buff *>I<skb>B<, struct "
"bpf_tunnel_key *>I<key>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:591
msgid ""
"Populate tunnel metadata for packet associated to I<skb.> The tunnel "
"metadata is set to the contents of I<key>, of I<size>\\&. The I<flags> can "
"be set to a combination of the following values:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:592
#, no-wrap
msgid "B<BPF_F_TUNINFO_IPV6>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:596
msgid "Indicate that the tunnel is based on IPv6 protocol instead of IPv4."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:596
#, no-wrap
msgid "B<BPF_F_ZERO_CSUM_TX>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:601
msgid ""
"For IPv4 packets, add a flag to tunnel metadata indicating that checksum "
"computation should be skipped and checksum set to zeroes."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:601
#, no-wrap
msgid "B<BPF_F_DONT_FRAGMENT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:605
msgid ""
"Add a flag to tunnel metadata indicating that the packet should not be "
"fragmented."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:605
#, no-wrap
msgid "B<BPF_F_SEQ_NUMBER>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:612
msgid ""
"Add a flag to tunnel metadata indicating that a sequence number should be "
"added to tunnel header before sending the packet. This flag was added for "
"GRE encapsulation, but might be used with other protocols as well in the "
"future."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:615
msgid "Here is a typical usage on the transmit path:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:624
#, no-wrap
msgid ""
"struct bpf_tunnel_key key;\n"
"     populate key ...\n"
"bpf_skb_set_tunnel_key(skb, &key, sizeof(key), 0);\n"
"bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:631
msgid ""
"See also the description of the B<bpf_skb_get_tunnel_key>()  helper for "
"additional information."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:635
#, no-wrap
msgid "B<u64 bpf_perf_event_read(struct bpf_map *>I<map>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:650
msgid ""
"Read the value of a perf event counter. This helper relies on a I<map> of "
"type B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. The nature of the perf event "
"counter is selected when I<map> is updated with perf event file descriptors."
" The I<map> is an array whose size is the number of available CPUs, and each"
" cell contains a value relative to one CPU. The value to retrieve is "
"indicated by I<flags>, that contains the index of the CPU to look up, masked"
" with B<BPF_F_INDEX_MASK>\\&. Alternatively, I<flags> can be set to "
"B<BPF_F_CURRENT_CPU> to indicate that the value for the current CPU should "
"be retrieved."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:653
msgid ""
"Note that before Linux 4.13, only hardware perf event can be retrieved."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:662
msgid ""
"Also, be aware that the newer helper B<bpf_perf_event_read_value>() is "
"recommended over B<bpf_perf_event_read>() in general. The latter has some "
"ABI quirks where error and counter value are used as a return code (which is"
" wrong to do since ranges may overlap). This issue is fixed with "
"B<bpf_perf_event_read_value>(), which at the same time provides more "
"features over the B<bpf_perf_event_read>() interface. Please refer to the "
"description of B<bpf_perf_event_read_value>() for details."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:666
msgid ""
"The value of the perf event counter read from the map, or a negative error "
"code in case of failure."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:667
#, no-wrap
msgid "B<int bpf_redirect(u32 >I<ifindex>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:675
msgid ""
"Redirect the packet to another net device of index I<ifindex>\\&.  This "
"helper is somewhat similar to B<bpf_clone_redirect>(), except that the "
"packet is not cloned, which provides increased performance."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:682
msgid ""
"Except for XDP, both ingress and egress interfaces can be used for "
"redirection. The B<BPF_F_INGRESS> value in I<flags> is used to make the "
"distinction (ingress path is selected if the flag is present, egress path "
"otherwise). Currently, XDP only supports redirection to the egress "
"interface, and accepts no flag at all."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:686
msgid ""
"The same effect can be attained with the more generic B<bpf_redirect_map>(),"
" which requires specific maps to be used but offers better performance."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:692
msgid ""
"For XDP, the helper returns B<XDP_REDIRECT> on success or B<XDP_ABORTED> on "
"error. For other program types, the values are B<TC_ACT_REDIRECT> on success"
" or B<TC_ACT_SHOT> on error."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:693
#, no-wrap
msgid "B<u32 bpf_get_route_realm(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:704
msgid ""
"Retrieve the realm or the route, that is to say the B<tclassid> field of the"
" destination for the I<skb>\\&. The indentifier retrieved is a user-provided"
" tag, similar to the one used with the net_cls cgroup (see description for "
"B<bpf_get_cgroup_classid>() helper), but here this tag is held by a route (a"
" destination entry), not by a task."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:713
msgid ""
"Retrieving this identifier works with the clsact TC egress hook (see also B"
"<tc-bpf(8)>), or alternatively on conventional classful egress qdiscs, but "
"not on TC ingress path. In case of clsact TC egress hook, this has the "
"advantage that, internally, the destination entry has not been dropped yet "
"in the transmit path. Therefore, the destination entry does not need to be "
"artificially held via B<netif_keep_dst>() for a classful qdisc until the "
"I<skb> is freed."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:716
msgid ""
"This helper is available only if the kernel was compiled with "
"B<CONFIG_IP_ROUTE_CLASSID> configuration option."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:720
msgid ""
"The realm of the route for the packet associated to I<skb>, or 0 if none was"
" found."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:721
#, no-wrap
msgid ""
"B<int bpf_perf_event_output(struct pt_reg *>I<ctx>B<, struct bpf_map "
"*>I<map>B<, u64 >I<flags>B<, void *>I<data>B<, u64 >I<size>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:731
msgid ""
"Write raw I<data> blob into a special BPF perf event held by I<map> of type "
"B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. This perf event must have the following"
" attributes: B<PERF_SAMPLE_RAW> as B<sample_type>, B<PERF_TYPE_SOFTWARE> as "
"B<type>, and B<PERF_COUNT_SW_BPF_OUTPUT> as B<config>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:737
msgid ""
"The I<flags> are used to indicate the index in I<map> for which the value "
"must be put, masked with B<BPF_F_INDEX_MASK>\\&.  Alternatively, I<flags> "
"can be set to B<BPF_F_CURRENT_CPU> to indicate that the index of the current"
" CPU core should be used."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:740
msgid ""
"The value to write, of I<size>, is passed through eBPF stack and pointed by "
"I<data>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:743
msgid "The context of the program I<ctx> needs also be passed to the helper."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:752
msgid ""
"On user space, a program willing to read the values needs to call "
"B<perf_event_open>() on the perf event (either for one or for all CPUs) and "
"to store the file descriptor into the I<map>\\&. This must be done before "
"the eBPF program can send data into it. An example is available in file "
"I<samples/bpf/trace_output_user.c> in the Linux kernel source tree (the eBPF"
" program counterpart is in I<samples/bpf/trace_output_kern.c>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:757
msgid ""
"B<bpf_perf_event_output>() achieves better performance than "
"B<bpf_trace_printk>() for sharing data with user space, and is much better "
"suitable for streaming data from eBPF programs."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:762
msgid ""
"Note that this helper is not restricted to tracing use cases and can be used"
" with programs attached to TC or XDP as well, where it allows for passing "
"data to user space listeners. Data can be:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:765
msgid "Only custom structs,"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:767
msgid "Only the packet payload, or"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:769
msgid "A combination of both."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:774
#, no-wrap
msgid ""
"B<int bpf_skb_load_bytes(const struct sk_buff *>I<skb>B<, u32 >I<offset>B<, "
"void *>I<to>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:783
msgid ""
"This helper was provided as an easy way to load data from a packet. It can "
"be used to load I<len> bytes from I<offset> from the packet associated to "
"I<skb>, into the buffer pointed by I<to>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:791
msgid ""
"Since Linux 4.7, usage of this helper has mostly been replaced by \"direct "
"packet access\", enabling packet data to be manipulated with "
"I<skb>B<-E<gt>data> and I<skb>B<-E<gt>data_end> pointing respectively to the"
" first byte of packet data and to the byte after the last byte of packet "
"data. However, it remains useful if one wishes to read large quantities of "
"data at once from a packet into the eBPF stack."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:795
#, no-wrap
msgid ""
"B<int bpf_get_stackid(struct pt_reg *>I<ctx>B<, struct bpf_map *>I<map>B<, "
"u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:804
msgid ""
"Walk a user or a kernel stack and return its id. To achieve this, the helper"
" needs I<ctx>, which is a pointer to the context on which the tracing "
"program is executed, and a pointer to a I<map> of type "
"B<BPF_MAP_TYPE_STACK_TRACE>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:809
msgid ""
"The last argument, I<flags>, holds the number of stack frames to skip (from "
"0 to 255), masked with B<BPF_F_SKIP_FIELD_MASK>\\&. The next bits can be "
"used to set a combination of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:810 man-pages/man7/bpf-helpers.7:1864
#, no-wrap
msgid "B<BPF_F_USER_STACK>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:813 man-pages/man7/bpf-helpers.7:1867
msgid "Collect a user space stack instead of a kernel stack."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:813
#, no-wrap
msgid "B<BPF_F_FAST_STACK_CMP>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:816
msgid "Compare stacks by hash only."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:816
#, no-wrap
msgid "B<BPF_F_REUSE_STACKID>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:820
msgid ""
"If two different stacks hash into the same I<stackid>, discard the old one."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:827
msgid ""
"The stack id retrieved is a 32 bit long integer handle which can be further "
"combined with other data (including other stack ids) and used as a key into "
"maps. This can be useful for generating a variety of graphs (such as flame "
"graphs or off-cpu graphs)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:836
msgid ""
"For walking a stack, this helper is an improvement over B<bpf_probe_read>(),"
" which can be used with unrolled loops but is not efficient and consumes a "
"lot of eBPF instructions.  Instead, B<bpf_get_stackid>() can collect up to "
"B<PERF_MAX_STACK_DEPTH> both kernel and user frames. Note that this limit "
"can be controlled with the B<sysctl> program, and that it should be manually"
" increased in order to profile long user stacks (such as stacks for Java "
"programs). To do so, use:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:842 man-pages/man7/bpf-helpers.7:1885
#, no-wrap
msgid "# sysctl kernel.perf_event_max_stack=E<lt>new valueE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:850
msgid ""
"The positive or null stack id on success, or a negative error in case of "
"failure."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:851
#, no-wrap
msgid ""
"B<s64 bpf_csum_diff(__be32 *>I<from>B<, u32 >I<from_size>B<, __be32 "
"*>I<to>B<, u32 >I<to_size>B<, __wsum >I<seed>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:862
msgid ""
"Compute a checksum difference, from the raw buffer pointed by I<from>, of "
"length I<from_size> (that must be a multiple of 4), towards the raw buffer "
"pointed by I<to>, of size I<to_size> (same remark). An optional I<seed> can "
"be added to the value (this can be cascaded, the seed may come from a "
"previous call to the helper)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:864
msgid "This is flexible enough to be used in several ways:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:868
msgid ""
"With I<from_size> == 0, I<to_size> E<gt> 0 and I<seed> set to checksum, it "
"can be used when pushing new data."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:871
msgid ""
"With I<from_size> E<gt> 0, I<to_size> == 0 and I<seed> set to checksum, it "
"can be used when removing data from a packet."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:875
msgid ""
"With I<from_size> E<gt> 0, I<to_size> E<gt> 0 and I<seed> set to 0, it can "
"be used to compute a diff. Note that I<from_size> and I<to_size> do not need"
" to be equal."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:881
msgid ""
"This helper can be used in combination with B<bpf_l3_csum_replace>() and "
"B<bpf_l4_csum_replace>(), to which one can feed in the difference computed "
"with B<bpf_csum_diff>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:885
msgid "The checksum result, or a negative error code in case of failure."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:886
#, no-wrap
msgid ""
"B<int bpf_skb_get_tunnel_opt(struct sk_buff *>I<skb>B<, u8 *>I<opt>B<, u32 "
">I<size>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:894
msgid ""
"Retrieve tunnel options metadata for the packet associated to I<skb>, and "
"store the raw tunnel option data to the buffer I<opt> of I<size>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:904
msgid ""
"This helper can be used with encapsulation devices that can operate in "
"\"collect metadata\" mode (please refer to the related note in the "
"description of B<bpf_skb_get_tunnel_key>() for more details). A particular "
"example where this can be used is in combination with the Geneve "
"encapsulation protocol, where it allows for pushing (with "
"B<bpf_skb_get_tunnel_opt>() helper)  and retrieving arbitrary TLVs (Type-"
"Length-Value headers) from the eBPF program. This allows for full "
"customization of these headers."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:907
msgid "The size of the option data retrieved."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:908
#, no-wrap
msgid ""
"B<int bpf_skb_set_tunnel_opt(struct sk_buff *>I<skb>B<, u8 *>I<opt>B<, u32 "
">I<size>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:915
msgid ""
"Set tunnel options metadata for the packet associated to I<skb> to the "
"option data contained in the raw buffer I<opt> of I<size>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:918
msgid ""
"See also the description of the B<bpf_skb_get_tunnel_opt>()  helper for "
"additional information."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:922
#, no-wrap
msgid ""
"B<int bpf_skb_change_proto(struct sk_buff *>I<skb>B<, __be16 >I<proto>B<, "
"u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:935
msgid ""
"Change the protocol of the I<skb> to I<proto>\\&. Currently supported are "
"transition from IPv4 to IPv6, and from IPv6 to IPv4. The helper takes care "
"of the groundwork for the transition, including resizing the socket buffer. "
"The eBPF program is expected to fill the new headers, if any, via "
"B<skb_store_bytes>() and to recompute the checksums with "
"B<bpf_l3_csum_replace>() and B<bpf_l4_csum_replace>(). The main case for "
"this helper is to perform NAT64 operations out of an eBPF program."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:939
msgid ""
"Internally, the GSO type is marked as dodgy so that headers are checked and "
"segments are recalculated by the GSO/GRO engine.  The size for GSO target is"
" adapted as well."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:942 man-pages/man7/bpf-helpers.7:1201
#: man-pages/man7/bpf-helpers.7:1389 man-pages/man7/bpf-helpers.7:1413
#: man-pages/man7/bpf-helpers.7:1785 man-pages/man7/bpf-helpers.7:1841
#: man-pages/man7/bpf-helpers.7:2307 man-pages/man7/bpf-helpers.7:2350
msgid ""
"All values for I<flags> are reserved for future usage, and must be left at "
"zero."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:952
#, no-wrap
msgid "B<int bpf_skb_change_type(struct sk_buff *>I<skb>B<, u32 >I<type>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:961
msgid ""
"Change the packet type for the packet associated to I<skb>\\&. This comes "
"down to setting I<skb>B<-E<gt>pkt_type> to I<type>, except the eBPF program "
"does not have a write access to I<skb>B<-E<gt>pkt_type> beside this helper. "
"Using a helper here allows for graceful handling of errors."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:966
msgid ""
"The major use case is to change incoming I<skb*s to **PACKET_HOST*> in a "
"programmatic way instead of having to recirculate via B<redirect>(..., "
"B<BPF_F_INGRESS>), for example."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:969
msgid "Note that I<type> only allows certain values. At this time, they are:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:970
#, no-wrap
msgid "B<PACKET_HOST>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:973
msgid "Packet is for us."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:973
#, no-wrap
msgid "B<PACKET_BROADCAST>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:976
msgid "Send packet to all."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:976
#, no-wrap
msgid "B<PACKET_MULTICAST>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:979
msgid "Send packet to group."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:979
#, no-wrap
msgid "B<PACKET_OTHERHOST>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:982
msgid "Send packet to someone else."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:987
#, no-wrap
msgid ""
"B<int bpf_skb_under_cgroup(struct sk_buff *>I<skb>B<, struct bpf_map "
"*>I<map>B<, u32 >I<index>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:994
msgid ""
"Check whether I<skb> is a descendant of the cgroup2 held by I<map> of type "
"B<BPF_MAP_TYPE_CGROUP_ARRAY>, at I<index>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:997 man-pages/man7/bpf-helpers.7:1067
msgid "The return value depends on the result of the test, and can be:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1000
msgid "0, if the I<skb> failed the cgroup2 descendant test."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1002
msgid "1, if the I<skb> succeeded the cgroup2 descendant test."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1004 man-pages/man7/bpf-helpers.7:1074
msgid "A negative error code, if an error occurred."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1006
#, no-wrap
msgid "B<u32 bpf_get_hash_recalc(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1015
msgid ""
"Retrieve the hash of the packet, I<skb>B<-E<gt>hash>\\&. If it is not set, "
"in particular if the hash was cleared due to mangling, recompute this hash. "
"Later accesses to the hash can be done directly with I<skb>B<-E<gt>hash>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1022
msgid ""
"Calling B<bpf_set_hash_invalid>(), changing a packet prototype with "
"B<bpf_skb_change_proto>(), or calling B<bpf_skb_store_bytes>() with the "
"B<BPF_F_INVALIDATE_HASH> are actions susceptible to clear the hash and to "
"trigger a new computation for the next call to B<bpf_get_hash_recalc>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1025
msgid "The 32-bit hash."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1026
#, no-wrap
msgid "B<u64 bpf_get_current_task(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1032
msgid "A pointer to the current task struct."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1033
#, no-wrap
msgid ""
"B<int bpf_probe_write_user(void *>I<dst>B<, const void *>I<src>B<, u32 "
">I<len>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1041
msgid ""
"Attempt in a safe way to write I<len> bytes from the buffer I<src> to I<dst>"
" in memory. It only works for threads that are in user context, and I<dst> "
"must be a valid user space address."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1046
msgid ""
"This helper should not be used to implement any kind of security mechanism "
"because of TOC-TOU attacks, but rather to debug, divert, and manipulate "
"execution of semi-cooperative processes."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1052
msgid ""
"Keep in mind that this feature is meant for experiments, and it has a risk "
"of crashing the system and running programs.  Therefore, when an eBPF "
"program using this helper is attached, a warning including PID and process "
"name is printed to kernel logs."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1056
#, no-wrap
msgid ""
"B<int bpf_current_task_under_cgroup(struct bpf_map *>I<map>B<, u32 "
">I<index>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1064
msgid ""
"Check whether the probe is being run is the context of a given subset of the"
" cgroup2 hierarchy. The cgroup2 to test is held by I<map> of type "
"B<BPF_MAP_TYPE_CGROUP_ARRAY>, at I<index>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1070
msgid "0, if the I<skb> task belongs to the cgroup2."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1072
msgid "1, if the I<skb> task does not belong to the cgroup2."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1076
#, no-wrap
msgid ""
"B<int bpf_skb_change_tail(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1084
msgid ""
"Resize (trim or grow) the packet associated to I<skb> to the new I<len>\\&. "
"The I<flags> are reserved for future usage, and must be left at zero."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1094
msgid ""
"The basic idea is that the helper performs the needed work to change the "
"size of the packet, then the eBPF program rewrites the rest via helpers like"
" B<bpf_skb_store_bytes>(), B<bpf_l3_csum_replace>(), "
"B<bpf_l3_csum_replace>()  and others. This helper is a slow path utility "
"intended for replies with control messages. And because it is targeted for "
"slow path, the helper itself can afford to be slow: it implicitly "
"linearizes, unclones and drops offloads from the I<skb>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1104
#, no-wrap
msgid "B<int bpf_skb_pull_data(struct sk_buff *>I<skb>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1113
msgid ""
"Pull in non-linear data in case the I<skb> is non-linear and not all of "
"I<len> are part of the linear section. Make I<len> bytes from I<skb> "
"readable and writable. If a zero value is passed for I<len>, then the whole "
"length of the I<skb> is pulled."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1116
msgid ""
"This helper is only needed for reading and writing with direct packet "
"access."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1127
msgid ""
"For direct packet access, testing that offsets to access are within packet "
"boundaries (test on I<skb>B<-E<gt>data_end>) is susceptible to fail if "
"offsets are invalid, or if the requested data is in non-linear parts of the "
"I<skb>\\&. On failure the program can just bail out, or in the case of a "
"non-linear buffer, use a helper to make the data available. The "
"B<bpf_skb_load_bytes>() helper is a first solution to access the data. "
"Another one consists in using B<bpf_skb_pull_data> to pull in once the non-"
"linear parts, then retesting and eventually access the data."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1134
msgid ""
"At the same time, this also makes sure the I<skb> is uncloned, which is a "
"necessary condition for direct write. As this needs to be an invariant for "
"the write part only, the verifier detects writes and adds a prologue that is"
" calling B<bpf_skb_pull_data()> to effectively unclone the I<skb> from the "
"very beginning in case it is indeed cloned."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1144
#, no-wrap
msgid "B<s64 bpf_csum_update(struct sk_buff *>I<skb>B<, __wsum >I<csum>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1155
msgid ""
"Add the checksum I<csum> into I<skb>B<-E<gt>csum> in case the driver has "
"supplied a checksum for the entire packet into that field. Return an error "
"otherwise. This helper is intended to be used in combination with "
"B<bpf_csum_diff>(), in particular when the checksum needs to be updated "
"after data has been written into the packet through direct packet access."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1159
msgid "The checksum on success, or a negative error code in case of failure."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1160
#, no-wrap
msgid "B<void bpf_set_hash_invalid(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1170
msgid ""
"Invalidate the current I<skb>B<-E<gt>hash>\\&. It can be used after mangling"
" on headers through direct packet access, in order to indicate that the hash"
" is outdated and to trigger a recalculation the next time the kernel tries "
"to access this hash or when the B<bpf_get_hash_recalc>() helper is called."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1171
#, no-wrap
msgid "B<int bpf_get_numa_node_id(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1182
msgid ""
"Return the id of the current NUMA node. The primary use case for this helper"
" is the selection of sockets for the local NUMA node, when the program is "
"attached to sockets using the B<SO_ATTACH_REUSEPORT_EBPF> option (see also "
"B<socket(7)>), but the helper is also available to other eBPF program types,"
" similarly to B<bpf_get_smp_processor_id>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1185
msgid "The id of current NUMA node."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1186
#, no-wrap
msgid ""
"B<int bpf_skb_change_head(struct sk_buff *>I<skb>B<, u32 >I<len>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1195
msgid ""
"Grows headroom of packet associated to I<skb> and adjusts the offset of the "
"MAC header accordingly, adding I<len> bytes of space. It automatically "
"extends and reallocates memory as required."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1198
msgid ""
"This helper can be used on a layer 3 I<skb> to push a MAC header for "
"redirection into a layer 2 device."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1211
#, no-wrap
msgid ""
"B<int bpf_xdp_adjust_head(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1220
msgid ""
"Adjust (move) I<xdp_md>B<-E<gt>data> by I<delta> bytes. Note that it is "
"possible to use a negative value for I<delta>\\&. This helper can be used to"
" prepare the packet for pushing or popping headers."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1230
#, no-wrap
msgid ""
"B<int bpf_probe_read_str(void *>I<dst>B<, int >I<size>B<, const void "
"*>I<unsafe_ptr>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1241
msgid ""
"Copy a NUL terminated string from an unsafe address I<unsafe_ptr> to "
"I<dst>\\&. The I<size> should include the terminating NUL byte. In case the "
"string length is smaller than I<size>, the target is not padded with further"
" NUL bytes. If the string length is larger than I<size>, just I<size>-1 "
"bytes are copied and the last byte is set to NUL."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1246
msgid ""
"On success, the length of the copied string is returned. This makes this "
"helper useful in tracing programs for reading strings, and more importantly "
"to get its length at runtime. See the following snippet:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1256
#, no-wrap
msgid ""
"SEC(\"kprobe/sys_open\")\n"
"void bpf_sys_open(struct pt_regs *ctx)\n"
"        char buf[PATHLEN]; // PATHLEN is defined to 256\n"
"        int res = bpf_probe_read_str(buf, sizeof(buf),\n"
"                                     ctx-E<gt>di);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1261
#, no-wrap
msgid ""
"        // Consume buf, for example push it to\n"
"        // userspace via bpf_perf_event_output(); we\n"
"        // can use res (the string length) as event\n"
"        // size, after checking its boundaries.\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1270
msgid ""
"In comparison, using B<bpf_probe_read()> helper here instead to read the "
"string would require to estimate the length at compile time, and would often"
" result in copying more memory than necessary."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1275
msgid ""
"Another useful use case is when parsing individual process arguments or "
"individual environment variables navigating "
"I<current>B<-E<gt>mm-E<gt>arg_start> and "
"I<current>B<-E<gt>mm-E<gt>env_start>: using this helper and the return "
"value, one can quickly iterate at the right offset of the memory area."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1280
msgid ""
"On success, the strictly positive length of the string, including the "
"trailing NUL character. On error, a negative value."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1281
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1293
msgid ""
"If the B<struct sk_buff> pointed by I<skb> has a known socket, retrieve the "
"cookie (generated by the kernel) of this socket.  If no cookie has been set "
"yet, generate a new cookie. Once generated, the socket cookie remains stable"
" for the life of the socket. This helper can be useful for monitoring per "
"socket networking traffic statistics as it provides a unique socket "
"identifier per namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1297
msgid ""
"A 8-byte long non-decreasing number on success, or 0 if the socket field is "
"missing inside I<skb>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1298
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct bpf_sock_addr *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1305
msgid ""
"Equivalent to bpf_get_socket_cookie() helper that accepts I<skb>, but gets "
"socket from B<struct bpf_sock_addr> contex."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1308 man-pages/man7/bpf-helpers.7:1319
msgid "A 8-byte long non-decreasing number."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1309
#, no-wrap
msgid "B<u64 bpf_get_socket_cookie(struct bpf_sock_ops *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1316
msgid ""
"Equivalent to bpf_get_socket_cookie() helper that accepts I<skb>, but gets "
"socket from B<struct bpf_sock_ops> contex."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1320
#, no-wrap
msgid "B<u32 bpf_get_socket_uid(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1330
msgid ""
"The owner UID of the socket associated to I<skb>\\&. If the socket is "
"B<NULL>, or if it is not a full socket (i.e. if it is a time-wait or a "
"request socket instead), B<overflowuid> value is returned (note that "
"B<overflowuid> might also be the actual UID value for the socket)."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1331
#, no-wrap
msgid "B<u32 bpf_set_hash(struct sk_buff *>I<skb>B<, u32 >I<hash>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1338
msgid ""
"Set the full hash for I<skb> (set the field I<skb>B<-E<gt>hash>)  to value "
"I<hash>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1341
#, no-wrap
msgid ""
"B<int bpf_setsockopt(struct bpf_sock_ops *>I<bpf_socket>B<, int >I<level>B<,"
" int >I<optname>B<, char *>I<optval>B<, int >I<optlen>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1351
msgid ""
"Emulate a call to B<setsockopt()> on the socket associated to I<bpf_socket>,"
" which must be a full socket. The I<level> at which the option resides and "
"the name I<optname> of the option must be specified, see B<setsockopt(2)> "
"for more information.  The option value of length I<optlen> is pointed by "
"I<optval>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1354
msgid ""
"This helper actually implements a subset of B<setsockopt()>\\&.  It supports"
" the following I<level>s:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1359
msgid ""
"B<SOL_SOCKET>, which supports the following I<optname>s: B<SO_RCVBUF>, "
"B<SO_SNDBUF>, B<SO_MAX_PACING_RATE>, B<SO_PRIORITY>, B<SO_RCVLOWAT>, "
"B<SO_MARK>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1363
msgid ""
"B<IPPROTO_TCP>, which supports the following I<optname>s: B<TCP_CONGESTION>,"
" B<TCP_BPF_IW>, B<TCP_BPF_SNDCWND_CLAMP>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1365 man-pages/man7/bpf-helpers.7:1591
msgid "B<IPPROTO_IP>, which supports I<optname> B<IP_TOS>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1367 man-pages/man7/bpf-helpers.7:1593
msgid "B<IPPROTO_IPV6>, which supports I<optname> B<IPV6_TCLASS>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1372
#, no-wrap
msgid ""
"B<int bpf_skb_adjust_room(struct sk_buff *>I<skb>B<, s32 >I<len_diff>B<, u32"
" >I<mode>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1379
msgid ""
"Grow or shrink the room for data in the packet associated to I<skb> by "
"I<len_diff>, and according to the selected I<mode>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1381
msgid "There is a single supported mode at this time:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1385
msgid ""
"B<BPF_ADJ_ROOM_NET>: Adjust room at the network layer (room space is added "
"or removed below the layer 3 header)."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1399
#, no-wrap
msgid ""
"B<int bpf_redirect_map(struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1410
msgid ""
"Redirect the packet to the endpoint referenced by I<map> at index I<key>\\&."
" Depending on its type, this I<map> can contain references to net devices "
"(for forwarding packets through other ports), or to CPUs (for redirecting "
"XDP frames to another CPU; but this is only implemented for native XDP (with"
" driver support) as of this writing)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1418
msgid ""
"When used to redirect packets to net devices, this helper provides a high "
"performance increase over B<bpf_redirect>().  This is due to various "
"implementation details of the underlying mechanisms, one of which is the "
"fact that B<bpf_redirect_map>() tries to send packet as a \"bulk\" to the "
"device."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1421
msgid "B<XDP_REDIRECT> on success, or B<XDP_ABORTED> on error."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1422
#, no-wrap
msgid ""
"B<int bpf_sk_redirect_map(struct bpf_map *>I<map>B<, u32 >I<key>B<, u64 "
">I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1433
msgid ""
"Redirect the packet to the socket referenced by I<map> (of type "
"B<BPF_MAP_TYPE_SOCKMAP>) at index I<key>\\&. Both ingress and egress "
"interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for"
" now."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1436 man-pages/man7/bpf-helpers.7:1693
#: man-pages/man7/bpf-helpers.7:2010 man-pages/man7/bpf-helpers.7:2028
msgid "B<SK_PASS> on success, or B<SK_DROP> on error."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1437
#, no-wrap
msgid ""
"B<int bpf_sock_map_update(struct bpf_sock_ops *>I<skops>B<, struct bpf_map "
"*>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1445
msgid ""
"Add an entry to, or update a I<map> referencing sockets. The I<skops> is "
"used as a new value for the entry associated to I<key>\\&. I<flags> is one "
"of:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1460 man-pages/man7/bpf-helpers.7:1989
msgid ""
"If the I<map> has eBPF programs (parser and verdict), those will be "
"inherited by the socket being added. If the socket is already attached to "
"eBPF programs, this results in an error."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1464
#, no-wrap
msgid ""
"B<int bpf_xdp_adjust_meta(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1474
msgid ""
"Adjust the address pointed by I<xdp_md>B<-E<gt>data_meta> by I<delta> (which"
" can be positive or negative). Note that this operation modifies the address"
" stored in I<xdp_md>B<-E<gt>data>, so the latter must be loaded only after "
"the helper has been called."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1487
msgid ""
"The use of I<xdp_md>B<-E<gt>data_meta> is optional and programs are not "
"required to use it. The rationale is that when the packet is processed with "
"XDP (e.g. as DoS filter), it is possible to push further meta data along "
"with it before passing to the stack, and to give the guarantee that an "
"ingress eBPF program attached as a TC classifier on the same device can pick"
" this up for further post-processing. Since TC works with socket buffers, it"
" remains possible to set from XDP the B<mark> or B<priority> pointers, or "
"other pointers for the socket buffer.  Having this scratch space generic and"
" programmable allows for more flexibility as the user is free to store "
"whatever meta data they need."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1497
#, no-wrap
msgid ""
"B<int bpf_perf_event_read_value(struct bpf_map *>I<map>B<, u64 >I<flags>B<, "
"struct bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1513
msgid ""
"Read the value of a perf event counter, and store it into I<buf> of size "
"I<buf_size>\\&. This helper relies on a I<map> of type "
"B<BPF_MAP_TYPE_PERF_EVENT_ARRAY>\\&. The nature of the perf event counter is"
" selected when I<map> is updated with perf event file descriptors. The "
"I<map> is an array whose size is the number of available CPUs, and each cell"
" contains a value relative to one CPU. The value to retrieve is indicated by"
" I<flags>, that contains the index of the CPU to look up, masked with "
"B<BPF_F_INDEX_MASK>\\&. Alternatively, I<flags> can be set to "
"B<BPF_F_CURRENT_CPU> to indicate that the value for the current CPU should "
"be retrieved."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1522
msgid ""
"This helper behaves in a way close to B<bpf_perf_event_read>() helper, save "
"that instead of just returning the value observed, it fills the I<buf> "
"structure. This allows for additional data to be retrieved: in particular, "
"the enabled and running times (in I<buf>B<-E<gt>enabled> and "
"I<buf>B<-E<gt>running>, respectively) are copied. In general, "
"B<bpf_perf_event_read_value>() is recommended over B<bpf_perf_event_read>(),"
" which has some ABI issues and provides fewer functionalities."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1534
msgid ""
"These values are interesting, because hardware PMU (Performance Monitoring "
"Unit) counters are limited resources. When there are more PMU based perf "
"events opened than available counters, kernel will multiplex these events so"
" each event gets certain percentage (but not all) of the PMU time. In case "
"that multiplexing happens, the number of samples or counter value will not "
"reflect the case compared to when no multiplexing occurs. This makes "
"comparison between different runs difficult.  Typically, the counter value "
"should be normalized before comparing to other experiments. The usual "
"normalization is done as follows."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1540
#, no-wrap
msgid "normalized_counter = counter * t_enabled / t_running\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1552
msgid ""
"Where t_enabled is the time enabled for event and t_running is the time "
"running for event since last normalization. The enabled and running times "
"are accumulated since the perf event open. To achieve scaling factor between"
" two invocations of an eBPF program, users can can use CPU id as the key "
"(which is typical for perf array usage model) to remember the previous value"
" and do the calculation inside the eBPF program."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1556
#, no-wrap
msgid ""
"B<int bpf_perf_prog_read_value(struct bpf_perf_event_data *>I<ctx>B<, struct"
" bpf_perf_event_value *>I<buf>B<, u32 >I<buf_size>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1567
msgid ""
"For en eBPF program attached to a perf event, retrieve the value of the "
"event counter associated to I<ctx> and store it in the structure pointed by "
"I<buf> and of size I<buf_size>\\&. Enabled and running times are also stored"
" in the structure (see description of helper B<bpf_perf_event_read_value>() "
"for more details)."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1571
#, no-wrap
msgid ""
"B<int bpf_getsockopt(struct bpf_sock_ops *>I<bpf_socket>B<, int >I<level>B<,"
" int >I<optname>B<, char *>I<optval>B<, int >I<optlen>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1582
msgid ""
"Emulate a call to B<getsockopt()> on the socket associated to I<bpf_socket>,"
" which must be a full socket. The I<level> at which the option resides and "
"the name I<optname> of the option must be specified, see B<getsockopt(2)> "
"for more information.  The retrieved value is stored in the structure "
"pointed by I<opval> and of length I<optlen>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1585
msgid ""
"This helper actually implements a subset of B<getsockopt()>\\&.  It supports"
" the following I<level>s:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1589
msgid "B<IPPROTO_TCP>, which supports I<optname> B<TCP_CONGESTION>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1598
#, no-wrap
msgid "B<int bpf_override_return(struct pt_reg *>I<regs>B<, u64 >I<rc>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1607
msgid ""
"Used for error injection, this helper uses kprobes to override the return "
"value of the probed function, and to set it to I<rc>\\&.  The first argument"
" is the context I<regs> on which the kprobe works."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1613
msgid ""
"This helper works by setting setting the PC (program counter)  to an "
"override function which is run in place of the original probed function. "
"This means the probed function is not run at all. The replacement function "
"just returns with the required value."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1619
msgid ""
"This helper has security implications, and thus is subject to restrictions. "
"It is only available if the kernel was compiled with the "
"B<CONFIG_BPF_KPROBE_OVERRIDE> configuration option, and in this case it only"
" works on functions tagged with B<ALLOW_ERROR_INJECTION> in the kernel code."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1623
msgid ""
"Also, the helper is only available for the architectures having the "
"CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing, x86 architecture"
" is the only one to support this feature."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1626
#, no-wrap
msgid ""
"B<int bpf_sock_ops_cb_flags_set(struct bpf_sock_ops *>I<bpf_sock>B<, int "
">I<argval>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1634
msgid ""
"Attempt to set the value of the B<bpf_sock_ops_cb_flags> field for the full "
"TCP socket associated to I<bpf_sock_ops> to I<argval>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1644
msgid ""
"The primary use of this field is to determine if there should be calls to "
"eBPF programs of type B<BPF_PROG_TYPE_SOCK_OPS> at various points in the TCP"
" code. A program of the same type can change its value, per connection and "
"as necessary, when the connection is established. This field is directly "
"accessible for reading, but this helper must be used for updates in order to"
" return an error if an eBPF program tries to set a callback that is not "
"supported in the current kernel."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1646
msgid "The supported callback values that I<argval> can combine are:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1649
msgid "B<BPF_SOCK_OPS_RTO_CB_FLAG> (retransmission time out)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1651
msgid "B<BPF_SOCK_OPS_RETRANS_CB_FLAG> (retransmission)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1653
msgid "B<BPF_SOCK_OPS_STATE_CB_FLAG> (TCP state change)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1657
msgid "Here are some examples of where one could call such eBPF program:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1660
msgid "When RTO fires."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1662
msgid "When a packet is retransmitted."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1664
msgid "When the connection terminates."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1666
msgid "When a packet is sent."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1668
msgid "When a packet is received."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1675
msgid ""
"Code B<-EINVAL> if the socket is not a full TCP socket; otherwise, a "
"positive number containing the bits that could not be set is returned (which"
" comes down to 0 if all bits were set as required)."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1676
#, no-wrap
msgid ""
"B<int bpf_msg_redirect_map(struct sk_msg_buff *>I<msg>B<, struct bpf_map "
"*>I<map>B<, u32 >I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1690
msgid ""
"This helper is used in programs implementing policies at the socket level. "
"If the message I<msg> is allowed to pass (i.e. if the verdict eBPF program "
"returns B<SK_PASS>), redirect it to the socket referenced by I<map> (of type"
" B<BPF_MAP_TYPE_SOCKMAP>) at index I<key>\\&. Both ingress and egress "
"interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for"
" now."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1694
#, no-wrap
msgid ""
"B<int bpf_msg_apply_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1701
msgid ""
"For socket policies, apply the verdict of the eBPF program to the next "
"I<bytes> (number of bytes) of message I<msg>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1703
msgid "For example, this helper can be used in the following cases:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1708
msgid ""
"A single B<sendmsg>() or B<sendfile>() system call contains multiple logical"
" messages that the eBPF program is supposed to read and for which it should "
"apply a verdict."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1714
msgid ""
"An eBPF program only cares to read the first I<bytes> of a I<msg>\\&. If the"
" message has a large payload, then setting up and calling the eBPF program "
"repeatedly for all bytes, even though the verdict is already known, would "
"create unnecessary overhead."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1727
msgid ""
"When called from within an eBPF program, the helper sets a counter internal "
"to the BPF infrastructure, that is used to apply the last verdict to the "
"next I<bytes>\\&. If I<bytes> is smaller than the current data being "
"processed from a B<sendmsg>() or B<sendfile>() system call, the first "
"I<bytes> will be sent and the eBPF program will be re-run with the pointer "
"for start of data pointing to byte number I<bytes> B<+ 1>\\&. If I<bytes> is"
" larger than the current data being processed, then the eBPF verdict will be"
" applied to multiple B<sendmsg>() or B<sendfile>() calls until I<bytes> are "
"consumed."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1731
msgid ""
"Note that if a socket closes with the internal counter holding a non-zero "
"value, this is not a problem because data is not being buffered for I<bytes>"
" and is sent as it is received."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1734
#, no-wrap
msgid ""
"B<int bpf_msg_cork_bytes(struct sk_msg_buff *>I<msg>B<, u32 >I<bytes>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1742
msgid ""
"For socket policies, prevent the execution of the verdict eBPF program for "
"message I<msg> until I<bytes> (byte number) have been accumulated."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1752
msgid ""
"This can be used when one needs a specific number of bytes before a verdict "
"can be assigned, even if the data spans multiple B<sendmsg>() or "
"B<sendfile>() calls. The extreme case would be a user calling B<sendmsg>() "
"repeatedly with 1-byte long message segments. Obviously, this is bad for "
"performance, but it is still valid. If the eBPF program needs I<bytes> bytes"
" to validate a header, this helper can be used to prevent the eBPF program "
"to be called again until I<bytes> have been accumulated."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1755
#, no-wrap
msgid ""
"B<int bpf_msg_pull_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 "
">I<end>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1763
msgid ""
"For socket policies, pull in non-linear data from user space for I<msg> and "
"set pointers I<msg>B<-E<gt>data> and I<msg>B<-E<gt>data_end> to I<start> and"
" I<end> bytes offsets into I<msg>, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1776
msgid ""
"If a program of type B<BPF_PROG_TYPE_SK_MSG> is run on a I<msg> it can only "
"parse data that the (B<data>, B<data_end>)  pointers have already consumed. "
"For B<sendmsg>() hooks this is likely the first scatterlist element. But for"
" calls relying on the B<sendpage> handler (e.g. B<sendfile>()) this will be "
"the range (B<0>, B<0>) because the data is shared with user space and by "
"default the objective is to avoid allowing user space to modify data while "
"(or after) eBPF verdict is being decided. This helper can be used to pull in"
" data and to set the start and end pointer to given values. Data will be "
"copied if necessary (i.e. if data was not linear and if start and end "
"pointers do not point to the same chunk)."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1789
#, no-wrap
msgid ""
"B<int bpf_bind(struct bpf_sock_addr *>I<ctx>B<, struct sockaddr *>I<addr>B<,"
" int >I<addr_len>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1799
msgid ""
"Bind the socket associated to I<ctx> to the address pointed by I<addr>, of "
"length I<addr_len>\\&. This allows for making outgoing connection from the "
"desired IP address, which can be useful for example when all processes "
"inside a cgroup should use one single IP address on a host that has multiple"
" IP configured."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1806
msgid ""
"This helper works for IPv4 and IPv6, TCP and UDP sockets. The domain "
"(I<addr>B<-E<gt>sa_family>) must be B<AF_INET> (or B<AF_INET6>). Looking for"
" a free port to bind to can be expensive, therefore binding to port is not "
"permitted by the helper: I<addr>B<-E<gt>sin_port> (or B<sin6_port>, "
"respectively)  must be set to zero."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1810
#, no-wrap
msgid ""
"B<int bpf_xdp_adjust_tail(struct xdp_buff *>I<xdp_md>B<, int >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1818
msgid ""
"Adjust (move) I<xdp_md>B<-E<gt>data_end> by I<delta> bytes. It is only "
"possible to shrink the packet as of this writing, therefore I<delta> must be"
" a negative integer."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1828
#, no-wrap
msgid ""
"B<int bpf_skb_get_xfrm_state(struct sk_buff *>I<skb>B<, u32 >I<index>B<, "
"struct bpf_xfrm_state *>I<xfrm_state>B<, u32 >I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1835
msgid ""
"Retrieve the XFRM state (IP transform framework, see also B<ip-xfrm(8)>) at "
"I<index> in XFRM \"security path\" for I<skb>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1838
msgid ""
"The retrieved value is stored in the B<struct bpf_xfrm_state> pointed by "
"I<xfrm_state> and of length I<size>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1844
msgid ""
"This helper is available only if the kernel was compiled with B<CONFIG_XFRM>"
" configuration option."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1848
#, no-wrap
msgid ""
"B<int bpf_get_stack(struct pt_regs *>I<regs>B<, void *>I<buf>B<, u32 "
">I<size>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1858
msgid ""
"Return a user or a kernel stack in bpf program provided buffer.  To achieve "
"this, the helper needs I<ctx>, which is a pointer to the context on which "
"the tracing program is executed.  To store the stacktrace, the bpf program "
"provides I<buf> with a nonnegative I<size>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1863
msgid ""
"The last argument, I<flags>, holds the number of stack frames to skip (from "
"0 to 255), masked with B<BPF_F_SKIP_FIELD_MASK>\\&. The next bits can be "
"used to set the following flags:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1867
#, no-wrap
msgid "B<BPF_F_USER_BUILD_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1871
msgid ""
"Collect buildid+offset instead of ips for user stack, only valid if "
"B<BPF_F_USER_STACK> is also specified."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1879
msgid ""
"B<bpf_get_stack>() can collect up to B<PERF_MAX_STACK_DEPTH> both kernel and"
" user frames, subject to sufficient large buffer size. Note that this limit "
"can be controlled with the B<sysctl> program, and that it should be manually"
" increased in order to profile long user stacks (such as stacks for Java "
"programs). To do so, use:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1893
msgid ""
"A non-negative value equal to or less than I<size> on success, or a negative"
" error in case of failure."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1894
#, no-wrap
msgid ""
"B<int bpf_skb_load_bytes_relative(const struct sk_buff *>I<skb>B<, u32 "
">I<offset>B<, void *>I<to>B<, u32 >I<len>B<, u32 >I<start_header>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1905
msgid ""
"This helper is similar to B<bpf_skb_load_bytes>() in that it provides an "
"easy way to load I<len> bytes from I<offset> from the packet associated to "
"I<skb>, into the buffer pointed by I<to>\\&. The difference to "
"B<bpf_skb_load_bytes>() is that a fifth argument I<start_header> exists in "
"order to select a base offset to start from. I<start_header> can be one of:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1906
#, no-wrap
msgid "B<BPF_HDR_START_MAC>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1909
msgid "Base offset to load data from is I<skb>\\(aqs mac header."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1909
#, no-wrap
msgid "B<BPF_HDR_START_NET>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1912
msgid "Base offset to load data from is I<skb>\\(aqs network header."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1919
msgid ""
"In general, \"direct packet access\" is the preferred method to access "
"packet data, however, this helper is in particular useful in socket filters "
"where I<skb>B<-E<gt>data> does not always point to the start of the mac "
"header and where \"direct packet access\" is not available."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1923
#, no-wrap
msgid ""
"B<int bpf_fib_lookup(void *>I<ctx>B<, struct bpf_fib_lookup *>I<params>B<, "
"int >I<plen>B<, u32 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1937
msgid ""
"Do FIB lookup in kernel tables using parameters in I<params>\\&.  If lookup "
"is successful and result shows packet is to be forwarded, the neighbor "
"tables are searched for the nexthop.  If successful (ie., FIB lookup shows "
"forwarding and nexthop is resolved), the nexthop address is returned in "
"ipv4_dst or ipv6_dst based on family, smac is set to mac address of egress "
"device, dmac is set to nexthop mac address, rt_metric is set to metric from "
"route (IPv4/IPv6 only), and ifindex is set to the device index of the "
"nexthop from the FIB lookup."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1941
msgid ""
"I<plen> argument is the size of the passed in struct.  I<flags> argument can"
" be a combination of one or more of the following values:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1942
#, no-wrap
msgid "B<BPF_FIB_LOOKUP_DIRECT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1946
msgid "Do a direct table lookup vs full lookup using FIB rules."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1946
#, no-wrap
msgid "B<BPF_FIB_LOOKUP_OUTPUT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1950
msgid "Perform lookup from an egress perspective (default is ingress)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1954
msgid ""
"I<ctx> is either B<struct xdp_md> for XDP programs or B<struct sk_buff> tc "
"cls_act programs."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1959
msgid "E<lt> 0 if any input argument is invalid"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1961
msgid "0 on success (packet is forwarded, nexthop neighbor exists)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1964
msgid ""
"E<gt> 0 one of B<BPF_FIB_LKUP_RET_> codes explaining why the packet is not "
"forwarded or needs assist from full stack"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1966
#, no-wrap
msgid ""
"B<int bpf_sock_hash_update(struct bpf_sock_ops_kern *>I<skops>B<, struct "
"bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:1974
msgid ""
"Add an entry to, or update a sockhash I<map> referencing sockets.  The "
"I<skops> is used as a new value for the entry associated to I<key>\\&. "
"I<flags> is one of:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:1993
#, no-wrap
msgid ""
"B<int bpf_msg_redirect_hash(struct sk_msg_buff *>I<msg>B<, struct bpf_map "
"*>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2007
msgid ""
"This helper is used in programs implementing policies at the socket level. "
"If the message I<msg> is allowed to pass (i.e. if the verdict eBPF program "
"returns B<SK_PASS>), redirect it to the socket referenced by I<map> (of type"
" B<BPF_MAP_TYPE_SOCKHASH>) using hash I<key>\\&. Both ingress and egress "
"interfaces can be used for redirection. The B<BPF_F_INGRESS> value in "
"I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress path otherwise). This is the only flag supported for"
" now."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2011
#, no-wrap
msgid ""
"B<int bpf_sk_redirect_hash(struct sk_buff *>I<skb>B<, struct bpf_map "
"*>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2025
msgid ""
"This helper is used in programs implementing policies at the skb socket "
"level. If the sk_buff I<skb> is allowed to pass (i.e.  if the verdeict eBPF "
"program returns B<SK_PASS>), redirect it to the socket referenced by I<map> "
"(of type B<BPF_MAP_TYPE_SOCKHASH>) using hash I<key>\\&. Both ingress and "
"egress interfaces can be used for redirection. The B<BPF_F_INGRESS> value in"
" I<flags> is used to make the distinction (ingress path is selected if the "
"flag is present, egress otherwise). This is the only flag supported for now."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2029
#, no-wrap
msgid ""
"B<int bpf_lwt_push_encap(struct sk_buff *>I<skb>B<, u32 >I<type>B<, void "
"*>I<hdr>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2038
msgid ""
"Encapsulate the packet associated to I<skb> within a Layer 3 protocol "
"header. This header is provided in the buffer at address I<hdr>, with I<len>"
" its size in bytes. I<type> indicates the protocol of the header and can be "
"one of:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2039
#, no-wrap
msgid "B<BPF_LWT_ENCAP_SEG6>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2044
msgid ""
"IPv6 encapsulation with Segment Routing Header (B<struct ipv6_sr_hdr>). "
"I<hdr> only contains the SRH, the IPv6 header is computed by the kernel."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2044
#, no-wrap
msgid "B<BPF_LWT_ENCAP_SEG6_INLINE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2049
msgid ""
"Only works if I<skb> contains an IPv6 packet. Insert a Segment Routing "
"Header (B<struct ipv6_sr_hdr>) inside the IPv6 header."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2060
#, no-wrap
msgid ""
"B<int bpf_lwt_seg6_store_bytes(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, "
"const void *>I<from>B<, u32 >I<len>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2069
msgid ""
"Store I<len> bytes from address I<from> into the packet associated to "
"I<skb>, at I<offset>\\&. Only the flags, tag and TLVs inside the outermost "
"IPv6 Segment Routing Header can be modified through this helper."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2079
#, no-wrap
msgid ""
"B<int bpf_lwt_seg6_adjust_srh(struct sk_buff *>I<skb>B<, u32 >I<offset>B<, "
"s32 >I<delta>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2089
msgid ""
"Adjust the size allocated to TLVs in the outermost IPv6 Segment Routing "
"Header contained in the packet associated to I<skb>, at position I<offset> "
"by I<delta> bytes. Only offsets after the segments are accepted. I<delta> "
"can be as well positive (growing) as negative (shrinking)."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2099
#, no-wrap
msgid ""
"B<int bpf_lwt_seg6_action(struct sk_buff *>I<skb>B<, u32 >I<action>B<, void "
"*>I<param>B<, u32 >I<param_len>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2108
msgid ""
"Apply an IPv6 Segment Routing action of type I<action> to the packet "
"associated to I<skb>\\&. Each action takes a parameter contained at address "
"I<param>, and of length I<param_len> bytes.  I<action> can be one of:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2109
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_X>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2113
msgid ""
"End.X action: Endpoint with Layer-3 cross-connect.  Type of I<param>: "
"B<struct in6_addr>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2113
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_T>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2117
msgid ""
"End.T action: Endpoint with specific IPv6 table lookup.  Type of I<param>: "
"B<int>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2117
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_B6>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2121
msgid ""
"End.B6 action: Endpoint bound to an SRv6 policy.  Type of param: B<struct "
"ipv6_sr_hdr>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2121
#, no-wrap
msgid "B<SEG6_LOCAL_ACTION_END_B6_ENCAP>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2126
msgid ""
"End.B6.Encap action: Endpoint bound to an SRv6 encapsulation policy.  Type "
"of param: B<struct ipv6_sr_hdr>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2137
#, no-wrap
msgid ""
"B<int bpf_rc_keydown(void *>I<ctx>B<, u32 >I<protocol>B<, u64 "
">I<scancode>B<, u32 >I<toggle>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2150
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded key press with I<scancode>, I<toggle> value in the "
"given I<protocol>\\&. The scancode will be translated to a keycode using the"
" rc keymap, and reported as an input key down event. After a period a key up"
" event is generated. This period can be extended by calling either "
"B<bpf_rc_keydown>() again with the same values, or calling "
"B<bpf_rc_repeat>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2153
msgid ""
"Some protocols include a toggle bit, in case the button was released and "
"pressed again between consecutive scancodes."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2156 man-pages/man7/bpf-helpers.7:2181
#: man-pages/man7/bpf-helpers.7:2437
msgid "The I<ctx> should point to the lirc sample as passed into the program."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2159
msgid ""
"The I<protocol> is the decoded protocol number (see B<enum rc_proto> for "
"some predefined values)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2163 man-pages/man7/bpf-helpers.7:2185
#: man-pages/man7/bpf-helpers.7:2441
msgid ""
"This helper is only available is the kernel was compiled with the "
"B<CONFIG_BPF_LIRC_MODE2> configuration option set to \"B<y>\"."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2166
#, no-wrap
msgid "B<int bpf_rc_repeat(void *>I<ctx>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2175
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded repeat key message. This delays the generation of a key"
" up event for previously generated key down event."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2178
msgid ""
"Some IR protocols like NEC have a special IR message for repeating last "
"button, for when a button is held down."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2188
#, no-wrap
msgid "B<uint64_t bpf_skb_cgroup_id(struct sk_buff *>I<skb>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2200
msgid ""
"Return the cgroup v2 id of the socket associated with the I<skb>\\&.  This "
"is roughly similar to the B<bpf_get_cgroup_classid>()  helper for cgroup v1 "
"by providing a tag resp. identifier that can be matched on or used for map "
"lookups e.g. to implement policy. The cgroup v2 id of a given path in the "
"hierarchy is exposed in user space through the f_handle API in order to get "
"to the same 64-bit id."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2204
msgid ""
"This helper can be used on TC egress path, but not on ingress, and is "
"available only if the kernel was compiled with the "
"B<CONFIG_SOCK_CGROUP_DATA> configuration option."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2207 man-pages/man7/bpf-helpers.7:2229
msgid "The id is returned or 0 in case the id could not be retrieved."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2208
#, no-wrap
msgid ""
"B<u64 bpf_skb_ancestor_cgroup_id(struct sk_buff *>I<skb>B<, int "
">I<ancestor_level>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2219
msgid ""
"Return id of cgroup v2 that is ancestor of cgroup associated with the I<skb>"
" at the I<ancestor_level>\\&.  The root cgroup is at I<ancestor_level> zero "
"and each step down the hierarchy increments the level. If I<ancestor_level> "
"== level of cgroup associated with I<skb>, then return value will be same as"
" that of B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2223
msgid ""
"The helper is useful to implement policies based on cgroups that are upper "
"in hierarchy than immediate cgroup associated with I<skb>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2226
msgid ""
"The format of returned id and helper limitations are same as in "
"B<bpf_skb_cgroup_id>()."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2230
#, no-wrap
msgid "B<u64 bpf_get_current_cgroup_id(void)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2237
msgid ""
"A 64-bit integer containing the current cgroup id based on the cgroup within"
" which the current task is running."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2238
#, no-wrap
msgid "B<void* get_local_storage(void *>I<map>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2248
msgid ""
"Get the pointer to the local storage area.  The type and the size of the "
"local storage is defined by the I<map> argument.  The I<flags> meaning is "
"specific for each map type, and has to be 0 for cgroup local storage."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2252
msgid ""
"Depending on the BPF program type, a local storage area can be shared "
"between multiple instances of the BPF program, running simultaneously."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2256
msgid ""
"A user should care about the synchronization by himself.  For example, by "
"using the B<BPF_STX_XADD> instruction to alter the shared data."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2259
msgid "A pointer to the local storage area."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2260
#, no-wrap
msgid ""
"B<int bpf_sk_select_reuseport(struct sk_reuseport_md *>I<reuse>B<, struct "
"bpf_map *>I<map>B<, void *>I<key>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2269
msgid ""
"Select a B<SO_REUSEPORT> socket from a B<BPF_MAP_TYPE_REUSEPORT_ARRAY> "
"I<map>\\&.  It checks the selected socket is matching the incoming request "
"in the socket buffer."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2273
#, no-wrap
msgid ""
"B<struct bpf_sock *bpf_sk_lookup_tcp(void *>I<ctx>B<, struct bpf_sock_tuple "
"*>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2281
msgid ""
"Look for TCP socket matching I<tuple>, optionally in a child network "
"namespace I<netns>\\&. The return value must be checked, and if non-B<NULL>,"
" released via B<bpf_sk_release>()."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2285 man-pages/man7/bpf-helpers.7:2328
msgid ""
"The I<ctx> should point to the context of the program, such as the skb or "
"socket (depending on the hook in use). This is used to determine the base "
"network namespace for the lookup."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2287 man-pages/man7/bpf-helpers.7:2330
msgid "I<tuple_size> must be one of:"
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2288 man-pages/man7/bpf-helpers.7:2331
#, no-wrap
msgid "B<sizeof(>I<tuple>B<-E<gt>ipv4)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2291 man-pages/man7/bpf-helpers.7:2334
msgid "Look for an IPv4 socket."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2291 man-pages/man7/bpf-helpers.7:2334
#, no-wrap
msgid "B<sizeof(>I<tuple>B<-E<gt>ipv6)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2294 man-pages/man7/bpf-helpers.7:2337
msgid "Look for an IPv6 socket."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2304 man-pages/man7/bpf-helpers.7:2347
msgid ""
"If the I<netns> is a negative signed 32-bit integer, then the socket lookup "
"table in the netns associated with the I<ctx> will will be used. For the TC "
"hooks, this is the netns of the device in the skb. For socket hooks, this is"
" the netns of the socket.  If I<netns> is any other signed 32-bit value "
"greater than or equal to zero then it specifies the ID of the netns relative"
" to the netns associated with the I<ctx>\\&. I<netns> values beyond the "
"range of 32-bit integers are reserved for future use."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2310 man-pages/man7/bpf-helpers.7:2353
msgid ""
"This helper is available only if the kernel was compiled with B<CONFIG_NET> "
"configuration option."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2315 man-pages/man7/bpf-helpers.7:2358
msgid ""
"Pointer to B<struct bpf_sock>, or B<NULL> in case of failure.  For sockets "
"with reuseport option, the B<struct bpf_sock> result is from "
"B<reuse-E<gt>socks>[] using the hash of the tuple."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2316
#, no-wrap
msgid ""
"B<struct bpf_sock *bpf_sk_lookup_udp(void *>I<ctx>B<, struct bpf_sock_tuple "
"*>I<tuple>B<, u32 >I<tuple_size>B<, u64 >I<netns>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2324
msgid ""
"Look for UDP socket matching I<tuple>, optionally in a child network "
"namespace I<netns>\\&. The return value must be checked, and if non-B<NULL>,"
" released via B<bpf_sk_release>()."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2359
#, no-wrap
msgid "B<int bpf_sk_release(struct bpf_sock *>I<sock>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2367
msgid ""
"Release the reference held by I<sock>\\&. I<sock> must be a non-B<NULL> "
"pointer that was returned from B<bpf_sk_lookup_xxx>()."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2371
#, no-wrap
msgid "B<int bpf_map_pop_elem(struct bpf_map *>I<map>B<, void *>I<value>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2377
msgid "Pop an element from I<map>\\&."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2381
#, no-wrap
msgid "B<int bpf_map_peek_elem(struct bpf_map *>I<map>B<, void *>I<value>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2387
msgid "Get an element from I<map> without removing it."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2391
#, no-wrap
msgid ""
"B<int bpf_msg_push_data(struct sk_buff *>I<skb>B<, u32 >I<start>B<, u32 "
">I<len>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2398
msgid ""
"For socket policies, insert I<len> bytes into I<msg> at offset I<start>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2403
msgid ""
"If a program of type B<BPF_PROG_TYPE_SK_MSG> is run on a I<msg> it may want "
"to insert metadata or options into the I<msg>\\&.  This can later be read "
"and used by any of the lower layer BPF hooks."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2407
msgid ""
"This helper may fail if under memory pressure (a malloc fails) in these "
"cases BPF programs will get an appropriate error and BPF programs will need "
"to handle them."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2411
#, no-wrap
msgid ""
"B<int bpf_msg_pop_data(struct sk_msg_buff *>I<msg>B<, u32 >I<start>B<, u32 "
">I<pop>B<, u64 >I<flags>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2423
msgid ""
"Will remove I<pop> bytes from a I<msg> starting at byte I<start>\\&.  This "
"may result in B<ENOMEM> errors under certain situations if an allocation and"
" copy are required due to a full ring buffer.  However, the helper will try "
"to avoid doing the allocation if possible. Other errors can occur if input "
"parameters are invalid either due to I<start> byte not being valid part of "
"I<msg> payload and/or I<pop> value being to large."
msgstr ""

#. type: TP
#: man-pages/man7/bpf-helpers.7:2427
#, no-wrap
msgid ""
"B<int bpf_rc_pointer_rel(void *>I<ctx>B<, s32 >I<rel_x>B<, s32 >I<rel_y>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2434
msgid ""
"This helper is used in programs implementing IR decoding, to report a "
"successfully decoded pointer movement."
msgstr ""

#. type: SH
#: man-pages/man7/bpf-helpers.7:2445
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2449
msgid ""
"Example usage for most of the eBPF helpers listed in this manual page are "
"available within the Linux kernel sources, at the following locations:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2452
msgid "I<samples/bpf/>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2454
msgid "I<tools/testing/selftests/bpf/>"
msgstr ""

#. type: SH
#: man-pages/man7/bpf-helpers.7:2455
#, no-wrap
msgid "LICENSE"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2462
msgid ""
"eBPF programs can have an associated license, passed along with the bytecode"
" instructions to the kernel when the programs are loaded. The format for "
"that string is identical to the one in use for kernel modules (Dual "
"licenses, such as \"Dual BSD/GPL\", may be used). Some helper functions are "
"only accessible to programs that are compatible with the GNU Privacy License"
" (GPL)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2467
msgid ""
"In order to use such helpers, the eBPF program must be loaded with the "
"correct license string passed (via B<attr>) to the B<bpf>() system call, and"
" this generally translates into the C source code of the program containing "
"a line similar to the following:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2473
#, no-wrap
msgid "char ____license[] __attribute__((section(\"license\"), used)) = \"GPL\";\n"
msgstr ""

#. type: SH
#: man-pages/man7/bpf-helpers.7:2477
#, no-wrap
msgid "IMPLEMENTATION"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2487
msgid ""
"This manual page is an effort to document the existing eBPF helper "
"functions.  But as of this writing, the BPF sub-system is under heavy "
"development. New eBPF program or map types are added, along with new helper "
"functions. Some helpers are occasionally made available for additional "
"program types. So in spite of the efforts of the community, this page might "
"not be up-to-date. If you want to check by yourself what helper functions "
"exist in your kernel, or what types of programs they can support, here are "
"some files among the kernel tree that you may be interested in:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2492
msgid ""
"I<include/uapi/linux/bpf.h> is the main BPF header. It contains the full "
"list of all helper functions, as well as many other BPF definitions "
"including most of the flags, structs or constants used by the helpers."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2495
msgid ""
"I<net/core/filter.c> contains the definition of most network-related helper "
"functions, and the list of program types from which they can be used."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2498
msgid ""
"I<kernel/trace/bpf_trace.c> is the equivalent for most tracing program-"
"related helpers."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2501
msgid ""
"I<kernel/bpf/verifier.c> contains the functions used to check that valid "
"types of eBPF maps are used with a given helper function."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2504
msgid ""
"I<kernel/bpf/> directory contains other files in which additional helpers "
"are defined (for cgroups, sockmaps, etc.)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2513
msgid ""
"Compatibility between helper functions and program types can generally be "
"found in the files where helper functions are defined. Look for the B<struct"
" bpf_func_proto> objects and for functions returning them: these functions "
"contain a list of helpers that a given program type can call. Note that the "
"B<default:> label of the B<switch ... case> used to filter helpers can call "
"other functions, themselves allowing access to additional helpers. The "
"requirement for GPL license is also in those B<struct bpf_func_proto>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2516
msgid ""
"Compatibility between helper functions and map types can be found in the "
"B<check_map_func_compatibility>() function in file "
"I<kernel/bpf/verifier.c>\\&."
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2520
msgid ""
"Helper functions that invalidate the checks on B<data> and B<data_end> "
"pointers for network processing are listed in function "
"B<bpf_helper_changes_pkt_data>() in file I<net/core/filter.c>\\&."
msgstr ""

#. type: SH
#: man-pages/man7/bpf-helpers.7:2520
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man7/bpf-helpers.7:2528
msgid ""
"B<bpf>(2), B<cgroups>(7), B<ip>(8), B<perf_event_open>(2), B<sendmsg>(2), "
"B<socket>(7), B<tc-bpf>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/boot.7:15
#, no-wrap
msgid "BOOT"
msgstr ""

#. type: TH
#: man-pages/man7/boot.7:15
#, no-wrap
msgid "2015-03-11"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:18
msgid "boot - System bootup process based on UNIX System V Release 4"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:23
msgid ""
"The B<bootup process> (or \"B<boot sequence>\") varies in details among "
"systems, but can be roughly divided into phases controlled by the following "
"components:"
msgstr ""

#. type: IP
#: man-pages/man7/boot.7:23
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:25
msgid "hardware"
msgstr ""

#. type: IP
#: man-pages/man7/boot.7:25
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:27
msgid "operating system (OS) loader"
msgstr ""

#. type: IP
#: man-pages/man7/boot.7:27
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:29
msgid "kernel"
msgstr ""

#. type: IP
#: man-pages/man7/boot.7:29
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:31
msgid "root user-space process (I<init> and I<inittab>)"
msgstr ""

#. type: IP
#: man-pages/man7/boot.7:31
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:33
msgid "boot scripts"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:35
msgid "Each of these is described below in more detail."
msgstr ""

#. type: SS
#: man-pages/man7/boot.7:35
#, no-wrap
msgid "Hardware"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:40
msgid ""
"After power-on or hard reset, control is given to a program stored in read-"
"only memory (normally PROM); for historical reasons involving the personal "
"computer, this program is often called \"the B<BIOS>\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:49
msgid ""
"This program normally performs a basic self-test of the machine and accesses"
" nonvolatile memory to read further parameters.  This memory in the PC is "
"battery-backed CMOS memory, so most people refer to it as \"the B<CMOS>\"; "
"outside of the PC world, it is usually called \"the B<NVRAM>\" (nonvolatile "
"RAM)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:57
msgid ""
"The parameters stored in the NVRAM vary among systems, but as a minimum, "
"they should specify which device can supply an OS loader, or at least which "
"devices may be probed for one; such a device is known as \"the B<boot "
"device>\".  The hardware boot stage loads the OS loader from a fixed "
"position on the boot device, and then transfers control to it."
msgstr ""

#. type: TP
#: man-pages/man7/boot.7:57 man-pages/man7/boot.7:118
#: man-pages/man7/boot.7:152
#, no-wrap
msgid "Note:"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:62
msgid ""
"The device from which the OS loader is read may be attached via a network, "
"in which case the details of booting are further specified by protocols such"
" as DHCP, TFTP, PXE, Etherboot, etc."
msgstr ""

#. type: SS
#: man-pages/man7/boot.7:62
#, no-wrap
msgid "OS loader"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:70
msgid ""
"The main job of the OS loader is to locate the kernel on some device, load "
"it, and run it.  Most OS loaders allow interactive use, in order to enable "
"specification of an alternative kernel (maybe a backup in case the one last "
"compiled isn't functioning) and to pass optional parameters to the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:74
msgid ""
"In a traditional PC, the OS loader is located in the initial 512-byte block "
"of the boot device; this block is known as \"the B<MBR>\" (Master Boot "
"Record)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:82
msgid ""
"In most systems, the OS loader is very limited due to various constraints.  "
"Even on non-PC systems, there are some limitations on the size and "
"complexity of this loader, but the size limitation of the PC MBR (512 bytes,"
" including the partition table) makes it almost impossible to squeeze much "
"functionality into it."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:87
msgid ""
"Therefore, most systems split the role of loading the OS between a primary "
"OS loader and a secondary OS loader; this secondary OS loader may be located"
" within a larger portion of persistent storage, such as a disk partition."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:92
msgid "In Linux, the OS loader is often either B<lilo>(8)  or B<grub>(8)."
msgstr ""

#. type: SS
#: man-pages/man7/boot.7:92
#, no-wrap
msgid "Kernel"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:101
msgid ""
"When the kernel is loaded, it initializes various components of the computer"
" and operating system; each portion of software responsible for such a task "
"is usually consider \"a B<driver>\" for the applicable component.  The "
"kernel starts the virtual memory swapper (it is a kernel process, called "
"\"kswapd\" in a modern Linux kernel), and mounts some filesystem at the root"
" path, I</>."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:107
msgid ""
"Some of the parameters that may be passed to the kernel relate to these "
"activities (for example, the default root filesystem can be overridden); for"
" further information on Linux kernel parameters, read B<bootparam>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:117
msgid ""
"Only then does the kernel create the initial userland process, which is "
"given the number 1 as its B<PID> (process ID).  Traditionally, this process "
"executes the program I</sbin/init>, to which are passed the parameters that "
"haven't already been handled by the kernel."
msgstr ""

#. type: SS
#: man-pages/man7/boot.7:117
#, no-wrap
msgid "Root user-space process"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:126
msgid ""
"The following description applies to an OS based on UNIX System V Release 4."
"  However, a number of widely used systems have adopted a related but "
"fundamentally different approach known as B<systemd>(1), for which the "
"bootup process is detailed in its associated B<bootup>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:139
msgid ""
"When I</sbin/init> starts, it reads I</etc/inittab> for further "
"instructions.  This file defines what should be run when the I</sbin/init> "
"program is instructed to enter a particular I<run-level>, giving the "
"administrator an easy way to establish an environment for some usage; each "
"run-level is associated with a set of services (for example, run-level B<S> "
"is I<single-user> mode, and run-level B<2> entails running most network "
"services)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:145
msgid ""
"The administrator may change the current run-level via B<init>(1), and query"
" the current run-level via B<runlevel>(8)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:151
msgid ""
"However, since it is not convenient to manage individual services by editing"
" this file, I</etc/inittab> only bootstraps a set of scripts that actually "
"start/stop the individual services."
msgstr ""

#. type: SS
#: man-pages/man7/boot.7:151
#, no-wrap
msgid "Boot scripts"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:157
msgid ""
"The following description applies to an OS based on UNIX System V Release 4."
"  However, a number of widely used systems (Slackware Linux, FreeBSD, "
"OpenBSD)  have a somewhat different scheme for boot scripts."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:170
msgid ""
"For each managed service (mail, nfs server, cron, etc.), there is a single "
"startup script located in a specific directory (I</etc/init.d> in most "
"versions of Linux).  Each of these scripts accepts as a single argument the "
"word \"start\" (causing it to start the service) or the word \\&\"stop\" "
"(causing it to stop the service).  The script may optionally accept other "
"\"convenience\" parameters (e.g., \"restart\" to stop and then start, "
"\"status\" to display the service status, etc.).  Running the script without"
" parameters displays the possible arguments."
msgstr ""

#. type: SS
#: man-pages/man7/boot.7:170
#, no-wrap
msgid "Sequencing directories"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:177
msgid ""
"To make specific scripts start/stop at specific run-levels and in a specific"
" order, there are I<sequencing directories>, normally of the form "
"I</etc/rc[0-6S].d>.  In each of these directories, there are links (usually "
"symbolic) to the scripts in the I</etc/init.d> directory."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:186
msgid ""
"A primary script (usually I</etc/rc>) is called from B<inittab>(5); this "
"primary script calls each service's script via a link in the relevant "
"sequencing directory.  Each link whose name begins with \\(aqS\\(aq is "
"called with the argument \"start\" (thereby starting the service).  Each "
"link whose name begins with \\(aqK\\(aq is called with the argument \"stop\""
" (thereby stopping the service)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:196
msgid ""
"To define the starting or stopping order within the same run-level, the name"
" of a link contains an B<order-number>.  Also, for clarity, the name of a "
"link usually ends with the name of the service to which it refers.  For "
"example, the link I</etc/rc2.d/S80sendmail> starts the sendmail service on "
"runlevel 2.  This happens after I</etc/rc2.d/S12syslog> is run but before "
"I</etc/rc2.d/S90xfs> is run."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:201
msgid ""
"To manage these links is to manage the boot order and run-levels; under many"
" systems, there are tools to help with this task (e.g., B<chkconfig>(8))."
msgstr ""

#. type: SS
#: man-pages/man7/boot.7:201
#, no-wrap
msgid "Boot configuration"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:210
msgid ""
"A program that provides a service is often called a \"B<daemon>\".  Usually,"
" a daemon may receive various command-line options and parameters.  To allow"
" a system administrator to change these inputs without editing an entire "
"boot script, some separate configuration file is used, and is located in a "
"specific directory where an associated boot script may find it "
"(I</etc/sysconfig> on older Red Hat systems)."
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:217
msgid ""
"In older UNIX systems, such a file contained the actual command line options"
" for a daemon, but in modern Linux systems (and also in HP-UX), it just "
"contains shell variables.  A boot script in I</etc/init.d> reads and "
"includes its configuration file (that is, it \"B<sources>\" its "
"configuration file) and then uses the variable values."
msgstr ""

#. type: SH
#: man-pages/man7/boot.7:217
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:222
msgid "I</etc/init.d/>, I</etc/rc[S0-6].d/>, I</etc/sysconfig/>"
msgstr ""

#. type: Plain text
#: man-pages/man7/boot.7:229
msgid ""
"B<init>(1), B<systemd>(1), B<inittab>(5), B<bootparam>(7), B<bootup>(7), "
"B<runlevel>(8), B<shutdown>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/bootparam.7:28
#, no-wrap
msgid "BOOTPARAM"
msgstr ""

#. type: TH
#: man-pages/man7/bootparam.7:28
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:31
msgid "bootparam - introduction to boot time parameters of the Linux kernel"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:38
msgid ""
"The Linux kernel accepts certain 'command-line options' or 'boot time "
"parameters' at the moment it is started.  In general, this is used to supply"
" the kernel with information about hardware parameters that the kernel would"
" not be able to determine on its own, or to avoid/override the values that "
"the kernel would otherwise detect."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:43
msgid ""
"When the kernel is booted directly by the BIOS, you have no opportunity to "
"specify any parameters.  So, in order to take advantage of this possibility "
"you have to use a boot loader that is able to pass parameters, such as GRUB."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:43
#, no-wrap
msgid "The argument list"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:47
msgid ""
"The kernel command line is parsed into a list of strings (boot arguments) "
"separated by spaces.  Most of the boot arguments have the form:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:51
#, no-wrap
msgid "name[=value_1][,value_2]...[,value_10]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:61
msgid ""
"where 'name' is a unique keyword that is used to identify what part of the "
"kernel the associated values (if any) are to be given to.  Note the limit of"
" 10 is real, as the present code handles only 10 comma separated parameters "
"per keyword.  (However, you can reuse the same keyword with up to an "
"additional 10 parameters in unusually complicated situations, assuming the "
"setup function supports it.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:68
msgid ""
"Most of the sorting is coded in the kernel source file I<init/main.c>.  "
"First, the kernel checks to see if the argument is any of the special "
"arguments 'root=', \\&'nfsroot=', 'nfsaddrs=', 'ro', 'rw', 'debug' or "
"'init'.  The meaning of these special arguments is described below."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:79
msgid ""
"Then it walks a list of setup functions to see if the specified argument "
"string (such as 'foo') has been associated with a setup function "
"('foo_setup()') for a particular device or part of the kernel.  If you "
"passed the kernel the line foo=3,4,5,6 then the kernel would search the "
"bootsetups array to see if 'foo' was registered.  If it was, then it would "
"call the setup function associated with 'foo' (foo_setup()) and hand it the "
"arguments 3, 4, 5, and 6 as given on the kernel command line."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:85
msgid ""
"Anything of the form 'foo=bar' that is not accepted as a setup function as "
"described above is then interpreted as an environment variable to be set.  A"
" (useless?) example would be to use 'TERM=vt100' as a boot argument."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:101
msgid ""
"Any remaining arguments that were not picked up by the kernel and were not "
"interpreted as environment variables are then passed onto PID 1, which is "
"usually the B<init>(1)  program.  The most common argument that is passed to"
" the I<init> process is the word 'single' which instructs it to boot the "
"computer in single user mode, and not launch all the usual daemons.  Check "
"the manual page for the version of B<init>(1)  installed on your system to "
"see what arguments it accepts."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:101
#, no-wrap
msgid "General non-device-specific boot arguments"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:102
#, no-wrap
msgid "B<'init=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:114
msgid ""
"This sets the initial command to be executed by the kernel.  If this is not "
"set, or cannot be found, the kernel will try I</sbin/init>, then "
"I</etc/init>, then I</bin/init>, then I</bin/sh> and panic if all of this "
"fails."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:114
#, no-wrap
msgid "B<'nfsaddrs=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:118
msgid ""
"This sets the NFS boot address to the given string.  This boot address is "
"used in case of a net boot."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:118
#, no-wrap
msgid "B<'nfsroot=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:125
msgid ""
"This sets the NFS root name to the given string.  If this string does not "
"begin with '/' or ',' or a digit, then it is prefixed by \\&'/tftpboot/'.  "
"This root name is used in case of a net boot."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:125
#, no-wrap
msgid "B<'root=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:135
msgid ""
"This argument tells the kernel what device is to be used as the root "
"filesystem while booting.  The default of this setting is determined at "
"compile time, and usually is the value of the root device of the system that"
" the kernel was built on.  To override this value, and select the second "
"floppy drive as the root device, one would use 'root=/dev/fd1'."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:144
msgid ""
"The root device can be specified symbolically or numerically.  A symbolic "
"specification has the form I</dev/XXYN>, where XX designates the device type"
" (e.g., 'hd' for ST-506 compatible hard disk, with Y in \\&'a'-'d'; 'sd' for"
" SCSI compatible disk, with Y in 'a'-'e'), Y the driver letter or number, "
"and N the number (in decimal) of the partition on this device."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:148
msgid ""
"Note that this has nothing to do with the designation of these devices on "
"your filesystem.  The '/dev/' part is purely conventional."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:155
msgid ""
"The more awkward and less portable numeric specification of the above "
"possible root devices in major/minor format is also accepted.  (For example,"
" I</dev/sda3> is major 8, minor 3, so you could use 'root=0x803' as an "
"alternative.)"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:155
#, no-wrap
msgid "B<'rootdelay='>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:159
msgid ""
"This parameter sets the delay (in seconds) to pause before attempting to "
"mount the root filesystem."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:159
#, no-wrap
msgid "B<'rootflags=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:164
msgid ""
"This parameter sets the mount option string for the root filesystem (see "
"also B<fstab>(5))."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:164
#, no-wrap
msgid "B<'rootfstype=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:172
msgid ""
"The 'rootfstype' option tells the kernel to mount the root filesystem as if "
"it where of the type specified.  This can be useful (for example) to mount "
"an ext3 filesystem as ext2 and then remove the journal in the root "
"filesystem, in fact reverting its format from ext3 to ext2 without the need "
"to boot the box from alternate media."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:172
#, no-wrap
msgid "B<'ro'> and B<'rw'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:182
msgid ""
"The 'ro' option tells the kernel to mount the root filesystem as 'read-only'"
" so that filesystem consistency check programs (fsck)  can do their work on "
"a quiescent filesystem.  No processes can write to files on the filesystem "
"in question until it is 'remounted' as read/write capable, for example, by "
"'mount -w -n -o remount /'.  (See also B<mount>(8).)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:185
msgid ""
"The 'rw' option tells the kernel to mount the root filesystem read/write.  "
"This is the default."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:185
#, no-wrap
msgid "B<'resume=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:190
msgid ""
"This tells the kernel the location of the suspend-to-disk data that you want"
" the machine to resume from after hibernation.  Usually, it is the same as "
"your swap partition or file.  Example:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:194
#, no-wrap
msgid "resume=/dev/hda2\n"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:196
#, no-wrap
msgid "B<'reserve=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:200
msgid ""
"This is used to protect I/O port regions from probes.  The form of the "
"command is:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:204
#, no-wrap
msgid "B<reserve=>I<iobase,extent[,iobase,extent]...>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:213
msgid ""
"In some machines it may be necessary to prevent device drivers from checking"
" for devices (auto-probing) in a specific region.  This may be because of "
"hardware that reacts badly to the probing, or hardware that would be "
"mistakenly identified, or merely hardware you don't want the kernel to "
"initialize."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:218
msgid ""
"The reserve boot-time argument specifies an I/O port region that shouldn't "
"be probed.  A device driver will not probe a reserved region, unless another"
" boot argument explicitly specifies that it do so."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:220
msgid "For example, the boot line"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:224
#, no-wrap
msgid "reserve=0x300,32  blah=0x300\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:229
msgid ""
"keeps all device drivers except the driver for 'blah' from probing "
"0x300-0x31f."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:229
#, no-wrap
msgid "B<'panic=N'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:234
msgid ""
"By default, the kernel will not reboot after a panic, but this option will "
"cause a kernel reboot after N seconds (if N is greater than zero).  This "
"panic timeout can also be set by"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:238
#, no-wrap
msgid "echo N E<gt> /proc/sys/kernel/panic\n"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:240
#, no-wrap
msgid "B<'reboot=[warm|cold][,[bios|hard]]'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:252
msgid ""
"Since Linux 2.0.22, a reboot is by default a cold reboot.  One asks for the "
"old default with 'reboot=warm'.  (A cold reboot may be required to reset "
"certain hardware, but might destroy not yet written data in a disk cache.  A"
" warm reboot may be faster.)  By default, a reboot is hard, by asking the "
"keyboard controller to pulse the reset line low, but there is at least one "
"type of motherboard where that doesn't work.  The option 'reboot=bios' will "
"instead jump through the BIOS."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:252
#, no-wrap
msgid "B<'nosmp'> and B<'maxcpus=N'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:258
msgid ""
"(Only when __SMP__ is defined.)  A command-line option of 'nosmp' or "
"'maxcpus=0' will disable SMP activation entirely; an option 'maxcpus=N' "
"limits the maximum number of CPUs activated in SMP mode to N."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:258
#, no-wrap
msgid "Boot arguments for use by kernel developers"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:259
#, no-wrap
msgid "B<'debug'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:285
msgid ""
"Kernel messages are handed off to a daemon (e.g., B<klogd>(8)  or similar) "
"so that they may be logged to disk.  Messages with a priority above "
"I<console_loglevel> are also printed on the console.  (For a discussion of "
"log levels, see B<syslog>(2).)  By default, I<console_loglevel> is set to "
"log messages at levels higher than B<KERN_DEBUG>.  This boot argument will "
"cause the kernel to also print messages logged at level B<KERN_DEBUG>.  The "
"console loglevel can also be set on a booted system via the "
"I</proc/sys/kernel/printk> file (described in B<syslog>(2)), the "
"B<syslog>(2)  B<SYSLOG_ACTION_CONSOLE_LEVEL> operation, or B<dmesg>(8)."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:285
#, no-wrap
msgid "B<'profile=N'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:303
msgid ""
"It is possible to enable a kernel profiling function, if one wishes to find "
"out where the kernel is spending its CPU cycles.  Profiling is enabled by "
"setting the variable I<prof_shift> to a nonzero value.  This is done either "
"by specifying B<CONFIG_PROFILE> at compile time, or by giving the 'profile='"
" option.  Now the value that I<prof_shift> gets will be N, when given, or "
"B<CONFIG_PROFILE_SHIFT>, when that is given, or 2, the default.  The "
"significance of this variable is that it gives the granularity of the "
"profiling: each clock tick, if the system was executing kernel code, a "
"counter is incremented:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:307
#, no-wrap
msgid "profile[address E<gt>E<gt> prof_shift]++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:316
msgid ""
"The raw profiling information can be read from I</proc/profile>.  Probably "
"you'll want to use a tool such as readprofile.c to digest it.  Writing to "
"I</proc/profile> will clear the counters."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:316
#, no-wrap
msgid "Boot arguments for ramdisk use"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:327
msgid ""
"(Only if the kernel was compiled with B<CONFIG_BLK_DEV_RAM>.)  In general it"
" is a bad idea to use a ramdisk under Linux\\(emthe system will use "
"available memory more efficiently itself.  But while booting, it is often "
"useful to load the floppy contents into a ramdisk.  One might also have a "
"system in which first some modules (for filesystem or hardware) must be "
"loaded before the main disk can be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:338
msgid ""
"In Linux 1.3.48, ramdisk handling was changed drastically.  Earlier, the "
"memory was allocated statically, and there was a 'ramdisk=N' parameter to "
"tell its size.  (This could also be set in the kernel image at compile "
"time.)  These days ram disks use the buffer cache, and grow dynamically.  "
"For a lot of information on the current ramdisk setup, see the kernel source"
" file I<Documentation/blockdev/ramdisk.txt> (I<Documentation/ramdisk.txt> in"
" older kernels)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:340
msgid "There are four parameters, two boolean and two integral."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:340
#, no-wrap
msgid "B<'load_ramdisk=N'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:345
msgid ""
"If N=1, do load a ramdisk.  If N=0, do not load a ramdisk.  (This is the "
"default.)"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:345
#, no-wrap
msgid "B<'prompt_ramdisk=N'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:351
msgid ""
"If N=1, do prompt for insertion of the floppy.  (This is the default.)  If "
"N=0, do not prompt.  (Thus, this parameter is never needed.)"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:351
#, no-wrap
msgid "B<'ramdisk_size=N'> or (obsolete) B<'ramdisk=N'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:355
msgid ""
"Set the maximal size of the ramdisk(s) to N kB.  The default is 4096 (4\\ "
"MB)."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:355
#, no-wrap
msgid "B<'ramdisk_start=N'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:360
msgid ""
"Sets the starting block number (the offset on the floppy where the ramdisk "
"starts) to N.  This is needed in case the ramdisk follows a kernel image."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:360
#, no-wrap
msgid "B<'noinitrd'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:379
msgid ""
"(Only if the kernel was compiled with B<CONFIG_BLK_DEV_RAM> and "
"B<CONFIG_BLK_DEV_INITRD>.)  These days it is possible to compile the kernel "
"to use initrd.  When this feature is enabled, the boot process will load the"
" kernel and an initial ramdisk; then the kernel converts initrd into a "
"\"normal\" ramdisk, which is mounted read-write as root device; then "
"I</linuxrc> is executed; afterward the \"real\" root filesystem is mounted, "
"and the initrd filesystem is moved over to I</initrd>; finally the usual "
"boot sequence (e.g., invocation of I</sbin/init>)  is performed."
msgstr ""

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: man-pages/man7/bootparam.7:386
msgid ""
"For a detailed description of the initrd feature, see the kernel source file"
" I<Documentation/admin-guide/initrd.rst> (or I<Documentation/initrd.txt> "
"before Linux 4.10)."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:394
msgid ""
"The 'noinitrd' option tells the kernel that although it was compiled for "
"operation with initrd, it should not go through the above steps, but leave "
"the initrd data under I</dev/initrd>.  (This device can be used only once: "
"the data is freed as soon as the last process that used it has closed "
"I</dev/initrd>.)"
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:394
#, no-wrap
msgid "Boot arguments for SCSI devices"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:396
msgid "General notation for this section:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:401
msgid ""
"I<iobase> -- the first I/O port that the SCSI host occupies.  These are "
"specified in hexadecimal notation, and usually lie in the range from 0x200 "
"to 0x3ff."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:409
msgid ""
"I<irq> -- the hardware interrupt that the card is configured to use.  Valid "
"values will be dependent on the card in question, but will usually be 5, 7, "
"9, 10, 11, 12, and 15.  The other values are usually used for common "
"peripherals like IDE hard disks, floppies, serial ports, and so on."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:417
msgid ""
"I<scsi-id> -- the ID that the host adapter uses to identify itself on the "
"SCSI bus.  Only some host adapters allow you to change this value, as most "
"have it permanently specified internally.  The usual default value is 7, but"
" the Seagate and Future Domain TMC-950 boards use 6."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:425
msgid ""
"I<parity> -- whether the SCSI host adapter expects the attached devices to "
"supply a parity value with all information exchanges.  Specifying a one "
"indicates parity checking is enabled, and a zero disables parity checking.  "
"Again, not all adapters will support selection of parity behavior as a boot "
"argument."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:425
#, no-wrap
msgid "B<'max_scsi_luns=...'>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:436
msgid ""
"A SCSI device can have a number of 'subdevices' contained within itself.  "
"The most common example is one of the new SCSI CD-ROMs that handle more than"
" one disk at a time.  Each CD is addressed as a \\&'Logical Unit Number' "
"(LUN) of that particular device.  But most devices, such as hard disks, tape"
" drives and such are only one device, and will be assigned to LUN zero."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:442
msgid ""
"Some poorly designed SCSI devices cannot handle being probed for LUNs not "
"equal to zero.  Therefore, if the compile-time flag B<CONFIG_SCSI_MULTI_LUN>"
" is not set, newer kernels will by default probe only LUN zero."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:448
msgid ""
"To specify the number of probed LUNs at boot, one enters "
"\\&'max_scsi_luns=n' as a boot arg, where n is a number between one and "
"eight.  To avoid problems as described above, one would use n=1 to avoid "
"upsetting such broken devices."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:448
#, no-wrap
msgid "B<SCSI tape configuration>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:452
msgid ""
"Some boot time configuration of the SCSI tape driver can be achieved by "
"using the following:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:456
#, no-wrap
msgid "B<st=>I<buf_size[,write_threshold[,max_bufs]]>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:471
msgid ""
"The first two numbers are specified in units of kB.  The default I<buf_size>"
" is 32k\\ B, and the maximum size that can be specified is a ridiculous "
"16384\\ kB.  The I<write_threshold> is the value at which the buffer is "
"committed to tape, with a default value of 30\\ kB.  The maximum number of "
"buffers varies with the number of drives detected, and has a default of two."
"  An example usage would be:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:475
#, no-wrap
msgid "st=32,30,2\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:483
msgid ""
"Full details can be found in the file I<Documentation/scsi/st.txt> (or "
"I<drivers/scsi/README.st> for older kernels) in the Linux kernel source."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:483
#, no-wrap
msgid "Hard disks"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:484
#, no-wrap
msgid "B<IDE Disk/CD-ROM Driver Parameters>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:489
msgid ""
"The IDE driver accepts a number of parameters, which range from disk "
"geometry specifications, to support for broken controller chips.  Drive-"
"specific options are specified by using 'hdX=' with X in 'a'-'h'."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:493
msgid ""
"Non-drive-specific options are specified with the prefix 'hd='.  Note that "
"using a drive-specific prefix for a non-drive-specific option will still "
"work, and the option will just be applied as expected."
msgstr ""

#.  Linux 2.0, 2.2, 2.4
#. type: Plain text
#: man-pages/man7/bootparam.7:506
msgid ""
"Also note that 'hd=' can be used to refer to the next unspecified drive in "
"the (a, ..., h) sequence.  For the following discussions, the 'hd=' option "
"will be cited for brevity.  See the file I<Documentation/ide/ide.txt> (or "
"I<Documentation/ide.txt> in older kernels, or I<drivers/block/README.ide> in"
" ancient kernels) in the Linux kernel source for more details."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:506
#, no-wrap
msgid "B<The 'hd=cyls,heads,sects[,wpcom[,irq]]' options>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:517
msgid ""
"These options are used to specify the physical geometry of the disk.  Only "
"the first three values are required.  The cylinder/head/sectors values will "
"be those used by fdisk.  The write precompensation value is ignored for IDE "
"disks.  The IRQ value specified will be the IRQ used for the interface that "
"the drive resides on, and is not really a drive-specific parameter."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:517
#, no-wrap
msgid "B<The 'hd=serialize' option>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:525
msgid ""
"The dual IDE interface CMD-640 chip is broken as designed such that when "
"drives on the secondary interface are used at the same time as drives on the"
" primary interface, it will corrupt your data.  Using this option tells the "
"driver to make sure that both interfaces are never used at the same time."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:525
#, no-wrap
msgid "B<The 'hd=noprobe' option>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:529
msgid "Do not probe for this drive.  For example,"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:533
#, no-wrap
msgid "hdb=noprobe hdb=1166,7,17\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:539
msgid ""
"would disable the probe, but still specify the drive geometry so that it "
"would be registered as a valid block device, and hence usable."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:539
#, no-wrap
msgid "B<The 'hd=nowerr' option>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:545
msgid ""
"Some drives apparently have the B<WRERR_STAT> bit stuck on permanently.  "
"This enables a work-around for these broken devices."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:545
#, no-wrap
msgid "B<The 'hd=cdrom' option>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:551
msgid ""
"This tells the IDE driver that there is an ATAPI compatible CD-ROM attached "
"in place of a normal IDE hard disk.  In most cases the CD-ROM is identified "
"automatically, but if it isn't then this may help."
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:551
#, no-wrap
msgid "B<Standard ST-506 Disk Driver Options ('hd=')>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:560
msgid ""
"The standard disk driver can accept geometry arguments for the disks similar"
" to the IDE driver.  Note however that it expects only three values (C/H/S);"
" any more or any less and it will silently ignore you.  Also, it accepts "
"only 'hd=' as an argument, that is, 'hda=' and so on are not valid here.  "
"The format is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:564
#, no-wrap
msgid "hd=cyls,heads,sects\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:569
msgid ""
"If there are two disks installed, the above is repeated with the geometry "
"parameters of the second disk."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:569
#, no-wrap
msgid "Ethernet devices"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:573
msgid ""
"Different drivers make use of different parameters, but they all at least "
"share having an IRQ, an I/O port base value, and a name.  In its most "
"generic form, it looks something like this:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:577
#, no-wrap
msgid "ether=irq,iobase[,param_1[,...param_8]],name\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:586
msgid ""
"The first nonnumeric argument is taken as the name.  The param_n values (if "
"applicable) usually have different meanings for each different card/driver."
"  Typical param_n values are used to specify things like shared memory "
"address, interface selection, DMA channel and the like."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:590
msgid ""
"The most common use of this parameter is to force probing for a second "
"ethercard, as the default is to probe only for one.  This can be "
"accomplished with a simple:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:594
#, no-wrap
msgid "ether=0,0,eth1\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:599
msgid ""
"Note that the values of zero for the IRQ and I/O base in the above example "
"tell the driver(s) to autoprobe."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:605
msgid ""
"The Ethernet-HowTo has extensive documentation on using multiple cards and "
"on the card/driver-specific implementation of the param_n values where used."
"  Interested readers should refer to the section in that document on their "
"particular card."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:605
#, no-wrap
msgid "The floppy disk driver"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:614
msgid ""
"There are many floppy driver options, and they are all listed in "
"I<Documentation/blockdev/floppy.txt> (or I<Documentation/floppy.txt> in "
"older kernels, or I<drivers/block/README.fd> for ancient kernels) in the "
"Linux kernel source.  See that file for the details."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:614
#, no-wrap
msgid "The sound driver"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:624
msgid ""
"The sound driver can also accept boot arguments to override the compiled-in "
"values.  This is not recommended, as it is rather complex.  It is described "
"in the Linux kernel source file I<Documentation/sound/oss/README.OSS> "
"(I<drivers/sound/Readme.linux> in older kernel versions).  It accepts a boot"
" argument of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:628
#, no-wrap
msgid "sound=device1[,device2[,device3...[,device10]]]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:633
msgid ""
"where each deviceN value is of the following format 0xTaaaId and the bytes "
"are used as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:636
msgid ""
"T - device type: 1=FM, 2=SB, 3=PAS, 4=GUS, 5=MPU401, 6=SB16, 7=SB16-MPU401"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:638
msgid "aaa - I/O address in hex."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:640
msgid "I - interrupt line in hex (i.e., 10=a, 11=b, ...)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:642
msgid "d - DMA channel."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:647
msgid ""
"As you can see, it gets pretty messy, and you are better off to compile in "
"your own personal values as recommended.  Using a boot argument of "
"\\&'sound=0' will disable the sound driver entirely."
msgstr ""

#. type: SS
#: man-pages/man7/bootparam.7:647
#, no-wrap
msgid "The line printer driver"
msgstr ""

#. type: TP
#: man-pages/man7/bootparam.7:648
#, no-wrap
msgid "B<'lp='>"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:652
msgid "Syntax:"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:659
#, no-wrap
msgid ""
"lp=0\n"
"lp=auto\n"
"lp=reset\n"
"lp=port[,port...]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:667
msgid ""
"You can tell the printer driver what ports to use and what ports not to use."
"  The latter comes in handy if you don't want the printer driver to claim "
"all available parallel ports, so that other drivers (e.g., PLIP, PPA) can "
"use them instead."
msgstr ""

#.  .SH AUTHORS
#.  Linus Torvalds (and many others)
#. type: Plain text
#: man-pages/man7/bootparam.7:676
msgid ""
"The format of the argument is multiple port names.  For example, "
"lp=none,parport0 would use the first parallel port for lp1, and disable lp0."
"  To disable the printer driver entirely, one can use lp=0."
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:679
msgid "B<klogd>(8), B<mount>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man7/bootparam.7:681
msgid ""
"For up-to-date information, see the kernel source file I<Documentation"
"/admin-guide/kernel-parameters.txt>."
msgstr ""

#. type: TH
#: man-pages/man2/brk.2:29
#, no-wrap
msgid "BRK"
msgstr ""

#. type: TH
#: man-pages/man2/brk.2:29
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:32
msgid "brk, sbrk - change data segment size"
msgstr ""

#. type: SH
#: man-pages/man2/brk.2:32
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:34
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:36
msgid "B<int brk(void *>I<addr>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:38
msgid "B<void *sbrk(intptr_t >I<increment>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:42
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:46
msgid "B<brk>(), B<sbrk>():"
msgstr ""

#. type: TP
#: man-pages/man2/brk.2:49
#, no-wrap
msgid "Since glibc 2.19:"
msgstr ""

#.     (_XOPEN_SOURCE\ >=\ 500 ||
#.         _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
#. type: Plain text
#: man-pages/man2/brk.2:57
#, no-wrap
msgid ""
"_DEFAULT_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#. type: TP
#: man-pages/man2/brk.2:58
#, no-wrap
msgid "From glibc 2.12 to 2.19:"
msgstr ""

#.     (_XOPEN_SOURCE\ >=\ 500 ||
#.         _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
#. type: Plain text
#: man-pages/man2/brk.2:66
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#. type: TP
#: man-pages/man2/brk.2:67
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/brk.2:71
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:86
msgid ""
"B<brk>()  and B<sbrk>()  change the location of the I<program break>, which "
"defines the end of the process's data segment (i.e., the program break is "
"the first location after the end of the uninitialized data segment).  "
"Increasing the program break has the effect of allocating memory to the "
"process; decreasing the break deallocates memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:93
msgid ""
"B<brk>()  sets the end of the data segment to the value specified by "
"I<addr>, when that value is reasonable, the system has enough memory, and "
"the process does not exceed its maximum data size (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:103
msgid ""
"B<sbrk>()  increments the program's data space by I<increment> bytes.  "
"Calling B<sbrk>()  with an I<increment> of 0 can be used to find the current"
" location of the program break."
msgstr ""

#. type: SH
#: man-pages/man2/brk.2:103
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:111
msgid ""
"On success, B<brk>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set to B<ENOMEM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:123
msgid ""
"On success, B<sbrk>()  returns the previous program break.  (If the break "
"was increased, then this value is a pointer to the start of the newly "
"allocated memory).  On error, I<(void\\ *)\\ -1> is returned, and I<errno> "
"is set to B<ENOMEM>."
msgstr ""

#. type: SH
#: man-pages/man2/brk.2:123
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#.  .BR brk ()
#.  and
#.  .BR sbrk ()
#.  are not defined in the C Standard and are deliberately excluded from the
#.  POSIX.1-1990 standard (see paragraphs B.1.1.1.3 and B.8.3.3).
#. type: Plain text
#: man-pages/man2/brk.2:131
msgid "4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001."
msgstr ""

#. type: SH
#: man-pages/man2/brk.2:131
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:140
msgid ""
"Avoid using B<brk>()  and B<sbrk>(): the B<malloc>(3)  memory allocation "
"package is the portable and comfortable way of allocating memory."
msgstr ""

#.  One sees
#.  \fIint\fP (e.g., XPGv4, DU 4.0, HP-UX 11, FreeBSD 4.0, OpenBSD 3.2),
#.  \fIssize_t\fP (OSF1 2.0, Irix 5.3, 6.5),
#.  \fIptrdiff_t\fP (libc4, libc5, ulibc, glibc 2.0, 2.1),
#.  \fIintptr_t\fP (e.g., XPGv5, AIX, SunOS 5.8, 5.9, FreeBSD 4.7, NetBSD 1.6,
#.  Tru64 5.1, glibc2.2).
#. type: Plain text
#: man-pages/man2/brk.2:150
msgid ""
"Various systems use various types for the argument of B<sbrk>().  Common are"
" I<int>, I<ssize_t>, I<ptrdiff_t>, I<intptr_t>."
msgstr ""

#. type: SS
#: man-pages/man2/brk.2:150
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:166
msgid ""
"The return value described above for B<brk>()  is the behavior provided by "
"the glibc wrapper function for the Linux B<brk>()  system call.  (On most "
"other implementations, the return value from B<brk>()  is the same; this "
"return value was also specified in SUSv2.)  However, the actual Linux system"
" call returns the new program break on success.  On failure, the system call"
" returns the current break.  The glibc wrapper function does some work "
"(i.e., checks whether the new break is less than I<addr>)  to provide the 0 "
"and -1 return values described above."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:173
msgid ""
"On Linux, B<sbrk>()  is implemented as a library function that uses the "
"B<brk>()  system call, and does some internal bookkeeping so that it can "
"return the old break value."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:177
msgid "B<execve>(2), B<getrlimit>(2), B<end>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/bind.2:68
#, no-wrap
msgid "BIND"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:71
msgid "bind - bind a name to a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:75
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:78
#, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:92
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:99
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a"
" B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:130
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET>, see "
"B<ip>(7); for B<AF_INET6>, see B<ipv6>(7); for B<AF_UNIX>, see B<unix>(7); "
"for B<AF_APPLETALK>, see B<ddp>(7); for B<AF_PACKET>, see B<packet>(7); for "
"B<AF_X25>, see B<x25>(7); and for B<AF_NETLINK>, see B<netlink>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:137
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:144
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:152
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLE below."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:157
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""

#. type: SH
#: man-pages/man2/bind.2:157
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:158 man-pages/man2/bind.2:199
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
#: man-pages/man2/bind.2:162
msgid "The address is protected, and the user is not the superuser."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:162 man-pages/man2/bind.2:165
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:165
msgid "The given address is already in use."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:175
msgid ""
"(Internet domain sockets)  The port number was specified as zero in the "
"socket address structure, but, upon attempting to bind to an ephemeral port,"
" it was determined that all port numbers in the ephemeral port range are "
"currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> B<ip>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:175
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:179
msgid "I<sockfd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:179 man-pages/man2/bind.2:184
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
#: man-pages/man2/bind.2:184
msgid "The socket is already bound to an address."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:190
msgid ""
"I<addrlen> is wrong, or I<addr> is not a valid address for this socket's "
"domain."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:190
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:195
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:199
msgid ""
"The following errors are specific to UNIX domain (B<AF_UNIX>)  sockets:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:204
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:204
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:208
msgid ""
"A nonexistent interface was requested or the requested address was not "
"local."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:208
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:212
msgid "I<addr> points outside the user's accessible address space."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:212
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:216
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:216
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:220
msgid "I<addr> is too long."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:220
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:223
msgid ""
"A component in the directory prefix of the socket pathname does not exist."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:223
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:226
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:226
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:229
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:229
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:232
msgid "The socket inode would reside on a read-only filesystem."
msgstr ""

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  UNIX-domain error conditions.
#. type: Plain text
#: man-pages/man2/bind.2:244
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<bind>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:250
msgid ""
"POSIX.1 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and this"
" header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:255
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr ""

#. type: SH
#: man-pages/man2/bind.2:255
#, no-wrap
msgid "BUGS"
msgstr ""

#.  FIXME Document transparent proxy options
#. type: Plain text
#: man-pages/man2/bind.2:258
msgid "The transparent proxy options are not described."
msgstr ""

#. type: SH
#: man-pages/man2/bind.2:258
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:263
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
#: man-pages/man2/bind.2:270
msgid ""
"The following example shows how to bind a stream socket in the UNIX "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:277
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:280
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:283
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:290
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:294
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:300
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(struct sockaddr_un));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:304
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(struct sockaddr_un)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:307
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:310
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:316
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(struct sockaddr_un);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:318
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:322
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:335
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), "
"B<path_resolution>(7), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/bpf.2:26
#, no-wrap
msgid "BPF"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:29
msgid "bpf - perform a command on an extended BPF map or program"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:32
#, no-wrap
msgid "B<#include E<lt>linux/bpf.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:34
#, no-wrap
msgid ""
"B<int bpf(int >I<cmd>B<, union bpf_attr *>I<attr>B<, unsigned int "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:45
msgid ""
"The B<bpf>()  system call performs a range of operations related to extended"
" Berkeley Packet Filters.  Extended BPF (or eBPF) is similar to the original"
" (\"classic\") BPF (cBPF) used to filter network packets.  For both cBPF and"
" eBPF programs, the kernel statically analyzes the programs before loading "
"them, in order to ensure that they cannot harm the running system."
msgstr ""

#.  See 'enum bpf_func_id' in include/uapi/linux/bpf.h
#. type: Plain text
#: man-pages/man2/bpf.2:54
msgid ""
"eBPF extends cBPF in multiple ways, including the ability to call a fixed "
"set of in-kernel helper functions (via the B<BPF_CALL> opcode extension "
"provided by eBPF)  and access shared data structures such as eBPF maps."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:54
#, no-wrap
msgid "Extended BPF Design/Architecture"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:59
msgid ""
"eBPF maps are a generic data structure for storage of different data types."
"  Data types are generally treated as binary blobs, so a user just specifies"
" the size of the key and the size of the value at map-creation time.  In "
"other words, a key/value for a given map can have an arbitrary structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:65
msgid ""
"A user process can create multiple maps (with key/value-pairs being opaque "
"bytes of data) and access them via file descriptors.  Different eBPF "
"programs can access the same maps in parallel.  It's up to the user process "
"and eBPF program to decide what they store inside maps."
msgstr ""

#.  Defined by the kernel constant MAX_TAIL_CALL_CNT in include/linux/bpf.h
#. type: Plain text
#: man-pages/man2/bpf.2:83
msgid ""
"There's one special map type, called a program array.  This type of map "
"stores file descriptors referring to other eBPF programs.  When a lookup in "
"the map is performed, the program flow is redirected in-place to the "
"beginning of another eBPF program and does not return back to the calling "
"program.  The level of nesting has a fixed limit of 32, so that infinite "
"loops cannot be crafted.  At run time, the program file descriptors stored "
"in the map can be modified, so program functionality can be altered based on"
" specific requirements.  All programs referred to in a program-array map "
"must have been previously loaded into the kernel via B<bpf>().  If a map "
"lookup fails, the current program continues its execution.  See "
"B<BPF_MAP_TYPE_PROG_ARRAY> below for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:97
msgid ""
"Generally, eBPF programs are loaded by the user process and automatically "
"unloaded when the process exits.  In some cases, for example, B<tc-bpf>(8), "
"the program will continue to stay alive inside the kernel even after the "
"process that loaded the program exits.  In that case, the tc subsystem holds"
" a reference to the eBPF program after the file descriptor has been closed "
"by the user-space program.  Thus, whether a specific program continues to "
"live inside the kernel depends on how it is further attached to a given "
"kernel subsystem after it was loaded via B<bpf>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:105
msgid ""
"Each eBPF program is a set of instructions that is safe to run until its "
"completion.  An in-kernel verifier statically determines that the eBPF "
"program terminates and is safe to execute.  During verification, the kernel "
"increments reference counts for each of the maps that the eBPF program uses,"
" so that the attached maps can't be removed until the program is unloaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:116
msgid ""
"eBPF programs can be attached to different events.  These events can be the "
"arrival of network packets, tracing events, classification events by network"
" queueing disciplines (for eBPF programs attached to a B<tc>(8)  "
"classifier), and other types that may be added in the future.  A new event "
"triggers execution of the eBPF program, which may store information about "
"the event in eBPF maps.  Beyond storing data, eBPF programs may call a fixed"
" set of in-kernel helper functions."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:119
msgid ""
"The same eBPF program can be attached to multiple events and different eBPF "
"programs can access the same map:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:131
#, no-wrap
msgid ""
"tracing     tracing    tracing    packet      packet     packet\n"
"event A     event B    event C    on eth0     on eth1    on eth2\n"
" |             |         |          |           |          ^\n"
" |             |         |          |           v          |\n"
" --E<gt> tracing E<lt>--     tracing      socket    tc ingress   tc egress\n"
"      prog_1          prog_2      prog_3    classifier    action\n"
"      |  |              |           |         prog_4      prog_5\n"
"   |---  -----|  |------|          map_3        |           |\n"
" map_1       map_2                              --| map_4 |--\n"
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:134
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:150
msgid ""
"The operation to be performed by the B<bpf>()  system call is determined by "
"the I<cmd> argument.  Each operation takes an accompanying argument, "
"provided via I<attr>, which is a pointer to a union of type I<bpf_attr> (see"
" below).  The I<size> argument is the size of the union pointed to by "
"I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:154
msgid "The value provided in I<cmd> is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:154 man-pages/man2/bpf.2:248 man-pages/man2/bpf.2:1016
#, no-wrap
msgid "B<BPF_MAP_CREATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:160
msgid ""
"Create a map and return a file descriptor that refers to the map.  The "
"close-on-exec file descriptor flag (see B<fcntl>(2))  is automatically "
"enabled for the new file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:160 man-pages/man2/bpf.2:385
#, no-wrap
msgid "B<BPF_MAP_LOOKUP_ELEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:163
msgid "Look up an element by key in a specified map and return its value."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:163 man-pages/man2/bpf.2:421
#, no-wrap
msgid "B<BPF_MAP_UPDATE_ELEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:166
msgid "Create or update an element (key/value pair) in a specified map."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:166 man-pages/man2/bpf.2:493
#, no-wrap
msgid "B<BPF_MAP_DELETE_ELEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:169
msgid "Look up and delete an element by key in a specified map."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:169 man-pages/man2/bpf.2:523
#, no-wrap
msgid "B<BPF_MAP_GET_NEXT_KEY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:173
msgid ""
"Look up an element by key in a specified map and return the key of the next "
"element."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:173 man-pages/man2/bpf.2:1019
#, no-wrap
msgid "B<BPF_PROG_LOAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:180
msgid ""
"Verify and load an eBPF program, returning a new file descriptor associated "
"with the program.  The close-on-exec file descriptor flag (see B<fcntl>(2))"
"  is automatically enabled for the new file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:186
msgid ""
"The I<bpf_attr> union consists of various anonymous structures that are used"
" by different B<bpf>()  commands:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:197
#, no-wrap
msgid ""
"union bpf_attr {\n"
"    struct {    /* Used by BPF_MAP_CREATE */\n"
"        __u32         map_type;\n"
"        __u32         key_size;    /* size of key in bytes */\n"
"        __u32         value_size;  /* size of value in bytes */\n"
"        __u32         max_entries; /* maximum number of entries\n"
"                                      in a map */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:208
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY\n"
"                   commands */\n"
"        __u32         map_fd;\n"
"        __aligned_u64 key;\n"
"        union {\n"
"            __aligned_u64 value;\n"
"            __aligned_u64 next_key;\n"
"        };\n"
"        __u64         flags;\n"
"    };\n"
msgstr ""

#.                  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: man-pages/man2/bpf.2:224
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_PROG_LOAD */\n"
"        __u32         prog_type;\n"
"        __u32         insn_cnt;\n"
"        __aligned_u64 insns;      /* 'const struct bpf_insn *' */\n"
"        __aligned_u64 license;    /* 'const char *' */\n"
"        __u32         log_level;  /* verbosity level of verifier */\n"
"        __u32         log_size;   /* size of user buffer */\n"
"        __aligned_u64 log_buf;    /* user supplied 'char *'\n"
"                                     buffer */\n"
"        __u32         kern_version;\n"
"                                  /* checked when prog_type=kprobe\n"
"                                     (since Linux 4.1) */\n"
"    };\n"
"} __attribute__((aligned(8)));\n"
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:227
#, no-wrap
msgid "eBPF maps"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:231
msgid ""
"Maps are a generic data structure for storage of different types of data.  "
"They allow sharing of data between eBPF kernel programs, and also between "
"kernel and user-space applications."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:233
msgid "Each map type has the following attributes:"
msgstr ""

#. type: IP
#: man-pages/man2/bpf.2:233 man-pages/man2/bpf.2:235 man-pages/man2/bpf.2:237
#: man-pages/man2/bpf.2:239 man-pages/man2/bpf.2:590 man-pages/man2/bpf.2:594
#: man-pages/man2/bpf.2:596 man-pages/man2/bpf.2:603 man-pages/man2/bpf.2:615
#: man-pages/man2/bpf.2:628 man-pages/man2/bpf.2:630 man-pages/man2/bpf.2:632
#: man-pages/man2/bpf.2:637 man-pages/man2/bpf.2:656 man-pages/man2/bpf.2:660
#: man-pages/man2/bpf.2:662 man-pages/man2/bpf.2:768 man-pages/man2/bpf.2:773
#: man-pages/man2/bpf.2:777 man-pages/man2/bpf.2:784 man-pages/man2/bpf.2:792
#: man-pages/man2/bpf.2:801 man-pages/man2/bpf.2:1188
#: man-pages/man2/bpf.2:1191 man-pages/man2/bpf.2:1193
#: man-pages/man2/bpf.2:1195 man-pages/man2/bpf.2:1197
#: man-pages/man2/bpf.2:1199 man-pages/man2/bpf.2:1201
#: man-pages/man2/bpf.2:1203
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:235
msgid "type"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:237
msgid "maximum number of elements"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:239
msgid "key size in bytes"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:241
msgid "value size in bytes"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:248
msgid ""
"The following wrapper functions demonstrate how various B<bpf>()  commands "
"can be used to access the maps.  The functions use the I<cmd> argument to "
"invoke different operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:254
msgid ""
"The B<BPF_MAP_CREATE> command creates a new map, returning a new file "
"descriptor that refers to the map."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:269
#, no-wrap
msgid ""
"int\n"
"bpf_create_map(enum bpf_map_type map_type,\n"
"               unsigned int key_size,\n"
"               unsigned int value_size,\n"
"               unsigned int max_entries)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_type    = map_type,\n"
"        .key_size    = key_size,\n"
"        .value_size  = value_size,\n"
"        .max_entries = max_entries\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:272
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:290
msgid ""
"The new map has the type specified by I<map_type>, and attributes as "
"specified in I<key_size>, I<value_size>, and I<max_entries>.  On success, "
"this operation returns a file descriptor.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, or B<ENOMEM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:307
msgid ""
"The I<key_size> and I<value_size> attributes will be used by the verifier "
"during program loading to check that the program is calling "
"B<bpf_map_*_elem>()  helper functions with a correctly initialized I<key> "
"and to check that the program doesn't access the map element I<value> beyond"
" the specified I<value_size>.  For example, when a map is created with a "
"I<key_size> of 8 and the eBPF program calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:311
#, no-wrap
msgid "bpf_map_lookup_elem(map_fd, fp - 4)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:316
msgid "the program will be rejected, since the in-kernel helper function"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:319
#, no-wrap
msgid "    bpf_map_lookup_elem(map_fd, void *key)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:329
msgid ""
"expects to read 8 bytes from the location pointed to by I<key>, but the "
"I<fp\\ -\\ 4> (where I<fp> is the top of the stack)  starting address will "
"cause out-of-bounds stack access."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:333
msgid ""
"Similarly, when a map is created with a I<value_size> of 1 and the eBPF "
"program contains"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:338
#, no-wrap
msgid ""
"value = bpf_map_lookup_elem(...);\n"
"*(u32 *) value = 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:346
msgid ""
"the program will be rejected, since it accesses the I<value> pointer beyond "
"the specified 1 byte I<value_size> limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:349
msgid "Currently, the following values are supported for I<map_type>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:371
#, no-wrap
msgid ""
"enum bpf_map_type {\n"
"    BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */\n"
"    BPF_MAP_TYPE_HASH,\n"
"    BPF_MAP_TYPE_ARRAY,\n"
"    BPF_MAP_TYPE_PROG_ARRAY,\n"
"    BPF_MAP_TYPE_PERF_EVENT_ARRAY,\n"
"    BPF_MAP_TYPE_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_PERCPU_ARRAY,\n"
"    BPF_MAP_TYPE_STACK_TRACE,\n"
"    BPF_MAP_TYPE_CGROUP_ARRAY,\n"
"    BPF_MAP_TYPE_LRU_HASH,\n"
"    BPF_MAP_TYPE_LRU_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_LPM_TRIE,\n"
"    BPF_MAP_TYPE_ARRAY_OF_MAPS,\n"
"    BPF_MAP_TYPE_HASH_OF_MAPS,\n"
"    BPF_MAP_TYPE_DEVMAP,\n"
"    BPF_MAP_TYPE_SOCKMAP,\n"
"    BPF_MAP_TYPE_CPUMAP,\n"
"};\n"
msgstr ""

#.  FIXME We need an explanation of why one might choose each of
#.  these map implementations
#. type: Plain text
#: man-pages/man2/bpf.2:385
msgid ""
"I<map_type> selects one of the available map implementations in the kernel."
"  For all map types, eBPF programs access maps with the same "
"B<bpf_map_lookup_elem>()  and B<bpf_map_update_elem>()  helper functions.  "
"Further details of the various map types are given below."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:393
msgid ""
"The B<BPF_MAP_LOOKUP_ELEM> command looks up an element with a given I<key> "
"in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:404
#, no-wrap
msgid ""
"int\n"
"bpf_lookup_elem(int fd, const void *key, void *value)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:407
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:416
msgid ""
"If an element is found, the operation returns zero and stores the element's "
"value into I<value>, which must point to a buffer of I<value_size> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:421
msgid ""
"If no element is found, the operation returns -1 and sets I<errno> to "
"B<ENOENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:430
msgid ""
"The B<BPF_MAP_UPDATE_ELEM> command creates or updates an element with a "
"given I<key/value> in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:443
#, no-wrap
msgid ""
"int\n"
"bpf_update_elem(int fd, const void *key, const void *value,\n"
"                uint64_t flags)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"        .flags  = flags,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:446
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:452
msgid "The I<flags> argument should be specified as one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:456
msgid "Create a new element or update an existing element."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:459
msgid "Create a new element only if it did not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:462
msgid "Update an existing element."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:493
msgid ""
"On success, the operation returns zero.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, B<ENOMEM>, or B<E2BIG>.  B<E2BIG> "
"indicates that the number of elements in the map reached the I<max_entries> "
"limit specified at map creation time.  B<EEXIST> will be returned if "
"I<flags> specifies B<BPF_NOEXIST> and the element with I<key> already exists"
" in the map.  B<ENOENT> will be returned if I<flags> specifies B<BPF_EXIST> "
"and the element with I<key> doesn't exist in the map."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:502
msgid ""
"The B<BPF_MAP_DELETE_ELEM> command deletes the element whose key is I<key> "
"from the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:512
#, no-wrap
msgid ""
"int\n"
"bpf_delete_elem(int fd, const void *key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:515
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:523
msgid ""
"On success, zero is returned.  If the element is not found, -1 is returned "
"and I<errno> is set to B<ENOENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:534
msgid ""
"The B<BPF_MAP_GET_NEXT_KEY> command looks up an element by I<key> in the map"
" referred to by the file descriptor I<fd> and sets the I<next_key> pointer "
"to the key of the next element."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:545
#, no-wrap
msgid ""
"int\n"
"bpf_get_next_key(int fd, const void *key, void *next_key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd   = fd,\n"
"        .key      = ptr_to_u64(key),\n"
"        .next_key = ptr_to_u64(next_key),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:548
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:576
msgid ""
"If I<key> is found, the operation returns zero and sets the I<next_key> "
"pointer to the key of the next element.  If I<key> is not found, the "
"operation returns zero and sets the I<next_key> pointer to the key of the "
"first element.  If I<key> is the last element, -1 is returned and I<errno> "
"is set to B<ENOENT>.  Other possible I<errno> values are B<ENOMEM>, "
"B<EFAULT>, B<EPERM>, and B<EINVAL>.  This method can be used to iterate over"
" all elements in the map."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:576
#, no-wrap
msgid "B<close(map_fd)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:583
msgid ""
"Delete the map referred to by the file descriptor I<map_fd>.  When the user-"
"space program that created a map exits, all maps will be deleted "
"automatically (but see NOTES)."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:583
#, no-wrap
msgid "eBPF map types"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:585
msgid "The following map types are supported:"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:585
#, no-wrap
msgid "B<BPF_MAP_TYPE_HASH>"
msgstr ""

#.  commit 0f8e4bd8a1fc8c4185f1630061d0a1f2d197a475
#. type: Plain text
#: man-pages/man2/bpf.2:589
msgid "Hash-table maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:594
msgid ""
"Maps are created and destroyed by user-space programs.  Both user-space and "
"eBPF programs can perform lookup, update, and delete operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:596
msgid "The kernel takes care of allocating and freeing key/value pairs."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:603
msgid ""
"The B<map_update_elem>()  helper will fail to insert new element when the "
"I<max_entries> limit is reached.  (This ensures that eBPF programs cannot "
"exhaust memory.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:606
msgid "B<map_update_elem>()  replaces existing elements atomically."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:610
msgid "Hash-table maps are optimized for speed of lookup."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:610
#, no-wrap
msgid "B<BPF_MAP_TYPE_ARRAY>"
msgstr ""

#.  commit 28fbcfa08d8ed7c5a50d41a0433aad222835e8e3
#. type: Plain text
#: man-pages/man2/bpf.2:614
msgid "Array maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:628
msgid ""
"Optimized for fastest possible lookup.  In the future the verifier/JIT "
"compiler may recognize lookup() operations that employ a constant key and "
"optimize it into constant pointer.  It is possible to optimize a non-"
"constant key into direct pointer arithmetic as well, since pointers and "
"I<value_size> are constant for the life of the eBPF program.  In other "
"words, B<array_map_lookup_elem>()  may be 'inlined' by the verifier/JIT "
"compiler while preserving concurrent access to this map from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:630
msgid "All array elements pre-allocated and zero initialized at init time"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:632
msgid "The key is an array index, and must be exactly four bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:637
msgid ""
"B<map_delete_elem>()  fails with the error B<EINVAL>, since elements cannot "
"be deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:652
msgid ""
"B<map_update_elem>()  replaces elements in a B<nonatomic> fashion; for "
"atomic updates, a hash-table map should be used instead.  There is however "
"one special case that can also be used with arrays: the atomic built-in "
"B<__sync_fetch_and_add()> can be used on 32 and 64 bit atomic counters.  For"
" example, it can be applied on the whole value itself if it represents a "
"single counter, or in case of a structure containing multiple counters, it "
"could be used on individual counters.  This is quite often useful for "
"aggregation and accounting of events."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:655
msgid "Among the uses for array maps are the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:660
msgid ""
"As \"global\" eBPF variables: an array of 1 element whose key is (index) 0 "
"and where the value is a collection of 'global' variables which eBPF "
"programs can use to keep state between events."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:662
msgid "Aggregation of tracing events into a fixed set of buckets."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:665
msgid ""
"Accounting of networking events, for example, number of packets and packet "
"sizes."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:666
#, no-wrap
msgid "B<BPF_MAP_TYPE_PROG_ARRAY> (since Linux 4.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:678
msgid ""
"A program array map is a special kind of array map whose map values contain "
"only file descriptors referring to other eBPF programs.  Thus, both the "
"I<key_size> and I<value_size> must be exactly four bytes.  This map is used "
"in conjunction with the B<bpf_tail_call>()  helper."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:681
msgid ""
"This means that an eBPF program with a program array map attached to it can "
"call from kernel side into"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:686
#, no-wrap
msgid ""
"void bpf_tail_call(void *context, void *prog_map,\n"
"                   unsigned int index);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:695
msgid ""
"and therefore replace its own program flow with the one from the program at "
"the given program array slot, if present.  This can be regarded as kind of a"
" jump table to a different eBPF program.  The invoked program will then "
"reuse the same stack.  When a jump into the new program has been performed, "
"it won't return to the old program anymore."
msgstr ""

#.  MAX_TAIL_CALL_CNT
#. type: Plain text
#: man-pages/man2/bpf.2:704
msgid ""
"If no eBPF program is found at the given index of the program array (because"
" the map slot doesn't contain a valid program file descriptor, the specified"
" lookup index/key is out of bounds, or the limit of 32 nested calls has been"
" exceed), execution continues with the current eBPF program.  This can be "
"used as a fall-through for default cases."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:716
msgid ""
"A program array map is useful, for example, in tracing or networking, to "
"handle individual system calls or protocols in their own subprograms and use"
" their identifiers as an individual map index.  This approach may result in "
"performance benefits, and also makes it possible to overcome the maximum "
"instruction limit of a single eBPF program.  In dynamic environments, a "
"user-space daemon might atomically replace individual subprograms at run-"
"time with newer versions to alter overall program behavior, for instance, if"
" global policies change."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:716
#, no-wrap
msgid "eBPF programs"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:722
msgid ""
"The B<BPF_PROG_LOAD> command is used to load an eBPF program into the "
"kernel.  The return value for this command is a new file descriptor "
"associated with this eBPF program."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:726
#, no-wrap
msgid "char bpf_log_buf[LOG_BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:741
#, no-wrap
msgid ""
"int\n"
"bpf_prog_load(enum bpf_prog_type type,\n"
"              const struct bpf_insn *insns, int insn_cnt,\n"
"              const char *license)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .prog_type = type,\n"
"        .insns     = ptr_to_u64(insns),\n"
"        .insn_cnt  = insn_cnt,\n"
"        .license   = ptr_to_u64(license),\n"
"        .log_buf   = ptr_to_u64(bpf_log_buf),\n"
"        .log_size  = LOG_BUF_SIZE,\n"
"        .log_level = 1,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:744
#, no-wrap
msgid ""
"    return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:749
msgid "I<prog_type> is one of the available program types:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:760
#, no-wrap
msgid ""
"enum bpf_prog_type {\n"
"    BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid\n"
"                                    program type */\n"
"    BPF_PROG_TYPE_SOCKET_FILTER,\n"
"    BPF_PROG_TYPE_KPROBE,\n"
"    BPF_PROG_TYPE_SCHED_CLS,\n"
"    BPF_PROG_TYPE_SCHED_ACT,\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:764
msgid "For further details of eBPF program types, see below."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:768
msgid "The remaining fields of I<bpf_attr> are set as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:773
msgid "I<insns> is an array of I<struct bpf_insn> instructions."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:777
msgid ""
"I<insn_cnt> is the number of instructions in the program referred to by "
"I<insns>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:784
msgid ""
"I<license> is a license string, which must be GPL compatible to call helper "
"functions marked I<gpl_only>.  (The licensing rules are the same as for "
"kernel modules, so that also dual licenses, such as \"Dual BSD/GPL\", may be"
" used.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:792
msgid ""
"I<log_buf> is a pointer to a caller-allocated buffer in which the in-kernel "
"verifier can store the verification log.  This log is a multi-line string "
"that can be checked by the program author in order to understand how the "
"verifier came to the conclusion that the eBPF program is unsafe.  The format"
" of the output can change at any time as the verifier evolves."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:801
msgid ""
"I<log_size> size of the buffer pointed to by I<log_buf>.  If the size of the"
" buffer is not large enough to store all verifier messages, -1 is returned "
"and I<errno> is set to B<ENOSPC>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:810
msgid ""
"I<log_level> verbosity level of the verifier.  A value of zero means that "
"the verifier will not provide a log; in this case, I<log_buf> must be a NULL"
" pointer, and I<log_size> must be zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:816
msgid ""
"Applying B<close>(2)  to the file descriptor returned by B<BPF_PROG_LOAD> "
"will unload the eBPF program (but see NOTES)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:828
msgid ""
"Maps are accessible from eBPF programs and are used to exchange data between"
" eBPF programs and between eBPF programs and user-space programs.  For "
"example, eBPF programs can process various events (like kprobe, packets) and"
" store their data into a map, and user-space programs can then fetch data "
"from the map.  Conversely, user-space programs can use a map as a "
"configuration mechanism, populating the map with values checked by the eBPF "
"program, which then modifies its behavior on the fly according to those "
"values."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:828
#, no-wrap
msgid "eBPF program types"
msgstr ""

#.  FIXME
#.  Somewhere in this page we need a general introduction to the
#.  bpf_context. For example, how does a BPF program access the
#.  context?
#. type: Plain text
#: man-pages/man2/bpf.2:842
msgid ""
"The eBPF program type (I<prog_type>)  determines the subset of kernel helper"
" functions that the program may call.  The program type also determines the "
"program input (context)\\(emthe format of I<struct bpf_context> (which is "
"the data blob passed into the eBPF program as the first argument)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:849
msgid ""
"For example, a tracing program does not have the exact same subset of helper"
" functions as a socket filter program (though they may have some helpers in "
"common).  Similarly, the input (context) for a tracing program is a set of "
"register values, while for a socket filter it is a network packet."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:852
msgid ""
"The set of functions available to eBPF programs of a given type may increase"
" in the future."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:854
msgid "The following program types are supported:"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:854
#, no-wrap
msgid "B<BPF_PROG_TYPE_SOCKET_FILTER> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:859
msgid "Currently, the set of functions for B<BPF_PROG_TYPE_SOCKET_FILTER> is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:868
#, no-wrap
msgid ""
"bpf_map_lookup_elem(map_fd, void *key)\n"
"                    /* look up key in a map_fd */\n"
"bpf_map_update_elem(map_fd, void *key, void *value)\n"
"                    /* update key/value */\n"
"bpf_map_delete_elem(map_fd, void *key)\n"
"                    /* delete key in a map_fd */\n"
msgstr ""

#.  FIXME: We need some text here to explain how the program
#.  accesses __sk_buff.
#.  See 'struct __sk_buff' and commit 9bac3d6d548e5
#.  Alexei commented:
#.  Actually now in case of SOCKET_FILTER, SCHED_CLS, SCHED_ACT
#.  the program can now access skb fields.
#. type: Plain text
#: man-pages/man2/bpf.2:883
msgid "The I<bpf_context> argument is a pointer to a I<struct __sk_buff>."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:883
#, no-wrap
msgid "B<BPF_PROG_TYPE_KPROBE> (since Linux 4.1)"
msgstr ""

#.  commit 94caee8c312d96522bcdae88791aaa9ebcd5f22c
#.  commit a8cb5f556b567974d75ea29c15181c445c541b1f
#.  FIXME Document this program type
#. 	  Describe allowed helper functions for this program type
#. 	  Describe bpf_context for this program type
#. type: Plain text
#: man-pages/man2/bpf.2:892 man-pages/man2/bpf.2:900 man-pages/man2/bpf.2:908
msgid "[To be documented]"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:892
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_CLS> (since Linux 4.1)"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:900
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_ACT> (since Linux 4.1)"
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:908
#, no-wrap
msgid "Events"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:911
msgid ""
"Once a program is loaded, it can be attached to an event.  Various kernel "
"subsystems have different ways to do so."
msgstr ""

#.  commit 89aa075832b0da4402acebd698d0411dcc82d03e
#. type: Plain text
#: man-pages/man2/bpf.2:920
msgid ""
"Since Linux 3.19, the following call will attach the program I<prog_fd> to "
"the socket I<sockfd>, which was created by an earlier call to B<socket>(2):"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:925
#, no-wrap
msgid ""
"setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,\n"
"           &prog_fd, sizeof(prog_fd));\n"
msgstr ""

#.  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: man-pages/man2/bpf.2:937
msgid ""
"Since Linux 4.1, the following call may be used to attach the eBPF program "
"referred to by the file descriptor I<prog_fd> to a perf event file "
"descriptor, I<event_fd>, that was created by a previous call to "
"B<perf_event_open>(2):"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:941
#, no-wrap
msgid "ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:960
#, no-wrap
msgid ""
"/* bpf+sockets example:\n"
" * 1. create array map of 256 elements\n"
" * 2. load program that counts number of packets received\n"
" *    r0 = skb-E<gt>data[ETH_HLEN + offsetof(struct iphdr, protocol)]\n"
" *    map[r0]++\n"
" * 3. attach prog_fd to raw socket via setsockopt()\n"
" * 4. print number of received TCP/UDP packets every second\n"
" */\n"
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int sock, map_fd, prog_fd, key;\n"
"    long long value = 0, tcp_cnt, udp_cnt;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:968
#, no-wrap
msgid ""
"    map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),\n"
"                            sizeof(value), 256);\n"
"    if (map_fd E<lt> 0) {\n"
"        printf(\"failed to create map '%s'\\en\", strerror(errno));\n"
"        /* likely not run as root */\n"
"        return 1;\n"
"    }\n"
msgstr ""

#.                                 == atomic64_add
#. type: Plain text
#: man-pages/man2/bpf.2:989
#, no-wrap
msgid ""
"    struct bpf_insn prog[] = {\n"
"        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */\n"
"        BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),\n"
"                                /* r0 = ip-E<gt>proto */\n"
"        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),\n"
"                                /* *(u32 *)(fp - 4) = r0 */\n"
"        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */\n"
"        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */\n"
"        BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */\n"
"        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),\n"
"                                /* r0 = map_lookup(r1, r2) */\n"
"        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\n"
"                                /* if (r0 == 0) goto pc+2 */\n"
"        BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */\n"
"        BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),\n"
"                                /* lock *(u64 *) r0 += r1 */\n"
"        BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */\n"
"        BPF_EXIT_INSN(),                            /* return r0 */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:992
#, no-wrap
msgid ""
"    prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,\n"
"                            sizeof(prog) / sizeof(prog[0]), \"GPL\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:994
#, no-wrap
msgid "    sock = open_raw_sock(\"lo\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:997
#, no-wrap
msgid ""
"    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,\n"
"                      sizeof(prog_fd)) == 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1006
#, no-wrap
msgid ""
"    for (;;) {\n"
"        key = IPPROTO_TCP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);\n"
"        key = IPPROTO_UDP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);\n"
"        printf(\"TCP %lld UDP %lld packets\\en\", tcp_cnt, udp_cnt);\n"
"        sleep(1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1009
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1014
msgid ""
"Some complete working code can be found in the I<samples/bpf> directory in "
"the kernel source tree."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1016
msgid "For a successful call, the return value depends on the operation:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1019
msgid "The new file descriptor associated with the eBPF map."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1022
msgid "The new file descriptor associated with the eBPF program."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:1022
#, no-wrap
msgid "All other commands"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1025
msgid "Zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1029
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:1030
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1035
msgid ""
"The eBPF program is too large or a map reached the I<max_entries> limit "
"(maximum number of elements)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1052
msgid ""
"For B<BPF_PROG_LOAD>, even though all program instructions are valid, the "
"program has been rejected because it was deemed unsafe.  This may be because"
" it may have accessed a disallowed memory region or an uninitialized "
"stack/register or because the function constraints don't match the actual "
"types or because there was a misaligned memory access.  In this case, it is "
"recommended to call B<bpf>()  again with I<log_level = 1> and examine "
"I<log_buf> for the specific reason provided by the verifier."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1056
msgid "I<fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1067
msgid ""
"One of the pointers (I<key> or I<value> or I<log_buf> or I<insns>)  is "
"outside the accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1072
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1079
msgid "For B<BPF_MAP_CREATE>, either I<map_type> or attributes are invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1088
msgid ""
"For B<BPF_MAP_*_ELEM> commands, some of the fields of I<union bpf_attr> that"
" are not used by this command are not set to zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1096
msgid ""
"For B<BPF_PROG_LOAD>, indicates an attempt to load an invalid program.  eBPF"
" programs can be deemed invalid due to unrecognized instructions, the use of"
" reserved fields, jumps out of range, infinite loops or calls of unknown "
"functions."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1105
msgid ""
"For B<BPF_MAP_LOOKUP_ELEM> or B<BPF_MAP_DELETE_ELEM>, indicates that the "
"element with the given I<key> was not found."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1108
msgid "Cannot allocate sufficient memory."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:1108
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1114
msgid ""
"The call was made without sufficient privilege (without the B<CAP_SYS_ADMIN>"
" capability)."
msgstr ""

#. type: SH
#: man-pages/man2/bpf.2:1114
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1118
msgid "The B<bpf>()  system call first appeared in Linux 3.18."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1122
msgid "The B<bpf>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1128
msgid ""
"In the current implementation, all B<bpf>()  commands require the caller to "
"have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1141
msgid ""
"eBPF objects (maps and programs) can be shared between processes.  For "
"example, after B<fork>(2), the child inherits file descriptors referring to "
"the same eBPF objects.  In addition, file descriptors referring to eBPF "
"objects can be transferred over UNIX domain sockets.  File descriptors "
"referring to eBPF objects can be duplicated in the usual way, using "
"B<dup>(2)  and similar calls.  An eBPF object is deallocated only after all "
"file descriptors referring to the object have been closed."
msgstr ""

#.  There are also examples for the tc classifier, in the iproute2
#.  project, in examples/bpf
#. type: Plain text
#: man-pages/man2/bpf.2:1153
msgid ""
"eBPF programs can be written in a restricted C that is compiled (using the "
"B<clang> compiler) into eBPF bytecode.  Various features are omitted from "
"this restricted C, such as loops, global variables, variadic functions, "
"floating-point numbers, and passing structures as function arguments.  Some "
"examples can be found in the I<samples/bpf/*_kern.c> files in the kernel "
"source tree."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1161
msgid ""
"The kernel contains a just-in-time (JIT) compiler that translates eBPF "
"bytecode into native machine code for better performance.  In kernels before"
" Linux 4.15, the JIT compiler is disabled by default, but its operation can "
"be controlled by writing one of the following integer strings to the file "
"I</proc/sys/net/core/bpf_jit_enable>:"
msgstr ""

#. type: IP
#: man-pages/man2/bpf.2:1161
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1163
msgid "Disable JIT compilation (default)."
msgstr ""

#. type: IP
#: man-pages/man2/bpf.2:1163
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1165
msgid "Normal compilation."
msgstr ""

#. type: IP
#: man-pages/man2/bpf.2:1165
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1171
msgid ""
"Debugging mode.  The generated opcodes are dumped in hexadecimal into the "
"kernel log.  These opcodes can then be disassembled using the program "
"I<tools/net/bpf_jit_disasm.c> provided in the kernel source tree."
msgstr ""

#.  commit 290af86629b25ffd1ed6232c4e9107da031705cb
#. type: Plain text
#: man-pages/man2/bpf.2:1182
msgid ""
"Since Linux 4.15, the kernel may configured with the "
"B<CONFIG_BPF_JIT_ALWAYS_ON> option.  In this case, the JIT compiler is "
"always enabled, and the I<bpf_jit_enable> is initialized to 1 and is "
"immutable.  (This kernel configuration option was provided as a mitigation "
"for one of the Spectre attacks against the BPF interpreter.)"
msgstr ""

#.  Last reviewed in Linux 4.18-rc by grepping for BPF_ALU64 in arch/
#.  and by checking the documentation for bpf_jit_enable in
#.  Documentation/sysctl/net.txt
#. type: Plain text
#: man-pages/man2/bpf.2:1188
msgid ""
"The JIT compiler for eBPF is currently available for the following "
"architectures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1190
msgid "x86-64 (since Linux 3.18);"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1193
msgid "ARM-64 (since Linux 3.18);"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1195
msgid "s390 (since Linux 4.1);"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1197
msgid "PowerPC 64 (since Linux 4.8);"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1199
msgid "SPARC 64 (since Linux 4.12);"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1201
msgid "MIPS 64 (since Linux 4.13);"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1203
msgid "ARM32 (since Linux 4.14)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1205
msgid "x86-32 (since Linux 4.18)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1212
msgid "B<seccomp>(2), B<bpf-helpers>(7), B<socket>(7), B<tc>(8), B<tc-bpf>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1214
msgid ""
"Both classic and extended BPF are explained in the kernel source file "
"I<Documentation/networking/filter.txt>."
msgstr ""

#. type: TH
#: man-pages/man2/bdflush.2:27
#, no-wrap
msgid "BDFLUSH"
msgstr ""

#. type: TH
#: man-pages/man2/bdflush.2:27
#, no-wrap
msgid "2016-10-08"
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:30
msgid "bdflush - start, flush, or tune buffer-dirty-flush daemon"
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:33
#, no-wrap
msgid "B<#include E<lt>sys/kdaemon.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:36
#, no-wrap
msgid ""
"B<int bdflush(int >I<func>B<, long *>I<address>B<);>\n"
"B<int bdflush(int >I<func>B<, long >I<data>B<);>\n"
msgstr ""

#.  As noted in a changes in the 2.5.12 source
#. type: Plain text
#: man-pages/man2/bdflush.2:48
msgid ""
"I<Note>: Since Linux 2.6, this system call is deprecated and does nothing.  "
"It is likely to disappear altogether in a future kernel release.  Nowadays, "
"the task performed by B<bdflush>()  is handled by the kernel I<pdflush> "
"thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:55
msgid ""
"B<bdflush>()  starts, flushes, or tunes the buffer-dirty-flush daemon.  Only"
" a privileged process (one with the B<CAP_SYS_ADMIN> capability) may call "
"B<bdflush>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:61
msgid ""
"If I<func> is negative or 0, and no daemon has been started, then "
"B<bdflush>()  enters the daemon code and never returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:66
msgid "If I<func> is 1, some dirty buffers are written to disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:75
msgid ""
"If I<func> is 2 or more and is even (low bit is 0), then I<address> is the "
"address of a long word, and the tuning parameter numbered (I<func>-2)/2 is "
"returned to the caller in that address."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:84
msgid ""
"If I<func> is 3 or more and is odd (low bit is 1), then I<data> is a long "
"word, and the kernel sets tuning parameter numbered (I<func>-3)/2 to that "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:88
msgid ""
"The set of parameters, their values, and their valid ranges are defined in "
"the Linux kernel source file I<fs/buffer.c>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:97
msgid ""
"If I<func> is negative or 0 and the daemon successfully starts, B<bdflush>()"
"  never returns.  Otherwise, the return value is 0 on success and -1 on "
"failure, with I<errno> set to indicate the error."
msgstr ""

#. type: TP
#: man-pages/man2/bdflush.2:98
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:102
msgid ""
"An attempt was made to enter the daemon code after another process has "
"already entered."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:106
msgid "I<address> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:110
msgid ""
"An attempt was made to read or write an invalid parameter number, or to "
"write an invalid value to a parameter."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:115
msgid "Caller does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:117
msgid ""
"Since version 2.23, glibc no longer supports this obsolete system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:121
msgid ""
"B<bdflush>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:124
msgid "B<sync>(1), B<fsync>(2), B<sync>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/bswap.3:25
#, no-wrap
msgid "BSWAP"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:28
msgid "bswap_16, bswap_32, bswap_64 - reverse order of bytes"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:31
#, no-wrap
msgid "B<#include E<lt>byteswap.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:35
#, no-wrap
msgid ""
"B<bswap_16(>I<x>B<);>\n"
"B<bswap_32(>I<x>B<);>\n"
"B<bswap_64(>I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:39
msgid ""
"These macros return a value in which the order of the bytes in their 2-, 4-,"
" or 8-byte arguments is reversed."
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:41
msgid ""
"These macros return the value of their argument with the bytes reversed."
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:43
msgid "These macros always succeed."
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:45
msgid "These macros are GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:49
msgid ""
"The program below swaps the bytes of the 8-byte integer supplied as its "
"command-line argument.  The following shell session demonstrates the use of "
"the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:54
#, no-wrap
msgid ""
"$ B<./a.out 0x0123456789abcdef>\n"
"0x123456789abcdef ==E<gt> 0xefcdab8967452301\n"
msgstr ""

#. type: SS
#: man-pages/man3/bswap.3:56
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:64
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>inttypes.hE<gt>\n"
"#include E<lt>byteswap.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:69
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint64_t x;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:74
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:77
#, no-wrap
msgid ""
"    x = strtoul(argv[1], NULL, 0);\n"
"    printf(\"0x%\" PRIx64 \" ==E<gt> 0x%\" PRIx64 \"\\en\", x, bswap_64(x));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:80
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bswap.3:83
msgid "B<byteorder>(3), B<endian>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/bcmp.3:31
#, no-wrap
msgid "BCMP"
msgstr ""

#. type: TH
#: man-pages/man3/bcmp.3:31
#, no-wrap
msgid "2017-03-13"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:34
msgid "bcmp - compare byte sequences"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:37
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:39
#, no-wrap
msgid ""
"B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:56
msgid ""
"The B<bcmp>()  function compares the two byte sequences I<s1> and I<s2> of "
"length I<n> each.  If they are equal, and in particular if I<n> is zero, "
"B<bcmp>()  returns 0.  Otherwise, it returns a nonzero result."
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:61
msgid ""
"The B<bcmp>()  function returns 0 if the byte sequences are equal, otherwise"
" a nonzero result is returned."
msgstr ""

#. type: SH
#: man-pages/man3/bcmp.3:61
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:64
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man3/bcmp.3:68
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man3/bcmp.3:68
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man3/bcmp.3:68
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man3/bcmp.3:71
#, no-wrap
msgid "B<bcmp>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/bcmp.3:71
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man3/bcmp.3:71
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:80
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use"
" B<memcmp>(3)  in new programs.  POSIX.1-2008 removes the specification of "
"B<bcmp>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/bcmp.3:87
msgid ""
"B<bstring>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/basename.3:27
#, no-wrap
msgid "BASENAME"
msgstr ""

#. type: TH
#: man-pages/man3/basename.3:27
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:30
msgid "basename, dirname - parse pathname components"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:33
#, no-wrap
msgid "B<#include E<lt>libgen.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:35
#, no-wrap
msgid "B<char *dirname(char *>I<path>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:37
#, no-wrap
msgid "B<char *basename(char *>I<path>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:42
msgid "Warning: there are two different functions B<basename>()  - see below."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:55
msgid ""
"The functions B<dirname>()  and B<basename>()  break a null-terminated "
"pathname string into directory and filename components.  In the usual case, "
"B<dirname>()  returns the string up to, but not including, the final "
"\\(aq/\\(aq, and B<basename>()  returns the component following the final "
"\\(aq/\\(aq.  Trailing \\(aq/\\(aq characters are not counted as part of the"
" pathname."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:78
msgid ""
"If I<path> does not contain a slash, B<dirname>()  returns the string \".\" "
"while B<basename>()  returns a copy of I<path>.  If I<path> is the string "
"\"/\", then both B<dirname>()  and B<basename>()  return the string \"/\".  "
"If I<path> is a null pointer or points to an empty string, then both "
"B<dirname>()  and B<basename>()  return the string \".\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:84
msgid ""
"Concatenating the string returned by B<dirname>(), a \"/\", and the string "
"returned by B<basename>()  yields a complete pathname."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:93
msgid ""
"Both B<dirname>()  and B<basename>()  may modify the contents of I<path>, so"
" it may be desirable to pass a copy when calling one of these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:102
msgid ""
"These functions may return pointers to statically allocated memory which may"
" be overwritten by subsequent calls.  Alternatively, they may return a "
"pointer to some part of I<path>, so that the string referred to by I<path> "
"should not be modified or freed until the pointer returned by the function "
"is no longer required."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:109
msgid ""
"The following list of examples (taken from SUSv2)  shows the strings "
"returned by B<dirname>()  and B<basename>()  for different paths:"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:113
#, no-wrap
msgid "path    "
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:113
#, no-wrap
msgid "dirname"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:113
#, no-wrap
msgid "basename"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:114
#, no-wrap
msgid "/usr/lib"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:114
#, no-wrap
msgid "/usr"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:114
#, no-wrap
msgid "lib"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:115
#, no-wrap
msgid "/usr/   "
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:115 man-pages/man3/basename.3:117
#, no-wrap
msgid "/"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:115 man-pages/man3/basename.3:116
#, no-wrap
msgid "usr"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:116
#, no-wrap
msgid "usr     "
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:116 man-pages/man3/basename.3:118
#: man-pages/man3/basename.3:119
#, no-wrap
msgid "."
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:117
#, no-wrap
msgid "/       "
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:118
#, no-wrap
msgid "\\&.       "
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:119
#, no-wrap
msgid "\\&..      "
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:119
#, no-wrap
msgid ".."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:130
msgid ""
"Both B<dirname>()  and B<basename>()  return pointers to null-terminated "
"strings.  (Do not pass these pointers to B<free>(3).)"
msgstr ""

#. type: tbl table
#: man-pages/man3/basename.3:141
#, no-wrap
msgid ""
"B<basename>(),\n"
"B<dirname>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:145
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:150
msgid ""
"There are two different versions of B<basename>()  - the POSIX version "
"described above, and the GNU version, which one gets after"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:155
#, no-wrap
msgid ""
"B<    #define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:164
msgid ""
"The GNU version never modifies its argument, and returns the empty string "
"when I<path> has a trailing slash, and in particular also when it is \"/\"."
"  There is no GNU version of B<dirname>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:170
msgid ""
"With glibc, one gets the POSIX version of B<basename>()  when "
"I<E<lt>libgen.hE<gt>> is included, and the GNU version otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:176
msgid ""
"In the glibc implementation, the POSIX versions of these functions modify "
"the I<path> argument, and segfault when called with a static string such as "
"\"/usr/\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:181
msgid ""
"Before glibc 2.2.1, the glibc version of B<dirname>()  did not correctly "
"handle pathnames with trailing \\(aq/\\(aq characters, and generated a "
"segfault if given a NULL argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:186
msgid ""
"The following code snippet demonstrates the use of B<basename>()  and "
"B<dirname>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:190
#, no-wrap
msgid ""
"char *dirc, *basec, *bname, *dname;\n"
"char *path = \"/etc/passwd\";\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:196
#, no-wrap
msgid ""
"dirc = strdup(path);\n"
"basec = strdup(path);\n"
"dname = dirname(dirc);\n"
"bname = basename(basec);\n"
"printf(\"dirname=%s, basename=%s\\en\", dname, bname);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/basename.3:200
msgid "B<basename>(1), B<dirname>(1)"
msgstr ""

#. type: TH
#: man-pages/man3/bsearch.3:31
#, no-wrap
msgid "BSEARCH"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:34
msgid "bsearch - binary search of a sorted array"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:37
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:41
#, no-wrap
msgid ""
"B<void *bsearch(const void *>I<key>B<, const void *>I<base>B<,>\n"
"B<              size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<              int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:56
msgid ""
"The B<bsearch>()  function searches an array of I<nmemb> objects, the "
"initial member of which is pointed to by I<base>, for a member that matches "
"the object pointed to by I<key>.  The size of each member of the array is "
"specified by I<size>."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:70
msgid ""
"The contents of the array should be in ascending sorted order according to "
"the comparison function referenced by I<compar>.  The I<compar> routine is "
"expected to have two arguments which point to the I<key> object and to an "
"array member, in that order, and should return an integer less than, equal "
"to, or greater than zero if the I<key> object is found, respectively, to be "
"less than, to match, or be greater than the array member."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:77
msgid ""
"The B<bsearch>()  function returns a pointer to a matching member of the "
"array, or NULL if no match is found.  If there are multiple elements that "
"match the key, the element returned is unspecified."
msgstr ""

#. type: tbl table
#: man-pages/man3/bsearch.3:87
#, no-wrap
msgid "B<bsearch>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:92
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:97
msgid ""
"The example below first sorts an array of structures using B<qsort>(3), then"
" retrieves desired elements using B<bsearch>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:102
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:111
#, no-wrap
msgid ""
"struct mi {\n"
"    int nr;\n"
"    char *name;\n"
"} months[] = {\n"
"    { 1, \"jan\" }, { 2, \"feb\" }, { 3, \"mar\" }, { 4, \"apr\" },\n"
"    { 5, \"may\" }, { 6, \"jun\" }, { 7, \"jul\" }, { 8, \"aug\" },\n"
"    { 9, \"sep\" }, {10, \"oct\" }, {11, \"nov\" }, {12, \"dec\" }\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:113
#, no-wrap
msgid "#define nr_of_months (sizeof(months)/sizeof(months[0]))\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:121
#, no-wrap
msgid ""
"static int\n"
"compmi(const void *m1, const void *m2)\n"
"{\n"
"    struct mi *mi1 = (struct mi *) m1;\n"
"    struct mi *mi2 = (struct mi *) m2;\n"
"    return strcmp(mi1-E<gt>name, mi2-E<gt>name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:126
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:140
#, no-wrap
msgid ""
"    qsort(months, nr_of_months, sizeof(struct mi), compmi);\n"
"    for (i = 1; i E<lt> argc; i++) {\n"
"        struct mi key, *res;\n"
"        key.name = argv[i];\n"
"        res = bsearch(&key, months, nr_of_months,\n"
"                      sizeof(struct mi), compmi);\n"
"        if (res == NULL)\n"
"            printf(\"\\(aq%s\\(aq: unknown month\\en\", argv[i]);\n"
"        else\n"
"            printf(\"%s: month #%d\\en\", res-E<gt>name, res-E<gt>nr);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsearch.3:146
msgid "B<hsearch>(3), B<lsearch>(3), B<qsort>(3), B<tsearch>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/bzero.3:25
#, no-wrap
msgid "BZERO"
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:28
msgid "bzero, explicit_bzero - zero a byte string"
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:33
#, no-wrap
msgid "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:35
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:37
#, no-wrap
msgid "B<void explicit_bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:46
msgid ""
"The B<bzero>()  function erases the data in the I<n> bytes of the memory "
"starting at the location pointed to by I<s>, by writing zeros (bytes "
"containing \\(aq\\e0\\(aq) to that area."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:55
msgid ""
"The B<explicit_bzero>()  function performs the same task as B<bzero>().  It "
"differs from B<bzero>()  in that it guarantees that compiler optimizations "
"will not remove the erase operation if the compiler deduces that the "
"operation is \"unnecessary\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:57
msgid "None."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:60
msgid "B<explicit_bzero>()  first appeared in glibc 2.25."
msgstr ""

#. type: tbl table
#: man-pages/man3/bzero.3:70
#, no-wrap
msgid "B<bzero>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/bzero.3:70
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/bzero.3:72
#, no-wrap
msgid "B<explicit_bzero>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:85
msgid ""
"The B<bzero>()  function is deprecated (marked as LEGACY in POSIX.1-2001); "
"use B<memset>(3)  in new programs.  POSIX.1-2008 removes the specification "
"of B<bzero>().  The B<bzero>()  function first appeared in 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:93
msgid ""
"The B<explicit_bzero>()  function is a nonstandard extension that is also "
"present on some of the BSDs.  Some other implementations have a similar "
"function, such as B<memset_explicit>()  or B<memset_s>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:113
msgid ""
"The B<explicit_bzero>()  function addresses a problem that security-"
"conscious applications may run into when using B<bzero>(): if the compiler "
"can deduce that the location to zeroed will never again be touched by a "
"I<correct> program, then it may remove the B<bzero>()  call altogether.  "
"This is a problem if the intent of the B<bzero>()  call was to erase "
"sensitive data (e.g., passwords)  to prevent the possibility that the data "
"was leaked by an incorrect or compromised program.  Calls to "
"B<explicit_bzero>()  are never optimized away by the compiler."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:117
msgid ""
"The B<explicit_bzero>()  function does not solve all problems associated "
"with erasing sensitive data:"
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:130
msgid ""
"The B<explicit_bzero>()  function does I<not> guarantee that sensitive data "
"is completely erased from memory.  (The same is true of B<bzero>().)  For "
"example, there may be copies of the sensitive data in a register and in "
"\"scratch\" stack areas.  The B<explicit_bzero>()  function is not aware of "
"these copies, and can't erase them."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:152
msgid ""
"In some circumstances, B<explicit_bzero>()  can I<decrease> security.  If "
"the compiler determined that the variable containing the sensitive data "
"could be optimized to be stored in a register (because it is small enough to"
" fit in a register, and no operation other than the B<explicit_bzero>()  "
"call would need to take the address of the variable), then the "
"B<explicit_bzero>()  call will force the data to be copied from the register"
" to a location in RAM that is then immediately erased (while the copy in the"
" register remains unaffected).  The problem here is that data in RAM is more"
" likely to be exposed by a bug than data in a register, and thus the "
"B<explicit_bzero>()  call creates a brief time window where the sensitive "
"data is more vulnerable than it would otherwise have been if no attempt had "
"been made to erase the data."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:162
msgid ""
"Note that declaring the sensitive variable with the B<volatile> qualifier "
"does I<not> eliminate the above problems.  Indeed, it will make them worse, "
"since, for example, it may force a variable that would otherwise have been "
"optimized into a register to instead be maintained in (more vulnerable)  RAM"
" for its entire lifetime."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:172
msgid ""
"Notwithstanding the above details, for security-conscious applications, "
"using B<explicit_bzero>()  is generally preferable to not using it.  The "
"developers of B<explicit_bzero>()  anticipate that future compilers will "
"recognize calls to B<explicit_bzero>()  and take steps to ensure that all "
"copies of the sensitive data are erased, including copies in registers or in"
" \"scratch\" stack areas."
msgstr ""

#. type: Plain text
#: man-pages/man3/bzero.3:175
msgid "B<bstring>(3), B<memset>(3), B<swab>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/bsd_signal.3:25
#, no-wrap
msgid "BSD_SIGNAL"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:28
msgid "bsd_signal - signal handling with BSD semantics"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:30
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:32
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:34
msgid ""
"B<sighandler_t bsd_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:42
msgid "B<bsd_signal>():"
msgstr ""

#.     || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/bsd_signal.3:47
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"    _XOPEN_SOURCE E<gt>= 500\n"
"        && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:50
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:57
msgid ""
"The B<bsd_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:70
msgid ""
"The difference between the two is that B<bsd_signal>()  is guaranteed to "
"provide reliable signal semantics, that is: a) the disposition of the signal"
" is not reset to the default when the handler is invoked; b) delivery of "
"further instances of the signal is blocked while the signal handler is "
"executing; and c) if the handler interrupts a blocking system call, then the"
" system call is automatically restarted.  A portable application cannot rely"
" on B<signal>(2)  to provide these guarantees."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:76
msgid ""
"The B<bsd_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:79
msgid "As for B<signal>(2)."
msgstr ""

#. type: tbl table
#: man-pages/man3/bsd_signal.3:89
#, no-wrap
msgid "B<bsd_signal>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:98
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<bsd_signal>(), recommending the use of B<sigaction>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:104
msgid ""
"Use of B<bsd_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:115
msgid ""
"On modern Linux systems, B<bsd_signal>()  and B<signal>(2)  are equivalent."
"  But on older systems, B<signal>(2)  provided unreliable signal semantics; "
"see B<signal>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:122
msgid ""
"The use of I<sighandler_t> is a GNU extension; this type is defined only if "
"the B<_GNU_SOURCE> feature test macro is defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/bsd_signal.3:126
msgid "B<sigaction>(2), B<signal>(2), B<sysv_signal>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/bindresvport.3:30
#, no-wrap
msgid "BINDRESVPORT"
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:33
msgid "bindresvport - bind a socket to a privileged IP port"
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:39
#, no-wrap
msgid "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"
msgstr ""

#.  Glibc actually starts searching with a port # in the range 600 to 1023
#. type: Plain text
#: man-pages/man3/bindresvport.3:49
msgid ""
"B<bindresvport>()  is used to bind the socket referred to by the file "
"descriptor I<sockfd> to a privileged anonymous IP port, that is, a port "
"number arbitrarily selected from the range 512 to 1023."
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:59
msgid ""
"If the B<bind>(2)  performed by B<bindresvport>()  is successful, and I<sin>"
" is not NULL, then I<sin-E<gt>sin_port> returns the port number actually "
"allocated."
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:70
msgid ""
"I<sin> can be NULL, in which case I<sin-E<gt>sin_family> is implicitly taken"
" to be B<AF_INET>.  However, in this case, B<bindresvport>()  has no way to "
"return the port number actually allocated.  (This information can later be "
"obtained using B<getsockname>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:75
msgid ""
"B<bindresvport>()  returns 0 on success; otherwise -1 is returned and "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:80
msgid ""
"B<bindresvport>()  can fail for any of the same reasons as B<bind>(2).  In "
"addition, the following errors may occur:"
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:86
msgid ""
"The calling process was not privileged (on Linux: the calling process did "
"not have the B<CAP_NET_BIND_SERVICE> capability in the user namespace "
"governing its network namespace)."
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:89
msgid "All privileged ports are in use."
msgstr ""

#. type: TP
#: man-pages/man3/bindresvport.3:89
#, no-wrap
msgid "B<EAFNOSUPPORT> (B<EPFNOSUPPORT> in glibc 2.7 and earlier)"
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:96
msgid "I<sin> is not NULL and I<sin-E<gt>sin_family> is not B<AF_INET>."
msgstr ""

#. type: tbl table
#: man-pages/man3/bindresvport.3:106
#, no-wrap
msgid "B<bindresvport>()"
msgstr ""

#.  commit f6da27e53695ad1cc0e2a9490358decbbfdff5e5
#. type: tbl table
#: man-pages/man3/bindresvport.3:109
#, no-wrap
msgid "glibc E<gt>= 2.17: MT-Safe\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/bindresvport.3:111
#, no-wrap
msgid "glibc E<lt> 2.17: MT-Unsafe"
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:118
msgid ""
"The B<bindresvport>()  function uses a static variable that was not "
"protected by a lock before glibc 2.17, rendering the function MT-Unsafe."
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:121
msgid "Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:127
msgid ""
"Unlike some B<bindresvport>()  implementations, the glibc implementation "
"ignores any value that the caller supplies in I<sin-E<gt>sin_port>."
msgstr ""

#. type: Plain text
#: man-pages/man3/bindresvport.3:129
msgid "B<bind>(2), B<getsockname>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/bcopy.3:33
#, no-wrap
msgid "BCOPY"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcopy.3:36
msgid "bcopy - copy byte sequence"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcopy.3:41
#, no-wrap
msgid ""
"B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcopy.3:52
msgid ""
"The B<bcopy>()  function copies I<n> bytes from I<src> to I<dest>.  The "
"result is correct, even when both areas overlap."
msgstr ""

#. type: tbl table
#: man-pages/man3/bcopy.3:64
#, no-wrap
msgid "B<bcopy>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/bcopy.3:80
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use"
" B<memcpy>(3)  or B<memmove>(3)  in new programs.  Note that the first two "
"arguments are interchanged for B<memcpy>(3)  and B<memmove>(3).  "
"POSIX.1-2008 removes the specification of B<bcopy>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/bcopy.3:86
msgid ""
"B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), "
"B<strncpy>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/btowc.3:16
#, no-wrap
msgid "BTOWC"
msgstr ""

#. type: TH
#: man-pages/man3/btowc.3:16
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:19
msgid "btowc - convert single byte to wide character"
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:22
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:24
#, no-wrap
msgid "B<wint_t btowc(int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:39
msgid ""
"The B<btowc>()  function converts I<c>, interpreted as a multibyte sequence "
"of length 1, starting in the initial shift state, to a wide character and "
"returns it.  If I<c> is B<EOF> or not a valid multibyte sequence of length "
"1, the B<btowc>()  function returns B<WEOF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:49
msgid ""
"The B<btowc>()  function returns the wide character converted from the "
"single byte I<c>.  If I<c> is B<EOF> or not a valid multibyte sequence of "
"length 1, it returns B<WEOF>."
msgstr ""

#. type: tbl table
#: man-pages/man3/btowc.3:59
#, no-wrap
msgid "B<btowc>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:63
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:70
msgid ""
"The behavior of B<btowc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:80
msgid ""
"This function should never be used.  It does not work for encodings which "
"have state, and unnecessarily treats single bytes differently from multibyte"
" sequences.  Use either B<mbtowc>(3)  or the thread-safe B<mbrtowc>(3)  "
"instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/btowc.3:83
msgid "B<mbrtowc>(3), B<mbtowc>(3), B<wctob>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/bstring.3:32
#, no-wrap
msgid "BSTRING"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:36
msgid ""
"bcmp, bcopy, bzero, memccpy, memchr, memcmp, memcpy, memfrob, memmem, "
"memmove, memset - byte string operations"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:47
#, no-wrap
msgid ""
"B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t"
" >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:49
#, no-wrap
msgid "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:51
#, no-wrap
msgid ""
"B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:53
#, no-wrap
msgid ""
"B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:55
#, no-wrap
msgid "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:58
#, no-wrap
msgid ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:60
#, no-wrap
msgid ""
"B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:62
#, no-wrap
msgid "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:68
msgid ""
"The byte string functions perform operations on strings (byte arrays)  that "
"are not necessarily null-terminated.  See the individual man pages for "
"descriptions of each function."
msgstr ""

#.  The old functions are not even available on some non-GNU/Linux systems.
#. type: Plain text
#: man-pages/man3/bstring.3:82
msgid ""
"The functions B<bcmp>(), B<bcopy>()  and B<bzero>()  are obsolete.  Use "
"B<memcmp>(), B<memcpy>()  and B<memset>()  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/bstring.3:93
msgid ""
"B<bcmp>(3), B<bcopy>(3), B<bzero>(3), B<memccpy>(3), B<memchr>(3), "
"B<memcmp>(3), B<memcpy>(3), B<memfrob>(3), B<memmem>(3), B<memmove>(3), "
"B<memset>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/byteorder.3:32
#, no-wrap
msgid "BYTEORDER"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:36
msgid ""
"htonl, htons, ntohl, ntohs - convert values between host and network byte "
"order"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:39
#, no-wrap
msgid "B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:41
#, no-wrap
msgid "B<uint32_t htonl(uint32_t >I<hostlong>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:43
#, no-wrap
msgid "B<uint16_t htons(uint16_t >I<hostshort>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:45
#, no-wrap
msgid "B<uint32_t ntohl(uint32_t >I<netlong>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:47
#, no-wrap
msgid "B<uint16_t ntohs(uint16_t >I<netshort>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:54
msgid ""
"The B<htonl>()  function converts the unsigned integer I<hostlong> from host"
" byte order to network byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:60
msgid ""
"The B<htons>()  function converts the unsigned short integer I<hostshort> "
"from host byte order to network byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:66
msgid ""
"The B<ntohl>()  function converts the unsigned integer I<netlong> from "
"network byte order to host byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:72
msgid ""
"The B<ntohs>()  function converts the unsigned short integer I<netshort> "
"from network byte order to host byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:76
msgid ""
"On the i386 the host byte order is Least Significant Byte first, whereas the"
" network byte order, as used on the Internet, is Most Significant Byte "
"first."
msgstr ""

#. type: tbl table
#: man-pages/man3/byteorder.3:89
#, no-wrap
msgid ""
"B<htonl>(),\n"
"B<htons>(),\n"
"B<ntohl>(),\n"
"B<ntohs>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:98
msgid ""
"Some systems require the inclusion of I<E<lt>netinet/in.hE<gt>> instead of "
"I<E<lt>arpa/inet.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/byteorder.3:102
msgid "B<bswap>(3), B<endian>(3), B<gethostbyname>(3), B<getservent>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/backtrace.3:27
#, no-wrap
msgid "BACKTRACE"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:31
msgid ""
"backtrace, backtrace_symbols, backtrace_symbols_fd - support for application"
" self-debugging"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:33
msgid "B<#include E<lt>execinfo.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:38
msgid "B<int backtrace(void> B<**>I<buffer>B<,> B<int> I<size>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:43
msgid ""
"B<char **backtrace_symbols(void *const> B<*>I<buffer>B<,> B<int> "
"I<size>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:50
msgid ""
"B<void backtrace_symbols_fd(void *const> B<*>I<buffer>B<,> B<int> "
"I<size>B<,> B<int> I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:78
msgid ""
"B<backtrace>()  returns a backtrace for the calling program, in the array "
"pointed to by I<buffer>.  A backtrace is the series of currently active "
"function calls for the program.  Each item in the array pointed to by "
"I<buffer> is of type I<void\\ *>, and is the return address from the "
"corresponding stack frame.  The I<size> argument specifies the maximum "
"number of addresses that can be stored in I<buffer>.  If the backtrace is "
"larger than I<size>, then the addresses corresponding to the I<size> most "
"recent function calls are returned; to obtain the complete backtrace, make "
"sure that I<buffer> and I<size> are large enough."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:103
msgid ""
"Given the set of addresses returned by B<backtrace>()  in I<buffer>, "
"B<backtrace_symbols>()  translates the addresses into an array of strings "
"that describe the addresses symbolically.  The I<size> argument specifies "
"the number of addresses in I<buffer>.  The symbolic representation of each "
"address consists of the function name (if this can be determined), a "
"hexadecimal offset into the function, and the actual return address (in "
"hexadecimal).  The address of the array of string pointers is returned as "
"the function result of B<backtrace_symbols>().  This array is B<malloc>(3)ed"
" by B<backtrace_symbols>(), and must be freed by the caller.  (The strings "
"pointed to by the array of pointers need not and should not be freed.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:119
msgid ""
"B<backtrace_symbols_fd>()  takes the same I<buffer> and I<size> arguments as"
" B<backtrace_symbols>(), but instead of returning an array of strings to the"
" caller, it writes the strings, one per line, to the file descriptor I<fd>."
"  B<backtrace_symbols_fd>()  does not call B<malloc>(3), and so can be "
"employed in situations where the latter function might fail, but see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:131
msgid ""
"B<backtrace>()  returns the number of addresses returned in I<buffer>, which"
" is not greater than I<size>.  If the return value is less than I<size>, "
"then the full backtrace was stored; if it is equal to I<size>, then it may "
"have been truncated, in which case the addresses of the oldest stack frames "
"are not returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:138
msgid ""
"On success, B<backtrace_symbols>()  returns a pointer to the array "
"B<malloc>(3)ed by the call; on error, NULL is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:144
msgid ""
"B<backtrace>(), B<backtrace_symbols>(), and B<backtrace_symbols_fd>()  are "
"provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/backtrace.3:154
#, no-wrap
msgid "B<backtrace>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/backtrace.3:156
#, no-wrap
msgid "B<backtrace_symbols>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/backtrace.3:158
#, no-wrap
msgid "B<backtrace_symbols_fd>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:162
msgid "These functions are GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:166
msgid ""
"These functions make some assumptions about how a function's return address "
"is stored on the stack.  Note the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:172
msgid ""
"Omission of the frame pointers (as implied by any of B<gcc>(1)'s nonzero "
"optimization levels) may cause these assumptions to be violated."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:174
msgid "Inlined functions do not have stack frames."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:176
msgid "Tail-call optimization causes one stack frame to replace another."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:191
msgid ""
"B<backtrace>()  and B<backtrace_symbols_fd>()  don't call B<malloc>()  "
"explicitly, but they are part of I<libgcc>, which gets loaded dynamically "
"when first used.  Dynamic loading usually triggers a call to B<malloc>(3).  "
"If you need certain calls to these two functions to not allocate memory (in "
"signal handlers, for example), you need to make sure I<libgcc> is loaded "
"beforehand."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:199
msgid ""
"The symbol names may be unavailable without the use of special linker "
"options.  For systems using the GNU linker, it is necessary to use the "
"I<-rdynamic> linker option.  Note that names of \"static\" functions are not"
" exposed, and won't be available in the backtrace."
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:206
msgid ""
"The program below demonstrates the use of B<backtrace>()  and "
"B<backtrace_symbols>().  The following shell session shows what we might see"
" when running the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:220
#, no-wrap
msgid ""
"$B< cc -rdynamic prog.c -o prog>\n"
"$B< ./prog 3>\n"
"backtrace() returned 8 addresses\n"
"\\&./prog(myfunc3+0x5c) [0x80487f0]\n"
"\\&./prog [0x8048871]\n"
"\\&./prog(myfunc+0x21) [0x8048894]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(main+0x65) [0x80488fb]\n"
"\\&/lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]\n"
"\\&./prog [0x8048711]\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:229
#, no-wrap
msgid ""
"#include E<lt>execinfo.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:231
#, no-wrap
msgid "#define BT_BUF_SIZE 100\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:238
#, no-wrap
msgid ""
"void\n"
"myfunc3(void)\n"
"{\n"
"    int j, nptrs;\n"
"    void *buffer[BT_BUF_SIZE];\n"
"    char **strings;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:241
#, no-wrap
msgid ""
"    nptrs = backtrace(buffer, BT_BUF_SIZE);\n"
"    printf(\"backtrace() returned %d addresses\\en\", nptrs);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:244
#, no-wrap
msgid ""
"    /* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)\n"
"       would produce similar output to the following: */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:250
#, no-wrap
msgid ""
"    strings = backtrace_symbols(buffer, nptrs);\n"
"    if (strings == NULL) {\n"
"        perror(\"backtrace_symbols\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:253
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> nptrs; j++)\n"
"        printf(\"%s\\en\", strings[j]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:256
#, no-wrap
msgid ""
"    free(strings);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:262
#, no-wrap
msgid ""
"static void   /* \"static\" means don\\(aqt export the symbol... */\n"
"myfunc2(void)\n"
"{\n"
"    myfunc3();\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:271
#, no-wrap
msgid ""
"void\n"
"myfunc(int ncalls)\n"
"{\n"
"    if (ncalls E<gt> 1)\n"
"        myfunc(ncalls - 1);\n"
"    else\n"
"        myfunc2();\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:279
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s num-calls\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:283
#, no-wrap
msgid ""
"    myfunc(atoi(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/backtrace.3:290
msgid ""
"B<addr2line>(1), B<gcc>(1), B<gdb>(1), B<ld>(1), B<dlopen>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/btree.3:36
#, no-wrap
msgid "BTREE"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:40
msgid "btree - btree database access method"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:45
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>db.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:54
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces."
"  Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:62
msgid ""
"The routine B<dbopen>(3)  is the library interface to database files.  One "
"of the supported file formats is btree files.  The general description of "
"the database access methods is in B<dbopen>(3), this manual page describes "
"only the btree-specific information."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:65
msgid ""
"The btree data structure is a sorted, balanced tree structure storing "
"associated key/data pairs."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:71
msgid ""
"The btree access-method-specific data structure provided to B<dbopen>(3)  is"
" defined in the I<E<lt>db.hE<gt>> include file as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:84
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned long flags;\n"
"    unsigned int  cachesize;\n"
"    int           maxkeypage;\n"
"    int           minkeypage;\n"
"    unsigned int  psize;\n"
"    int         (*compare)(const DBT *key1, const DBT *key2);\n"
"    size_t      (*prefix)(const DBT *key1, const DBT *key2);\n"
"    int           lorder;\n"
"} BTREEINFO;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:88
msgid "The elements of this structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:88
#, no-wrap
msgid "I<flags>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:91
msgid "The flag value is specified by ORing any of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:92
#, no-wrap
msgid "B<R_DUP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:111
msgid ""
"Permit duplicate keys in the tree, that is, permit insertion if the key to "
"be inserted already exists in the tree.  The default behavior, as described "
"in B<dbopen>(3), is to overwrite a matching key when inserting a new key or "
"to fail if the B<R_NOOVERWRITE> flag is specified.  The B<R_DUP> flag is "
"overridden by the B<R_NOOVERWRITE> flag, and if the B<R_NOOVERWRITE> flag is"
" specified, attempts to insert duplicate keys into the tree will fail."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:121
msgid ""
"If the database contains duplicate keys, the order of retrieval of key/data "
"pairs is undefined if the I<get> routine is used, however, I<seq> routine "
"calls with the B<R_CURSOR> flag set will always return the logical \"first\""
" of any group of duplicate keys."
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:122
#, no-wrap
msgid "I<cachesize>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:137
msgid ""
"A suggested maximum size (in bytes) of the memory cache.  This value is "
"I<only> advisory, and the access method will allocate more memory rather "
"than fail.  Since every search examines the root page of the tree, caching "
"the most recently used pages substantially improves access time.  In "
"addition, physical writes are delayed as long as possible, so a moderate "
"cache can reduce the number of I/O operations significantly.  Obviously, "
"using a cache increases (but only increases) the likelihood of corruption or"
" lost data if the system crashes while a tree is being modified.  If "
"I<cachesize> is 0 (no size is specified), a default cache is used."
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:137
#, no-wrap
msgid "I<maxkeypage>"
msgstr ""

#.  The maximum number of keys which will be stored on any single page.
#.  Because of the way the btree data structure works,
#.  .I maxkeypage
#.  must always be greater than or equal to 2.
#.  If
#.  .I maxkeypage
#.  is 0 (no maximum number of keys is specified), the page fill factor is
#.  made as large as possible (which is almost invariably what is wanted).
#. type: Plain text
#: man-pages/man3/btree.3:149
msgid ""
"The maximum number of keys which will be stored on any single page.  Not "
"currently implemented."
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:149
#, no-wrap
msgid "I<minkeypage>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:159
msgid ""
"The minimum number of keys which will be stored on any single page.  This "
"value is used to determine which keys will be stored on overflow pages, that"
" is, if a key or data item is longer than the pagesize divided by the "
"minkeypage value, it will be stored on overflow pages instead of in the page"
" itself.  If I<minkeypage> is 0 (no minimum number of keys is specified), a "
"value of 2 is used."
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:159
#, no-wrap
msgid "I<psize>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:167
msgid ""
"Page size is the size (in bytes) of the pages used for nodes in the tree.  "
"The minimum page size is 512 bytes and the maximum page size is 64\\ KiB.  "
"If I<psize> is 0 (no page size is specified), a page size is chosen based on"
" the underlying filesystem I/O block size."
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:167
#, no-wrap
msgid "I<compare>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:179
msgid ""
"Compare is the key comparison function.  It must return an integer less "
"than, equal to, or greater than zero if the first key argument is considered"
" to be respectively less than, equal to, or greater than the second key "
"argument.  The same comparison function must be used on a given tree every "
"time it is opened.  If I<compare> is NULL (no comparison function is "
"specified), the keys are compared lexically, with shorter keys considered "
"less than longer keys."
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:179
#, no-wrap
msgid "I<prefix>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:198
msgid ""
"Prefix is the prefix comparison function.  If specified, this routine must "
"return the number of bytes of the second key argument which are necessary to"
" determine that it is greater than the first key argument.  If the keys are "
"equal, the key length should be returned.  Note, the usefulness of this "
"routine is very data-dependent, but, in some data sets can produce "
"significantly reduced tree sizes and search times.  If I<prefix> is NULL (no"
" prefix function is specified), I<and> no comparison function is specified, "
"a default lexical comparison routine is used.  If I<prefix> is NULL and a "
"comparison routine is specified, no prefix comparison is done."
msgstr ""

#. type: TP
#: man-pages/man3/btree.3:198
#, no-wrap
msgid "I<lorder>"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:206
msgid ""
"The byte order for integers in the stored database metadata.  The number "
"should represent the order as an integer; for example, big endian order "
"would be the number 4,321.  If I<lorder> is 0 (no order is specified), the "
"current host order is used."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:217
msgid ""
"If the file already exists (and the B<O_TRUNC> flag is not specified), the "
"values specified for the arguments I<flags>, I<lorder> and I<psize> are "
"ignored in favor of the values used when the tree was created."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:219
msgid ""
"Forward sequential scans of a tree are from the least key to the greatest."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:225
msgid ""
"Space freed up by deleting key/data pairs from the tree is never reclaimed, "
"although it is normally made available for reuse.  This means that the btree"
" storage structure is grow-only.  The only solutions are to avoid excessive "
"deletions, or to create a fresh tree periodically from a scan of an existing"
" one."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:231
msgid ""
"Searches, insertions, and deletions in a btree will all complete in O lg "
"base N where base is the average fill factor.  Often, inserting ordered data"
" into btrees results in a low fill factor.  This implementation has been "
"modified to make ordered insertion the best case, resulting in a much better"
" than normal page fill factor."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:238
msgid ""
"The I<btree> access method routines may fail and set I<errno> for any of the"
" errors specified for the library routine B<dbopen>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:240
msgid "Only big and little endian byte order is supported."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:245
msgid "B<dbopen>(3), B<hash>(3), B<mpool>(3), B<recno>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:248
msgid ""
"I<The Ubiquitous B-tree>, Douglas Comer, ACM Comput. Surv. 11, 2 (June "
"1979), 121-138."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:252
msgid ""
"I<Prefix B-trees>, Bayer and Unterauer, ACM Transactions on Database "
"Systems, Vol. 2, 1 (March 1977), 11-26."
msgstr ""

#. type: Plain text
#: man-pages/man3/btree.3:254
msgid ""
"I<The Art of Computer Programming Vol. 3: Sorting and Searching>, D.E. "
"Knuth, 1968, pp 471-480."
msgstr ""
