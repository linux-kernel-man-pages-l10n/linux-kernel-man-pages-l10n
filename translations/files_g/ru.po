# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2013-2014,2017
# Dmitry Bolkhovskikh <d20052005@yandex.ru>, 2017
# Vladislav <ivladislavefimov@gmail.com>, 2015
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2019
# Yuri Kozlov <yuray@komyakino.ru>, 2014
# Иван Павлов <pavia00@gmail.com>, 2017,2019
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-04-01 18:52+0300\n"
"PO-Revision-Date: 2019-06-29 07:13+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian (http://www.transifex.com/kruvalig/man-pages/language/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "GETENT"
msgstr "GETENT"

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "User Commands"
msgstr "Пользовательские команды"

#. type: SH
#: man-pages/man1/getent.1:26
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man1/getent.1:28
msgid "getent - get entries from Name Service Switch libraries"
msgstr "getent - возвращает записи из библиотек диспетчера службы имён"

#. type: SH
#: man-pages/man1/getent.1:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man1/getent.1:30
msgid "B<getent\\ [>I<option>B<]...\\ >I<database>B<\\ >I<key>B<...>"
msgstr "B<getent\\ [>I<параметр>B<]...\\ >I<база_данных>B<\\ >I<ключ>B<...>"

#. type: SH
#: man-pages/man1/getent.1:30
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man1/getent.1:45
msgid ""
"The B<getent> command displays entries from databases supported by the Name "
"Service Switch libraries, which are configured in I</etc/nsswitch.conf>.  If"
" one or more I<key> arguments are provided, then only the entries that match"
" the supplied keys will be displayed.  Otherwise, if no I<key> is provided, "
"all entries will be displayed (unless the database does not support "
"enumeration)."
msgstr "Команда B<getent> отображает записи из баз данных, поддерживаемых библиотеками диспетчера службы имён (Name Service Switch), которые настраиваются в I</etc/nsswitch.conf>. Если указан один или более аргументов I<ключ>, то отображаются только записи, совпадающие с заданными ключами. В противном случае, если I<ключ> не указан, то будут показаны все записи (если база данных поддерживает перечисление)."

#. type: Plain text
#: man-pages/man1/getent.1:49
msgid ""
"The I<database> may be any of those supported by the GNU C Library, listed "
"below:"
msgstr "Значение I<базы данных> может быть любым из поддерживаемых библиотекой GNU C:"

#. type: TP
#: man-pages/man1/getent.1:50
#, no-wrap
msgid "B<ahosts>"
msgstr "B<ahosts>"

#. type: Plain text
#: man-pages/man1/getent.1:71
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  This is identical to "
"using B<hosts>.  When one or more I<key> arguments are provided, pass each "
"I<key> in succession to B<getaddrinfo>(3)  with the address family "
"B<AF_UNSPEC>, enumerating each socket address structure returned."
msgstr "Если I<ключ> не указан, то используются B<sethostent>(3), B<gethostent>(3) и B<endhostent>(3) для перечисления базы данных hosts. Идентично использованию B<hosts>. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getaddrinfo>(3) с адресным семейством B<AF_UNSPEC>, которая возвращает каждую перечисляемую адресную структуру сокета."

#. type: TP
#: man-pages/man1/getent.1:71
#, no-wrap
msgid "B<ahostsv4>"
msgstr "B<ahostsv4>"

#. type: Plain text
#: man-pages/man1/getent.1:77
msgid "Same as B<ahosts>, but use the address family B<AF_INET>."
msgstr "То же, что и B<ahosts>, но используется адресное семейство B<AF_INET>."

#. type: TP
#: man-pages/man1/getent.1:77
#, no-wrap
msgid "B<ahostsv6>"
msgstr "B<ahostsv6>"

#. type: Plain text
#: man-pages/man1/getent.1:88
msgid ""
"Same as B<ahosts>, but use the address family B<AF_INET6>.  The call to "
"B<getaddrinfo>(3)  in this case includes the B<AI_V4MAPPED> flag."
msgstr "То же, что и B<ahosts>, но используется адресное семейство B<AF_INET6>. В этом случае при вызове B<getaddrinfo>(3) включается флаг B<AI_V4MAPPED>."

#. type: TP
#: man-pages/man1/getent.1:88
#, no-wrap
msgid "B<aliases>"
msgstr "B<aliases>"

#. type: Plain text
#: man-pages/man1/getent.1:105
msgid ""
"When no I<key> is provided, use B<setaliasent>(3), B<getaliasent>(3), and "
"B<endaliasent>(3)  to enumerate the aliases database.  When one or more "
"I<key> arguments are provided, pass each I<key> in succession to "
"B<getaliasbyname>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setaliasent>(3), B<getaliasent>(3) и B<endaliasent>(3) для перечисления базы данных aliases. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getaliasbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:105
#, no-wrap
msgid "B<ethers>"
msgstr "B<ethers>"

#. type: Plain text
#: man-pages/man1/getent.1:121
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<ether_aton>(3)  and B<ether_hostton>(3)  until a result is "
"obtained, and display the result.  Enumeration is not supported on "
"B<ethers>, so a I<key> must be provided."
msgstr "Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<ether_aton>(3) и B<ether_hostton>(3), пока не будет возвращён результат, и показывается результат. Перечисление B<ethers> не поддерживается, поэтому I<ключ> обязателен."

#. type: TP
#: man-pages/man1/getent.1:121
#, no-wrap
msgid "B<group>"
msgstr "B<group>"

#. type: Plain text
#: man-pages/man1/getent.1:142
msgid ""
"When no I<key> is provided, use B<setgrent>(3), B<getgrent>(3), and "
"B<endgrent>(3)  to enumerate the group database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getgrgid>(3)  and each"
" nonnumeric I<key> to B<getgrnam>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setgrent>(3), B<getgrent>(3) и B<endgrent>(3) для перечисления базы данных group. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getgrgid>(3) и каждый не числовой I<ключ> в B<getgrnam>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:142
#, no-wrap
msgid "B<gshadow>"
msgstr "B<gshadow>"

#. type: Plain text
#: man-pages/man1/getent.1:159
msgid ""
"When no I<key> is provided, use B<setsgent>(3), B<getsgent>(3), and "
"B<endsgent>(3)  to enumerate the gshadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getsgnam>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setsgent>(3), B<getsgent>(3) и B<endsgent>(3) для перечисления базы данных gshadow. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getsgnam>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:159
#, no-wrap
msgid "B<hosts>"
msgstr "B<hosts>"

#. type: Plain text
#: man-pages/man1/getent.1:182
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  When one or more I<key> "
"arguments are provided, pass each I<key> to B<gethostbyaddr>(3)  or "
"B<gethostbyname2>(3), depending on whether a call to B<inet_pton>(3)  "
"indicates that the I<key> is an IPv6 or IPv4 address or not, and display the"
" result."
msgstr "Если I<ключ> не указан, используется B<sethostent>(3), B<gethostent>(3) и B<endhostent>(3) для перечисления базы данных hosts. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<gethostbyaddr>(3) или B<gethostbyname2>(3), в зависимости от результата вызова B<inet_pton>(3), определяющего, является ли I<ключ> адресом IPv6 или IPv4, и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:182
#, no-wrap
msgid "B<initgroups>"
msgstr "B<initgroups>"

#. type: Plain text
#: man-pages/man1/getent.1:196
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<getgrouplist>(3)  and display the result.  Enumeration is "
"not supported on B<initgroups>, so a I<key> must be provided."
msgstr "Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getgrouplist>(3) и показывается результат. Перечисление B<initgroups> не поддерживается, поэтому I<ключ> обязателен."

#. type: TP
#: man-pages/man1/getent.1:196
#, no-wrap
msgid "B<netgroup>"
msgstr "B<netgroup>"

#. type: Plain text
#: man-pages/man1/getent.1:222
msgid ""
"When one I<key> is provided, pass the I<key> to B<setnetgrent>(3)  and, "
"using B<getnetgrent>(3)  display the resulting string triple (I<hostname>, "
"I<username>, I<domainname>).  Alternatively, three I<keys> may be provided, "
"which are interpreted as the I<hostname>, I<username> and I<domainname> to "
"match to a netgroup name via B<innetgr>(3).  Enumeration is not supported on"
" B<netgroup>, so either one or three I<keys> must be provided."
msgstr "Если указан один I<ключ>, то он передаётся в B<setnetgrent>(3) и, с помощью B<getnetgrent>(3), отображается полученная строковая тройка (I<hostname>, I<username>, I<domainname>). В противном случае могут быть указаны три I<ключа>, которые рассматриваются как I<hostname>, I<username> и I<domainname> для поиска имени netgroup посредством B<innetgr>(3). Перечисление B<netgroup> не поддерживается, поэтому должен быть указан либо один, либо три I<ключа>."

#. type: TP
#: man-pages/man1/getent.1:222
#, no-wrap
msgid "B<networks>"
msgstr "B<networks>"

#. type: Plain text
#: man-pages/man1/getent.1:243
msgid ""
"When no I<key> is provided, use B<setnetent>(3), B<getnetent>(3), and "
"B<endnetent>(3)  to enumerate the networks database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getnetbyaddr>(3)  and each nonnumeric I<key> to B<getnetbyname>(3)  and "
"display the result."
msgstr "Если I<ключ> не указан, используется B<setnetent>(3), B<getnetent>(3) и B<endnetent>(3) для перечисления базы данных networks. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getnetbyaddr>(3) и каждый не числовой I<ключ> в B<getnetbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:243
#, no-wrap
msgid "B<passwd>"
msgstr "B<passwd>"

#. type: Plain text
#: man-pages/man1/getent.1:264
msgid ""
"When no I<key> is provided, use B<setpwent>(3), B<getpwent>(3), and "
"B<endpwent>(3)  to enumerate the passwd database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getpwuid>(3)  and each"
" nonnumeric I<key> to B<getpwnam>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setpwent>(3), B<getpwent>(3) и B<endpwent>(3) для перечисления базы данных passwd. Если указан один или более I<ключ>, то  каждый числовой I<ключ> передаётся в B<getpwuid>(3) и каждый не числовой I<ключ> в B<getpwnam>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:264
#, no-wrap
msgid "B<protocols>"
msgstr "B<protocols>"

#. type: Plain text
#: man-pages/man1/getent.1:285
msgid ""
"When no I<key> is provided, use B<setprotoent>(3), B<getprotoent>(3), and "
"B<endprotoent>(3)  to enumerate the protocols database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getprotobynumber>(3)  and each nonnumeric I<key> to B<getprotobyname>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setprotoent>(3), B<getprotoent>(3) и B<endprotoent>(3) для перечисления базы данных protocols. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getprotobynumber>(3) и каждый не числовой I<ключ> в B<getprotobyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:285
#, no-wrap
msgid "B<rpc>"
msgstr "B<rpc>"

#. type: Plain text
#: man-pages/man1/getent.1:306
msgid ""
"When no I<key> is provided, use B<setrpcent>(3), B<getrpcent>(3), and "
"B<endrpcent>(3)  to enumerate the rpc database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getrpcbynumber>(3)  "
"and each nonnumeric I<key> to B<getrpcbyname>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setrpcent>(3), B<getrpcent>(3) и B<endrpcent>(3) для перечисления базы данных rpc. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getrpcbynumber>(3) и каждый не числовой I<ключ> в B<getrpcbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:306
#, no-wrap
msgid "B<services>"
msgstr "B<services>"

#. type: Plain text
#: man-pages/man1/getent.1:327
msgid ""
"When no I<key> is provided, use B<setservent>(3), B<getservent>(3), and "
"B<endservent>(3)  to enumerate the services database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getservbynumber>(3)  and each nonnumeric I<key> to B<getservbyname>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setservent>(3), B<getservent>(3) и B<endservent>(3) для перечисления базы данных services. Если указан один или более I<ключ>, то  каждый числовой I<ключ> передаётся в B<getservbynumber>(3) и каждый не числовой I<ключ> в B<getservbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:327
#, no-wrap
msgid "B<shadow>"
msgstr "B<shadow>"

#. type: Plain text
#: man-pages/man1/getent.1:344
msgid ""
"When no I<key> is provided, use B<setspent>(3), B<getspent>(3), and "
"B<endspent>(3)  to enumerate the shadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getspnam>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setspent>(3), B<getspent>(3) и B<endspent>(3) для перечисления базы данных shadow. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getspnam>(3) и показывается результат."

#. type: SH
#: man-pages/man1/getent.1:345
#, no-wrap
msgid "OPTIONS"
msgstr "ПАРАМЕТРЫ"

#. type: TP
#: man-pages/man1/getent.1:346
#, no-wrap
msgid "B<-s\\ >I<service>, B<--service\\ >I<service>"
msgstr "B<-s\\ >I<служба>, B<--service\\ >I<служба>"

#.  commit 9d0881aa76b399e6a025c5cf44bebe2ae0efa8af (glibc)
#. type: Plain text
#: man-pages/man1/getent.1:351
msgid ""
"Override all databases with the specified service.  (Since glibc 2.2.5.)"
msgstr "Заменить все базы данных с указанной службой (начиная с glibc 2.2.5)."

#. type: TP
#: man-pages/man1/getent.1:351
#, no-wrap
msgid ""
"B<-s\\ >I<database>B<:>I<service>, B<--service\\ >I<database>B<:>I<service>"
msgstr "B<-s\\ >I<база_данных>B<:>I<служба>, B<--service\\ >I<база_данных>B<:>I<служба>"

#.  commit b4f6f4be85d32b9c03361c38376e36f08100e3e8 (glibc)
#. type: Plain text
#: man-pages/man1/getent.1:359
msgid ""
"Override only specified databases with the specified service.  The option "
"may be used multiple times, but only the last service for each database will"
" be used.  (Since glibc 2.4.)"
msgstr "Заменить только указанные базы данных с указанной службой. Параметр может указываться несколько раз, но будет использоваться только последняя служба для каждой базы данных (начиная с glibc 2.4)."

#. type: TP
#: man-pages/man1/getent.1:359
#, no-wrap
msgid "B<-i>, B<--no-idn>"
msgstr "B<-i>, B<--no-idn>"

#.  commit a160f8d808cf8020b13bd0ef4a9eaf3c11f964ad (glibc)
#. type: Plain text
#: man-pages/man1/getent.1:365
msgid ""
"Disables IDN encoding in lookups for B<ahosts>/B<getaddrinfo>(3)  (Since "
"glibc-2.13.)"
msgstr "Отключить кодировку IDN в поиске B<ahosts>/B<getaddrinfo>(3) (начиная с glibc-2.13)."

#. type: TP
#: man-pages/man1/getent.1:365
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr "B<-?>, B<--help>"

#. type: Plain text
#: man-pages/man1/getent.1:368
msgid "Print a usage summary and exit."
msgstr "Показать справку по использованию и завершить работу."

#. type: TP
#: man-pages/man1/getent.1:368
#, no-wrap
msgid "B<--usage>"
msgstr "B<--usage>"

#. type: Plain text
#: man-pages/man1/getent.1:371
msgid "Print a short usage summary and exit."
msgstr "Показать краткую справку по использованию и завершить работу."

#. type: TP
#: man-pages/man1/getent.1:371
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr "B<-V>, B<--version>"

#. type: Plain text
#: man-pages/man1/getent.1:375
msgid ""
"Print the version number, license, and disclaimer of warranty for B<getent>."
msgstr "Показать номер версии, лицензию и уведомление о гарантиях для B<getent>."

#. type: SH
#: man-pages/man1/getent.1:375
#, no-wrap
msgid "EXIT STATUS"
msgstr "КОД РЕЗУЛЬТАТА"

#. type: Plain text
#: man-pages/man1/getent.1:378
msgid "One of the following exit values can be returned by B<getent>:"
msgstr "Программа B<getent> может возвращать один из следующих кодов завершения:"

#. type: TP
#: man-pages/man1/getent.1:379
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: man-pages/man1/getent.1:382
msgid "Command completed successfully."
msgstr "Команда успешно выполнена."

#. type: TP
#: man-pages/man1/getent.1:382
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: man-pages/man1/getent.1:387
msgid "Missing arguments, or I<database> unknown."
msgstr "Отсутствуют аргументы или неизвестная I<база данных>."

#. type: TP
#: man-pages/man1/getent.1:387
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: man-pages/man1/getent.1:393
msgid "One or more supplied I<key> could not be found in the I<database>."
msgstr "Один или более указанных I<ключей> невозможно найти в I<базе данных>."

#. type: TP
#: man-pages/man1/getent.1:393
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: man-pages/man1/getent.1:397
msgid "Enumeration not supported on this I<database>."
msgstr "Перечисление не поддерживается в этой I<базе данных>."

#. type: SH
#: man-pages/man1/getent.1:398
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man1/getent.1:399
msgid "B<nsswitch.conf>(5)"
msgstr "B<nsswitch.conf>(5)"

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "GLOB"
msgstr "GLOB"

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "2016-10-08"
msgstr "2016-10-08"

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: Plain text
#: man-pages/man7/glob.7:29
msgid "glob - globbing pathnames"
msgstr "glob - шаблоны полных имён файлов"

#. type: Plain text
#: man-pages/man7/glob.7:34
msgid ""
"Long ago, in UNIX\\ V6, there was a program I</etc/glob> that would expand "
"wildcard patterns.  Soon afterward this became a shell built-in."
msgstr "Давным-давно, во времена UNIX\\ V6, существовала программа I</etc/glob>, которая могла раскрывать шаблоны подстановки. Очень скоро она стала встроенной функцией командной оболочки."

#. type: Plain text
#: man-pages/man7/glob.7:38
msgid ""
"These days there is also a library routine B<glob>(3)  that will perform "
"this function for a user program."
msgstr "В наши дни существует библиотечная функция B<glob>(3), которая выполняет эту задачу для пользовательских программ."

#. type: Plain text
#: man-pages/man7/glob.7:40
msgid "The rules are as follows (POSIX.2, 3.13)."
msgstr "Следующие правила приведены в соответствии со стандартом POSIX.2, 3.13."

#. type: SS
#: man-pages/man7/glob.7:40
#, no-wrap
msgid "Wildcard matching"
msgstr "Тип шаблона"

#. type: Plain text
#: man-pages/man7/glob.7:47
msgid ""
"A string is a wildcard pattern if it contains one of the characters "
"\\(aq?\\(aq, \\(aq*\\(aq or \\(aq[\\(aq.  Globbing is the operation that "
"expands a wildcard pattern into the list of pathnames matching the pattern."
"  Matching is defined by:"
msgstr "Строка считается шаблоном подстановки, если содержит в себе один из символов \\(aq?\\(aq, \\(aq*\\(aq или \\(aq[\\(aq. Globbing — это операция, которая раскрывает шаблон подстановки в список имён путей, соответствующих данному шаблону. Соответствие определяется следующими правилами:"

#. type: Plain text
#: man-pages/man7/glob.7:49
msgid "A \\(aq?\\(aq (not between brackets) matches any single character."
msgstr "\\(aq?\\(aq (без учета кавычек) соответствует любому одному символу."

#. type: Plain text
#: man-pages/man7/glob.7:52
msgid ""
"A \\(aq*\\(aq (not between brackets) matches any string, including the empty"
" string."
msgstr "\\(aq*\\(aq (без учета кавычек) соответствует любой строке, включая пустую строку."

#. type: Plain text
#: man-pages/man7/glob.7:54
msgid "B<Character classes>"
msgstr "B<Классы символов>"

#. type: Plain text
#: man-pages/man7/glob.7:63
msgid ""
"An expression \"I<[...]>\" where the first character after the leading "
"\\(aq[\\(aq is not an \\(aq!\\(aq matches a single character, namely any of "
"the characters enclosed by the brackets.  The string enclosed by the "
"brackets cannot be empty; therefore \\(aq]\\(aq can be allowed between the "
"brackets, provided that it is the first character.  (Thus, \"I<[][!]>\" "
"matches the three characters \\(aq[\\(aq, \\(aq]\\(aq and \\(aq!\\(aq.)"
msgstr "Выражение «I<[...]>», где первый символ после открывающей \\(aq[\\(aq - не равен \\(aq!\\(aq, соответствует одному символу, который может быть любым символом из набора, находящегося внутри скобок. Строка внутри скобок не может быть пустой, таким образом, \\(aq]\\(aq также может находиться внутри скобок и выступать в качестве первого символа (то есть «I<[][!]>» будет соответствовать трем символам \\(aq[\\(aq, \\(aq]\\(aq и \\(aq!\\(aq)."

#. type: Plain text
#: man-pages/man7/glob.7:65
msgid "B<Ranges>"
msgstr "B<Диапазоны>"

#. type: Plain text
#: man-pages/man7/glob.7:76
msgid ""
"There is one special convention: two characters separated by \\(aq-\\(aq "
"denote a range.  (Thus, \"I<[A-Fa-f0-9]>\" is equivalent to "
"\"I<[ABCDEFabcdef0123456789]>\".)  One may include \\(aq-\\(aq in its "
"literal meaning by making it the first or last character between the "
"brackets.  (Thus, \"I<[]-]>\" matches just the two characters \\(aq]\\(aq "
"and \\(aq-\\(aq, and \"I<[--0]>\" matches the three characters \\(aq-\\(aq, "
"\\(aq.\\(aq, \\(aq0\\(aq, since \\(aq/\\(aq cannot be matched.)"
msgstr "Два символа, разделённые \\(aq-\\(aq, образуют особое выражение — диапазон (то есть «I<[A-Fa-f0-9]>» будет эквивалентен записи «I<[ABCDEFabcdef0123456789]>»). Сюда также может входить и сам \\(aq-\\(aq в качестве начального или конечного символа (то есть «I<[]-]>» будет соответствовать только двум символам - \\(aq]\\(aq и \\(aq-\\(aq, а «I<[--0]>» — трем символам: \\(aq-\\(aq, \\(aq.\\(aq, \\(aq0\\(aq, так как \\(aq/\\(aq не может быть использован)."

#. type: Plain text
#: man-pages/man7/glob.7:78
msgid "B<Complementation>"
msgstr "B<Разность множеств>"

#. type: Plain text
#: man-pages/man7/glob.7:84
msgid ""
"An expression \"I<[!...]>\" matches a single character, namely any character"
" that is not matched by the expression obtained by removing the first "
"\\(aq!\\(aq from it.  (Thus, \"I<[!]a-]>\" matches any single character "
"except \\(aq]\\(aq, \\(aqa\\(aq and \\(aq-\\(aq.)"
msgstr "Выражение «I<[!...]>» соответствует одному любому символу, который не входит в множество, получаемое путем удаления первого  \\(aq!\\(aq (то есть «I<[!]a-]>» будет соответствовать любому одному символу за исключением \\(aq]\\(aq, \\(aqa\\(aq и \\(aq-\\(aq)."

#. type: Plain text
#: man-pages/man7/glob.7:91
msgid ""
"One can remove the special meaning of \\(aq?\\(aq, \\(aq*\\(aq and "
"\\(aq[\\(aq by preceding them by a backslash, or, in case this is part of a "
"shell command line, enclosing them in quotes.  Between brackets these "
"characters stand for themselves.  Thus, \"I<[[?*\\e]>\" matches the four "
"characters \\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq and \\(aq\\e\\(aq."
msgstr "Специальное значение \\(aq?\\(aq, \\(aq*\\(aq и \\(aq[\\(aq может быть аннулировано путём экранирования их обратной косой чертой или, в случае, когда они являются частью оболочки командной строки, путём заключения их в кавычки. Внутри квадратных скобок эти символы не имеют специального значения. Таким образом, «I<[[?*\\e]>» совпадает с четырьмя символами \\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq и \\(aq\\e\\(aq."

#. type: SS
#: man-pages/man7/glob.7:91
#, no-wrap
msgid "Pathnames"
msgstr "Полные составные пути"

#. type: Plain text
#: man-pages/man7/glob.7:98
msgid ""
"Globbing is applied on each of the components of a pathname separately.  A "
"\\(aq/\\(aq in a pathname cannot be matched by a \\(aq?\\(aq or \\(aq*\\(aq "
"wildcard, or by a range like \"I<[.-0]>\".  A range containing an explicit "
"\\(aq/\\(aq character is syntactically incorrect.  (POSIX requires that "
"syntactically incorrect patterns are left unchanged.)"
msgstr "Раскрытие (globbing) применяется к каждой части полного составного имени файла отдельно. Символ \\(aq/\\(aq в полном имени файла не может совпадать с шаблоном \\(aq?\\(aq или \\(aq*\\(aq, а только с диапазоном подобным «I<[.-0]>». Диапазон не может включать в себя символ \\(aq/\\(aq, поскольку это будет считаться синтаксической ошибкой (в POSIX требуется, чтобы синтаксически некорректные шаблоны не изменялись)."

#. type: Plain text
#: man-pages/man7/glob.7:103
msgid ""
"If a filename starts with a \\(aq.\\(aq, this character must be matched "
"explicitly.  (Thus, I<rm\\ *> will not remove .profile, and I<tar\\ c\\ *> "
"will not archive all your files; I<tar\\ c\\ .> is better.)"
msgstr "Если имя файла начинается с \\(aq.\\(aq, то этот символ должен быть обязательно указан в шаблоне (таким образом, I<rm\\ *> не удалит .profile, а I<tar\\ c\\ *> заархивирует не все файлы; лучше использовать I<tar\\ c\\ .>)."

#. type: SS
#: man-pages/man7/glob.7:103
#, no-wrap
msgid "Empty lists"
msgstr "Пустые списки"

#. type: Plain text
#: man-pages/man7/glob.7:109
msgid ""
"The nice and simple rule given above: \"expand a wildcard pattern into the "
"list of matching pathnames\" was the original UNIX definition.  It allowed "
"one to have patterns that expand into an empty list, as in"
msgstr "Выше было приведено простое и замечательное правило из оригинального определения UNIX: «раскрытие шаблона — это операция, преобразующая шаблон в список соответствующих ему полных имён файлов». Оно допускает существование шаблона, соответствующего пустому списку, например:"

#. type: Plain text
#: man-pages/man7/glob.7:112
#, no-wrap
msgid "    xv -wait 0 *.gif *.jpg\n"
msgstr "    xv -wait 0 *.gif *.jpg\n"

#. type: Plain text
#: man-pages/man7/glob.7:122
msgid ""
"where perhaps no *.gif files are present (and this is not an error).  "
"However, POSIX requires that a wildcard pattern is left unchanged when it is"
" syntactically incorrect, or the list of matching pathnames is empty.  With "
"I<bash> one can force the classical behavior using this command:"
msgstr "где, возможно, файлы *.gif на самом деле отсутствуют (и это не ошибка). Несмотря на это, в POSIX требуется, чтобы шаблон, синтаксически неправильный или раскрывающийся в пустой список путей к файлам, оставался без изменений. В I<bash> можно принудительно включить классическое поведение с помощью команды:"

#.  In Bash v1, by setting allow_null_glob_expansion=true
#. type: Plain text
#: man-pages/man7/glob.7:125
#, no-wrap
msgid "    shopt -s nullglob\n"
msgstr "    shopt -s nullglob\n"

#. type: Plain text
#: man-pages/man7/glob.7:128
msgid ""
"(Similar problems occur elsewhere.  For example, where old scripts have"
msgstr "Подобная проблема может проявиться вновь. Например, там, где в старых сценариях использовалось"

#. type: Plain text
#: man-pages/man7/glob.7:131
#, no-wrap
msgid "    rm \\`find . -name \"*~\"\\`\n"
msgstr "    rm \\`find . -name \"*~\"\\`\n"

#. type: Plain text
#: man-pages/man7/glob.7:134
msgid "new scripts require"
msgstr "в новых сценариях используется"

#. type: Plain text
#: man-pages/man7/glob.7:137
#, no-wrap
msgid "    rm -f nosuchfile \\`find . -name \"*~\"\\`\n"
msgstr "    rm -f nosuchfile \\`find . -name \"*~\"\\`\n"

#. type: Plain text
#: man-pages/man7/glob.7:142
msgid ""
"to avoid error messages from I<rm> called with an empty argument list.)"
msgstr "для избежания сообщений об ошибках I<rm>, вызванного с пустым списком аргументов."

#. type: SH
#: man-pages/man7/glob.7:142
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: SS
#: man-pages/man7/glob.7:143
#, no-wrap
msgid "Regular expressions"
msgstr "Регулярные выражения"

#. type: Plain text
#: man-pages/man7/glob.7:150
msgid ""
"Note that wildcard patterns are not regular expressions, although they are a"
" bit similar.  First of all, they match filenames, rather than text, and "
"secondly, the conventions are not the same: for example, in a regular "
"expression \\(aq*\\(aq means zero or more copies of the preceding thing."
msgstr "Заметим, что шаблоны не являются регулярными выражениями, хотя и похожи. Во-первых, они используются для выявления совпадений в именах файлов, а не в тексте. Во-вторых, используются разные соглашения: например, регулярное выражение \\(aq*\\(aq означает ноль или более копий предшествующему символу."

#. type: Plain text
#: man-pages/man7/glob.7:154
msgid ""
"Now that regular expressions have bracket expressions where the negation is "
"indicated by a \\(aq^\\(aq, POSIX has declared the effect of a wildcard "
"pattern \"I<[^...]>\" to be undefined."
msgstr "Теперь, когда в квадратных скобках у регулярных выражений для отрицания используется \\(aq^\\(aq, в POSIX оговаривается, что эффект шаблона «I<[^...]>» не определён."

#. type: SS
#: man-pages/man7/glob.7:154
#, no-wrap
msgid "Character classes and internationalization"
msgstr "Классы символов и интернационализация"

#. type: Plain text
#: man-pages/man7/glob.7:172
msgid ""
"Of course ranges were originally meant to be ASCII ranges, so that \"I<[\\ "
"-%]>\" stands for \"I<[\\ !\"#$%]>\" and \"I<[a-z]>\" stands for \"any "
"lowercase letter\".  Some UNIX implementations generalized this so that a "
"range X-Y stands for the set of characters with code between the codes for X"
" and for Y.  However, this requires the user to know the character coding in"
" use on the local system, and moreover, is not convenient if the collating "
"sequence for the local alphabet differs from the ordering of the character "
"codes.  Therefore, POSIX extended the bracket notation greatly, both for "
"wildcard patterns and for regular expressions.  In the above we saw three "
"types of items that can occur in a bracket expression: namely (i) the "
"negation, (ii) explicit single characters, and (iii) ranges.  POSIX "
"specifies ranges in an internationally more useful way and adds three more "
"types:"
msgstr "Изначально диапазоны были определены для символов ASCII, так что «I<[\\ -%]>» соответствует «I<[\\ !\"#$%]>», а «I<[a-z]>» соответствует «любому символу нижнего регистра». В некоторых реализациях UNIX это обобщено так, что диапазон X-Y соответствует всем символам, коды которых находятся между X и Y. Однако, это требует знания способа кодирования символов в локальной системе и, более того, не удобно, если последовательность сортировки для локального алфавита отличается от последовательности кодов символов. Поэтому в POSIX значительно расширено обозначение квадратных скобок как для шаблонов файлов, так и для регулярных выражений. Выше встретилось три типа выражений в скобках: отрицание (i), указанный явно символ (ii) и диапазон (iii). В POSIX диапазоны определены в более удобном с точки зрения интернационализации виде, а также добавлены три новых типа:"

#. type: Plain text
#: man-pages/man7/glob.7:178
msgid ""
"(iii) Ranges X-Y comprise all characters that fall between X and Y "
"(inclusive) in the current collating sequence as defined by the "
"B<LC_COLLATE> category in the current locale."
msgstr "(iii) Диапазоны X-Y включают в себя все символы, находящиеся между X и Y (включительно) в соответствии с текущей последовательностью сортировки, определённой в категории B<LC_COLLATE> текущей локали."

#. type: Plain text
#: man-pages/man7/glob.7:180
msgid "(iv) Named character classes, like"
msgstr "(iv) Именованные классы символов, такие, как:"

#. type: Plain text
#: man-pages/man7/glob.7:185
#, no-wrap
msgid ""
"[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n"
"[:digit:]  [:graph:]  [:lower:]  [:print:]\n"
"[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"
msgstr "[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n[:digit:]  [:graph:]  [:lower:]  [:print:]\n[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"

#. type: Plain text
#: man-pages/man7/glob.7:194
msgid ""
"so that one can say \"I<[[:lower:]]>\" instead of \"I<[a-z]>\", and have "
"things work in Denmark, too, where there are three letters past \\(aqz\\(aq "
"in the alphabet.  These character classes are defined by the B<LC_CTYPE> "
"category in the current locale."
msgstr "Благодаря им можно указать значение «I<[[:lower:]]>» вместо «I<[a-z]>», и это будет работать для Дании, где в алфавите есть три буквы, стоящие после «z». Эти классы символов определяются категорией B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man7/glob.7:200
msgid ""
"(v) Collating symbols, like \"I<[.ch.]>\" or \"I<[.a-acute.]>\", where the "
"string between \"I<[.>\" and \"I<.]>\" is a collating element defined for "
"the current locale.  Note that this may be a multicharacter element."
msgstr "(v) Сортировочные символы, такие, как «I<[.ch.]>» или «I<[.a-acute.]>», строка которых, лежащая между «I<[.>» и «I<.]>», является элементом сортировки, определённым для текущей локали. Заметим, что это может быть многосимвольный элемент."

#. type: Plain text
#: man-pages/man7/glob.7:208
msgid ""
"(vi) Equivalence class expressions, like \"I<[=a=]>\", where the string "
"between \"I<[=>\" and \"I<=]>\" is any collating element from its "
"equivalence class, as defined for the current locale.  For example, "
"\"I<[[=a=]]>\" might be equivalent to \"I<[a\\('a\\(`a\\(:a\\(^a]>\", that "
"is, to \"I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>\"."
msgstr "(vi) Классы эквивалентности, такие, как «I<[=a=]>», где строка между «I<[=>» и «I<=]>» является любым элементом сортировки из своего класса эквивалентности, определённого в текущей локали. Например, «I<[[=a=]]>» может быть эквивалентно «I<[a\\('a\\(`a\\(:a\\(^a]>», то есть «I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>»."

#. type: Plain text
#: man-pages/man7/glob.7:213
msgid "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"
msgstr "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"

#. type: TH
#: man-pages/man2/getsid.2:27
#, no-wrap
msgid "GETSID"
msgstr "GETSID"

#. type: TH
#: man-pages/man2/getsid.2:27
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: man-pages/man2/getsid.2:30
msgid "getsid - get session ID"
msgstr "getsid - получить ID сеанса"

#. type: Plain text
#: man-pages/man2/getsid.2:32
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getsid.2:34
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getsid.2:36
msgid "B<pid_t getsid(pid_t>I< pid>B<);>"
msgstr "B<pid_t getsid(pid_t>I< pid>B<);>"

#. type: Plain text
#: man-pages/man2/getsid.2:40
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/getsid.2:45
msgid "B<getsid>():"
msgstr "B<getsid>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/getsid.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man2/getsid.2:50
#, no-wrap
msgid "    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr "    || /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"

#. type: Plain text
#: man-pages/man2/getsid.2:64
msgid ""
"I<getsid(0)> returns the session ID of the calling process.  B<getsid>()  "
"returns the session ID of the process with process ID I<pid>.  If I<pid> is "
"0, B<getsid>()  returns the session ID of the calling process."
msgstr "Вызов I<getsid(0)> возвращает идентификатор (ID) сеанса вызвавшего процесса. Вызов B<getsid>() возвращает идентификатор сеанса процесса с ID равным I<pid>. Если I<pid> равно 0, то B<getsid>() возвращает идентификатор сеанса вызвавшего процесса."

#. type: SH
#: man-pages/man2/getsid.2:64
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/getsid.2:69
msgid ""
"On success, a session ID is returned.  On error, I<(pid_t)\\ -1> will be "
"returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении возвращается идентификатор сеанса. В случае ошибки возвращается I<(pid_t)\\ -1>, а I<errno> устанавливается в соответствующее значение."

#. type: SH
#: man-pages/man2/getsid.2:69
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man2/getsid.2:70
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/getsid.2:76
msgid ""
"A process with process ID I<pid> exists, but it is not in the same session "
"as the calling process, and the implementation considers this an error."
msgstr "Процесс с идентификатором I<pid> существует, но не находится в том же сеансе что и вызвавший процесс; в данной реализации это считается ошибкой."

#. type: TP
#: man-pages/man2/getsid.2:76
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/getsid.2:81
msgid "No process with process ID I<pid> was found."
msgstr "Процесс с идентификатором I<pid> не найден."

#. type: SH
#: man-pages/man2/getsid.2:81
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#.  Linux has this system call since Linux 1.3.44.
#.  There is libc support since libc 5.2.19.
#. type: Plain text
#: man-pages/man2/getsid.2:85
msgid "This system call is available on Linux since version 2.0."
msgstr "Данный системный вызов доступен в Linux начиная с версии 2.0."

#. type: SH
#: man-pages/man2/getsid.2:85
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man2/getsid.2:87
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#. type: Plain text
#: man-pages/man2/getsid.2:90
msgid "Linux does not return B<EPERM>."
msgstr "Linux не возвращает B<EPERM>."

#. type: Plain text
#: man-pages/man2/getsid.2:94
msgid "See B<credentials>(7)  for a description of sessions and session IDs."
msgstr "На странице B<credentials>(7) есть описание сеансов и их идентификаторов."

#. type: Plain text
#: man-pages/man2/getsid.2:97
msgid "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/getpid.2:25
#, no-wrap
msgid "GETPID"
msgstr "GETPID"

#. type: Plain text
#: man-pages/man2/getpid.2:28
msgid "getpid, getppid - get process identification"
msgstr "getpid, getppid - получение идентификатора процесса"

#. type: Plain text
#: man-pages/man2/getpid.2:34
msgid "B<pid_t getpid(void);>"
msgstr "B<pid_t getpid(void);>"

#. type: Plain text
#: man-pages/man2/getpid.2:36
msgid "B<pid_t getppid(void);>"
msgstr "B<pid_t getppid(void);>"

#. type: Plain text
#: man-pages/man2/getpid.2:41
msgid ""
"B<getpid>()  returns the process ID (PID) of the calling process.  (This is "
"often used by routines that generate unique temporary filenames.)"
msgstr "Вызов B<getpid>() возвращает идентификатор (PID) вызвавшего процесса (часто используется функциями, которые генерируют уникальные имена временных файлов)."

#. type: Plain text
#: man-pages/man2/getpid.2:53
msgid ""
"B<getppid>()  returns the process ID of the parent of the calling process.  "
"This will be either the ID of the process that created this process using "
"B<fork>(), or, if that process has already terminated, the ID of the process"
" to which this process has been reparented (either B<init>(1)  or a "
"\"subreaper\" process defined via the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER>"
" operation)."
msgstr "Вызов B<getppid>() возвращает идентификатор процесса, являющегося родительским по отношению к вызвавшему процессу. Результат равен идентификатору процесса, который создал этот процесс с помощью B<fork>(), или идентификатору процесса, который заместил родителя (или B<init>(1), или процесс «сборщик», определённый с помощью операции B<PR_SET_CHILD_SUBREAPER> вызовом B<prctl>(2)), если этот процесс уже завершён."

#. type: Plain text
#: man-pages/man2/getpid.2:55
msgid "These functions are always successful."
msgstr "Функции всегда завершаются успешно."

#. type: Plain text
#: man-pages/man2/getpid.2:57
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4."

#. type: Plain text
#: man-pages/man2/getpid.2:62
msgid ""
"If the caller's parent is in a different PID namespace (see "
"B<pid_namespaces>(7)), B<getppid>()  returns 0."
msgstr "Если родитель вызывающего находит в другом пространстве имён PID (смотрите B<pid_namespaces>(7)), то B<getppid>() возвращает 0."

#. type: Plain text
#: man-pages/man2/getpid.2:75
msgid ""
"From a kernel perspective, the PID (which is shared by all of the threads in"
" a multithreaded process)  is sometimes also known as the thread group ID "
"(TGID).  This contrasts with the kernel thread ID (TID), which is unique for"
" each thread.  For further details, see B<gettid>(2)  and the discussion of "
"the B<CLONE_THREAD> flag in B<clone>(2)."
msgstr "Со стороны ядра PID (одинаков у всех нитей в многонитевом процессе) иногда называют идентификатором группы нитей (TGID). Он отличается от идентификатора нити (TID), который является уникальным для каждой нити. Подробней смотрите в B<gettid>(2) и описание флага B<CLONE_THREAD> в B<clone>(2)."

#. type: SS
#: man-pages/man2/getpid.2:75
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#.  The following program demonstrates this "feature":
#.  #define _GNU_SOURCE
#.  #include <sys/syscall.h>
#.  #include <sys/wait.h>
#.  #include <stdio.h>
#.  #include <stdlib.h>
#.  #include <unistd.h>
#.  int
#.  main(int argc, char *argv[])
#.  {
#.     /* The following statement fills the getpid() cache */
#.     printf("parent PID = %ld
#. ", (long) getpid());
#.     if (syscall(SYS_fork) == 0) {
#.         if (getpid() != syscall(SYS_getpid))
#.             printf("child getpid() mismatch: getpid()=%ld; "
#.                     "syscall(SYS_getpid)=%ld
#. ",
#.                     (long) getpid(), (long) syscall(SYS_getpid));
#.         exit(EXIT_SUCCESS);
#.     }
#.     wait(NULL);
#. }
#. type: Plain text
#: man-pages/man2/getpid.2:129
msgid ""
"From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper"
" function for B<getpid>()  cached PIDs, with the goal of avoiding additional"
" system calls when a process calls B<getpid>()  repeatedly.  Normally this "
"caching was invisible, but its correct operation relied on support in the "
"wrapper functions for B<fork>(2), B<vfork>(2), and B<clone>(2): if an "
"application bypassed the glibc wrappers for these system calls by using "
"B<syscall>(2), then a call to B<getpid>()  in the child would return the "
"wrong value (to be precise: it would return the PID of the parent process)."
"  In addition, there were cases where B<getpid>()  could return the wrong "
"value even when invoking B<clone>(2)  via the glibc wrapper function.  (For "
"a discussion of one such case, see BUGS in B<clone>(2).)  Furthermore, the "
"complexity of the caching code had been the source of a few bugs within "
"glibc over the years."
msgstr "В версиях glibc с 2.3.4 по 2.24 включительно обёрточная функция glibc для B<getpid>()  кэширует PID, чтобы не делать дополнительных системных вызовов, когда процесс систематически вызывает B<getpid>(). Обычно, это кэширование незаметно, но его корректность работы полагается на поддержку в обёрточных функциях для B<fork>(2), B<vfork>(2) и B<clone>(2): если приложение не воспользуется обёртками glibc для этих системных вызовов, а вызовет из через B<syscall>(2), то вызов B<getpid>() в потомке вернёт неправильное значение (точнее, вернёт PID родительского процесса). Также, бывают случаи, когда B<getpid>() может вернуть неверное значение даже при вызове B<clone>(2) через обёрточную функцию glibc (описание одного из них смотрите в разделе ДЕФЕКТЫ в B<clone>(2)). Кроме того, сложность кэширующего кода была источником нескольких дефектов в glibc многие годы."

#.  commit c579f48edba88380635ab98cb612030e3ed8691e
#.  https://sourceware.org/glibc/wiki/Release/2.25#pid_cache_removal
#.  FIXME .
#.  Review progress of https://bugzilla.redhat.com/show_bug.cgi?id=1469757
#. type: Plain text
#: man-pages/man2/getpid.2:139
msgid ""
"Because of the aforementioned problems, since glibc version 2.25, the PID "
"cache is removed: calls to B<getpid>()  always invoke the actual system "
"call, rather than returning a cached value."
msgstr "Из-за вышеперечисленных проблем начиная с glibc версии 2.25 кэширование PID было удалено: вызов B<getpid>() всегда вызывает реальный системный вызов, а не возвращает значение из кэша."

#. type: Plain text
#: man-pages/man2/getpid.2:155
msgid ""
"On Alpha, instead of a pair of B<getpid>()  and B<getppid>()  system calls, "
"a single B<getxpid>()  system call is provided, which returns a pair of PID "
"and parent PID.  The glibc B<getpid>()  and B<getppid>()  wrapper functions "
"transparently deal with this.  See B<syscall>(2)  for details regarding "
"register mapping."
msgstr "На Alpha вместо пары системных вызовов B<getpid>() и B<getppid>() предоставляется один B<getxpid>(), который возвращает пару PID и родительский PID. Обёрточные функции glibc B<getpid>() и B<getppid>() скрывают это. Подробности об отображении регистров смотрите в B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/getpid.2:166
msgid ""
"B<clone>(2), B<fork>(2), B<gettid>(2), B<kill>(2), B<exec>(3), "
"B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), "
"B<credentials>(7), B<pid_namespaces>(7)"
msgstr "B<clone>(2), B<fork>(2), B<gettid>(2), B<kill>(2), B<exec>(3), B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), B<credentials>(7), B<pid_namespaces>(7)"

#. type: TH
#: man-pages/man2/getpriority.2:45
#, no-wrap
msgid "GETPRIORITY"
msgstr "GETPRIORITY"

#. type: Plain text
#: man-pages/man2/getpriority.2:48
msgid "getpriority, setpriority - get/set program scheduling priority"
msgstr "getpriority, setpriority - получить/установить приоритет планирования программы"

#. type: Plain text
#: man-pages/man2/getpriority.2:50
msgid "B<#include E<lt>sys/time.hE<gt>>"
msgstr "B<#include E<lt>sys/time.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getpriority.2:52
msgid "B<#include E<lt>sys/resource.hE<gt>>"
msgstr "B<#include E<lt>sys/resource.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getpriority.2:54
msgid "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"
msgstr "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"

#. type: Plain text
#: man-pages/man2/getpriority.2:56
msgid "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"
msgstr "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"

#. type: Plain text
#: man-pages/man2/getpriority.2:70
msgid ""
"The scheduling priority of the process, process group, or user, as indicated"
" by I<which> and I<who> is obtained with the B<getpriority>()  call and set "
"with the B<setpriority>()  call.  The process attribute dealt with by these "
"system calls is the same attribute (also known as the \"nice\" value) that "
"is dealt with by B<nice>(2)."
msgstr "С помощью вызова B<getpriority>() можно получить приоритет планирования (scheduling priority) процесса, группы процессов или пользователя, которые заданы в аргументах I<which> и I<who>, а с помощью вызова B<setpriority>() назначить его. Атрибут процесса этих системных вызовов тот же самый что атрибут (так называемое значение уступчивости «nice»), с которым работает вызов B<nice>(2)."

#. type: Plain text
#: man-pages/man2/getpriority.2:93
msgid ""
"The value I<which> is one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>,"
" and I<who> is interpreted relative to I<which> (a process identifier for "
"B<PRIO_PROCESS>, process group identifier for B<PRIO_PGRP>, and a user ID "
"for B<PRIO_USER>).  A zero value for I<who> denotes (respectively) the "
"calling process, the process group of the calling process, or the real user "
"ID of the calling process."
msgstr "Значением I<which> может быть одно из: B<PRIO_PROCESS>, B<PRIO_PGRP> или B<PRIO_USER>, а значение I<who> рассматривается относительно I<which> (идентификатор процесса, если B<PRIO_PROCESS>; группы процесса, если B<PRIO_PGRP>; идентификатор пользователя, если B<PRIO_USER>). Нулевое значение I<who> означает (соответственно) вызывающий процесс, группу вызывающего процесса или реальный идентификатор пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getpriority.2:102
msgid ""
"The I<prio> argument is a value in the range -20 to 19 (but see NOTES "
"below).  with -20 being the highest priority and 19 being the lowest "
"priority.  Attempts to set a priority outside this range are silently "
"clamped to the range.  The default priority is 0; lower values give a "
"process a higher scheduling priority."
msgstr "Аргумент I<prio> — это значение в диапазоне от -20 до 19 (смотрите ЗАМЕЧАНИЯ ниже), где -20 это наивысший приоритет, а 19 — наинизший. Попытка задать приоритет вне этого диапазона просто подгоняется под диапазон. По умолчанию приоритет равен 0; низкие значения дают процессу больший приоритет при планировании."

#. type: Plain text
#: man-pages/man2/getpriority.2:111
msgid ""
"The B<getpriority>()  call returns the highest priority (lowest numerical "
"value)  enjoyed by any of the specified processes.  The B<setpriority>()  "
"call sets the priorities of all of the specified processes to the specified "
"value."
msgstr "Вызов B<getpriority>() возвращает наивысший приоритет (наименьшее числовое значение) из приоритетов всех указанных процессов. Вызов B<setpriority>() устанавливает приоритеты всех указанных процессов в заданное значение."

#. type: Plain text
#: man-pages/man2/getpriority.2:120
msgid ""
"Traditionally, only a privileged process could lower the nice value (i.e., "
"set a higher priority).  However, since Linux 2.6.12, an unprivileged "
"process can decrease the nice value of a target process that has a suitable "
"B<RLIMIT_NICE> soft limit; see B<getrlimit>(2)  for details."
msgstr "Обычно, только привилегированный процесс может понижать значение уступчивости (т. е., повышать приоритет). Однако начиная с Linux 2.6.12 непривилегированный процесс может понизить значение уступчивости процесса назначения, у которого установлено подходящее мягкое ограничение B<RLIMIT_NICE>; подробности смотрите в B<getrlimit>(2)."

#. type: Plain text
#: man-pages/man2/getpriority.2:135
msgid ""
"On success, B<getpriority>()  returns the calling thread's nice value, which"
" may be a negative number.  On error, it returns -1 and sets I<errno> to "
"indicate the cause of the error.  Since a successful call to "
"B<getpriority>()  can legitimately return the value -1, it is necessary to "
"clear the external variable I<errno> prior to the call, then check it "
"afterward to determine if -1 is an error or a legitimate value."
msgstr "При успешном выполнении B<getpriority>() возвращает значение уступчивости вызывающей нити, которое может быть отрицательным. При ошибке возвращается -1 и изменяется значение I<errno>, указывающее код ошибки. Так как B<getpriority>() в качестве результата может вернуть -1, то перед вызовом необходимо очищать значение внешней переменной I<errno>, а затем проверять его после вызова, чтобы определить, является ли -1 ошибкой или результатом вызова."

#. type: Plain text
#: man-pages/man2/getpriority.2:141
msgid ""
"B<setpriority>()  returns 0 on success.  On error, it returns -1 and sets "
"I<errno> to indicate the cause of the error."
msgstr "При нормальном завершении работы B<setpriority>() возвращает 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/getpriority.2:142
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man2/getpriority.2:150
msgid ""
"I<which> was not one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>."
msgstr "Значение I<which> не равно B<PRIO_PROCESS>, B<PRIO_PGRP> или B<PRIO_USER>."

#. type: Plain text
#: man-pages/man2/getpriority.2:157
msgid "No process was located using the I<which> and I<who> values specified."
msgstr "Не найдено процессов, которые заданы значениями I<which> и I<who>."

#. type: Plain text
#: man-pages/man2/getpriority.2:161
msgid ""
"In addition to the errors indicated above, B<setpriority>()  may fail if:"
msgstr "В дополнение к вышеуказанным ошибкам, B<setpriority>() может завершиться неудачно:"

#. type: TP
#: man-pages/man2/getpriority.2:161
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/getpriority.2:168
msgid ""
"The caller attempted to set a lower nice value (i.e., a higher process "
"priority), but did not have the required privilege (on Linux: did not have "
"the B<CAP_SYS_NICE> capability)."
msgstr "Вызывающий пытается понизить значение уступчивости (то есть повысить приоритет процесса), но он не имеет на это прав (в Linux: не имеет мандата B<CAP_SYS_NICE>)."

#. type: Plain text
#: man-pages/man2/getpriority.2:176
msgid ""
"A process was located, but its effective user ID did not match either the "
"effective or the real user ID of the caller, and was not privileged (on "
"Linux: did not have the B<CAP_SYS_NICE> capability).  But see NOTES below."
msgstr "Процесс был найден, но эффективному идентификатору пользователя этого процесса не соответствует заданный в вызове эффективный (или реальный) идентификатор вызывающего и  у вызывающего нет прав (в Linux: не имеет мандата B<CAP_SYS_NICE>). Смотрите ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man2/getpriority.2:179
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these interfaces first appeared in"
" 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (эти интерфейсы впервые появились в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/getpriority.2:182
msgid "For further details on the nice value, see B<sched>(7)."
msgstr "Дополнительную информацию о значении уступчивости смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/getpriority.2:188
msgid ""
"I<Note>: the addition of the \"autogroup\" feature in Linux 2.6.38 means "
"that the nice value no longer has its traditional effect in many "
"circumstances.  For details, see B<sched>(7)."
msgstr "I<Замечание>: дополнительное свойство «autogroup» из Linux 2.6.38 означает, что значение уступчивости во многих случаях больше не работает как обычно. Подробней смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/getpriority.2:194
msgid ""
"A child created by B<fork>(2)  inherits its parent's nice value.  The nice "
"value is preserved across B<execve>(2)."
msgstr "Потомок, созданный с помощью B<fork>(2), наследует значение nice родителя. При вызове B<execve>(2)  значение nice сохраняется."

#. type: Plain text
#: man-pages/man2/getpriority.2:209
msgid ""
"The details on the condition for B<EPERM> depend on the system.  The above "
"description is what POSIX.1-2001 says, and seems to be followed on all "
"System\\ V-like systems.  Linux kernels before 2.6.12 required the real or "
"effective user ID of the caller to match the real user of the process I<who>"
" (instead of its effective user ID).  Linux 2.6.12 and later require the "
"effective user ID of the caller to match the real or effective user ID of "
"the process I<who>.  All BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, "
"FreeBSD 4.3, OpenBSD-2.5, ...) behave in the same manner as Linux 2.6.12 and"
" later."
msgstr "Детали условия возникновения ошибки B<EPERM> зависят от системы. Описание, приведённое выше, соответствует POSIX.1-2001, и, кажется, ему удовлетворяют все System\\ V-подобные системы. Ядра Linux до версии 2.6.12 требуют, чтобы эффективный идентификатор пользователя вызывающего совпадал с реальным идентификатором пользователя процесса I<who> (вместо его эффективного идентификатора пользователя). В Linux 2.6.12 и новее требуется, чтобы эффективный идентификатор пользователя вызывающего совпадал с реальным или эффективным идентификатором пользователя процесса I<who>. Все системы BSD (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, FreeBSD 4.3, OpenBSD-2.5, …) действуют также как Linux 2.6.12 и новее."

#. type: Plain text
#: man-pages/man2/getpriority.2:222
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr "Включать I<E<lt>sys/time.hE<gt>> в настоящее время не требуется, но это увеличивает переносимость (безусловно, в I<E<lt>sys/resource.hE<gt>> определена структура I<rusage> с полями типа I<struct timeval>, которая определена в I<E<lt>sys/time.hE<gt>>)."

#. type: Plain text
#: man-pages/man2/getpriority.2:237
msgid ""
"Within the kernel, nice values are actually represented using the range "
"40..1 (since negative numbers are error codes) and these are the values "
"employed by the B<setpriority>()  and B<getpriority>()  system calls.  The "
"glibc wrapper functions for these system calls handle the translations "
"between the user-land and kernel representations of the nice value according"
" to the formula I<unice\\ =\\ 20\\ -\\ knice>.  (Thus, the kernel's 40..1 "
"range corresponds to the range -20..19 as seen by user space.)"
msgstr "Внутри ядра значения nice на самом деле представлены как диапазон  (так как отрицательными числами задаются коды ошибок) и эти значения возвращаются системными вызовами B<setpriority>() и B<getpriority>(). Обёрточные функции glibc для этих системных вызовов преобразуют значение между пользовательским и ядерным диапазонами по формуле I<unice\\ =\\ 20\\ -\\ knice> (таким образом, ядерный диапазон 40..1 соответствует диапазону -20..19, видимый в пользовательском пространстве)."

#. type: SH
#: man-pages/man2/getpriority.2:237
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man2/getpriority.2:244
msgid ""
"According to POSIX, the nice value is a per-process setting.  However, under"
" the current Linux/NPTL implementation of POSIX threads, the nice value is a"
" per-thread attribute: different threads in the same process can have "
"different nice values.  Portable applications should avoid relying on the "
"Linux behavior, which may be made standards conformant in the future."
msgstr "Согласно POSIX, значение nice — свойство процесса. Однако в текущей реализации Linux/NPTL нитей POSIX значение nice — атрибут нити: различные нити в одном процессе могут иметь разные значения nice. Переносимые приложения не должны полагаться на поведение Linux, которое может стать стандартом в будущем."

#. type: Plain text
#: man-pages/man2/getpriority.2:250
msgid "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"
msgstr "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"

#. type: Plain text
#: man-pages/man2/getpriority.2:252
msgid ""
"I<Documentation/scheduler/sched-nice-design.txt> in the Linux kernel source "
"tree (since Linux 2.6.23)"
msgstr "Файл I<Documentation/scheduler/sched-nice-design.txt> из дерева исходного кода ядра Linux (начиная с Linux 2.6.23)"

#. type: TH
#: man-pages/man2/getpeername.2:42
#, no-wrap
msgid "GETPEERNAME"
msgstr "GETPEERNAME"

#. type: Plain text
#: man-pages/man2/getpeername.2:45
msgid "getpeername - get name of connected peer socket"
msgstr "getpeername - получает имя подключившегося сокета"

#. type: Plain text
#: man-pages/man2/getpeername.2:47
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getpeername.2:50
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr "B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>"

#. type: Plain text
#: man-pages/man2/getpeername.2:63
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by I<addr>."
"  On return it contains the actual size of the name returned (in bytes).  "
"The name is truncated if the buffer provided is too small."
msgstr "B<getpeername>() возвращает адрес машины, подключившейся к сокету I<sockfd>, в буфер, указанный I<addr>. В параметре I<addrlen> должно быть указано, сколько места выделено, на которое указывает I<addr>. По возвращении он содержит реальный размер памяти, занимаемый возвращаемым именем (в байтах). Имя обрезается, если буфер окажется слишком мал."

#. type: Plain text
#: man-pages/man2/getpeername.2:68
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr "Возвращаемый адрес урежется, если предоставленный буфер окажется слишком маленьким; в этом случае в I<addrlen> будет возвращено значение большее чем было в вызове."

#. type: Plain text
#: man-pages/man2/getpeername.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/getpeername.2:74
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/getpeername.2:79
msgid "The argument I<sockfd> is not a valid file descriptor."
msgstr "Аргумент I<sockfd> не является допустимым файловым дескриптором."

#. type: TP
#: man-pages/man2/getpeername.2:79
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/getpeername.2:85
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr "Аргумент I<addr> указывает на память в недопустимой части адресуемого пространства процесса."

#. type: Plain text
#: man-pages/man2/getpeername.2:89
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr "Неправильное значение аргумента I<addrlen> (например, отрицательное)."

#. type: TP
#: man-pages/man2/getpeername.2:89
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: man-pages/man2/getpeername.2:93
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr "Недостаточно ресурсов в системе для выполнения операции."

#. type: TP
#: man-pages/man2/getpeername.2:93
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man2/getpeername.2:96
msgid "The socket is not connected."
msgstr "Сокет не подключён."

#. type: TP
#: man-pages/man2/getpeername.2:96
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man2/getpeername.2:101
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr "Файловый дескриптор I<sockfd> указывает не на каталог."

#. type: Plain text
#: man-pages/man2/getpeername.2:105
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getpeername>()  first appeared "
"in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (B<getpeername>() впервые появился в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/getpeername.2:110
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr "Описание типа I<socklen_t> смотрите в B<accept>(2)."

#. type: Plain text
#: man-pages/man2/getpeername.2:137
msgid ""
"For stream sockets, once a B<connect>(2)  has been performed, either socket "
"can call B<getpeername>()  to obtain the address of the peer socket.  On the"
" other hand, datagram sockets are connectionless.  Calling B<connect>(2)  on"
" a datagram socket merely sets the peer address for outgoing datagrams sent "
"with B<write>(2)  or B<recv>(2).  The caller of B<connect>(2)  can use "
"B<getpeername>()  to obtain the peer address that it earlier set for the "
"socket.  However, the peer socket is unaware of this information, and "
"calling B<getpeername>()  on the peer socket will return no useful "
"information (unless a B<connect>(2)  call was also executed on the peer).  "
"Note also that the receiver of a datagram can obtain the address of the "
"sender when using B<recvfrom>(2)."
msgstr "Для потоковых сокетов после выполнения B<connect>(2) любой сокет может вызвать B<getpeername>() для получения адреса соседа (peer). С другой стороны, дейтаграмные сокеты не устанавливают соединения. Вызов B<connect>(2) для дейтаграмного сокета просто задаст адрес соседа в исходящих дейтаграммах, посылаемых с помощью B<write>(2) или B<recv>(2). Вызывающий B<connect>(2) может использовать B<getpeername>() для получения адреса соседа., который был установлен у сокета ранее. Однако, сокет соседа не знает про это и  вызов B<getpeername>() для сокета соседа не вернёт полезной информации (если сосед также не вызвал B<connect>(2)). Заметим, что получатель дейтаграммы может получить адрес отправителя, если использует B<recvfrom>(2)."

#. type: Plain text
#: man-pages/man2/getpeername.2:143
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr "B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/getgid.2:25
#, no-wrap
msgid "GETGID"
msgstr "GETGID"

#. type: Plain text
#: man-pages/man2/getgid.2:28
msgid "getgid, getegid - get group identity"
msgstr "getgid, getegid - получить идентификатор группы процесса"

#. type: Plain text
#: man-pages/man2/getgid.2:34
msgid "B<gid_t getgid(void);>"
msgstr "B<gid_t getgid(void);>"

#. type: Plain text
#: man-pages/man2/getgid.2:36
msgid "B<gid_t getegid(void);>"
msgstr "B<gid_t getegid(void);>"

#. type: Plain text
#: man-pages/man2/getgid.2:39
msgid "B<getgid>()  returns the real group ID of the calling process."
msgstr "B<getgid>() возвращает действительный идентификатор группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getgid.2:42
msgid "B<getegid>()  returns the effective group ID of the calling process."
msgstr "B<getegid>() возвращает эффективный идентификатор группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getgid.2:46
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: man-pages/man2/getgid.2:62
msgid ""
"The original Linux B<getgid>()  and B<getegid>()  system calls supported "
"only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
"B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and "
"B<getegid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr "Первоначальные версии системных вызовов B<getgid>() и B<getegid>() в Linux поддерживали только 16-битные идентификаторы групп. Позднее в Linux 2.4 были добавлены вызовы B<getgid32>() и B<getegid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<getgid>() и B<getegid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getgid.2:78
msgid ""
"On Alpha, instead of a pair of B<getgid>()  and B<getegid>()  system calls, "
"a single B<getxgid>()  system call is provided, which returns a pair of real"
" and effective GIDs.  The glibc B<getgid>()  and B<getegid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr "На Alpha вместо пары системных вызовов B<getgid>() и B<getegid>() предоставляется один B<getxgid>(), который возвращает пару реальный и эффективный GID. Обёрточные функции glibc B<getgid>() и B<getegid>() скрывают это. Подробности об отображении регистров смотрите в B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/getgid.2:82
msgid "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"
msgstr "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/getdents.2:31
#, no-wrap
msgid "GETDENTS"
msgstr "GETDENTS"

#. type: Plain text
#: man-pages/man2/getdents.2:34
msgid "getdents, getdents64 - get directory entries"
msgstr "getdents, getdents64 - возвращает записи каталога"

#. type: Plain text
#: man-pages/man2/getdents.2:40
#, no-wrap
msgid ""
"B<int getdents(unsigned int >I<fd>B<, struct linux_dirent *>I<dirp>B<,>\n"
"B<             unsigned int >I<count>B<);>\n"
"B<int getdents64(unsigned int >I<fd>B<, struct linux_dirent64 *>I<dirp>B<,>\n"
"B<             unsigned int >I<count>B<);>\n"
msgstr "B<int getdents(unsigned int >I<fd>B<, struct linux_dirent *>I<dirp>B<,>\nB<             unsigned int >I<count>B<);>\nB<int getdents64(unsigned int >I<fd>B<, struct linux_dirent64 *>I<dirp>B<,>\nB<             unsigned int >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man2/getdents.2:44
msgid ""
"I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr "I<Замечание>: В glibc нет обёрточных функций для этих системных вызовов; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/getdents.2:50
msgid ""
"These are not the interfaces you are interested in.  Look at B<readdir>(3)  "
"for the POSIX-conforming C library interface.  This page documents the bare "
"kernel system call interfaces."
msgstr "Это не те функции, которые должны представлять для вас интерес. Смотрите описание функции B<readdir>(3), которая является интерфейсом библиотеки языка C, соответствующим стандарту POSIX. В этой странице описаны минимальные интерфейсы системных вызовов ядра."

#. type: SS
#: man-pages/man2/getdents.2:50
#, no-wrap
msgid "getdents()"
msgstr "getdents()"

#. type: Plain text
#: man-pages/man2/getdents.2:63
msgid ""
"The system call B<getdents>()  reads several I<linux_dirent> structures from"
" the directory referred to by the open file descriptor I<fd> into the buffer"
" pointed to by I<dirp>.  The argument I<count> specifies the size of that "
"buffer."
msgstr "Системный вызов B<getdents>() читает несколько структур I<linux_dirent> из каталога, на который указывает открытый файловый дескриптор I<fd>, в буфер, указанный в I<dirp>. В аргументе I<count> задаётся размер этого буфера."

#. type: Plain text
#: man-pages/man2/getdents.2:67
msgid "The I<linux_dirent> structure is declared as follows:"
msgstr "Структура I<linux_dirent> определена следующим образом:"

#. type: Plain text
#: man-pages/man2/getdents.2:83
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    unsigned long  d_ino;     /* Inode number */\n"
"    unsigned long  d_off;     /* Offset to next I<linux_dirent> */\n"
"    unsigned short d_reclen;  /* Length of this I<linux_dirent> */\n"
"    char           d_name[];  /* Filename (null-terminated) */\n"
"                      /* length is actually (d_reclen - 2 -\n"
"                         offsetof(struct linux_dirent, d_name)) */\n"
"    /*\n"
"    char           pad;       // Zero padding byte\n"
"    char           d_type;    // File type (only since Linux\n"
"                              // 2.6.4); offset is (d_reclen - 1)\n"
"    */\n"
"}\n"
msgstr "struct linux_dirent {\n    unsigned long  d_ino;     /* номер иноды */\n    unsigned long  d_off;     /* смещение до следующей I<linux_dirent> */\n    unsigned short d_reclen;  /* длина этой I<linux_dirent> */\n    char           d_name[];  /* имя файла (в конце null) */\n                      /* реальная длина (d_reclen - 2 -\n                         offsetof(struct linux_dirent, d_name)) */\n    /*\n    char           pad;       // нулевой байт заполнения\n    char           d_type;    // тип файла (только начиная с Linux\n                              // 2.6.4); смещение (d_reclen - 1)\n    */\n}\n"

#. type: Plain text
#: man-pages/man2/getdents.2:96
msgid ""
"I<d_ino> is an inode number.  I<d_off> is the distance from the start of the"
" directory to the start of the next I<linux_dirent>.  I<d_reclen> is the "
"size of this entire I<linux_dirent>.  I<d_name> is a null-terminated "
"filename."
msgstr "В I<d_ino> указан номер inode. В I<d_off> задаётся расстояние от начала каталога до начала следующей I<linux_dirent>. В I<d_reclen> указывается размер данного I<linux_dirent> целиком. В I<d_name> задаётся имя файла, завершающееся null."

#. type: Plain text
#: man-pages/man2/getdents.2:101
msgid ""
"I<d_type> is a byte at the end of the structure that indicates the file "
"type.  It contains one of the following values (defined in "
"I<E<lt>dirent.hE<gt>>):"
msgstr "I<d_type> \\(em байт в конце структуры, которым определяется тип файла. В нём содержится одно из следующих значений (определённых в I<E<lt>dirent.hE<gt>>):"

#. type: TP
#: man-pages/man2/getdents.2:101
#, no-wrap
msgid "B<DT_BLK>"
msgstr "B<DT_BLK>"

#. type: Plain text
#: man-pages/man2/getdents.2:104
msgid "This is a block device."
msgstr "Блочное устройство."

#. type: TP
#: man-pages/man2/getdents.2:104
#, no-wrap
msgid "B<DT_CHR>"
msgstr "B<DT_CHR>"

#. type: Plain text
#: man-pages/man2/getdents.2:107
msgid "This is a character device."
msgstr "Символьное устройство."

#. type: TP
#: man-pages/man2/getdents.2:107
#, no-wrap
msgid "B<DT_DIR>"
msgstr "B<DT_DIR>"

#. type: Plain text
#: man-pages/man2/getdents.2:110
msgid "This is a directory."
msgstr "Каталог."

#. type: TP
#: man-pages/man2/getdents.2:110
#, no-wrap
msgid "B<DT_FIFO>"
msgstr "B<DT_FIFO>"

#. type: Plain text
#: man-pages/man2/getdents.2:113
msgid "This is a named pipe (FIFO)."
msgstr "Именованный канал (FIFO)."

#. type: TP
#: man-pages/man2/getdents.2:113
#, no-wrap
msgid "B<DT_LNK>"
msgstr "B<DT_LNK>"

#. type: Plain text
#: man-pages/man2/getdents.2:116
msgid "This is a symbolic link."
msgstr "Символическая ссылка."

#. type: TP
#: man-pages/man2/getdents.2:116
#, no-wrap
msgid "B<DT_REG>"
msgstr "B<DT_REG>"

#. type: Plain text
#: man-pages/man2/getdents.2:119
msgid "This is a regular file."
msgstr "Обычный файл."

#. type: TP
#: man-pages/man2/getdents.2:119
#, no-wrap
msgid "B<DT_SOCK>"
msgstr "B<DT_SOCK>"

#. type: Plain text
#: man-pages/man2/getdents.2:122
msgid "This is a UNIX domain socket."
msgstr "Доменный сокет UNIX."

#. type: TP
#: man-pages/man2/getdents.2:122
#, no-wrap
msgid "B<DT_UNKNOWN>"
msgstr "B<DT_UNKNOWN>"

#. type: Plain text
#: man-pages/man2/getdents.2:125
msgid "The file type is unknown."
msgstr "Неизвестный тип."

#. type: Plain text
#: man-pages/man2/getdents.2:135
msgid ""
"The I<d_type> field is implemented since Linux 2.6.4.  It occupies a space "
"that was previously a zero-filled padding byte in the I<linux_dirent> "
"structure.  Thus, on kernels up to and including 2.6.3, attempting to access"
" this field always provides the value 0 (B<DT_UNKNOWN>)."
msgstr "Поле I<d_type> появилось начиная с Linux 2.6.4. Оно занимает пространство, которое раньше в структуре I<linux_dirent> было отведено для заполняющего байта с нулевым значением. Поэтому при работе с ядрами до версии 2.6.3 включительно при чтении значения этого поля всегда возвращается 0 (B<DT_UNKNOWN>)."

#.  kernel 2.6.27
#.  The same sentence is in readdir.2
#. type: Plain text
#: man-pages/man2/getdents.2:144
msgid ""
"Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4)  "
"have full support for returning the file type in I<d_type>.  All "
"applications must properly handle a return of B<DT_UNKNOWN>."
msgstr "В настоящее время, только файловые системы (среди которых: Btrfs, ext2, ext3 и ext4) поддерживают возврат типа файла в I<d_type>. Все приложения должны правильно обрабатывать возвращаемое значение B<DT_UNKNOWN>."

#. type: SS
#: man-pages/man2/getdents.2:144
#, no-wrap
msgid "getdents64()"
msgstr "getdents64()"

#. type: Plain text
#: man-pages/man2/getdents.2:160
msgid ""
"The original Linux B<getdents>()  system call did not handle large "
"filesystems and large file offsets.  Consequently, Linux 2.4 added "
"B<getdents64>(), with wider types for the I<d_ino> and I<d_off> fields.  In "
"addition, B<getdents64>()  supports an explicit I<d_type> field."
msgstr "Первоначальный системный вызов Linux B<getdents>() не работал с файловыми системами большого размера и большими смещениями файлов. В связи с этим, в Linux 2.4 была добавлен B<getdents64>(), с более широкими типами полей I<d_ino> и I<d_off>. Также B<getdents64>() поддерживает явно указанное поле I<d_type>."

#. type: Plain text
#: man-pages/man2/getdents.2:167
msgid ""
"The B<getdents64>()  system call is like B<getdents>(), except that its "
"second argument is a pointer to a buffer containing structures of the "
"following type:"
msgstr "Системный вызов B<getdents64>() подобен B<getdents>(), за исключением того, что второй аргумент является указателем на буфер, содержащий структуры следующего типа:"

#. type: Plain text
#: man-pages/man2/getdents.2:177
#, no-wrap
msgid ""
"struct linux_dirent64 {\n"
"    ino64_t        d_ino;    /* 64-bit inode number */\n"
"    off64_t        d_off;    /* 64-bit offset to next structure */\n"
"    unsigned short d_reclen; /* Size of this dirent */\n"
"    unsigned char  d_type;   /* File type */\n"
"    char           d_name[]; /* Filename (null-terminated) */\n"
"};\n"
msgstr "struct linux_dirent64 {\n    ino64_t        d_ino;    /* 64-битный номер иноды */\n    off64_t        d_off;    /* 64-битное смещение следующей структуры */\n    unsigned short d_reclen; /* размер этой dirent */\n    unsigned char  d_type;   /* тип файла */\n    char           d_name[]; /* имя файла (в конце null) */\n};\n"

#. type: Plain text
#: man-pages/man2/getdents.2:185
msgid ""
"On success, the number of bytes read is returned.  On end of directory, 0 is"
" returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При нормальном завершении работы возвращается количество прочитанных байт. При достижении конца каталога возвращается 0. В случае ошибки возвращается -1 и значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/getdents.2:190
msgid "Invalid file descriptor I<fd>."
msgstr "Неверный файловый дескриптор I<fd>."

#. type: Plain text
#: man-pages/man2/getdents.2:193
msgid "Argument points outside the calling process's address space."
msgstr "Аргумент указывает за пределы адресного пространства вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getdents.2:196
msgid "Result buffer is too small."
msgstr "Буфер результата слишком мал."

#. type: TP
#: man-pages/man2/getdents.2:196
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/getdents.2:199
msgid "No such directory."
msgstr "Заданный каталог не существует."

#. type: TP
#: man-pages/man2/getdents.2:199
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/getdents.2:202
msgid "File descriptor does not refer to a directory."
msgstr "Файловый дескриптор указывает не на каталог."

#.  SVr4 documents additional ENOLINK, EIO error conditions.
#. type: Plain text
#: man-pages/man2/getdents.2:205
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man2/getdents.2:216
msgid ""
"Glibc does not provide a wrapper for these system calls; call them using "
"B<syscall>(2).  You will need to define the I<linux_dirent> or "
"I<linux_dirent64> structure yourself.  However, you probably want to use "
"B<readdir>(3)  instead."
msgstr "В glibc нет обёртки для данных системных вызовов; запускайте их с помощью B<syscall>(2). Структуру I<linux_dirent> или I<linux_dirent64> нужно определить самостоятельно. Однако лучше использовать B<readdir>(3)."

#. type: Plain text
#: man-pages/man2/getdents.2:219
msgid "These calls supersede B<readdir>(2)."
msgstr "Данные системные вызовы заместил B<readdir>(2)."

#. type: SH
#: man-pages/man2/getdents.2:219
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#.  FIXME The example program needs to be revised, since it uses the older
#.  getdents() system call and the structure with smaller field widths.
#. type: Plain text
#: man-pages/man2/getdents.2:226
msgid ""
"The program below demonstrates the use of B<getdents>().  The following "
"output shows an example of what we see when running this program on an ext2 "
"directory:"
msgstr "В программе, показанной далее, демонстрируется использование B<getdents>(). В следующем выводе показан пример запуска этой программы с каталогом с ext2:"

#. type: Plain text
#: man-pages/man2/getdents.2:239
#, no-wrap
msgid ""
"$B< ./a.out /testfs/>\n"
"--------------- nread=120 ---------------\n"
"inode#    file type  d_reclen  d_off   d_name\n"
"       2  directory    16         12  .\n"
"       2  directory    16         24  ..\n"
"      11  directory    24         44  lost+found\n"
"      12  regular      16         56  a\n"
"  228929  directory    16         68  sub\n"
"   16353  directory    16         80  sub2\n"
"  130817  directory    16       4096  sub3\n"
msgstr "$B< ./a.out /testfs/>\n--------------- nread=120 ---------------\ninode#    file type  d_reclen  d_off   d_name\n       2  directory    16         12  .\n       2  directory    16         24  ..\n      11  directory    24         44  lost+found\n      12  regular      16         56  a\n  228929  directory    16         68  sub\n   16353  directory    16         80  sub2\n  130817  directory    16       4096  sub3\n"

#. type: SS
#: man-pages/man2/getdents.2:241
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/getdents.2:252
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>dirent.hE<gt>     /* Defines DT_* constants */\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>dirent.hE<gt>     /* Определяет константы DT_* */\n#include E<lt>fcntl.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>sys/stat.hE<gt>\n#include E<lt>sys/syscall.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/getdents.2:255
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr "#define handle_error(msg) \\e\n        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man2/getdents.2:262
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    long           d_ino;\n"
"    off_t          d_off;\n"
"    unsigned short d_reclen;\n"
"    char           d_name[];\n"
"};\n"
msgstr "struct linux_dirent {\n    long           d_ino;\n    off_t          d_off;\n    unsigned short d_reclen;\n    char           d_name[];\n};\n"

#. type: Plain text
#: man-pages/man2/getdents.2:264
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: man-pages/man2/getdents.2:273
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd, nread;\n"
"    char buf[BUF_SIZE];\n"
"    struct linux_dirent *d;\n"
"    int bpos;\n"
"    char d_type;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int fd, nread;\n    char buf[BUF_SIZE];\n    struct linux_dirent *d;\n    int bpos;\n    char d_type;\n"

#. type: Plain text
#: man-pages/man2/getdents.2:277
#, no-wrap
msgid ""
"    fd = open(argc E<gt> 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr "    fd = open(argc E<gt> 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);\n    if (fd == -1)\n        handle_error(\"open\");\n"

#. type: Plain text
#: man-pages/man2/getdents.2:282
#, no-wrap
msgid ""
"    for ( ; ; ) {\n"
"        nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);\n"
"        if (nread == -1)\n"
"            handle_error(\"getdents\");\n"
msgstr "    for ( ; ; ) {\n        nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);\n        if (nread == -1)\n            handle_error(\"getdents\");\n"

#. type: Plain text
#: man-pages/man2/getdents.2:285
#, no-wrap
msgid ""
"        if (nread == 0)\n"
"            break;\n"
msgstr "        if (nread == 0)\n            break;\n"

#. type: Plain text
#: man-pages/man2/getdents.2:304
#, no-wrap
msgid ""
"        printf(\"--------------- nread=%d ---------------\\en\", nread);\n"
"        printf(\"inode#    file type  d_reclen  d_off   d_name\\en\");\n"
"        for (bpos = 0; bpos E<lt> nread;) {\n"
"            d = (struct linux_dirent *) (buf + bpos);\n"
"            printf(\"%8ld  \", d-E<gt>d_ino);\n"
"            d_type = *(buf + bpos + d-E<gt>d_reclen - 1);\n"
"            printf(\"%-10s \", (d_type == DT_REG) ?  \"regular\" :\n"
"                             (d_type == DT_DIR) ?  \"directory\" :\n"
"                             (d_type == DT_FIFO) ? \"FIFO\" :\n"
"                             (d_type == DT_SOCK) ? \"socket\" :\n"
"                             (d_type == DT_LNK) ?  \"symlink\" :\n"
"                             (d_type == DT_BLK) ?  \"block dev\" :\n"
"                             (d_type == DT_CHR) ?  \"char dev\" : \"???\");\n"
"            printf(\"%4d %10lld  %s\\en\", d-E<gt>d_reclen,\n"
"                    (long long) d-E<gt>d_off, d-E<gt>d_name);\n"
"            bpos += d-E<gt>d_reclen;\n"
"        }\n"
"    }\n"
msgstr "        printf(\"--------------- nread=%d ---------------\\en\", nread);\n        printf(\"inode#    file type  d_reclen  d_off   d_name\\en\");\n        for (bpos = 0; bpos E<lt> nread;) {\n            d = (struct linux_dirent *) (buf + bpos);\n            printf(\"%8ld  \", d-E<gt>d_ino);\n            d_type = *(buf + bpos + d-E<gt>d_reclen - 1);\n            printf(\"%-10s \", (d_type == DT_REG) ?  \"regular\" :\n                             (d_type == DT_DIR) ?  \"directory\" :\n                             (d_type == DT_FIFO) ? \"FIFO\" :\n                             (d_type == DT_SOCK) ? \"socket\" :\n                             (d_type == DT_LNK) ?  \"symlink\" :\n                             (d_type == DT_BLK) ?  \"block dev\" :\n                             (d_type == DT_CHR) ?  \"char dev\" : \"???\");\n            printf(\"%4d %10lld  %s\\en\", d-E<gt>d_reclen,\n                    (long long) d-E<gt>d_off, d-E<gt>d_name);\n            bpos += d-E<gt>d_reclen;\n        }\n    }\n"

#. type: Plain text
#: man-pages/man2/getdents.2:307
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/getdents.2:311
msgid "B<readdir>(2), B<readdir>(3), B<inode>(7)"
msgstr "B<readdir>(2), B<readdir>(3), B<inode>(7)"

#. type: TH
#: man-pages/man2/getsockopt.2:44
#, no-wrap
msgid "GETSOCKOPT"
msgstr "GETSOCKOPT"

#. type: Plain text
#: man-pages/man2/getsockopt.2:47
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr "getsockopt, setsockopt - получить или установить флаги сокета"

#. type: Plain text
#: man-pages/man2/getsockopt.2:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>          /* смотрите ЗАМЕЧАНИЯ */\nB<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getsockopt.2:56
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr "B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\nB<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\nB<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\nB<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/getsockopt.2:66
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple"
" protocol levels; they are always present at the uppermost socket level."
msgstr "B<getsockopt>() и B<setsockopt>() управляют параметрами сокета, на который указывает файловый дескриптор I<sockfd>. Параметры могут быть из различных уровней протоколов; они всегда присутствуют на самом верхнем уровне сокета."

#. type: Plain text
#: man-pages/man2/getsockopt.2:85
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option"
" is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr "При работе с параметрами сокета должен быть указан уровень, на котором находится этот параметр и его имя. Для работы с параметрами на уровне API сокета в I<level> указывается значение B<SOL_SOCKET>. Для работы с параметрами на любом другом уровне, этим вызовам передаётся номер соответствующего протокола, который они контролируют. Например, для указания, что параметр должен интерпретироваться протоколом B<TCP>, в I<level> нужно указать номер протокола B<TCP>; смотрите B<getprotoent>(3)."

#. type: Plain text
#: man-pages/man2/getsockopt.2:107
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr "Аргументы I<optval> и I<optlen> используются в B<setsockopt>() для доступа к значениям параметров. Для B<getsockopt>() они задают буфер, в который нужно поместить запрошенное значение параметра при возврате. У B<getsockopt>() в аргументе I<optlen> изначально содержится размер буфера, на который указывает I<optval>, а при завершении в нём содержится реальный размер возвращаемого значения. Если значение параметра не указывается или возвращается, то I<optval> может быть NULL."

#. type: Plain text
#: man-pages/man2/getsockopt.2:117
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file "
"I<E<lt>sys/socket.hE<gt>> contains definitions for socket level options, "
"described below.  Options at other protocol levels vary in format and name; "
"consult the appropriate entries in section 4 of the manual."
msgstr "Аргумент I<optname> и все указанные параметры без изменений передаются для интерпретации соответствующему модулю протоколов. Файл I<E<lt>sys/socket.hE<gt>> содержит определения параметров уровня сокета; их описание дано ниже. Параметры на других уровнях протоколов различаются по формату и по имени. Обращайтесь к соответствующим файлам раздела 4 справочных страниц."

#. type: Plain text
#: man-pages/man2/getsockopt.2:126
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr "Большинство параметров уровня сокета используют тип I<int> для аргумента I<optval>. Чтобы установить параметр логического типа аргумент B<setsockopt>() должен быть ненулевым, и ноль, если нужно отключить этот параметр."

#. type: Plain text
#: man-pages/man2/getsockopt.2:130
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr "Описание доступных параметров сокетов находится в B<socket>(7) и соответствующих протоколам справочных страницах."

#. type: Plain text
#: man-pages/man2/getsockopt.2:135
msgid ""
"On success, zero is returned for the standard options.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении при стандартных параметрах возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getsockopt.2:139
msgid ""
"Netfilter allows the programmer to define custom socket options with "
"associated handlers; for such options, the return value on success is the "
"value returned by the handler."
msgstr "Netfilter позволяет программисту определять собственные параметры сокетов со привязанными обработчиками; для таких параметров при успешном выполнении возвращается значение, полученное от обработчика."

#. type: Plain text
#: man-pages/man2/getsockopt.2:155
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr "Адрес, на который указывает I<optval>, не находится в разрешённой части адресного пространства процесса. Для B<getsockopt>() эта ошибка может также появиться, если I<optlen> выходит за пределы адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/getsockopt.2:166
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr "Неправильное значение I<optlen> в B<setsockopt>(). В некоторых случаях эта ошибка может возникать из-за неправильного значения в I<optval> (например, для параметра B<IP_ADD_MEMBERSHIP>, описанного в B<ip>(7))."

#. type: TP
#: man-pages/man2/getsockopt.2:166
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr "B<ENOPROTOOPT>"

#. type: Plain text
#: man-pages/man2/getsockopt.2:169
msgid "The option is unknown at the level indicated."
msgstr "Неизвестный параметр для указанного уровня."

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: man-pages/man2/getsockopt.2:181
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these system calls first appeared "
"in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (данные системные вызовы впервые появились в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/getsockopt.2:187
msgid ""
"POSIX.1 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and this"
" header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr "В POSIX.1 не требуется включение I<E<lt>sys/types.hE<gt>>, и этот заголовочный файл не требуется в Linux. Однако, для некоторых старых реализаций (BSD) требует данный файл, и в переносимых приложениях для предосторожности, вероятно, лучше его указать."

#. type: Plain text
#: man-pages/man2/getsockopt.2:195
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr "Некоторые параметры сокетов должны обрабатываться на более низких уровнях системы."

#. type: Plain text
#: man-pages/man2/getsockopt.2:205
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), "
"B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr "B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr "GETCPU"

#. type: Plain text
#: man-pages/man2/getcpu.2:15
msgid ""
"getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr "getcpu - определяет ЦП и узел NUMA, на котором выполняется вызывающая нить"

#. type: Plain text
#: man-pages/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr "B<#include E<lt>linux/getcpu.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getcpu.2:21
#, no-wrap
msgid ""
"B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache "
"*>I<tcache>B<);>\n"
msgstr "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"

#. type: Plain text
#: man-pages/man2/getcpu.2:39
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a"
" unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr "Системный вызов B<getcpu>() определяет процессор и узел, на котором вызывающая нить или процесс выполняются в данный момент и записывает их в виде целых чисел в память, на которую указывают аргументы I<cpu> и I<node>. Процессор представляется в виде уникального малого целого числа, закреплённого за определённым ЦП. Узел представляется в виде уникального идентификатора, закреплённого за определённым узлом NUMA. Если значение I<cpu> или I<node> равно NULL, то по соответствующему указателю ничего не записывается."

#. type: Plain text
#: man-pages/man2/getcpu.2:43
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr "Третий аргумент этого системного вызова в настоящее время не используется и указываться как NULL, не требуется переносимость на Linux 2.6.23 или более младшие версии (смотрите ЗАМЕЧАНИЯ)."

#. type: Plain text
#: man-pages/man2/getcpu.2:58
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr "Информация, помещаемая в I<cpu>, будет находиться там только на время вызова: unless the CPU affinity has been fixed using B<sched_setaffinity>(2), the kernel might change the CPU at any time.  (Normally this does not happen because the scheduler tries to minimize movements between CPUs to keep caches hot, but it is possible.) Достоверность информации, помещаемой в I<cpu>, гарантируется только на момент  вызова: если привязка ЦП не была изменена с помощью B<sched_setaffinity>(2), то ядро может сменить ЦП в любой момент (обычно этого не происходит, так как планировщик пытается минимизировать перемещения задач между процессорами для поддержания актуальности кэша,но всё же это возможно). Вызывающий должен быть готов к ситуации, что информация, возвращённая в I<cpu> и I<node>, может потерять актуальность уже после возврата из вызова."

#. type: Plain text
#: man-pages/man2/getcpu.2:63
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getcpu.2:67
msgid "Arguments point outside the calling process's address space."
msgstr "Аргументы указывают за пределы адресного пространства вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getcpu.2:74
msgid ""
"B<getcpu>()  was added in kernel 2.6.19 for x86-64 and i386.  Library "
"support was added in glibc 2.29 (Earlier glibc versions did not provide a "
"wrapper for this system call, necessitating the use of B<syscall>(2).)"
msgstr "Системный вызов B<getcpu>() добавлен в ядре 2.6.19 для x86-64 и i386. Библиотечная поддержка добавлена в glibc 2.29 (ранние версии glibc не содержали обёрточную функцию для этого вызова, нужно было использовать B<syscall>(2))."

#. type: Plain text
#: man-pages/man2/getcpu.2:77
msgid "B<getcpu>()  is Linux-specific."
msgstr "Вызов B<getcpu>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/getcpu.2:85
msgid ""
"Linux makes a best effort to make this call as fast as possible.  (On some "
"architectures, this is done via an implementation in the B<vdso>(7).)  The "
"intention of B<getcpu>()  is to allow programs to make optimizations with "
"per-CPU data or for NUMA optimization."
msgstr "Linux старается выполнить данный вызов как можно быстрее (на некоторых архитектурах это делается через реализацию в B<vdso>(7)). Предназначение B<getcpu>() — позволить программам оптимизировать обработку данных на разных ЦП или выполнить оптимизации NUMA."

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: man-pages/man2/getcpu.2:136
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if"
" this argument was non-NULL, then it specified a pointer to a caller-"
"allocated buffer in thread-local storage that was used to provide a caching "
"mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  calls,"
" at the cost that there was a very small chance that the returned "
"information would be out of date.  The caching mechanism was considered to "
"cause problems when migrating threads between CPUs, and so the argument is "
"now ignored."
msgstr "Аргумент I<tcache> не используется начиная с Linux 2.6.24. В более старых ядрах, если этот аргумент не равнялся NULL, то в нём задавался указатель на буфер, выделяемый вызывающим в локальном хранилище нити, который использовался для работы механизма кэширования B<getcpu>(). Использование кэша могло бы увеличить скорость работы B<getcpu>(), и расплатой за это было бы возникновение очень маленькой вероятности, что возвращаемая информация устарела. Кэширующий механизм стал рассматриваться как вызывающий проблемы при перемещения нитей между ЦП, и поэтому теперь этот аргумент игнорируется."

#. type: Plain text
#: man-pages/man2/getcpu.2:142
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7), B<vdso>(7)"
msgstr "B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), B<sched_getcpu>(3), B<cpuset>(7), B<vdso>(7)"

#. type: TH
#: man-pages/man2/gettid.2:26
#, no-wrap
msgid "GETTID"
msgstr "GETTID"

#. type: Plain text
#: man-pages/man2/gettid.2:29
msgid "gettid - get thread identification"
msgstr "gettid - получить идентификатор нити"

#. type: Plain text
#: man-pages/man2/gettid.2:32
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/gettid.2:34
#, no-wrap
msgid "B<pid_t gettid(void);>\n"
msgstr "B<pid_t gettid(void);>\n"

#. type: Plain text
#: man-pages/man2/gettid.2:47
msgid ""
"B<gettid>()  returns the caller's thread ID (TID).  In a single-threaded "
"process, the thread ID is equal to the process ID (PID, as returned by "
"B<getpid>(2)).  In a multithreaded process, all threads have the same PID, "
"but each one has a unique TID.  For further details, see the discussion of "
"B<CLONE_THREAD> in B<clone>(2)."
msgstr "B<gettid>() возвращает идентификатор нити вызвавшего процесса (TID). В случае процесса с одной нитью он эквивалентен идентификатору процесса (PID, возвращаемому B<getpid>(2)). В случае процесса с множеством нитей все нити имеют одинаковый идентификатор процесса PID, но каждый из них имеет уникальный идентификатор нити TID. Для получения подробной информации см. обсуждение B<CLONE_THREAD> B<clone>(2)."

#. type: Plain text
#: man-pages/man2/gettid.2:49
msgid "On success, returns the thread ID of the calling thread."
msgstr "При успешном выполнении возвращается идентификатор вызывающей нити."

#. type: Plain text
#: man-pages/man2/gettid.2:51
msgid "This call is always successful."
msgstr "Этот системный вызов всегда выполняется успешно."

#.  FIXME . See http://sourceware.org/bugzilla/show_bug.cgi?id=6399
#.  "gettid() should have a wrapper"
#. type: Plain text
#: man-pages/man2/gettid.2:61
msgid ""
"The B<gettid>()  system call first appeared on Linux in kernel 2.4.11.  "
"Library support was added in glibc 2.30.  (Earlier glibc versions did not "
"provide a wrapper for this system call, necessitating the use of "
"B<syscall>(2).)"
msgstr "Системный вызов B<gettid>() впервые появился в ядре Linux 2.4.11. Библиотечная поддержка добавлена в glibc 2.30. (ранние версии glibc не содержали обёрточную функцию для этого вызова, нужно было использовать B<syscall>(2))."

#. type: Plain text
#: man-pages/man2/gettid.2:65
msgid ""
"B<gettid>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr "Вызов B<gettid>() является специфичным для Linux и не должен использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/gettid.2:69
msgid ""
"The thread ID returned by this call is not the same thing as a POSIX thread "
"ID (i.e., the opaque value returned by B<pthread_self>(3))."
msgstr "Идентификатор нити, возвращаемый этим вызовом, не является идентификатором нити POSIX (т.е., значением с произвольной структурой, возвращаемым B<pthread_self>(3))."

#. type: Plain text
#: man-pages/man2/gettid.2:81
msgid ""
"In a new thread group created by a B<clone>(2)  call that does not specify "
"the B<CLONE_THREAD> flag (or, equivalently, a new process created by "
"B<fork>(2)), the new process is a thread group leader, and its thread group "
"ID (the value returned by B<getpid>(2))  is the same as its thread ID (the "
"value returned by B<gettid>())."
msgstr "В новой группе нитей, созданной вызовом B<clone>(2) без флага B<CLONE_THREAD> (или новый процесс, созданный B<fork>(2)), новый процесс является лидером группы нитей, и ID этой группы нитей (значение, возвращаемое B<getpid>(2)) совпадает с ID этой нити (значение, возвращаемое B<gettid>())."

#.  .BR kcmp (2),
#.  .BR move_pages (2),
#.  .BR migrate_pages (2),
#.  .BR process_vm_readv (2),
#.  .BR ptrace (2),
#. type: Plain text
#: man-pages/man2/gettid.2:99
msgid ""
"B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<getpid>(2), "
"B<get_robust_list>(2), B<ioprio_set>(2), B<perf_event_open>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<tgkill>(2), B<timer_create>(2)"
msgstr "B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<getpid>(2), B<get_robust_list>(2), B<ioprio_set>(2), B<perf_event_open>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), B<tgkill>(2), B<timer_create>(2)"

#. type: TH
#: man-pages/man2/getrandom.2:27
#, no-wrap
msgid "GETRANDOM"
msgstr "GETRANDOM"

#. type: Plain text
#: man-pages/man2/getrandom.2:30
msgid "getrandom - obtain a series of random bytes"
msgstr "getrandom - возвращает серию произвольных байт"

#. type: Plain text
#: man-pages/man2/getrandom.2:32
msgid "B<#include E<lt>sys/random.hE<gt>>"
msgstr "B<#include E<lt>sys/random.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getrandom.2:34
msgid ""
"B<ssize_t getrandom(void *>I<buf>B<, size_t >I<buflen>B<, unsigned int "
">I<flags>B<);>"
msgstr "B<ssize_t getrandom(void *>I<buf>B<, size_t >I<buflen>B<, unsigned int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man2/getrandom.2:44
msgid ""
"The B<getrandom>()  system call fills the buffer pointed to by I<buf> with "
"up to I<buflen> random bytes.  These bytes can be used to seed user-space "
"random number generators or for cryptographic purposes."
msgstr "Системный вызов B<getrandom>() заполняет буфер, указанный в I<buf>, произвольными байтами в количестве до I<buflen>. Эти байты можно использовать как начальные значения в генераторах произвольных чисел пространства пользователя или с целями шифрования."

#. type: Plain text
#: man-pages/man2/getrandom.2:55
msgid ""
"By default, B<getrandom>()  draws entropy from the I<urandom> source (i.e., "
"the same source as the I</dev/urandom> device).  This behavior can be "
"changed via the I<flags> argument."
msgstr "По умолчанию, B<getrandom>() забирает энтропию из источника I<urandom> (т. е., того же источника что и устройство I</dev/urandom>). Это поведение можно изменить через параметр I<flags>."

#. type: Plain text
#: man-pages/man2/getrandom.2:65
msgid ""
"If the I<urandom> source has been initialized, reads of up to 256 bytes will"
" always return as many bytes as requested and will not be interrupted by "
"signals.  No such guarantees apply for larger buffer sizes.  For example, if"
" the call is interrupted by a signal handler, it may return a partially "
"filled buffer, or fail with the error B<EINTR>."
msgstr "Если источник I<urandom> инициализирован, то из него можно прочитать не более 256 байт, но всегда возвращается столько байт, сколько запрошено и это не будет прерываться сигналами. Для буферов большего размера это не гарантируется. Например, если вызов прерывается обработчиком сигнала, то он может вернуть частично заполненный буфер или завершиться с ошибкой B<EINTR>."

#. type: Plain text
#: man-pages/man2/getrandom.2:74
msgid ""
"If the I<urandom> source has not yet been initialized, then B<getrandom>()  "
"will block, unless B<GRND_NONBLOCK> is specified in I<flags>."
msgstr "Если источник I<urandom> ещё не инициализирован, то вызов B<getrandom>() блокируется, если в I<flags> не указано значение B<GRND_NONBLOCK>."

#. type: Plain text
#: man-pages/man2/getrandom.2:79
msgid ""
"The I<flags> argument is a bit mask that can contain zero or more of the "
"following values ORed together:"
msgstr "Аргумент I<flags> является битовой маской, которая может содержать ноль или более следующих флагов:"

#. type: TP
#: man-pages/man2/getrandom.2:79
#, no-wrap
msgid "B<GRND_RANDOM>"
msgstr "B<GRND_RANDOM>"

#. type: Plain text
#: man-pages/man2/getrandom.2:104
msgid ""
"If this bit is set, then random bytes are drawn from the I<random> source "
"(i.e., the same source as the I</dev/random> device)  instead of the "
"I<urandom> source.  The I<random> source is limited based on the entropy "
"that can be obtained from environmental noise.  If the number of available "
"bytes in the I<random> source is less than requested in I<buflen>, the call "
"returns just the available random bytes.  If no random bytes are available, "
"the behavior depends on the presence of B<GRND_NONBLOCK> in the I<flags> "
"argument."
msgstr "Если этот бит установлен, то произвольные байты берутся из источника I<random> (т. е., того же источника что и устройство I</dev/urandom>), а не из источника I<urandom>. Ограничение источника I<random> следует из энтропии, которую можно получить из окружающего шума. Если количество доступных байт в I<random> меньше запрашиваемых в I<buflen>, то вызов завершается сразу после выдачи всех доступных произвольных байт. Если произвольных байт нет, то поведение зависит от наличия флага B<GRND_NONBLOCK> в параметре I<flags>."

#. type: TP
#: man-pages/man2/getrandom.2:104
#, no-wrap
msgid "B<GRND_NONBLOCK>"
msgstr "B<GRND_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/getrandom.2:122
msgid ""
"By default, when reading from the I<random> source, B<getrandom>()  blocks "
"if no random bytes are available, and when reading from the I<urandom> "
"source, it blocks if the entropy pool has not yet been initialized.  If the "
"B<GRND_NONBLOCK> flag is set, then B<getrandom>()  does not block in these "
"cases, but instead immediately returns -1 with I<errno> set to B<EAGAIN>."
msgstr "По умолчанию, при чтении из источника I<random> вызов B<getrandom>() блокируется, если произвольные байты недоступны, и а при чтении из источника I<urandom> блокируется, если ещё не инициализирован пул энтропии. Если указан флаг B<GRND_NONBLOCK>, то в этих случаях B<getrandom>() не блокируется, а сразу возвращает -1 и присваивает I<errno> значение B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/getrandom.2:136
msgid ""
"On success, B<getrandom>()  returns the number of bytes that were copied to "
"the buffer I<buf>.  This may be less than the number of bytes requested via "
"I<buflen> if either B<GRND_RANDOM> was specified in I<flags> and "
"insufficient entropy was present in the I<random> source or the system call "
"was interrupted by a signal."
msgstr "При успешном выполнении B<getrandom>() возвращает количество скопированных в буфер I<buf> байт. Это значение может быть меньше, чем количество запрашиваемых в I<buflen> байт, если в I<flags> был указан B<GRND_RANDOM> и нет достаточного  количества энтропии в источнике I<random>, или если системный вызов был прерван сигналом."

#. type: Plain text
#: man-pages/man2/getrandom.2:140
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "В случае ошибки возвращается -1 и значение I<errno> устанавливается соответствующим образом."

#. type: TP
#: man-pages/man2/getrandom.2:141
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/getrandom.2:148
msgid ""
"The requested entropy was not available, and B<getrandom>()  would have "
"blocked if the B<GRND_NONBLOCK> flag was not set."
msgstr "Запрошенное количество энтропии недоступно, и B<getrandom>() заблокировался бы, если бы отсутствовал флаг B<GRND_NONBLOCK>."

#. type: Plain text
#: man-pages/man2/getrandom.2:153
msgid ""
"The address referred to by I<buf> is outside the accessible address space."
msgstr "Адрес, указанный в I<buf>, лежит вне доступного адресного пространства."

#. type: TP
#: man-pages/man2/getrandom.2:153
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/getrandom.2:163
msgid ""
"The call was interrupted by a signal handler; see the description of how "
"interrupted B<read>(2)  calls on \"slow\" devices are handled with and "
"without the B<SA_RESTART> flag in the B<signal>(7)  man page."
msgstr "Вызов был прерван обработчиком сигнала; смотрите описание о прерывании вызовов B<read>(2) при работе с «медленными» устройствами и при отсутствии флага B<SA_RESTART> в справочной странице B<signal>(7)."

#. type: Plain text
#: man-pages/man2/getrandom.2:167
msgid "An invalid flag was specified in I<flags>."
msgstr "В I<flags> указан неверный флаг."

#. type: TP
#: man-pages/man2/getrandom.2:167
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/getrandom.2:172
msgid ""
"The glibc wrapper function for B<getrandom>()  determined that the "
"underlying kernel does not implement this system call."
msgstr "Обёрточная функция в glibc для B<getrandom>() определила, что используемое ядро не поддерживает данный системный вызов."

#. type: Plain text
#: man-pages/man2/getrandom.2:176
msgid ""
"B<getrandom>()  was introduced in version 3.17 of the Linux kernel.  Support"
" was added to glibc in version 2.25."
msgstr "Вызов B<getrandom>() появился в версии ядра Linux 3.17. Поддержка в glibc добавлена в версии 2.5."

#. type: Plain text
#: man-pages/man2/getrandom.2:178
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/getrandom.2:182
msgid ""
"For an overview and comparison of the various interfaces that can be used to"
" obtain randomness, see B<random>(7)."
msgstr "Обзор и сравнение возможных интерфейсов, через которые можно получать случайные данные, смотрите в B<random>(7)."

#. type: Plain text
#: man-pages/man2/getrandom.2:200
msgid ""
"Unlike I</dev/random> and I</dev/urandom>, B<getrandom>()  does not involve "
"the use of pathnames or file descriptors.  Thus, B<getrandom>()  can be "
"useful in cases where B<chroot>(2)  makes I</dev> pathnames invisible, and "
"where an application (e.g., a daemon during start-up)  closes a file "
"descriptor for one of these files that was opened by a library."
msgstr "В отличие от I</dev/random> и I</dev/urandom>, в вызове B<getrandom>() не используются пути или файловые дескрипторы. Таким образом, B<getrandom>() полезен в случаях, когда B<chroot>(2) делает пути I</dev> невидимыми и приложение (например, служба во время загрузки) закрывает файловый дескриптор одного из этих файлов, которые были открыты библиотекой."

#. type: SS
#: man-pages/man2/getrandom.2:200
#, no-wrap
msgid "Maximum number of bytes returned"
msgstr "Возвращается максимальное количество байтов"

#. type: Plain text
#: man-pages/man2/getrandom.2:202
msgid "As of Linux 3.19 the following limits apply:"
msgstr "На момент Linux 3.19 существуют следующие ограничения:"

#. type: IP
#: man-pages/man2/getrandom.2:202 man-pages/man2/getrandom.2:210
#: man-pages/man2/getrandom.2:301
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man2/getrandom.2:210
msgid ""
"When reading from the I<urandom> source, a maximum of 33554431 bytes is "
"returned by a single call to B<getrandom>()  on systems where I<int> has a "
"size of 32 bits."
msgstr "При чтении из источника I<urandom> в системах, где размер I<int> равен 32 битам, один вызов B<getrandom>() возвращает максимум 33554431 байт."

#. type: Plain text
#: man-pages/man2/getrandom.2:214
msgid ""
"When reading from the I<random> source, a maximum of 512 bytes is returned."
msgstr "При чтении из источника I<random> возвращается максимум 512 байт."

#. type: SS
#: man-pages/man2/getrandom.2:214
#, no-wrap
msgid "Interruption by a signal handler"
msgstr "Прерывание обработчиком сигнала"

#. type: Plain text
#: man-pages/man2/getrandom.2:240
msgid ""
"When reading from the I<urandom> source (B<GRND_RANDOM> is not set), "
"B<getrandom>()  will block until the entropy pool has been initialized "
"(unless the B<GRND_NONBLOCK> flag was specified).  If a request is made to "
"read a large number of bytes (more than 256), B<getrandom>()  will block "
"until those bytes have been generated and transferred from kernel memory to "
"I<buf>.  When reading from the I<random> source (B<GRND_RANDOM> is set), "
"B<getrandom>()  will block until some random bytes become available (unless "
"the B<GRND_NONBLOCK> flag was specified)."
msgstr "При чтении из источника I<urandom> (B<GRND_RANDOM> не указан), B<getrandom>() блокируется до тех пор, пока не специализируется пул энтропии (если не указан флаг B<GRND_NONBLOCK>). Если запрос требует большого количества байт (больше 256), B<getrandom>() будет заблокирован до тех пор, пока байты не будут сгенерированы и переданы из памяти ядра в I<buf>. При чтении из I<random> (указан B<GRND_RANDOM>), B<getrandom>() будет заблокирован до тех пор, пока какое-то количество произвольных байт не станет доступно (если не указан флаг B<GRND_NONBLOCK>)."

#. type: Plain text
#: man-pages/man2/getrandom.2:265
msgid ""
"The behavior when a call to B<getrandom>()  that is blocked while reading "
"from the I<urandom> source is interrupted by a signal handler depends on the"
" initialization state of the entropy buffer and on the request size, "
"I<buflen>.  If the entropy is not yet initialized, then the call fails with "
"the B<EINTR> error.  If the entropy pool has been initialized and the "
"request size is large (I<buflen>\\ E<gt>\\ 256), the call either succeeds, "
"returning a partially filled buffer, or fails with the error B<EINTR>.  If "
"the entropy pool has been initialized and the request size is small "
"(I<buflen>\\ E<lt>=\\ 256), then B<getrandom>()  will not fail with "
"B<EINTR>.  Instead, it will return all of the bytes that have been "
"requested."
msgstr "Поведение при прерывании обработчиком сигнала вызова B<getrandom>(), заблокированного чтением источника I<urandom>, зависит от состояния инициализации буфера энтропии и от запрашиваемого объёма I<buflen>. Если энтропия ещё не инициализирована, то вызов завершается ошибкой B<EINTR>. Если пул энтропии инициализирован и запрашиваемый объём большой (I<buflen>\\ E<gt>\\ 256), то вызов или завершится успешно, вернув частично заполненный буфер, или завершится с ошибкой B<EINTR>. Если пул энтропии инициализирован и запрашиваемый объём мал (I<buflen>\\ E<lt>=\\ 256), то B<getrandom>() завершится без ошибки B<EINTR>. Вместо этого, он вернёт все запрашиваемый байты."

#. type: Plain text
#: man-pages/man2/getrandom.2:271
msgid ""
"When reading from the I<random> source, blocking requests of any size can be"
" interrupted by a signal handler (the call fails with the error B<EINTR>)."
msgstr "При чтении из источника I<random> блокирующие запросы на любой объём могут быть прерваны обработчиком сигналом (вызов завершается с ошибкой B<EINTR>)."

#. type: Plain text
#: man-pages/man2/getrandom.2:277
msgid ""
"Using B<getrandom>()  to read small buffers (E<lt>=\\ 256 bytes) from the "
"I<urandom> source is the preferred mode of usage."
msgstr "Использование B<getrandom>() для чтения маленьких буферов (E<lt>=\\ 256 байт) из источника I<urandom> — предпочтительный способ использования."

#. type: Plain text
#: man-pages/man2/getrandom.2:284
msgid ""
"The special treatment of small values of I<buflen> was designed for "
"compatibility with OpenBSD's B<getentropy>(3), which is nowadays supported "
"by glibc."
msgstr "Специальный режим для маленького объёма I<buflen> был разработан для совместимости с системным вызовом B<getentropy>(3) из OpenBSD, который теперь поддерживается glibc."

#. type: Plain text
#: man-pages/man2/getrandom.2:298
msgid ""
"The user of B<getrandom>()  I<must> always check the return value, to "
"determine whether either an error occurred or fewer bytes than requested "
"were returned.  In the case where B<GRND_RANDOM> is not specified and "
"I<buflen> is less than or equal to 256, a return of fewer bytes than "
"requested should never happen, but the careful programmer will check for "
"this anyway!"
msgstr "Пользователь B<getrandom>() всегда I<должен> проверять возвращаемое значение, чтобы определить что возникла ошибка или возвращено меньшее количество запрошенных байт. В случае когда флаг B<GRND_RANDOM> не указан и значение I<buflen> меньше или равно 256, возврат меньшего количества байт чем запрошено никогда не происходит, но осторожный программист всегда проверяет значение!"

#.  FIXME patch proposed https://lkml.org/lkml/2014/11/29/16
#. type: Plain text
#: man-pages/man2/getrandom.2:301
msgid "As of Linux 3.19, the following bug exists:"
msgstr "В Linux 3.19 существуют следующие дефекты:"

#. type: Plain text
#: man-pages/man2/getrandom.2:305
msgid ""
"Depending on CPU load, B<getrandom>()  does not react to interrupts before "
"reading all bytes requested."
msgstr "В зависимости от загруженности ЦП, B<getrandom>() не реагирует на прерывания, пока не прочитает все запрашиваемые байты."

#. type: Plain text
#: man-pages/man2/getrandom.2:310
msgid ""
"B<getentropy>(3), B<random>(4), B<urandom>(4), B<random>(7), B<signal>(7)"
msgstr "B<getentropy>(3), B<random>(4), B<urandom>(4), B<random>(7), B<signal>(7)"

#. type: TH
#: man-pages/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr "GETXATTR"

#. type: Plain text
#: man-pages/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr "getxattr, lgetxattr, fgetxattr - получить расширенное значение атрибута"

#. type: Plain text
#: man-pages/man2/getxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/xattr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr "B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\nB<                 void\\ *>I<value>B<, size_t >I<size>B<);>\nB<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\nB<                 void\\ *>I<value>B<, size_t >I<size>B<);>\nB<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\nB<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man2/getxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr "Расширенные атрибуты представляют собой пару I<имя>:I<значение> и связываются с записями inode (файлы, каталоги, символьные ссылки и т.п.). Они являются расширениями к обычным атрибутам, связанным со всеми записями inode в системе (например, данные B<stat>(2)). Полное описание модели расширенных атрибутов можно найти в B<xattr>(7)."

#. type: Plain text
#: man-pages/man2/getxattr.2:66
msgid ""
"B<getxattr>()  retrieves the value of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"attribute value is placed in the buffer pointed to by I<value>; I<size> "
"specifies the size of that buffer.  The return value of the call is the "
"number of bytes placed in I<value>."
msgstr "B<getxattr>() возвращает значение расширенного атрибута с именем I<name> и связанного с указанным путем I<path> в файловой системе. Значение атрибута помещается в буфер, указанный в I<value>; в I<size> задаётся размер этого буфера. В качестве возвращаемого значения вызова возвращается количество байт, помещённых в I<value>."

#. type: Plain text
#: man-pages/man2/getxattr.2:72
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr "B<lgetxattr>() идентичен B<getxattr>(), за исключением указания символьной ссылки, когда рассматривается именно ссылка, а не файл, на который она указывает."

#. type: Plain text
#: man-pages/man2/getxattr.2:82
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr "B<fgetxattr>() идентичен B<getxattr>(), только вместо I<path> берётся открытый файл, на который указывает I<fd> (возвращаемый B<open>(2))."

#. type: Plain text
#: man-pages/man2/getxattr.2:91
msgid ""
"An extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data that was assigned using "
"B<setxattr>(2)."
msgstr "Расширенный атрибут I<name> является строкой, заканчивающейся null. Имя включает префикс пространства имён; их может быть несколько, разрозненные пространства связаны с разными записями inode. Значением расширенного атрибута является произвольный кусок текстовых или двоичных данных, который был назначен с помощью B<setxattr>(2)."

#. type: Plain text
#: man-pages/man2/getxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"named extended attribute (and leave I<value> unchanged).  This can be used "
"to determine the size of the buffer that should be supplied in a subsequent "
"call.  (But, bear in mind that there is a possibility that the attribute "
"value may change between the two calls, so that it is still necessary to "
"check the return status from the second call.)"
msgstr "Если I<size> равно нулю, то эти вызовы возвращают текущий размер указанного расширенного атрибута (и не изменяют I<value>). Это можно использовать для определения размера буфера, который вместил бы всё значение, связанное с расширенным атрибутом (но учтите, есть вероятность, что значение атрибута может измениться между двумя вызовами, поэтому всё равно нужно проверять возвращаемое состояние после второго вызова)."

#. type: Plain text
#: man-pages/man2/getxattr.2:110
msgid ""
"On success, these calls return a nonnegative value which is the size (in "
"bytes) of the extended attribute value.  On failure, -1 is returned and "
"I<errno> is set appropriately."
msgstr "При успешном выполнении эти вызовы возвращают неотрицательное число, обозначающее размер (в байтах) значения расширенного атрибута. При ошибке возвращается -1 и I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/getxattr.2:111
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/getxattr.2:117
msgid ""
"The size of the attribute value is larger than the maximum size allowed; the"
" attribute cannot be retrieved.  This can happen on filesystems that support"
" very large attribute values such as NFSv4, for example."
msgstr "Размер значения атрибута больше максимально разрешённого размера; атрибут невозможно считать. Это может случиться в файловых системах (например NFSv4), которые поддерживают очень большие значения атрибутов."

#. type: TP
#: man-pages/man2/getxattr.2:117
#, no-wrap
msgid "B<ENODATA>"
msgstr "B<ENODATA>"

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/getxattr.2:126
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute."
msgstr "Атрибут с таким именем не существует или процесс не имеет доступа к этому атрибуту."

#. type: TP
#: man-pages/man2/getxattr.2:126
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man2/getxattr.2:129
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled."
msgstr "Расширенные атрибуты не поддерживаются файловой системой или отключены."

#. type: TP
#: man-pages/man2/getxattr.2:129
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man2/getxattr.2:136
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr "Размер I<size> буфера I<value> слишком мал для хранения результата."

#. type: Plain text
#: man-pages/man2/getxattr.2:140
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "Также могут возникать ошибки, описанные в B<stat>(2)."

#. type: Plain text
#: man-pages/man2/getxattr.2:143
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr "Данные системные вызовы доступны в Linux начиная с ядра версии 2.4; поддержка в glibc появилась в версии 2.3."

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@computer.org >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#.  Please send any bug reports or comments to these addresses.
#. type: Plain text
#: man-pages/man2/getxattr.2:151
msgid "These system calls are Linux-specific."
msgstr "Данные системные вызовы есть только в Linux."

#. type: Plain text
#: man-pages/man2/getxattr.2:154
msgid "See B<listxattr>(2)."
msgstr "Смотрите B<listxattr>(2)."

#. type: Plain text
#: man-pages/man2/getxattr.2:163
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr "B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"

#. type: TH
#: man-pages/man2/getunwind.2:27
#, no-wrap
msgid "GETUNWIND"
msgstr "GETUNWIND"

#. type: Plain text
#: man-pages/man2/getunwind.2:30
msgid "getunwind - copy the unwind data to caller's buffer"
msgstr "getunwind - копирует раскрученные данные в буфер вызывающего"

#. type: Plain text
#: man-pages/man2/getunwind.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"
msgstr "B<#include E<lt>syscall.hE<gt>>\nB<#include E<lt>linux/unwind.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getunwind.2:36
#, no-wrap
msgid "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"
msgstr "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"

#. type: Plain text
#: man-pages/man2/getunwind.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr "I<Замечание>: в glibc нет обёрточной функции для данного системного вызова; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/getunwind.2:42
msgid "I<Note: this function is obsolete.>"
msgstr "I<Замечание: этот вызов устарел.>"

#. type: Plain text
#: man-pages/man2/getunwind.2:52
msgid ""
"The IA-64-specific B<getunwind>()  system call copies the kernel's call "
"frame unwind data into the buffer pointed to by I<buf> and returns the size "
"of the unwind data; this data describes the gate page (kernel code that is "
"mapped into user space)."
msgstr "Специальный системный вызов B<getunwind>() для IA-64 копирует раскрученные данные кадра вызова ядра в буфер, указанный в I<buf>, и возвращает размер раскрученных данных; эти данные описывают шлюзовую страницу (gate page, код ядра, который отображается в адресное пространство пользователя)."

#. type: Plain text
#: man-pages/man2/getunwind.2:64
msgid ""
"The size of the buffer I<buf> is specified in I<buf_size>.  The data is "
"copied only if I<buf_size> is greater than or equal to the size of the "
"unwind data and I<buf> is not NULL; otherwise, no data is copied, and the "
"call succeeds, returning the size that would be needed to store the unwind "
"data."
msgstr "Размер буфера I<buf> задаётся в I<buf_size>. Данные копируются только, если значение I<buf_size> больше или равно размеру раскрученных данных и значение I<buf> не равно NULL; в противном случае, данные не копируются и вызов завершается без ошибки, возвращая размер, который необходим для хранения раскрученных данных."

#. type: Plain text
#: man-pages/man2/getunwind.2:68
msgid ""
"The first part of the unwind data contains an unwind table.  The rest "
"contains the associated unwind information, in no particular order.  The "
"unwind table contains entries of the following form:"
msgstr "В начале раскрученных данных содержится таблица раскрутки. После неё хранится связанная с раскруткой информация в произвольном порядке. В таблице раскрутки содержатся записи в следующем виде:"

#. type: Plain text
#: man-pages/man2/getunwind.2:74
#, no-wrap
msgid ""
"u64 start;      (64-bit address of start of function)\n"
"u64 end;        (64-bit address of end of function)\n"
"u64 info;       (BUF-relative offset to unwind info)\n"
msgstr "u64 start;    (64-битный адрес начала функции)\nu64 end;      (64-битный адрес конца функции)\nu64 info;     (смещение относительно BUF на раскрученную информацию)\n"

#. type: Plain text
#: man-pages/man2/getunwind.2:83
msgid ""
"An entry whose I<start> value is zero indicates the end of the table.  For "
"more information about the format, see the I<IA-64 Software Conventions and "
"Runtime Architecture> manual."
msgstr "Запись, у которой значение I<start> равно нулю, указывает на конец таблицы. Подробности формата смотрите в руководстве I<IA-64 Software Conventions and Runtime Architecture>."

#. type: Plain text
#: man-pages/man2/getunwind.2:90
msgid ""
"On success, B<getunwind>()  returns the size of the unwind data.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<getunwind>() возвращает размер раскрученных данных. При ошибке возвращается -1, а в I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/getunwind.2:96
msgid ""
"B<getunwind>()  fails with the error B<EFAULT> if the unwind info can't be "
"stored in the space specified by I<buf>."
msgstr "Вызов B<getunwind>() завершается с ошибкой B<EFAULT>, если раскрученную информацию невозможно сохранить в пространство, указанное I<buf>."

#. type: Plain text
#: man-pages/man2/getunwind.2:98
msgid "This system call is available since Linux 2.4."
msgstr "Данный системный вызов доступен в Linux начиная с версии 2.4."

#. type: Plain text
#: man-pages/man2/getunwind.2:101
msgid ""
"This system call is Linux-specific, and is available only on the IA-64 "
"architecture."
msgstr "Данный системный вызов есть только в Linux и доступен только на архитектуре IA-64."

#. type: Plain text
#: man-pages/man2/getunwind.2:105
msgid ""
"This system call has been deprecated.  The modern way to obtain the kernel's"
" unwind data is via the B<vdso>(7)."
msgstr "Данный системный вызов устарел. Современным способом получить раскрученные данные ядра является работа через B<vdso>(7)."

#. type: Plain text
#: man-pages/man2/getunwind.2:109
msgid ""
"Glibc does not provide a wrapper for this system call; in the unlikely event"
" that you want to call it, use B<syscall>(2)."
msgstr "В glibc нет обёрточной функции для данного системного вызова; в маловероятном случае, когда вам нужно использовать его, используйте B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/getunwind.2:110
msgid "B<getauxval>(3)"
msgstr "B<getauxval>(3)"

#. type: TH
#: man-pages/man2/getsockname.2:40
#, no-wrap
msgid "GETSOCKNAME"
msgstr "GETSOCKNAME"

#. type: Plain text
#: man-pages/man2/getsockname.2:43
msgid "getsockname - get socket name"
msgstr "getsockname - получить имя сокета"

#. type: Plain text
#: man-pages/man2/getsockname.2:46
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getsockname.2:49
#, no-wrap
msgid ""
"B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr "B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/getsockname.2:62
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr "B<getsockname>() возвращает текущий адрес, к которому привязан сокет I<sockfd>, в буфере, указываемом I<addr>. В параметре I<addrlen> должно быть указано, сколько места выделено (в байтах), на которое указывает I<addr>. При возврате в этом параметре передается реальный размер адреса сокета."

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: man-pages/man2/getsockname.2:103
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getsockname>()  first appeared "
"in 4.2BSD)."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (B<getsockname>() впервые появился в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/getsockname.2:114
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr "B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/getrlimit.2:64
#, no-wrap
msgid "GETRLIMIT"
msgstr "GETRLIMIT"

#. type: TH
#: man-pages/man2/getrlimit.2:64
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: man-pages/man2/getrlimit.2:67
msgid "getrlimit, setrlimit, prlimit - get/set resource limits"
msgstr "getrlimit, setrlimit, prlimit - считывает/устанавливает ограничения использования ресурсов"

#. type: Plain text
#: man-pages/man2/getrlimit.2:73
msgid "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"
msgstr "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:75
msgid "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"
msgstr "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:78
msgid ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"
msgstr "B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit *>I<new_limit>B<,>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:80
msgid "B< struct rlimit *>I<old_limit>B<);>"
msgstr "B< struct rlimit *>I<old_limit>B<);>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:88
msgid "B<prlimit>(): _GNU_SOURCE"
msgstr "B<prlimit>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/getrlimit.2:97
msgid ""
"The B<getrlimit>()  and B<setrlimit>()  system calls get and set resource "
"limits.  Each resource has an associated soft and hard limit, as defined by "
"the I<rlimit> structure:"
msgstr "Системные вызовы B<getrlimit>() и B<setrlimit>() получают и устанавливают ограничения использования ресурсов. Каждому ресурсу назначается мягкое и жёсткое ограничение, определяемое структурой I<rlimit>:"

#. type: Plain text
#: man-pages/man2/getrlimit.2:104
#, no-wrap
msgid ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* Soft limit */\n"
"    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */\n"
"};\n"
msgstr "struct rlimit {\n    rlim_t rlim_cur;  /* мягкое ограничение */\n    rlim_t rlim_max;  /* жёсткое ограничение (максимум для rlim_cur) */\n};\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:116
msgid ""
"The soft limit is the value that the kernel enforces for the corresponding "
"resource.  The hard limit acts as a ceiling for the soft limit: an "
"unprivileged process may set only its soft limit to a value in the range "
"from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A "
"privileged process (under Linux: one with the B<CAP_SYS_RESOURCE> capability"
" in the initial user namespace)  may make arbitrary changes to either limit "
"value."
msgstr "Мягким ограничением является значение, принудительно устанавливаемое ядром для соответствующего ресурса. Жёсткое ограничение работает как максимальное значение для мягкого ограничения: непривилегированные процессы могут определять только свои мягкие ограничения в диапазоне от 0 до жёсткого ограничения, то есть однозначно меньше жёсткого ограничения. Привилегированные процессы (в  Linux: имеющие мандат B<CAP_SYS_RESOURCE> в начальном пространстве имён пользователя) могут устанавливать произвольные значения в любых пределах."

#. type: Plain text
#: man-pages/man2/getrlimit.2:123
msgid ""
"The value B<RLIM_INFINITY> denotes no limit on a resource (both in the "
"structure returned by B<getrlimit>()  and in the structure passed to "
"B<setrlimit>())."
msgstr "Значение B<RLIM_INFINITY> означает отсутствие ограничений для ресурса (в структуре, возвращаемой B<getrlimit>() и в структуре, передаваемой в B<setrlimit>())."

#. type: Plain text
#: man-pages/man2/getrlimit.2:127
msgid "The I<resource> argument must be one of:"
msgstr "Значение I<resource> должно быть одним из:"

#. type: TP
#: man-pages/man2/getrlimit.2:127
#, no-wrap
msgid "B<RLIMIT_AS>"
msgstr "B<RLIMIT_AS>"

#.  since 2.0.27 / 2.1.12
#. type: Plain text
#: man-pages/man2/getrlimit.2:149
msgid ""
"This is the maximum size of the process's virtual memory (address space).  "
"The limit is specified in bytes, and is rounded down to the system page "
"size.  This limit affects calls to B<brk>(2), B<mmap>(2), and B<mremap>(2), "
"which fail with the error B<ENOMEM> upon exceeding this limit.  In addition,"
" automatic stack expansion fails (and generates a B<SIGSEGV> that kills the "
"process if no alternate stack has been made available via "
"B<sigaltstack>(2)).  Since the value is a I<long>, on machines with a 32-bit"
" I<long> either this limit is at most 2\\ GiB, or this resource is "
"unlimited."
msgstr "Максимальный размер виртуальной памяти (адресного пространства) процесса. Данное ограничение задаётся в байтах и округляется в меньшую сторону к размеру системной страницы. Учитывается в вызовах B<brk>(2), B<mmap>(2) и B<mremap>(2), которые завершатся с ошибкой B<ENOMEM>, если будет превышено это ограничение. К тому же завершается ошибкой автоматическое расширение стека (и генерируется сигнал B<SIGSEGV>, по которому процесс завершится, если не было создано с помощью B<sigaltstack>(2) альтернативного стека). Так как значение имеет тип I<long>, на машинах с 32-битным I<long> максимальное значение ограничения будет около 2\\ ГиБ, или этот ресурс не ограничивается."

#. type: TP
#: man-pages/man2/getrlimit.2:149
#, no-wrap
msgid "B<RLIMIT_CORE>"
msgstr "B<RLIMIT_CORE>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:158
msgid ""
"This is the maximum size of a I<core> file (see B<core>(5))  in bytes that "
"the process may dump.  When 0 no core dump files are created.  When nonzero,"
" larger dumps are truncated to this size."
msgstr "Максимальный размер файла I<core> (смотрите B<core>(5)) в байтах, который может получиться из процесса. Если значение равно 0, то файлы core не создаются. Если значение больше нуля, то создаваемые дампы обрезаются до этого размера."

#. type: TP
#: man-pages/man2/getrlimit.2:158
#, no-wrap
msgid "B<RLIMIT_CPU>"
msgstr "B<RLIMIT_CPU>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:179
msgid ""
"This is a limit, in seconds, on the amount of CPU time that the process can "
"consume.  When the process reaches the soft limit, it is sent a B<SIGXCPU> "
"signal.  The default action for this signal is to terminate the process.  "
"However, the signal can be caught, and the handler can return control to the"
" main program.  If the process continues to consume CPU time, it will be "
"sent B<SIGXCPU> once per second until the hard limit is reached, at which "
"time it is sent B<SIGKILL>.  (This latter point describes Linux behavior.  "
"Implementations vary in how they treat processes which continue to consume "
"CPU time after reaching the soft limit.  Portable applications that need to "
"catch this signal should perform an orderly termination upon first receipt "
"of B<SIGXCPU>.)"
msgstr "Ограничение времени выполнения процесса на ЦП в секундах. Когда процесс достигает своего мягкого ограничения, то ему отправляется сигнал B<SIGX CPU>. Действием по умолчанию для этого сигнала является завершение процесса. Однако, этот сигнал может быть перехвачен, и обработчик может передать управление в основную программу. Если процесс продолжает потреблять процессорное время, то ему будет отправляться B<SIGXCPU> раз в секунду до тех пор, пока не будет достигнуто жёсткое ограничение, и тогда процессу будет послан сигнал B<SIGKILL> (последний пункт описывает поведение Linux. В разных реализациях действия над потребляющими процессорное время после прохождения мягкого ограничения процессами различаются. Переносимые приложения, где требуется перехват сигнала, должны выполнять корректное завершение процесса после первого получения B<SIGXCPU>)."

#. type: TP
#: man-pages/man2/getrlimit.2:179
#, no-wrap
msgid "B<RLIMIT_DATA>"
msgstr "B<RLIMIT_DATA>"

#.  commits 84638335900f1995495838fe1bd4870c43ec1f67
#.  ("mm: rework virtual memory accounting"),
#.  f4fcd55841fc9e46daac553b39361572453c2b88
#.  (mm: enable RLIMIT_DATA by default with workaround for valgrind).
#. type: Plain text
#: man-pages/man2/getrlimit.2:197
msgid ""
"This is the maximum size of the process's data segment (initialized data, "
"uninitialized data, and heap).  The limit is specified in bytes, and is "
"rounded down to the system page size.  This limit affects calls to "
"B<brk>(2), B<sbrk>(2), and (since Linux 4.7)  B<mmap>(2), which fail with "
"the error B<ENOMEM> upon encountering the soft limit of this resource."
msgstr "Максимальный размер сегмента данных процесса (инициализированные данные, неинициализированные данные, куча). Данное ограничение задаётся в байтах и округляется в меньшую сторону к размеру системной страницы. Это ограничение учитывается в вызовах B<brk>(2), B<sbrk>(2) и (начиная с Linux 4.7)  B<mmap>(2), которые завершатся с ошибкой B<ENOMEM> при достижении мягкого ограничения этого ресурса."

#. type: TP
#: man-pages/man2/getrlimit.2:197
#, no-wrap
msgid "B<RLIMIT_FSIZE>"
msgstr "B<RLIMIT_FSIZE>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:209
msgid ""
"This is the maximum size in bytes of files that the process may create.  "
"Attempts to extend a file beyond this limit result in delivery of a "
"B<SIGXFSZ> signal.  By default, this signal terminates a process, but a "
"process can catch this signal instead, in which case the relevant system "
"call (e.g., B<write>(2), B<truncate>(2))  fails with the error B<EFBIG>."
msgstr "Максимальный размер (в байтах) файлов, создаваемых процессом. Попытки расширить файл сверх этого ограничения приведёт к доставке сигнала B<SIGXFSZ>. По умолчанию по этому сигналу процесс завершается, но процесс может перехватить этот сигнал и в этом случае выполнявшийся системный вызов (например, B<write>(2), B<truncate>(2)) завершится с ошибкой B<EFBIG>."

#. type: TP
#: man-pages/man2/getrlimit.2:209
#, no-wrap
msgid "B<RLIMIT_LOCKS> (early Linux 2.4 only)"
msgstr "B<RLIMIT_LOCKS> (только в ранних версиях Linux 2.4)"

#.  to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
#. type: Plain text
#: man-pages/man2/getrlimit.2:217
msgid ""
"This is a limit on the combined number of B<flock>(2)  locks and B<fcntl>(2)"
"  leases that this process may establish."
msgstr "Ограничение на общее количество блокировок B<flock>(2) и аренд B<fcntl>(2), которое может установить процесс."

#. type: TP
#: man-pages/man2/getrlimit.2:217
#, no-wrap
msgid "B<RLIMIT_MEMLOCK>"
msgstr "B<RLIMIT_MEMLOCK>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:249
msgid ""
"This is the maximum number of bytes of memory that may be locked into RAM.  "
"This limit is in effect rounded down to the nearest multiple of the system "
"page size.  This limit affects B<mlock>(2), B<mlockall>(2), and the "
"B<mmap>(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9, it also affects the"
" B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the total "
"bytes in shared memory segments (see B<shmget>(2))  that may be locked by "
"the real user ID of the calling process.  The B<shmctl>(2)  B<SHM_LOCK> "
"locks are accounted for separately from the per-process memory locks "
"established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  B<MAP_LOCKED>; a"
" process can lock bytes up to this limit in each of these two categories."
msgstr "Максимальное количество байт памяти, которое может быть заблокировано в ОЗУ. В целях эффективности это ограничение округляется в меньшую сторону до ближайшего значения, кратного размеру системной страницы. Это ограничение учитывается в B<mlock>(2), B<mlockall>(2) и в B<mmap>(2) при операции B<MAP_LOCKED>. Начиная с Linux 2.6.9, оно также учитывается в B<shmctl>(2) при операции B<SHM_LOCK>, где определяет максимальное количество байт всех общих сегментов памяти (смотрите B<shmget>(2)), которые могут быть заблокированы вызывающим процессом с реальным идентификатором пользователя. Блокировки по операции B<SHM_LOCK> у B<shmctl>(2) учитываются отдельно от попроцессных блокировок памяти, устанавливаемых B<mlock>(2), B<mlockall>(2) и B<mmap>(2) с операцией B<MAP_LOCKED>; процесс может заблокировать пространство до этого значения заданного ограничения байт в каждой из этих двух категорий."

#. type: Plain text
#: man-pages/man2/getrlimit.2:255
msgid ""
"In Linux kernels before 2.6.9, this limit controlled the amount of memory "
"that could be locked by a privileged process.  Since Linux 2.6.9, no limits "
"are placed on the amount of memory that a privileged process may lock, and "
"this limit instead governs the amount of memory that an unprivileged process"
" may lock."
msgstr "В ядрах Linux до версии 2.6.9 этим ограничением контролировалось количество памяти, которое можно было блокировать привилегированному процессу. Начиная с Linux 2.6.9 привилегированный процесс не ограничен по количеству памяти, и теперь это ограничение управляет количеством памяти, которое может блокировать непривилегированный процесс."

#. type: TP
#: man-pages/man2/getrlimit.2:255
#, no-wrap
msgid "B<RLIMIT_MSGQUEUE> (since Linux 2.6.8)"
msgstr "B<RLIMIT_MSGQUEUE> (начиная с Linux 2.6.8)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:263
msgid ""
"This is a limit on the number of bytes that can be allocated for POSIX "
"message queues for the real user ID of the calling process.  This limit is "
"enforced for B<mq_open>(3).  Each message queue that the user creates counts"
" (until it is removed)  against this limit according to the formula:"
msgstr "Ограничение на количество байт, которое может выделяться для очередей сообщений POSIX для вызывающего процесса с реальным идентификатором пользователя. Это ограничение учитывается в B<mq_open>(3). Каждая очередь сообщений, которую создаёт пользователь, учитывается (пока не будет удалена) в формуле:"

#. type: Plain text
#: man-pages/man2/getrlimit.2:265
#, no-wrap
msgid "    Since Linux 3.5:\n"
msgstr "    Начиная Linux 3.5:\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:273
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +\n"
"                min(attr.mq_maxmsg, MQ_PRIO_MAX) *\n"
"                      sizeof(struct posix_msg_tree_node)+\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr "        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +\n                min(attr.mq_maxmsg, MQ_PRIO_MAX) *\n                      sizeof(struct posix_msg_tree_node)+\n                                /* издержки */\n                attr.mq_maxmsg * attr.mq_msgsize;\n                                /* данные из сообщения */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:276
#, no-wrap
msgid "    Linux 3.4 and earlier:\n"
msgstr "    Linux 3.4 и старше:\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:282
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr "        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n                                /* издержки */\n                attr.mq_maxmsg * attr.mq_msgsize;\n                                /* данные из сообщения */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:295
msgid ""
"where I<attr> is the I<mq_attr> structure specified as the fourth argument "
"to B<mq_open>(3), and the I<msg_msg> and I<posix_msg_tree_node> structures "
"are kernel-internal structures."
msgstr "где I<attr> — структура I<mq_attr>, указанная в четвёртом аргументе B<mq_open>(3), а I<msg_msg> и I<posix_msg_tree_node> — внутренние структуры ядра."

#. type: Plain text
#: man-pages/man2/getrlimit.2:301
msgid ""
"The \"overhead\" addend in the formula accounts for overhead bytes required "
"by the implementation and ensures that the user cannot create an unlimited "
"number of zero-length messages (such messages nevertheless each consume some"
" system memory for bookkeeping overhead)."
msgstr "Дополнение «издержки» (overhead) в формуле нужно учитывает байты расходов требуемые в реализации на то, чтобы пользователь не смог создать бесконечное количество сообщений нулевой длины (для таких сообщений, тем не менее, потребляется системная память для учёта использования системных ресурсов)."

#. type: TP
#: man-pages/man2/getrlimit.2:301
#, no-wrap
msgid "B<RLIMIT_NICE> (since Linux 2.6.12, but see BUGS below)"
msgstr "B<RLIMIT_NICE> (начиная с Linux 2.6.12, см. ДЕФЕКТЫ далее)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:320
msgid ""
"This specifies a ceiling to which the process's nice value can be raised "
"using B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice "
"value is calculated as I<20\\ -\\ rlim_cur>.  The useful range for this "
"limit is thus from 1 (corresponding to a nice value of 19) to 40 "
"(corresponding to a nice value of -20).  This unusual choice of range was "
"necessary because negative numbers cannot be specified as resource limit "
"values, since they typically have special meanings.  For example, "
"B<RLIM_INFINITY> typically is the same as -1.  For more detail on the nice "
"value, see B<sched>(7)."
msgstr "Определяет максимум, до которого может быть увеличено значение уступчивости процесса с помощью B<setpriority>(2) или B<nice>(2). Действительный максимум значения уступчивости высчитывается по формуле: I<20\\ -\\ rlim_cur>. Полезным диапазоном этого ограничения являются значения от 1 (соответствует значению уступчивости 19) до 40 (соответствует значению уступчивости -20). Так пришлось поступить из-за того, что отрицательные числа нельзя указывать в значениях ограничений ресурсов, так как они, обычно, имеют специальное предназначение. Например, B<RLIM_INFINITY>, обычно равно -1. Более подробно о значениях уступчивости описано в B<sched>(7)."

#. type: TP
#: man-pages/man2/getrlimit.2:320
#, no-wrap
msgid "B<RLIMIT_NOFILE>"
msgstr "B<RLIMIT_NOFILE>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:334
msgid ""
"This specifies a value one greater than the maximum file descriptor number "
"that can be opened by this process.  Attempts (B<open>(2), B<pipe>(2), "
"B<dup>(2), etc.)  to exceed this limit yield the error B<EMFILE>.  "
"(Historically, this limit was named B<RLIMIT_OFILE> on BSD.)"
msgstr "Определяет значение, на 1 больше максимального количества дескрипторов файлов, которое может открыть этот процесс. Попытки (B<open>(2), B<pipe>(2), B<dup>(2) и т.п.) превысить это ограничение приведут к ошибке B<EMFILE> (раньше это ограничение в BSD называлось B<RLIMIT_OFILE>)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:346
msgid ""
"Since Linux 4.5, this limit also defines the maximum number of file "
"descriptors that an unprivileged process (one without the "
"B<CAP_SYS_RESOURCE> capability) may have \"in flight\" to other processes, "
"by being passed across UNIX domain sockets.  This limit applies to the "
"B<sendmsg>(2)  system call.  For further details, see B<unix>(7)."
msgstr "Начиная с Linux 4.5, это ограничение также определяет максимальное количество файловых дескрипторов, которое непривилегированный процесс (не имеющий мандата B<CAP_SYS_RESOURCE>) может держать «пересылать» (in flight) другим процессам через доменные сокеты UNIX. Данное ограничение применяется только к системному вызову B<sendmsg>(2). Дополнительную информацию смотрите в B<unix>(7)."

#. type: TP
#: man-pages/man2/getrlimit.2:346
#, no-wrap
msgid "B<RLIMIT_NPROC>"
msgstr "B<RLIMIT_NPROC>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:356
msgid ""
"This is a limit on the number of extant process (or, more precisely on "
"Linux, threads)  for the real user ID of the calling process.  So long as "
"the current number of processes belonging to this process's real user ID is "
"greater than or equal to this limit, B<fork>(2)  fails with the error "
"B<EAGAIN>."
msgstr "Ограничивает количество живущих (extant) процессов (или, более точно для Linux, нитей), для реального идентификатора пользователя вызывающего процесса. Как только текущее количество процессов, принадлежащих реальному идентификатору пользователя вызывающего процесса, станет больше или равно этому ограничению B<fork>(2) начнёт завершаться с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:364
msgid ""
"The B<RLIMIT_NPROC> limit is not enforced for processes that have either the"
" B<CAP_SYS_ADMIN> or the B<CAP_SYS_RESOURCE> capability."
msgstr "Данное ограничение не учитываются процессы, имеющие мандат B<CAP_SYS_ADMIN> или B<CAP_SYS_RESOURCE>."

#. type: TP
#: man-pages/man2/getrlimit.2:364
#, no-wrap
msgid "B<RLIMIT_RSS>"
msgstr "B<RLIMIT_RSS>"

#.  As at kernel 2.6.12, this limit still does nothing in 2.6 though
#.  talk of making it do something has surfaced from time to time in LKML
#.        -- MTK, Jul 05
#. type: Plain text
#: man-pages/man2/getrlimit.2:376
msgid ""
"This is a limit (in bytes) on the process's resident set (the number of "
"virtual pages resident in RAM).  This limit has effect only in Linux 2.4.x, "
"x E<lt> 30, and there affects only calls to B<madvise>(2)  specifying "
"B<MADV_WILLNEED>."
msgstr "Максимальное ограничение (в байтах) размера постоянного присутствия процесса (числа виртуальных страниц, постоянно присутствующих в ОЗУ). Это ограничение учитывается только начиная с версии Linux 2.4.x, x E<lt> 30, и только в вызовах B<madvise>(2) со значением B<MADV_WILLNEED>."

#. type: TP
#: man-pages/man2/getrlimit.2:376
#, no-wrap
msgid "B<RLIMIT_RTPRIO> (since Linux 2.6.12, but see BUGS)"
msgstr "B<RLIMIT_RTPRIO> (начиная с Linux 2.6.12, смотрите ДЕФЕКТЫ)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:383
msgid ""
"This specifies a ceiling on the real-time priority that may be set for this "
"process using B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr "Определяет максимум для приоритета реального времени, который можно установить для процесса с помощью B<sched_setscheduler>(2) и B<sched_setparam>(2)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:386 man-pages/man2/getrlimit.2:415
msgid "For further details on real-time scheduling policies, see B<sched>(7)"
msgstr "Дополнительную информацию об алгоритмах планирования реального времени смотрите в B<sched>(7)."

#. type: TP
#: man-pages/man2/getrlimit.2:386
#, no-wrap
msgid "B<RLIMIT_RTTIME> (since Linux 2.6.25)"
msgstr "B<RLIMIT_RTTIME> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:398
msgid ""
"This is a limit (in microseconds)  on the amount of CPU time that a process "
"scheduled under a real-time scheduling policy may consume without making a "
"blocking system call.  For the purpose of this limit, each time a process "
"makes a blocking system call, the count of its consumed CPU time is reset to"
" zero.  The CPU time count is not reset if the process continues trying to "
"use the CPU but is preempted, its time slice expires, or it calls "
"B<sched_yield>(2)."
msgstr "Определяет ограничение (в микросекундах) на количество времени ЦП, которое процесс может быть запланирован выполняться в условиях реального времени без выполнения блокирующего системного вызова. Для работы ограничения, всякий раз когда процесс делает блокирующий системный вызов счётчик использованного времени ЦП сбрасывается в ноль. Счётчик времени ЦП не сбрасывается, если процесс продолжает пытаться использовать ЦП, но был вытеснен, его выделенное время на исполнение истекло или он вызвал B<sched_yield>(2)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:409
msgid ""
"Upon reaching the soft limit, the process is sent a B<SIGXCPU> signal.  If "
"the process catches or ignores this signal and continues consuming CPU time,"
" then B<SIGXCPU> will be generated once each second until the hard limit is "
"reached, at which point the process is sent a B<SIGKILL> signal."
msgstr "При достижении мягкого ограничения процессу посылается сигнал B<SIGXCPU>. Если процесс перехватил сигнал, проигнорировал его и продолжает потреблять время ЦП, то раз в секунду будет генерироваться сигнал B<SIGXCPU> до тех пор, пока не будет достигнуто жёсткое ограничение, и процессу не будет послан сигнал B<SIGKILL>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:412
msgid ""
"The intended use of this limit is to stop a runaway real-time process from "
"locking up the system."
msgstr "Это ограничение предназначено для предотвращения блокировки системы вышедшими из под контроля процессами реального времени."

#. type: TP
#: man-pages/man2/getrlimit.2:415
#, no-wrap
msgid "B<RLIMIT_SIGPENDING> (since Linux 2.6.8)"
msgstr "B<RLIMIT_SIGPENDING> (начиная с Linux 2.6.8)"

#.  This replaces the /proc/sys/kernel/rtsig-max system-wide limit
#.  that was present in kernels <= 2.6.7.  MTK Dec 04
#. type: Plain text
#: man-pages/man2/getrlimit.2:429
msgid ""
"This is a limit on the number of signals that may be queued for the real "
"user ID of the calling process.  Both standard and real-time signals are "
"counted for the purpose of checking this limit.  However, the limit is "
"enforced only for B<sigqueue>(3); it is always possible to use B<kill>(2)  "
"to queue one instance of any of the signals that are not already queued to "
"the process."
msgstr "Определяет ограничение на количество сигналов, которые могут быть поставлены в очередь вызывающего процесса с реальным пользовательским идентификатором. При проверке ограничения учитываются обычные сигналы и сигналы реального времени. Однако ограничение учитывается только в B<sigqueue>(3); всегда возможно использовать B<kill>(2) для постановки в очередь любого сигнала, которого ещё нет в очереди процесса."

#. type: TP
#: man-pages/man2/getrlimit.2:429
#, no-wrap
msgid "B<RLIMIT_STACK>"
msgstr "B<RLIMIT_STACK>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:437
msgid ""
"This is the maximum size of the process stack, in bytes.  Upon reaching this"
" limit, a B<SIGSEGV> signal is generated.  To handle this signal, a process "
"must employ an alternate signal stack (B<sigaltstack>(2))."
msgstr "Максимальный размер стека процесса в байтах. При достижении этого ограничения генерируется сигнал B<SIGSEGV>. Для обработки этого сигнала процесс должен использовать альтернативный стек сигналов (B<sigaltstack>(2))."

#. type: Plain text
#: man-pages/man2/getrlimit.2:442
msgid ""
"Since Linux 2.6.23, this limit also determines the amount of space used for "
"the process's command-line arguments and environment variables; for details,"
" see B<execve>(2)."
msgstr "Начиная с Linux 2.6.23, это ограничение также определяет количество места, используемого для аргументов командной строки процесса и его переменных окружения; подробней об этом смотрите в B<execve>(2)."

#. type: SS
#: man-pages/man2/getrlimit.2:442
#, no-wrap
msgid "prlimit()"
msgstr "prlimit()"

#.  commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Tue May 4 18:03:50 2010 +0200
#.      rlimits: implement prlimit64 syscall
#.  commit 6a1d5e2c85d06da35cdfd93f1a27675bfdc3ad8c
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Wed Mar 24 17:06:58 2010 +0100
#.      rlimits: add rlimit64 structure
#. type: Plain text
#: man-pages/man2/getrlimit.2:462
msgid ""
"The Linux-specific B<prlimit>()  system call combines and extends the "
"functionality of B<setrlimit>()  and B<getrlimit>().  It can be used to both"
" set and get the resource limits of an arbitrary process."
msgstr "Системный вызов B<prlimit>(), который есть только в Linux объединяет и расширяет функции B<setrlimit>() и B<getrlimit>(). Он может использоваться для задания и получения ограничений ресурсов произвольного процесса."

#. type: Plain text
#: man-pages/man2/getrlimit.2:469
msgid ""
"The I<resource> argument has the same meaning as for B<setrlimit>()  and "
"B<getrlimit>()."
msgstr "Аргумент I<resource> имеет тот же смысл что и в B<setrlimit>() и B<getrlimit>()."

#. type: Plain text
#: man-pages/man2/getrlimit.2:487
msgid ""
"If the I<new_limit> argument is a not NULL, then the I<rlimit> structure to "
"which it points is used to set new values for the soft and hard limits for "
"I<resource>.  If the I<old_limit> argument is a not NULL, then a successful "
"call to B<prlimit>()  places the previous soft and hard limits for "
"I<resource> in the I<rlimit> structure pointed to by I<old_limit>."
msgstr "Если значение аргумента I<new_limit> не равно NULL, то структура I<rlimit>, на которую он указывает, используется для задания новых значений мягкий и жёстких ограничений для I<resource>. Если значение аргумента I<old_limit> не равно NULL, то успешный вызов B<prlimit>() помещает текущие значения мягких и жёстких ограничений для I<resource> в структуру I<rlimit>, на которую указывает I<old_limit>."

#.  FIXME . this permission check is strange
#.  Asked about this on LKML, 7 Nov 2010
#.      "Inconsistent credential checking in prlimit() syscall"
#. type: Plain text
#: man-pages/man2/getrlimit.2:507
msgid ""
"The I<pid> argument specifies the ID of the process on which the call is to "
"operate.  If I<pid> is 0, then the call applies to the calling process.  To "
"set or get the resources of a process other than itself, the caller must "
"have the B<CAP_SYS_RESOURCE> capability in the user namespace of the process"
" whose resource limits are being changed, or the real, effective, and saved "
"set user IDs of the target process must match the real user ID of the caller"
" I<and> the real, effective, and saved set group IDs of the target process "
"must match the real group ID of the caller."
msgstr "В аргументе I<pid> задаётся идентификатор процесса с которым работает вызов. Если I<pid> равно 0, то вызов применяется к вызывающему процессу. Для установки и получения ресурсов не своего процесса, вызывающий должен иметь мандат B<CAP_SYS_RESOURCE> в пользовательском пространстве имён процесса, ограничения ресурсов которого изменяются или реальный, эффективный и сохранённый идентификатор пользователя процесса назначения должен совпадать с реальным идентификатором пользователя вызывающего I<и> реальный, эффективный и сохранённый идентификатор группы процесса назначения должны совпадать с реальным идентификатором группы вызывающего."

#. type: Plain text
#: man-pages/man2/getrlimit.2:512
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getrlimit.2:517
msgid ""
"A pointer argument points to a location outside the accessible address "
"space."
msgstr "Аргумент-указатель указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/getrlimit.2:529
msgid ""
"The value specified in I<resource> is not valid; or, for B<setrlimit>()  or "
"B<prlimit>(): I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr "Указано некорректное значение I<resource>; или для B<setrlimit>() или B<prlimit>(): I<rlim-E<gt>rlim_cur> больше чем I<rlim-E<gt>rlim_max>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:534
msgid ""
"An unprivileged process tried to raise the hard limit; the "
"B<CAP_SYS_RESOURCE> capability is required to do this."
msgstr "Непривилегированный процесс пытался увеличить жёсткое ограничение; для этого требуется мандат B<CAP_SYS_RESOURCE>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:542
msgid ""
"The caller tried to increase the hard B<RLIMIT_NOFILE> limit above the "
"maximum defined by I</proc/sys/fs/nr_open> (see B<proc>(5))"
msgstr "Вызывающий пытался увеличить жёсткое ограничение B<RLIMIT_NOFILE>, превышая максимум, заданный в I</proc/sys/fs/nr_open> (смотрите B<proc>(5))."

#. type: Plain text
#: man-pages/man2/getrlimit.2:548
msgid ""
"(B<prlimit>())  The calling process did not have permission to set limits "
"for the process specified by I<pid>."
msgstr "Вызывающий процесс не имеет прав для назначения ограничений процессу, указанному в I<pid>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:552
msgid "Could not find a process with the ID specified in I<pid>."
msgstr "Не удалось найти процесс с идентификатором, указанном в I<pid>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:557
msgid ""
"The B<prlimit>()  system call is available since Linux 2.6.36.  Library "
"support is available since glibc 2.13."
msgstr "Системный вызов B<prlimit>() появился в Linux 2.6.36. Поддержка в glibc доступна начиная с версии 2.13."

#. type: SH
#: man-pages/man2/getrlimit.2:557
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man2/getrlimit.2:560
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man2/getrlimit.2:564
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man2/getrlimit.2:564
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man2/getrlimit.2:564
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man2/getrlimit.2:569
#, no-wrap
msgid ""
"B<getrlimit>(),\n"
"B<setrlimit>(),\n"
"B<prlimit>()"
msgstr "B<getrlimit>(),\nB<setrlimit>(),\nB<prlimit>()"

#. type: tbl table
#: man-pages/man2/getrlimit.2:569
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man2/getrlimit.2:569
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: man-pages/man2/getrlimit.2:576
msgid ""
"B<getrlimit>(), B<setrlimit>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "B<getrlimit>(), B<setrlimit>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/getrlimit.2:579
msgid "B<prlimit>(): Linux-specific."
msgstr "B<prlimit>(): только в Linux."

#. type: Plain text
#: man-pages/man2/getrlimit.2:595
msgid ""
"B<RLIMIT_MEMLOCK> and B<RLIMIT_NPROC> derive from BSD and are not specified "
"in POSIX.1; they are present on the BSDs and Linux, but on few other "
"implementations.  B<RLIMIT_RSS> derives from BSD and is not specified in "
"POSIX.1; it is nevertheless present on most implementations.  "
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, and "
"B<RLIMIT_SIGPENDING> are Linux-specific."
msgstr "Ограничение B<RLIMIT_MEMLOCK> и B<RLIMIT_NPROC> появились из BSD и их нет в POSIX.1; они есть в BSD и Linux, но реализации несколько различны. Ограничение B<RLIMIT_RSS> появилось из BSD и его нет в POSIX.1; тем не менее оно есть в большинстве реализаций. Ограничения B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME> и B<RLIMIT_SIGPENDING> есть только в Linux."

#. type: Plain text
#: man-pages/man2/getrlimit.2:601
msgid ""
"A child process created via B<fork>(2)  inherits its parent's resource "
"limits.  Resource limits are preserved across B<execve>(2)."
msgstr "Дочерний процесс, созданный B<fork>(2), наследует ограничения ресурсов родителя. Ограничения ресурсов сохраняются при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:604
msgid ""
"Resource limits are per-process attributes that are shared by all of the "
"threads in a process."
msgstr "Атрибуты ограничения ресурсов есть у каждого процесса, они являются общими для всех нитей процесса."

#. type: Plain text
#: man-pages/man2/getrlimit.2:609
msgid ""
"Lowering the soft limit for a resource below the process's current "
"consumption of that resource will succeed (but will prevent the process from"
" further increasing its consumption of the resource)."
msgstr "Уменьшение мягкого ограничения ресурса ниже текущего потребления процесса будет выполнено (но в дальнейшем процесс не сможет увеличить потребление ресурса)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:618
msgid ""
"One can set the resource limits of the shell using the built-in I<ulimit> "
"command (I<limit> in B<csh>(1)).  The shell's resource limits are inherited "
"by the processes that it creates to execute commands."
msgstr "Ограничения ресурсов интерпретатора командной строки можно устанавливать с помощью встроенной команды I<ulimit> (I<limit> в B<csh>(1)). Ограничения ресурсов интерпретатора наследуются дочерними процессами, которые он создаёт при выполнении команд."

#. type: Plain text
#: man-pages/man2/getrlimit.2:623
msgid ""
"Since Linux 2.6.24, the resource limits of any process can be inspected via "
"I</proc/[pid]/limits>; see B<proc>(5)."
msgstr "Начиная с Linux 2.6.24, ограничения ресурсов любого процесса можно узнать с помощью I</proc/[pid]/limits>; смотрите B<proc>(5)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:632
msgid ""
"Ancient systems provided a B<vlimit>()  function with a similar purpose to "
"B<setrlimit>().  For backward compatibility, glibc also provides "
"B<vlimit>().  All new applications should be written using B<setrlimit>()."
msgstr "В старых системах была функция B<vlimit>() с подобным B<setrlimit>() назначением. Для обратной совместимости в glibc также есть функция B<vlimit>(). Во всех новых приложениях должен быть использован B<setrlimit>()."

#. type: SS
#: man-pages/man2/getrlimit.2:632
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr "Отличия между библиотекой C и ABI ядра"

#. type: Plain text
#: man-pages/man2/getrlimit.2:641
msgid ""
"Since version 2.13, the glibc B<getrlimit>()  and B<setrlimit>()  wrapper "
"functions no longer invoke the corresponding system calls, but instead "
"employ B<prlimit>(), for the reasons described in BUGS."
msgstr "Начиная с версии 2.13, обёрточные функции glibc B<getrlimit>() и B<setrlimit>() больше не вызывают соответствующие системные вызовы, вместо этого вызывается B<prlimit>() по причинам, описанным в разделе ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/getrlimit.2:646
msgid ""
"The name of the glibc wrapper function is B<prlimit>(); the underlying "
"system call is B<prlimit64>()."
msgstr "Обёрточная функция в glibc называется B<prlimit>(); нижележащий системный вызов называется B<prlimit64>()."

#. type: Plain text
#: man-pages/man2/getrlimit.2:655
msgid ""
"In older Linux kernels, the B<SIGXCPU> and B<SIGKILL> signals delivered when"
" a process encountered the soft and hard B<RLIMIT_CPU> limits were delivered"
" one (CPU) second later than they should have been.  This was fixed in "
"kernel 2.6.8."
msgstr "В старых ядрах Linux сигналы B<SIGXCPU> и B<SIGKILL>, посылаемые когда у процесса обнаруживается достижение мягкого и жёсткого ограничения B<RLIMIT_CPU>, доставляются на одну секунду (ЦП) позднее чем это должно быть. Это исправлено в ядре версии 2.6.8."

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:663
msgid ""
"In 2.6.x kernels before 2.6.17, a B<RLIMIT_CPU> limit of 0 is wrongly "
"treated as \"no limit\" (like B<RLIM_INFINITY>).  Since Linux 2.6.17, "
"setting a limit of 0 does have an effect, but is actually treated as a limit"
" of 1 second."
msgstr "В ядрах 2.6.x до версии 2.6.17, ограничение B<RLIMIT_CPU> равное 0, неправильно воспринималось как «без ограничения» (подобно B<RLIM_INFINITY>). Начиная с Linux 2.6.17, установка ограничения в 0 действует, но реально обрабатывается как ограничение в 1 секунду."

#.  See https://lwn.net/Articles/145008/
#. type: Plain text
#: man-pages/man2/getrlimit.2:668
msgid ""
"A kernel bug means that B<RLIMIT_RTPRIO> does not work in kernel 2.6.12; the"
" problem is fixed in kernel 2.6.13."
msgstr "Из-за дефекта ядра B<RLIMIT_RTPRIO> не работает в версии 2.6.12; это исправлено в ядре 2.6.13."

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:679
msgid ""
"In kernel 2.6.12, there was an off-by-one mismatch between the priority "
"ranges returned by B<getpriority>(2)  and B<RLIMIT_NICE>.  This had the "
"effect that the actual ceiling for the nice value was calculated as I<19\\ "
"-\\ rlim_cur>.  This was fixed in kernel 2.6.13."
msgstr "В ядре 2.6.12 было несоответствие в единицу между диапазонами приоритетов, возвращаемых B<getpriority>(2) и B<RLIMIT_NICE>. Это приводило к тому, что реальный максимум значения nice вычислялся как I<19\\ - \\ rlim_cur>. Исправлено в ядре 2.6.13."

#.  The relevant patch, sent to LKML, seems to be
#.  http://thread.gmane.org/gmane.linux.kernel/273462
#.  From: Roland McGrath <roland <at> redhat.com>
#.  Subject: [PATCH 7/7] make RLIMIT_CPU/SIGXCPU per-process
#.  Date: 2005-01-23 23:27:46 GMT
#.  Tested Solaris 10, FreeBSD 9, OpenBSD 5.0
#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=50951
#. type: Plain text
#: man-pages/man2/getrlimit.2:706
msgid ""
"Since Linux 2.6.12, if a process reaches its soft B<RLIMIT_CPU> limit and "
"has a handler installed for B<SIGXCPU>, then, in addition to invoking the "
"signal handler, the kernel increases the soft limit by one second.  This "
"behavior repeats if the process continues to consume CPU time, until the "
"hard limit is reached, at which point the process is killed.  Other "
"implementations do not change the B<RLIMIT_CPU> soft limit in this manner, "
"and the Linux behavior is probably not standards conformant; portable "
"applications should avoid relying on this Linux-specific behavior.  The "
"Linux-specific B<RLIMIT_RTTIME> limit exhibits the same behavior when the "
"soft limit is encountered."
msgstr "Начиная с Linux 2.6.12, если процесс имеет мягкое ограничение B<RLIMIT_CPU> и установлен обработчик для B<SIGXCPU>, то, помимо вызова обработчика сигнала, ядро увеличивает мягкое ограничение на одну секунду. Такое поведение повторяется, если процесс продолжает потреблять процессорное время, и происходит это до тех пор, пока не будет достигнуто жёсткое ограничение, после чего процесс будет завершён. В других реализациях мягкое ограничение B<RLIMIT_CPU> не меняется подобным образом, и поведение Linux, вероятно, нестандартно; переносимые приложения не должны полагаться на данную специфику Linux. Ограничение Linux B<RLIMIT_RTTIME> демонстрирует такое же поведение, при исчерпании мягкого ограничения."

#.  d3561f78fd379a7110e46c87964ba7aa4120235c
#. type: Plain text
#: man-pages/man2/getrlimit.2:716
msgid ""
"Kernels before 2.4.22 did not diagnose the error B<EINVAL> for "
"B<setrlimit>()  when I<rlim-E<gt>rlim_cur> was greater than "
"I<rlim-E<gt>rlim_max>."
msgstr "В ядрах до 2.4.22 не определялась ошибка B<EINVAL> в B<setrlimit>(), если значение I<rlim-E<gt>rlim_cur> было больше I<rlim-E<gt>rlim_max>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:721
msgid ""
"Linux doesn't return an error when an attempt to set B<RLIMIT_CPU> has "
"failed, for compatibility reasons."
msgstr "В целях совместимости, Linux не возвращает ошибку при неудачной попытке назначения B<RLIMIT_CPU>."

#. type: SS
#: man-pages/man2/getrlimit.2:721
#, no-wrap
msgid "Representation of \"large\" resource limit values on 32-bit platforms"
msgstr "Представление «больших» значений ограничений ресурсов на 32-битных платформах"

#.  Linux still uses long for limits internally:
#.  c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  kernel/sys.c:do_prlimit() still uses struct rlimit which
#.  uses kernel_ulong_t for its members, i.e. 32-bit  on 32-bit kernel.
#.  https://bugzilla.kernel.org/show_bug.cgi?id=5042
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: man-pages/man2/getrlimit.2:756
msgid ""
"The glibc B<getrlimit>()  and B<setrlimit>()  wrapper functions use a 64-bit"
" I<rlim_t> data type, even on 32-bit platforms.  However, the I<rlim_t> data"
" type used in the B<getrlimit>()  and B<setrlimit>()  system calls is a "
"(32-bit)  I<unsigned long>.  Furthermore, in Linux, the kernel represents "
"resource limits on 32-bit platforms as I<unsigned long>.  However, a 32-bit "
"data type is not wide enough.  The most pertinent limit here is "
"B<RLIMIT_FSIZE>, which specifies the maximum size to which a file can grow: "
"to be useful, this limit must be represented using a type that is as wide as"
" the type used to represent file offsets\\(emthat is, as wide as a 64-bit "
"B<off_t> (assuming a program compiled with I<_FILE_OFFSET_BITS=64>)."
msgstr "В обёрточных функциях glibc B<getrlimit>() и B<setrlimit>() используется 64-битный тип данных I<rlim_t>, даже на 32-битных платформах. Однако в системных вызовах B<getrlimit>() и B<setrlimit>() тип данных I<rlim_t> приводится к I<unsigned long> (32-битному). Кроме этого, в ядре Linux ограничители ресурсов на 32-битных платформах представлены типом I<unsigned long>. Однако 32-битный тип данных недостаточно велик. Для этого больше подходит B<RLIMIT_FSIZE>, который определяет максимальный размер на который можно увеличить файл; чтобы его можно было использовать, данное ограничение должно быть представлено типом, соразмерным с типом, используемым для представления файловых смещений — 64-битным B<off_t> (предполагается, что программа компилируется в параметром I<_FILE_OFFSET_BITS=64>)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:766
msgid ""
"To work around this kernel limitation, if a program tried to set a resource "
"limit to a value larger than can be represented in a 32-bit I<unsigned "
"long>, then the glibc B<setrlimit>()  wrapper function silently converted "
"the limit value to B<RLIM_INFINITY>.  In other words, the requested resource"
" limit setting was silently ignored."
msgstr "Если программа пытается задать ограничение ресурса значением, большим чем можно представить 32-битным I<unsigned long>, то, чтобы обойти это ограничение ядра, обёрточная функция glibc B<setrlimit>() просто преобразует значение ограничения в B<RLIM_INFINITY>. Иначе говоря, запрашиваемое назначение ограничения ресурса просто игнорируется."

#.  https://www.sourceware.org/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: man-pages/man2/getrlimit.2:779
msgid ""
"Since version 2.13, glibc works around the limitations of the B<getrlimit>()"
"  and B<setrlimit>()  system calls by implementing B<setrlimit>()  and "
"B<getrlimit>()  as wrapper functions that call B<prlimit>()."
msgstr "Начиная с версии 2.13, в glibc для обхода ограничений системных вызовов B<getrlimit>() и B<setrlimit>() для реализации обёрточных функций B<setrlimit>() и B<getrlimit>() используется вызов B<prlimit>()."

#. type: Plain text
#: man-pages/man2/getrlimit.2:782
msgid "The program below demonstrates the use of B<prlimit>()."
msgstr "Представленная ниже программа показывает использование B<prlimit>()."

#. type: Plain text
#: man-pages/man2/getrlimit.2:791
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#define _FILE_OFFSET_BITS 64\n#include E<lt>stdio.hE<gt>\n#include E<lt>time.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>sys/resource.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:794
#, no-wrap
msgid ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr "#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\e\n                        } while (0)\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:801
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct rlimit old, new;\n    struct rlimit *newp;\n    pid_t pid;\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:807
#, no-wrap
msgid ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> \"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (!(argc == 2 || argc == 4)) {\n        fprintf(stderr, \"Использование: %s E<lt>pidE<gt> [E<lt>новое-мягкое-ограничениеE<gt> \"\n                \"E<lt>новое-жёсткое-ограничениеE<gt>]\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:809
#, no-wrap
msgid "    pid = atoi(argv[1]);        /* PID of target process */\n"
msgstr "    pid = atoi(argv[1]);        /* PID процесса назначения */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:816
#, no-wrap
msgid ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"
msgstr "    newp = NULL;\n    if (argc == 4) {\n        new.rlim_cur = atoi(argv[2]);\n        new.rlim_max = atoi(argv[3]);\n        newp = &new;\n    }\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:819
#, no-wrap
msgid ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"
msgstr "    /* Установить ограничение на время ЦП процесса назначения; \n       получить и показать предыдущее ограничение */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:824
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr "    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n        errExit(\"prlimit-1\");\n    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n            (long long) old.rlim_cur, (long long) old.rlim_max);\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:826
#, no-wrap
msgid "    /* Retrieve and display new CPU time limit */\n"
msgstr "    /* Получить и показать новое ограничение времени ЦП */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:831
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr "    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n        errExit(\"prlimit-2\");\n    printf(\"Новые ограничения: мягкое=%lld; жёсткое=%lld\\en\",\n            (long long) old.rlim_cur, (long long) old.rlim_max);\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:854
msgid ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), "
"B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), "
"B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), "
"B<capabilities>(7), B<cgroups>(7), B<credentials>(7), B<signal>(7)"
msgstr "B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), B<capabilities>(7), B<cgroups>(7), B<credentials>(7), B<signal>(7)"

#. type: TH
#: man-pages/man2/getitimer.2:13
#, no-wrap
msgid "GETITIMER"
msgstr "GETITIMER"

#. type: Plain text
#: man-pages/man2/getitimer.2:16
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr "getitimer, setitimer - считывает или устанавливает значение таймера интервалов"

#. type: Plain text
#: man-pages/man2/getitimer.2:19
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:23
#, no-wrap
msgid ""
"B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr "B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\nB<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\nB<              struct itimerval *>I<old_value>B<);>\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:31
msgid ""
"These system calls provide access to interval timers, that is, timers that "
"initially expire at some point in the future, and (optionally) at regular "
"intervals after that.  When a timer expires, a signal is generated for the "
"calling process, and the timer is reset to the specified interval (if the "
"interval is nonzero)."
msgstr "Данные системные вызовы предоставляют доступ к интервальным таймерам, то есть таймерам, у которых изначально истекает срок в будущем, и (необязательно) с регулярными интервалами после. Когда у таймера истекает срок, вызвавшему процессу отправляется сигнал и таймер перезапускается с задаваемым интервалом (если интервал не равен нулю)."

#. type: Plain text
#: man-pages/man2/getitimer.2:37
msgid ""
"Three types of timers\\(emspecified via the I<which> argument\\(emare "
"provided, each of which counts against a different clock and generates a "
"different signal on timer expiration:"
msgstr "В аргументе I<which> можно задать три типа таймеров, каждый выполняет отсчёт по разным часам и генерирует разный сигнал по истечении срока:"

#. type: TP
#: man-pages/man2/getitimer.2:37
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr "B<ITIMER_REAL>"

#. type: Plain text
#: man-pages/man2/getitimer.2:43
msgid ""
"This timer counts down in real (i.e., wall clock) time.  At each expiration,"
" a B<SIGALRM> signal is generated."
msgstr "Этот таймер отсчитывается по реальному времени (то есть обычному). По каждому истечению выдаёт сигнал B<SIGALRM>."

#. type: TP
#: man-pages/man2/getitimer.2:43
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr "B<ITIMER_VIRTUAL>"

#. type: Plain text
#: man-pages/man2/getitimer.2:50
msgid ""
"This timer counts down against the user-mode CPU time consumed by the "
"process.  (The measurement includes CPU time consumed by all threads in the "
"process.)  At each expiration, a B<SIGVTALRM> signal is generated."
msgstr "Этот таймер отсчитывается по времени ЦП в пользовательском режиме, проведённым процессом (учёт включает время ЦП, потреблённое всеми нитями процесса). По каждому истечению выдаёт сигнал B<SIGVTALRM>."

#. type: TP
#: man-pages/man2/getitimer.2:50
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr "B<ITIMER_PROF>"

#. type: Plain text
#: man-pages/man2/getitimer.2:58
msgid ""
"This timer counts down against the total (i.e., both user and system)  CPU "
"time consumed by the process.  (The measurement includes CPU time consumed "
"by all threads in the process.)  At each expiration, a B<SIGPROF> signal is "
"generated."
msgstr "Этот таймер отсчитывается по полному времени ЦП, потраченному процессом (учёт включает время ЦП, потреблённое всеми нитями процесса). По каждому истечению выдаёт сигнал B<SIGPROF>."

#. type: Plain text
#: man-pages/man2/getitimer.2:63
msgid ""
"In conjunction with B<ITIMER_VIRTUAL>, this timer can be used to profile "
"user and system CPU time consumed by the process."
msgstr "Данный таймер вместе с B<ITIMER_VIRTUAL> можно использовать для профилирования затрат процессом системного и пользовательского времени ЦП."

#. type: Plain text
#: man-pages/man2/getitimer.2:65
msgid "A process has only one of each of the three types of timers."
msgstr "Процесс может иметь только по одному таймеру каждого типа."

#. type: Plain text
#: man-pages/man2/getitimer.2:67
msgid "Timer values are defined by the following structures:"
msgstr "Величина, на которую устанавливается таймер, определяется следующими структурами:"

#. type: Plain text
#: man-pages/man2/getitimer.2:74
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* Interval for periodic timer */\n"
"    struct timeval it_value;    /* Time until next expiration */\n"
"};\n"
msgstr "struct itimerval {\n    struct timeval it_interval; /* интервал для периодического таймера */\n    struct timeval it_value;    /* время до следующего окончания */\n};\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:79
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr "struct timeval {\n    time_t      tv_sec;     /* секунды */\n    suseconds_t tv_usec;    /* микросекунды */\n};\n"

#. type: SS
#: man-pages/man2/getitimer.2:82
#, no-wrap
msgid "getitimer()"
msgstr "getitimer()"

#. type: Plain text
#: man-pages/man2/getitimer.2:89
msgid ""
"The function B<getitimer>()  places the current value of the timer specified"
" by I<which> in the buffer pointed to by I<curr_value>."
msgstr "Функция B<getitimer>() помещает текущее значение таймера, указанного в I<which>, в буфер, указанный в I<curr_value>."

#. type: Plain text
#: man-pages/man2/getitimer.2:100
msgid ""
"The I<it_value> substructure is populated with the amount of time remaining "
"until the next expiration of the specified timer.  This value changes as the"
" timer counts down, and will be reset to I<it_interval> when the timer "
"expires.  If both fields of I<it_value> are zero, then this timer is "
"currently disarmed (inactive)."
msgstr "Вложенная структура I<it_value> содержит количество оставшегося времени до следующего истечения таймера. Это значение изменяется после начала отсчёта таймера и будет сброшено в I<it_interval> при истечении таймера. Если оба поля I<it_value> равны нулю, то это означает что таймер выключен (неактивен)."

#. type: Plain text
#: man-pages/man2/getitimer.2:107
msgid ""
"The I<it_interval> substructure is populated with the timer interval.  If "
"both fields of I<it_interval> are zero, then this is a single-shot timer "
"(i.e., it expires just once)."
msgstr "Вложенная структура I<it_interval> содержит интервал таймера. Если оба поля I<it_interval>равны нулю, то это указывает на одноразовый таймер (то срабатывающий один раз)."

#. type: SS
#: man-pages/man2/getitimer.2:107
#, no-wrap
msgid "setitimer()"
msgstr "setitimer()"

#. type: Plain text
#: man-pages/man2/getitimer.2:120
msgid ""
"The function B<setitimer>()  arms or disarms the timer specified by "
"I<which>, by setting the timer to the value specified by I<new_value>.  If "
"I<old_value> is non-NULL, the buffer it points to is used to return the "
"previous value of the timer (i.e., the same information that is returned by "
"B<getitimer>())."
msgstr "Функция B<setitimer>() настраивает таймер I<which> значением I<new_value>. Если значение I<old_value> не NULL, то оно указывает на буфер, в который сохраняется предыдущее значение таймера (т. е., информация, возвращаемая B<getitimer>())."

#. type: Plain text
#: man-pages/man2/getitimer.2:128
msgid ""
"If either field in I<new_value.it_value> is nonzero, then the timer is armed"
" to initially expire at the specified time.  If both fields in "
"I<new_value.it_value> are zero, then the timer is disarmed."
msgstr "Если какое-то из полей в I<new_value.it_value> не равно нулю, то таймер изначально включается как просроченный на указанное время. Если оба поля в I<new_value.it_value> равны нулю, то таймер отключён."

#. type: Plain text
#: man-pages/man2/getitimer.2:133
msgid ""
"The I<new_value.it_interval> field specifies the new interval for the timer;"
" if both of its subfields are zero, the timer is single-shot."
msgstr "Поле I<new_value.it_interval> задаёт новый интервал таймера;если оба поля равны нулю, то таймер будет одноразовым."

#. type: Plain text
#: man-pages/man2/getitimer.2:146
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr "Указатели I<new_value>, I<old_value> или I<curr_value> являются некорректными."

#. type: Plain text
#: man-pages/man2/getitimer.2:159
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>;"
" or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr "Значение I<which> не равно B<ITIMER_REAL>, B<ITIMER_VIRTUAL> или B<ITIMER_PROF>; или (начиная с Linux 2.6.22) одно из полей структуры I<tv_usec>, указанной в I<new_value>, содержит значение вне диапазона от 0 до 999999."

#. type: Plain text
#: man-pages/man2/getitimer.2:169
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr "POSIX.1-2001, SVr4, 4.4BSD (впервые этот вызов появился в 4.2BSD). В POSIX.1-2008 вызовы B<getitimer>() и B<setitimer>() помечены как устаревшие, и вместо них рекомендуется использовать программный интерфейс таймеров POSIX (B<timer_gettime>(2), B<timer_settime>(2) и т.д.)."

#. type: Plain text
#: man-pages/man2/getitimer.2:178
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  If the timer "
"expires while the process is active (always true for B<ITIMER_VIRTUAL>), the"
" signal will be delivered immediately when generated."
msgstr "Срок на таймерах никогда не заканчивается ранее указанного времени, но может (чуть-чуть) опоздать, что зависит от степени разрешения системного таймера и загрузки системы; смотрите B<time>(7) (но смотрите ДЕФЕКТЫ далее). Если время таймера истекает во время работы процесса (всегда, если используется B<ITIMER_VIRTUAL>), то сигнал после создания будет доставлен немедленно."

#. type: Plain text
#: man-pages/man2/getitimer.2:184
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr "Потомок, созданный через B<fork>(2), не наследует таймеры интервалов родителя. При вызове B<execve>(2) таймеры интервалов сохраняются."

#. type: Plain text
#: man-pages/man2/getitimer.2:194
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr "В POSIX.1 не определено взаимодействие между B<setitimer>() и тремя интерфейсами: B<alarm>(2), B<sleep>(3) и B<usleep>(3)."

#. type: Plain text
#: man-pages/man2/getitimer.2:196
msgid "The standards are silent on the meaning of the call:"
msgstr "В стандартах ничего не говорится о значении вызова:"

#. type: Plain text
#: man-pages/man2/getitimer.2:198
#, no-wrap
msgid "    setitimer(which, NULL, &old_value);\n"
msgstr "    setitimer(which, NULL, &old_value);\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:201
msgid ""
"Many systems (Solaris, the BSDs, and perhaps others)  treat this as "
"equivalent to:"
msgstr "В многих системах (Solaris, BSD и, возможно, другие) он считается эквивалентом:"

#. type: Plain text
#: man-pages/man2/getitimer.2:203
#, no-wrap
msgid "    getitimer(which, &old_value);\n"
msgstr "    getitimer(which, &old_value);\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:209
msgid ""
"In Linux, this is treated as being equivalent to a call in which the "
"I<new_value> fields are zero; that is, the timer is disabled.  I<Don't use "
"this Linux misfeature>: it is nonportable and unnecessary."
msgstr "В Linux это эквивалентно вызову, в котором поля I<new_value> равны 0, то есть таймер выключен. I<Не используйте это особенность Linux>: это непереносимо и нецелесообразно."

#. type: Plain text
#: man-pages/man2/getitimer.2:218
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an"
" event will be lost."
msgstr "Генерирование и доставка сигнала разделены, и только один экземпляр каждого сигнала, которые описаны выше, может ожидать передачи в процесс. При очень большой нагрузке, ожидание таймера B<ITIMER_REAL> может завершиться раньше чем будет доставлен сигнал о предыдущем завершении. Второй сигнал об этом событии будет потерян."

#. type: Plain text
#: man-pages/man2/getitimer.2:233
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If"
" a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux"
" 2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr "В ядрах Linux до версии 2.6.16, значения таймеров указывались в мигах. Если запрашивалась установка таймера в значение, представление в мигах которого превышало B<MAX_SEC_IN_JIFFIES> (определено в I<include/linux/jiffies.h>), то значение таймера просто урезалось до этого максимального значения. На Linux/i386 (где, начиная с Linux 2.6.13, по умолчанию миг равен 0.004 секунды), это означало, что максимальное значение таймера приблизительно равнялось 99.42 дня. Начиная с Linux 2.6.16, в ядрах стали использовать другое внутреннее представление времени, и этот предел был снят."

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: man-pages/man2/getitimer.2:240
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy"
" under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr "В некоторых системах (включая i386), ядра Linux до версии 2.6.12 содержали дефект, который при определённых условиях приводил к преждевременному завершению за один миг (jiffy). Этот дефект исправлен в ядре 2.6.12."

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: man-pages/man2/getitimer.2:259
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr "В POSIX.1-2001 сказано, что B<setitimer>() должен завершаться с ошибкой, если значение I<tv_usec> лежит вне диапазона от 0 до 999999. Однако, в ядрах до версии 2.6.21 включительно, в Linux ошибка не выдаётся, а вместо этого значение таймера просто подгоняется под соответствующие секунды. Начиная с ядра 2.6.22, это несоответствие убрано: некорректное значение I<tv_usec> приводит к ошибке B<EINVAL>."

#. type: Plain text
#: man-pages/man2/getitimer.2:265
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr "B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), B<timerfd_create>(2), B<time>(7)"

#. type: TH
#: man-pages/man2/getgroups.2:32
#, no-wrap
msgid "GETGROUPS"
msgstr "GETGROUPS"

#. type: Plain text
#: man-pages/man2/getgroups.2:35
msgid "getgroups, setgroups - get/set list of supplementary group IDs"
msgstr "getgroups, setgroups - получить/установить список дополнительных идентификаторов групп"

#. type: Plain text
#: man-pages/man2/getgroups.2:41
msgid "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"
msgstr "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"

#. type: Plain text
#: man-pages/man2/getgroups.2:43
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr "B<#include E<lt>grp.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getgroups.2:45
msgid "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"
msgstr "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"

#. type: Plain text
#: man-pages/man2/getgroups.2:56
#, no-wrap
msgid ""
"B<setgroups>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr "B<setgroups>():\nНачиная с glibc 2.19:\n_DEFAULT_SOURCE\nВ версии Glibc 2.19 и более ранних:\n_BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/getgroups.2:74
msgid ""
"B<getgroups>()  returns the supplementary group IDs of the calling process "
"in I<list>.  The argument I<size> should be set to the maximum number of "
"items that can be stored in the buffer pointed to by I<list>.  If the "
"calling process is a member of more than I<size> supplementary groups, then "
"an error results.  It is unspecified whether the effective group ID of the "
"calling process is included in the returned list.  (Thus, an application "
"should also call B<getegid>(2)  and add or remove the resulting value.)"
msgstr "Вызов B<getgroups>() возвращает идентификаторы дополнительных групп вызывающего процесса в списке I<list>. В аргументе I<size> должно быть указано максимальное количество элементов, которые можно сохранить в буфер, указанный I<list>. Если вызывающий процесс является членом в более чем I<size> дополнительных групп, то возвращается ошибка. an error results. Для него не определено, будет ли в этот список включён эффективный идентификатор группы вызывающего процесса. (То есть приложение также должно вызвать B<getegid>(2) и добавить или удалить полученное значение.)"

#. type: Plain text
#: man-pages/man2/getgroups.2:85
msgid ""
"If I<size> is zero, I<list> is not modified, but the total number of "
"supplementary group IDs for the process is returned.  This allows the caller"
" to determine the size of a dynamically allocated I<list> to be used in a "
"further call to B<getgroups>()."
msgstr "Если размер I<size> равен нулю, то список I<list> не изменяется, а просто возвращается общее количество идентификаторов дополнительных групп процесса. Это позволяет вызывающему определить размер динамически выделяемого списка I<list>, который будет использоваться при повторном вызове B<getgroups>()."

#. type: Plain text
#: man-pages/man2/getgroups.2:97
msgid ""
"B<setgroups>()  sets the supplementary group IDs for the calling process.  "
"Appropriate privileges are required (see the description of the B<EPERM> "
"error, below).  The I<size> argument specifies the number of supplementary "
"group IDs in the buffer pointed to by I<list>.  A process can drop all of "
"its supplementary groups with the call:"
msgstr "Вызов B<setgroups>() устанавливает идентификаторы дополнительных групп для вызывающего процесса. Для работы требуются права (смотрите описание ошибки B<EPERM> ниже). В аргументе I<size> задаётся количество дополнительных идентификаторов групп в буфере, указанном I<list>. Процесс может выйти из всех дополнительных группы вызвав:"

#. type: Plain text
#: man-pages/man2/getgroups.2:101
#, no-wrap
msgid "setgroups(0, NULL);\n"
msgstr "setgroups(0, NULL);\n"

#. type: Plain text
#: man-pages/man2/getgroups.2:110
msgid ""
"On success, B<getgroups>()  returns the number of supplementary group IDs.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении B<getgroups>() возвращается количество дополнительных идентификаторов. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getgroups.2:117
msgid ""
"On success, B<setgroups>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "При успешном выполнении B<setgroups>() возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getgroups.2:122
msgid "I<list> has an invalid address."
msgstr "Значение I<list> является неправильным адресом."

#. type: Plain text
#: man-pages/man2/getgroups.2:125
msgid "B<getgroups>()  can additionally fail with the following error:"
msgstr "Вызов B<getgroups>() также может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man2/getgroups.2:129
msgid ""
"I<size> is less than the number of supplementary group IDs, but is not zero."
msgstr "Значение I<size> меньше чем количество дополнительных идентификаторов групп, но не ноль."

#. type: Plain text
#: man-pages/man2/getgroups.2:132
msgid "B<setgroups>()  can additionally fail with the following errors:"
msgstr "Вызов B<setgroups>() также может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man2/getgroups.2:138
msgid ""
"I<size> is greater than B<NGROUPS_MAX> (32 before Linux 2.6.4; 65536 since "
"Linux 2.6.4)."
msgstr "Значение I<size> больше чем B<NGROUPS_MAX> (32, до Linux 2.6.4; 65536, начиная с Linux 2.6.4)."

#. type: TP
#: man-pages/man2/getgroups.2:138
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/getgroups.2:141
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: Plain text
#: man-pages/man2/getgroups.2:147
msgid ""
"The calling process has insufficient privilege (the caller does not have the"
" B<CAP_SETGID> capability in the user namespace in which it resides)."
msgstr "Вызывающий процесс не имеет достаточно прав (вызывающий не имеет мандата B<CAP_SETGID> в пользовательском пространстве имён, в котором он находится)."

#. type: TP
#: man-pages/man2/getgroups.2:147
#, no-wrap
msgid "B<EPERM> (since Linux 3.19)"
msgstr "B<EPERM> (начиная с Linux 3.19)"

#. type: Plain text
#: man-pages/man2/getgroups.2:156
msgid ""
"The use of B<setgroups>()  is denied in this user namespace.  See the "
"description of I</proc/[pid]/setgroups> in B<user_namespaces>(7)."
msgstr "Использование B<setgroups>() запрещено в этом пространстве имён user. Смотрите описание I</proc/[pid]/setgroups> в B<user_namespaces>(7)."

#. type: Plain text
#: man-pages/man2/getgroups.2:159
msgid "B<getgroups>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<getgroups>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/getgroups.2:165
msgid ""
"B<setgroups>(): SVr4, 4.3BSD.  Since B<setgroups>()  requires privilege, it "
"is not covered by POSIX.1."
msgstr "B<setgroups>(): SVr4, 4.3BSD. Так как для B<setgroups>() требуются права, она не описана в POSIX.1."

#. type: Plain text
#: man-pages/man2/getgroups.2:177
msgid ""
"A process can have up to B<NGROUPS_MAX> supplementary group IDs in addition "
"to the effective group ID.  The constant B<NGROUPS_MAX> is defined in "
"I<E<lt>limits.hE<gt>>.  The set of supplementary group IDs is inherited from"
" the parent process, and preserved across an B<execve>(2)."
msgstr "Процесс может иметь, как минимум, B<NGROUPS_MAX> дополнительных идентификаторов групп в дополнении к эффективному идентификатору группы. Константа B<NGROUPS_MAX> определена в I<E<lt>limits.hE<gt>>. Список дополнительных идентификаторов групп наследуется из родительского процесса и сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/getgroups.2:180
msgid ""
"The maximum number of supplementary group IDs can be found at run time using"
" B<sysconf>(3):"
msgstr "Максимальное количество дополнительных идентификаторов групп можно выяснить с помощью B<sysconf>(3):"

#. type: Plain text
#: man-pages/man2/getgroups.2:185
#, no-wrap
msgid ""
"long ngroups_max;\n"
"ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"
msgstr "long ngroups_max;\nngroups_max = sysconf(_SC_NGROUPS_MAX);\n"

#. type: Plain text
#: man-pages/man2/getgroups.2:194
msgid ""
"The maximum return value of B<getgroups>()  cannot be larger than one more "
"than this value.  Since Linux 2.6.4, the maximum number of supplementary "
"group IDs is also exposed via the Linux-specific read-only file, "
"I</proc/sys/kernel/ngroups_max>."
msgstr "Максимальное значение, возвращаемое B<getgroups>(), не может быть больше чем на единицу значения, полученного данным способом. Начиная с Linux 2.6.4, максимальное количество идентификаторов дополнительных групп также видимо через специальный файл Linux, доступный только для чтения — I</proc/sys/kernel/ngroups_max>."

#. type: Plain text
#: man-pages/man2/getgroups.2:205
msgid ""
"The original Linux B<getgroups>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<getgroups32>(), supporting 32-bit IDs."
"  The glibc B<getgroups>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr "Первоначальная версия системного вызова B<getgroups>() в Linux поддерживала только 16-битные идентификаторы групп. Позднее в Linux 2.4 был добавлен вызов B<getgroups32>(), поддерживающий 32-битные идентификаторы. В glibc обёрточная функция B<getgroups>() работает одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getgroups.2:219
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgroups>())  employ a signal-based technique to ensure that when"
" one thread changes credentials, all of the other threads in the process "
"also change their credentials.  For details, see B<nptl>(7)."
msgstr "На уровне ядра ID пользователя и группы являются атрибутами нити. Однако в POSIX требуется, чтобы все нити в процессе имели одинаковые права. В реализации нитей NPTL требования POSIX реализованы через обёрточные функции для различных системных вызовов, которые изменяют UID и GID процесса. В этих функциях (включая и для B<setgroups>()) используется алгоритмы на основе сигналов, которые следят за тем, что когда у одной нити изменяются права, эти изменения выполняются и для остальных нитей процесса. Подробное описание смотрите в B<nptl>(7)."

#. type: Plain text
#: man-pages/man2/getgroups.2:226
msgid ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<group_member>(3), "
"B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"
msgstr "B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<group_member>(3), B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/gethostname.2:32
#, no-wrap
msgid "GETHOSTNAME"
msgstr "GETHOSTNAME"

#. type: Plain text
#: man-pages/man2/gethostname.2:35
msgid "gethostname, sethostname - get/set hostname"
msgstr "gethostname, sethostname - получить/установить имя узла"

#. type: Plain text
#: man-pages/man2/gethostname.2:39
msgid "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/gethostname.2:41
msgid "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/gethostname.2:50
msgid "B<gethostname>():"
msgstr "B<gethostname>():"

#. type: Plain text
#: man-pages/man2/gethostname.2:53
msgid "Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "Начиная с glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man2/gethostname.2:55
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "|| /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/gethostname.2:58
msgid "B<sethostname>():"
msgstr "B<sethostname>():"

#. 		commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: man-pages/man2/gethostname.2:66
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr "    начиная с glibc 2.21:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и 2.20:\n        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n    до glibc 2.19, включительно:\n        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"

#. type: Plain text
#: man-pages/man2/gethostname.2:72
msgid ""
"These system calls are used to access or to change the hostname of the "
"current processor."
msgstr "Эти системные вызовы используются для доступа или изменения имени узла текущего процессора."

#. type: Plain text
#: man-pages/man2/gethostname.2:83
msgid ""
"B<sethostname>()  sets the hostname to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr "Вызов B<sethostname>() устанавливает имя узла равны значению, указанному в массиве символов I<name>. Аргумент I<len> определяет количество байт в I<name>. (Таким образом, I<name> не требует наличия завершающего байта с null.)"

#. type: Plain text
#: man-pages/man2/gethostname.2:95
msgid ""
"B<gethostname>()  returns the null-terminated hostname in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"hostname is too large to fit, then the name is truncated, and no error is "
"returned (but see NOTES below).  POSIX.1 says that if such truncation "
"occurs, then it is unspecified whether the returned buffer includes a "
"terminating null byte."
msgstr "B<gethostname>() возвращает имя узла с null на конце в массиве символов I<name> длиной I<len> байт. Если имя узла, оканчивающееся null, не помещается, то имя обрезается и ошибки не происходит (но смотрите ЗАМЕЧАНИЯ далее). В POSIX.1 сказано, что если обрезание произошло, то неясно, будет ли буфер содержать завершающий байт с null."

#. type: Plain text
#: man-pages/man2/gethostname.2:105
msgid "I<name> is an invalid address."
msgstr "I<name> является неправильным адресом. "

#.  Can't occur for gethostbyname() wrapper, since 'len' has an
#.  unsigned type; can occur for the underlying system call.
#. type: Plain text
#: man-pages/man2/gethostname.2:115
msgid ""
"I<len> is negative or, for B<sethostname>(), I<len> is larger than the "
"maximum allowed size."
msgstr "I<len> имеет отрицательное значение или для B<sethostname>() длина I<len> больше, чем максимально допустимое значение."

#. type: TP
#: man-pages/man2/gethostname.2:115
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/gethostname.2:123
msgid ""
"(glibc B<gethostname>())  I<len> is smaller than the actual size.  (Before "
"version 2.1, glibc uses B<EINVAL> for this case.)"
msgstr "(B<gethostname>() из glibc) I<len> меньше чем реальный размер. (До версии 2.1, glibc возвращала в этом случае B<EINVAL>.)"

#. type: Plain text
#: man-pages/man2/gethostname.2:131
msgid ""
"For B<sethostname>(), the caller did not have the B<CAP_SYS_ADMIN> "
"capability in the user namespace associated with its UTS namespace (see "
"B<namespaces>(7))."
msgstr "Для работы с B<sethostname>() у вызывающего нет мандата B<CAP_SYS_ADMIN> в пользовательском пространстве имён, связанном с его пространством имён UTS (смотрите B<namespaces>(7))."

#. type: Plain text
#: man-pages/man2/gethostname.2:137
msgid ""
"SVr4, 4.4BSD (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 and "
"POSIX.1-2008 specify B<gethostname>()  but not B<sethostname>()."
msgstr "SVr4, 4.4BSD (данная функция впервые появилась в 4.2BSD). В POSIX.1-2001 и POSIX.1-2008 определена B<gethostname>(), но нет B<sethostname>()."

#. type: Plain text
#: man-pages/man2/gethostname.2:147
msgid ""
"SUSv2 guarantees that \"Host names are limited to 255 bytes\".  POSIX.1 "
"guarantees that \"Host names (not including the terminating null byte) are "
"limited to B<HOST_NAME_MAX> bytes\".  On Linux, B<HOST_NAME_MAX> is defined "
"with the value 64, which has been the limit since Linux 1.0 (earlier kernels"
" imposed a limit of 8 bytes)."
msgstr "SUSv2 гарантирует, что «Длина имени узла ограничена 255-ю байтами». POSIX.1 гарантирует, что «Длина имени узла (не включая завершающий нулевой символ) ограничена B<HOST_NAME_MAX> байтами».  В Linux значение B<HOST_NAME_MAX> равно 64, которое было урезано начиная с Linux 1.0 (ранние версии имели предел в 8 байт)."

#. type: Plain text
#: man-pages/man2/gethostname.2:170
msgid ""
"The GNU C library does not employ the B<gethostname>()  system call; "
"instead, it implements B<gethostname>()  as a library function that calls "
"B<uname>(2)  and copies up to I<len> bytes from the returned I<nodename> "
"field into I<name>.  Having performed the copy, the function then checks if "
"the length of the I<nodename> was greater than or equal to I<len>, and if it"
" is, then the function returns -1 with I<errno> set to B<ENAMETOOLONG>; in "
"this case, a terminating null byte is not included in the returned I<name>."
msgstr "Библиотека GNU C library не использует системный вызов B<gethostname>(); вместо этого B<gethostname>() в ней реализован в виде библиотечной функции, которая вызывает B<uname>(2) и копирует до I<len> байт в I<name> из возвращаемого поля I<nodename>. Выполнив копирование, функция проверяет, что длина I<nodename> не больше или равна I<len>, и если это обнаруживается, то функция возвращает -1, устанавливая значение  I<errno> равным B<ENAMETOOLONG>; в этом случае в возвращаемое значение I<name> завершающий null не добавляется."

#.  At least glibc 2.0 and 2.1, older versions not checked
#. type: Plain text
#: man-pages/man2/gethostname.2:183
msgid ""
"Versions of glibc before 2.2 handle the case where the length of the "
"I<nodename> was greater than or equal to I<len> differently: nothing is "
"copied into I<name> and the function returns -1 with I<errno> set to "
"B<ENAMETOOLONG>."
msgstr "Версии glibc до 2.2 обрабатывали случай превышения длины I<nodename> по другому: ничего не копировалось в I<name> и функция возвращала -1, устанавливая I<errno> равным B<ENAMETOOLONG>."

#. type: Plain text
#: man-pages/man2/gethostname.2:187
msgid "B<hostname>(1), B<getdomainname>(2), B<setdomainname>(2), B<uname>(2)"
msgstr "B<hostname>(1), B<getdomainname>(2), B<setdomainname>(2), B<uname>(2)"

#. type: TH
#: man-pages/man2/getpagesize.2:25
#, no-wrap
msgid "GETPAGESIZE"
msgstr "GETPAGESIZE"

#. type: Plain text
#: man-pages/man2/getpagesize.2:28
msgid "getpagesize - get memory page size"
msgstr "getpagesize - определяет размер страницы памяти"

#. type: Plain text
#: man-pages/man2/getpagesize.2:32
msgid "B<int getpagesize(void);>"
msgstr "B<int getpagesize(void);>"

#. type: Plain text
#: man-pages/man2/getpagesize.2:39
msgid "B<getpagesize>():"
msgstr "B<getpagesize>():"

#. type: TP
#: man-pages/man2/getpagesize.2:42
#, no-wrap
msgid "Since glibc 2.19:"
msgstr "Начиная с glibc 2.19:"

#. type: Plain text
#: man-pages/man2/getpagesize.2:46
#, no-wrap
msgid "_DEFAULT_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr "_DEFAULT_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#. type: Plain text
#: man-pages/man2/getpagesize.2:49
msgid "From glibc 2.12 to 2.19:"
msgstr "В glibc с 2.12 по 2.19:"

#. type: Plain text
#: man-pages/man2/getpagesize.2:51
#, no-wrap
msgid "_BSD_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr "_BSD_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/getpagesize.2:56
msgid "Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "До glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#.  .SH HISTORY
#.  This call first appeared in 4.2BSD.
#. type: Plain text
#: man-pages/man2/getpagesize.2:68
msgid ""
"The function B<getpagesize>()  returns the number of bytes in a memory page,"
" where \"page\" is a fixed-length block, the unit for memory allocation and "
"file mapping performed by B<mmap>(2)."
msgstr "Вызов B<getpagesize>() возвращает количество байтов в странице памяти, где «страница» представляет собой блок фиксированной длины, единица измерения при выделения памяти и файлового отображения, выполняемого с помощью B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/getpagesize.2:75
msgid ""
"SVr4, 4.4BSD, SUSv2.  In SUSv2 the B<getpagesize>()  call is labeled LEGACY,"
" and in POSIX.1-2001 it has been dropped; HP-UX does not have this call."
msgstr "SVr4, 4.4BSD, SUSv2. В SUSv2 вызов B<getpagesize>() отмечен как УСТАРЕВШИЙ, и был удалён из POSIX.1-2001; в HP-UX такого вызова нет."

#. type: Plain text
#: man-pages/man2/getpagesize.2:80
msgid ""
"Portable applications should employ I<sysconf(_SC_PAGESIZE)> instead of "
"B<getpagesize>():"
msgstr "В переносимых программах вместо B<getpagesize>() следует использовать I<sysconf(_SC_PAGESIZE)>:"

#. type: Plain text
#: man-pages/man2/getpagesize.2:85
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"
msgstr "#include E<lt>unistd.hE<gt>\nlong sz = sysconf(_SC_PAGESIZE);\n"

#. type: Plain text
#: man-pages/man2/getpagesize.2:92
msgid "(Most systems allow the synonym B<_SC_PAGE_SIZE> for B<_SC_PAGESIZE>.)"
msgstr "(большинство систем позволяют использовать B<_SC_PAGE_SIZE> вместо B<_SC_PAGESIZE>.)"

#. type: Plain text
#: man-pages/man2/getpagesize.2:112
msgid ""
"Whether B<getpagesize>()  is present as a Linux system call depends on the "
"architecture.  If it is, it returns the kernel symbol B<PAGE_SIZE>, whose "
"value depends on the architecture and machine model.  Generally, one uses "
"binaries that are dependent on the architecture but not on the machine "
"model, in order to have a single binary distribution per architecture.  This"
" means that a user program should not find B<PAGE_SIZE> at compile time from"
" a header file, but use an actual system call, at least for those "
"architectures (like sun4) where this dependency exists.  Here glibc 2.0 "
"fails because its B<getpagesize>()  returns a statically derived value, and "
"does not use a system call.  Things are OK in glibc 2.1."
msgstr "В Linux системный вызов B<getpagesize>() есть не на всех архитектурах. Если он есть, то он возвращает символ ядра B<PAGE_SIZE>, чьё значение зависит от архитектуры и модели компьютера. Как правило, создаваемые двоичные файлы используются для всей архитектуры, а не для конкретной одной модели. Поэтому рекомендуется определять B<PAGE_SIZE> не на стадии компиляции из файла заголовка, а при выполнении программы с помощью данной функции, по крайней мере на тех архитектурах (таких как sun), где зависимость от модели существует. В этом случае в библиотечные вызовы glibc 2.0 завершатся неудачно, так как её B<getpagesize>() возвращает статически определённое значение и не использует системный вызов. В glibc 2.1 это исправлено."

#. type: Plain text
#: man-pages/man2/getpagesize.2:114
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr "B<mmap>(2), B<sysconf>(3)"

#. type: TH
#: man-pages/man2/getrusage.2:39
#, no-wrap
msgid "GETRUSAGE"
msgstr "GETRUSAGE"

#. type: Plain text
#: man-pages/man2/getrusage.2:42
msgid "getrusage - get resource usage"
msgstr "getrusage - считывает использованные ресурсы"

#. type: Plain text
#: man-pages/man2/getrusage.2:48
msgid "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"
msgstr "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"

#. type: Plain text
#: man-pages/man2/getrusage.2:54
msgid ""
"B<getrusage>()  returns resource usage measures for I<who>, which can be one"
" of the following:"
msgstr "B<getrusage>() возвращает текущие ограничения на ресурсы для значения I<who>, которое может быть:"

#. type: TP
#: man-pages/man2/getrusage.2:54
#, no-wrap
msgid "B<RUSAGE_SELF>"
msgstr "B<RUSAGE_SELF>"

#. type: Plain text
#: man-pages/man2/getrusage.2:58
msgid ""
"Return resource usage statistics for the calling process, which is the sum "
"of resources used by all threads in the process."
msgstr "Возвращает статистику по использованию ресурсов вызывающим процессом (суммируются значения всех нитей процесса)."

#. type: TP
#: man-pages/man2/getrusage.2:58
#, no-wrap
msgid "B<RUSAGE_CHILDREN>"
msgstr "B<RUSAGE_CHILDREN>"

#. type: Plain text
#: man-pages/man2/getrusage.2:65
msgid ""
"Return resource usage statistics for all children of the calling process "
"that have terminated and been waited for.  These statistics will include the"
" resources used by grandchildren, and further removed descendants, if all of"
" the intervening descendants waited on their terminated children."
msgstr "Возвращает статистику по использованию ресурсов всех потомков вызывающего процесса, которые завершились или завершение которых ожидается. Эта статистика включает в себя ресурсы, использованные внучками и дальнейшими потомками, если все промежуточные потомки завершились или их завершение ожидается."

#. type: TP
#: man-pages/man2/getrusage.2:65
#, no-wrap
msgid "B<RUSAGE_THREAD> (since Linux 2.6.26)"
msgstr "B<RUSAGE_THREAD> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/getrusage.2:75
msgid ""
"Return resource usage statistics for the calling thread.  The B<_GNU_SOURCE>"
" feature test macro must be defined (before including I<any> header file)  "
"in order to obtain the definition of this constant from "
"I<E<lt>sys/resource.hE<gt>>."
msgstr "Возвращает статистику по использованию ресурсов вызывающей нити. Чтобы получить определение этой константы из I<E<lt>sys/resource.hE<gt>> должен быть определён макрос тестирования свойств B<_GNU_SOURCE> (до включения всех заголовочных файлов)."

#. type: Plain text
#: man-pages/man2/getrusage.2:79
msgid ""
"The resource usages are returned in the structure pointed to by I<usage>, "
"which has the following form:"
msgstr "Данные по использованным ресурсам возвращаются в структуре, на которую указывает I<usage>; она имеет следующий вид:"

#. type: Plain text
#: man-pages/man2/getrusage.2:100
#, no-wrap
msgid ""
"struct rusage {\n"
"    struct timeval ru_utime; /* user CPU time used */\n"
"    struct timeval ru_stime; /* system CPU time used */\n"
"    long   ru_maxrss;        /* maximum resident set size */\n"
"    long   ru_ixrss;         /* integral shared memory size */\n"
"    long   ru_idrss;         /* integral unshared data size */\n"
"    long   ru_isrss;         /* integral unshared stack size */\n"
"    long   ru_minflt;        /* page reclaims (soft page faults) */\n"
"    long   ru_majflt;        /* page faults (hard page faults) */\n"
"    long   ru_nswap;         /* swaps */\n"
"    long   ru_inblock;       /* block input operations */\n"
"    long   ru_oublock;       /* block output operations */\n"
"    long   ru_msgsnd;        /* IPC messages sent */\n"
"    long   ru_msgrcv;        /* IPC messages received */\n"
"    long   ru_nsignals;      /* signals received */\n"
"    long   ru_nvcsw;         /* voluntary context switches */\n"
"    long   ru_nivcsw;        /* involuntary context switches */\n"
"};\n"
msgstr "struct rusage {\n    struct timeval ru_utime; /* время ЦП, исполь. в режиме пользователя */\n    struct timeval ru_stime; /* время ЦП, исполь. в режиме системы */\n    long   ru_maxrss;        /* максимальный rss */\n    long   ru_ixrss;         /* полный объём общей памяти */\n    long   ru_idrss;         /* полный объём собственной памяти */\n    long   ru_isrss;         /* полный объём собственного стека */\n    long   ru_minflt;        /* количество восстановленных страниц\n                                (мягких отказов) */\n    long   ru_majflt;        /* количество отказавших страниц\n                                (жёстких отказов) */\n    long   ru_nswap;         /* количество обращений при подкачке */\n    long   ru_inblock;       /* количество операций блокового ввода */\n    long   ru_oublock;       /* количество операций блокового вывода */\n    long   ru_msgsnd;        /* количество посланных сообщений IPC */\n    long   ru_msgrcv;        /* количество принятых сообщений IPC */\n    long   ru_nsignals;      /* количество принятых сигналов */\n    long   ru_nvcsw;         /* количество переключений контекста */\n    long   ru_nivcsw;        /* кол-во принудительных переключений контекста */\n};\n"

#. type: Plain text
#: man-pages/man2/getrusage.2:108
msgid ""
"Not all fields are completed; unmaintained fields are set to zero by the "
"kernel.  (The unmaintained fields are provided for compatibility with other "
"systems, and because they may one day be supported on Linux.)  The fields "
"are interpreted as follows:"
msgstr "Не все поля заполняются; несопровождаемые поля устанавливаются ядром в ноль. (Несопровождаемые поля предоставляются для совместимости с другими системами, и когда-нибудь станут поддерживаться в Linux.) Поля следует понимать так:"

#. type: TP
#: man-pages/man2/getrusage.2:108
#, no-wrap
msgid "I<ru_utime>"
msgstr "I<ru_utime>"

#. type: Plain text
#: man-pages/man2/getrusage.2:114
msgid ""
"This is the total amount of time spent executing in user mode, expressed in "
"a I<timeval> structure (seconds plus microseconds)."
msgstr "Общее количество времени, проведённое в режиме пользователя, выражается структурой I<timeval> (секунды и микросекунды)."

#. type: TP
#: man-pages/man2/getrusage.2:114
#, no-wrap
msgid "I<ru_stime>"
msgstr "I<ru_stime>"

#. type: Plain text
#: man-pages/man2/getrusage.2:120
msgid ""
"This is the total amount of time spent executing in kernel mode, expressed "
"in a I<timeval> structure (seconds plus microseconds)."
msgstr "Общее количество времени, проведённое в режиме ядра, выражается структурой I<timeval> (секунды и микросекунды)."

#. type: TP
#: man-pages/man2/getrusage.2:120
#, no-wrap
msgid "I<ru_maxrss> (since Linux 2.6.32)"
msgstr "I<ru_maxrss> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/getrusage.2:127
msgid ""
"This is the maximum resident set size used (in kilobytes).  For "
"B<RUSAGE_CHILDREN>, this is the resident set size of the largest child, not "
"the maximum resident set size of the process tree."
msgstr "Максимальный используемый размер постоянно занимаемый в памяти (в килобайтах). Для B<RUSAGE_CHILDREN> определяется наибольший размер постоянной памяти среди потомков, а не максимальный размер постоянной памяти всего дерева процесса."

#. type: TP
#: man-pages/man2/getrusage.2:127
#, no-wrap
msgid "I<ru_ixrss> (unmaintained)"
msgstr "I<ru_ixrss> (не ведётся)"

#.  On some systems, this field records the number of signals received.
#. type: Plain text
#: man-pages/man2/getrusage.2:133 man-pages/man2/getrusage.2:138
#: man-pages/man2/getrusage.2:143 man-pages/man2/getrusage.2:155
#: man-pages/man2/getrusage.2:167 man-pages/man2/getrusage.2:173
#: man-pages/man2/getrusage.2:177
msgid "This field is currently unused on Linux."
msgstr "В настоящее время в Linux не учитывается."

#. type: TP
#: man-pages/man2/getrusage.2:133
#, no-wrap
msgid "I<ru_idrss> (unmaintained)"
msgstr "I<ru_idrss> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:138
#, no-wrap
msgid "I<ru_isrss> (unmaintained)"
msgstr "I<ru_isrss> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:143
#, no-wrap
msgid "I<ru_minflt>"
msgstr "I<ru_minflt>"

#. type: Plain text
#: man-pages/man2/getrusage.2:148
msgid ""
"The number of page faults serviced without any I/O activity; here I/O "
"activity is avoided by ``reclaiming'' a page frame from the list of pages "
"awaiting reallocation."
msgstr "Количество сбойных страниц, обслуженных без операций ввода-вывода; в данном случае страницы «восстановлены» из списка страниц, ожидающих перемещения."

#. type: TP
#: man-pages/man2/getrusage.2:148
#, no-wrap
msgid "I<ru_majflt>"
msgstr "I<ru_majflt>"

#. type: Plain text
#: man-pages/man2/getrusage.2:151
msgid "The number of page faults serviced that required I/O activity."
msgstr "Количество сбойных страниц, обслуженных с помощью операций ввода-вывода."

#. type: TP
#: man-pages/man2/getrusage.2:151
#, no-wrap
msgid "I<ru_nswap> (unmaintained)"
msgstr "I<ru_nswap> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:155
#, no-wrap
msgid "I<ru_inblock> (since Linux 2.6.22)"
msgstr "I<ru_inblock> (начиная с Linux 2.6.22)"

#. type: Plain text
#: man-pages/man2/getrusage.2:158
msgid "The number of times the filesystem had to perform input."
msgstr "Количество обращений на чтение из файловой системы."

#. type: TP
#: man-pages/man2/getrusage.2:158
#, no-wrap
msgid "I<ru_oublock> (since Linux 2.6.22)"
msgstr "I<ru_oublock> (начиная с Linux 2.6.22)"

#. type: Plain text
#: man-pages/man2/getrusage.2:161
msgid "The number of times the filesystem had to perform output."
msgstr "Количество обращений на запись в файловую систему."

#. type: TP
#: man-pages/man2/getrusage.2:161
#, no-wrap
msgid "I<ru_msgsnd> (unmaintained)"
msgstr "I<ru_msgsnd> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:167
#, no-wrap
msgid "I<ru_msgrcv> (unmaintained)"
msgstr "I<ru_msgrcv> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:173
#, no-wrap
msgid "I<ru_nsignals> (unmaintained)"
msgstr "I<ru_nsignals> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:177
#, no-wrap
msgid "I<ru_nvcsw> (since Linux 2.6)"
msgstr "I<ru_nvcsw> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man2/getrusage.2:182
msgid ""
"The number of times a context switch resulted due to a process voluntarily "
"giving up the processor before its time slice was completed (usually to "
"await availability of a resource)."
msgstr "Количество переключений контекста в следствии добровольной отдачи процессом процессора до того, как истёк его рабочий временной интервал (обычно, из-за ожидания доступности ресурса)."

#. type: TP
#: man-pages/man2/getrusage.2:182
#, no-wrap
msgid "I<ru_nivcsw> (since Linux 2.6)"
msgstr "I<ru_nivcsw> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man2/getrusage.2:187
msgid ""
"The number of times a context switch resulted due to a higher priority "
"process becoming runnable or because the current process exceeded its time "
"slice."
msgstr "Количество переключений контекста в следствии вытеснения процессом с более высоким приоритетом или из-за истечения рабочего временного интервала процесса."

#. type: Plain text
#: man-pages/man2/getrusage.2:198
msgid "I<usage> points outside the accessible address space."
msgstr "I<usage> указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/getrusage.2:202
msgid "I<who> is invalid."
msgstr "Неверное значение I<who>."

#. type: tbl table
#: man-pages/man2/getrusage.2:212
#, no-wrap
msgid "B<getrusage>()"
msgstr "B<getrusage>()"

#. type: Plain text
#: man-pages/man2/getrusage.2:223
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX.1 specifies B<getrusage>(),"
" but specifies only the fields I<ru_utime> and I<ru_stime>."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD. В POSIX.1 определён вызов B<getrusage>(), но указаны только поля I<ru_utime> и I<ru_stime>."

#. type: Plain text
#: man-pages/man2/getrusage.2:226
msgid "B<RUSAGE_THREAD> is Linux-specific."
msgstr "B<RUSAGE_THREAD> есть только в Linux."

#. type: Plain text
#: man-pages/man2/getrusage.2:229
msgid "Resource usage metrics are preserved across an B<execve>(2)."
msgstr "Значения использованных ресурсов сохраняются при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/getrusage.2:237
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<struct timeval> is defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr "Включать I<E<lt>sys/time.hE<gt>> в настоящее время не требуется, но это увеличивает переносимость. (Хотя I<struct timeval> определена в I<E<lt>sys/time.hE<gt>>.)"

#.  See the description of getrusage() in XSH.
#.  A similar statement was also in SUSv2.
#. type: Plain text
#: man-pages/man2/getrusage.2:249
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN> then the resource usages of child processes are "
"automatically included in the value returned by B<RUSAGE_CHILDREN>, although"
" POSIX.1-2001 explicitly prohibits this.  This nonconformance is rectified "
"in Linux 2.6.9 and later."
msgstr "В ядрах Linux до версии 2.6.9, если значение B<SIGCHLD> равно B<SIG_IGN>, то использованные ресурсы потомков процессов автоматически включаются в значение, возвращаемое B<RUSAGE_CHILDREN>, хотя в POSIX.1-2001 это явно запрещено. Это несоответствие исправлено в Linux 2.6.9 и более новых версиях."

#. type: Plain text
#: man-pages/man2/getrusage.2:252
msgid ""
"The structure definition shown at the start of this page was taken from "
"4.3BSD Reno."
msgstr "Определение структуры, показанное в начале страницы, взято из 4.3BSD Reno."

#. type: Plain text
#: man-pages/man2/getrusage.2:261
msgid ""
"Ancient systems provided a B<vtimes>()  function with a similar purpose to "
"B<getrusage>().  For backward compatibility, glibc also provides "
"B<vtimes>().  All new applications should be written using B<getrusage>()."
msgstr "В старых системах была функция B<vtimes>() с подобным B<getrusage>() назначением. Для обратной совместимости в glibc также есть функция B<vtimes>(). Во всех новых приложениях должен быть использован B<getrusage>()."

#. type: Plain text
#: man-pages/man2/getrusage.2:266
msgid "See also the description of I</proc/[pid]/stat> in B<proc>(5)."
msgstr "Смотрите также описание I</proc/[pid]/stat> в B<proc>(5)."

#. type: Plain text
#: man-pages/man2/getrusage.2:272
msgid ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"
msgstr "B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), B<clock>(3)"

#. type: TH
#: man-pages/man2/gettimeofday.2:40
#, no-wrap
msgid "GETTIMEOFDAY"
msgstr "GETTIMEOFDAY"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:43
msgid "gettimeofday, settimeofday - get / set time"
msgstr "gettimeofday, settimeofday - получает/устанавливает время"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:48
#, no-wrap
msgid ""
"B<int gettimeofday(struct timeval *>I<tv>B<, struct timezone *>I<tz>B<);>\n"
msgstr "B<int gettimeofday(struct timeval *>I<tv>B<, struct timezone *>I<tz>B<);>\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:51
#, no-wrap
msgid ""
"B<int settimeofday(const struct timeval *>I<tv>B<, const struct timezone "
"*>I<tz>B<);>\n"
msgstr "B<int settimeofday(const struct timeval *>I<tv>B<, const struct timezone *>I<tz>B<);>\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:63
#, no-wrap
msgid ""
"B<settimeofday>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr "B<settimeofday>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:75
msgid ""
"The functions B<gettimeofday>()  and B<settimeofday>()  can get and set the "
"time as well as a timezone.  The I<tv> argument is a I<struct timeval> (as "
"specified in I<E<lt>sys/time.hE<gt>>):"
msgstr "Функция B<gettimeofday>() и B<settimeofday>() позволяют получить и задать время, а также часовой пояс. Аргумент I<tv> имеет тип I<struct timeval> (определён в I<E<lt>sys/time.hE<gt>>):"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:82
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;     /* seconds */\n"
"    suseconds_t tv_usec;    /* microseconds */\n"
"};\n"
msgstr "struct timeval {\n    time_t      tv_sec;     /* секунды */\n    suseconds_t tv_usec;    /* микросекунды */\n};\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:91
msgid ""
"and gives the number of seconds and microseconds since the Epoch (see "
"B<time>(2)).  The I<tz> argument is a I<struct timezone>:"
msgstr "и задаёт количество секунд и микросекунд, прошедших с начала эпохи (см. B<time>(2)). Аргумент I<tz> имеет тип I<struct timezone>:"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:98
#, no-wrap
msgid ""
"struct timezone {\n"
"    int tz_minuteswest;     /* minutes west of Greenwich */\n"
"    int tz_dsttime;         /* type of DST correction */\n"
"};\n"
msgstr "struct timezone {\n    int tz_minuteswest;     /* количество минут западнее Гринвича */\n    int tz_dsttime;         /* тип корректировки DST */\n};\n"

#.  FIXME . The compilation warning looks to be going away in 2.17
#.  see glibc commit 4b7634a5e03b0da6f8875de9d3f74c1cf6f2a6e8
#.  The following is covered under EPERM below:
#.  .PP
#.  Only the superuser may use
#.  .BR settimeofday ().
#. type: Plain text
#: man-pages/man2/gettimeofday.2:115
msgid ""
"If either I<tv> or I<tz> is NULL, the corresponding structure is not set or "
"returned.  (However, compilation warnings will result if I<tv> is NULL.)"
msgstr "Если I<tv> или I<tz> имеют значение NULL, то соответствующая структура не задана и не будет возвращена (однако при компиляции будут выдаваться предупреждения, если I<tv> равно NULL)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:122
msgid ""
"The use of the I<timezone> structure is obsolete; the I<tz> argument should "
"normally be specified as NULL.  (See NOTES below.)"
msgstr "Пользоваться структурой I<timezone> не рекомендуется; значением аргумента I<tz> в большинстве случаев должен быть NULL (см. ЗАМЕЧАНИЯ далее)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:141
msgid ""
"Under Linux, there are some peculiar \"warp clock\" semantics associated "
"with the B<settimeofday>()  system call if on the very first call (after "
"booting)  that has a non-NULL I<tz> argument, the I<tv> argument is NULL and"
" the I<tz_minuteswest> field is nonzero.  (The I<tz_dsttime> field should be"
" zero for this case.)  In such a case it is assumed that the CMOS clock is "
"on local time, and that it has to be incremented by this amount to get UTC "
"system time.  No doubt it is a bad idea to use this feature."
msgstr "В Linux существует специфическое понятие «временной сдвиг» (warp clock), связанное с системным вызовом B<settimeofday>(), который образуется при самом первом вызове (после загрузки), если аргумент I<tz> не равен NULL, аргумент I<tv> равен NULL и поле I<tz_minuteswest> не равно нулю (в этом случае значение поля I<tz_dsttime> должно быть равно нулю). В этом случае предполагается, что время аппаратных часов (CMOS clock) местное и к нему должен быть добавлен этот параметр для того, чтобы получилось время UTC. Но, как мы и говорили, использовать этот метод не рекомендуется."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:148
msgid ""
"B<gettimeofday>()  and B<settimeofday>()  return 0 for success, or -1 for "
"failure (in which case I<errno> is set appropriately)."
msgstr "При успешном выполнении B<gettimeofday>() и B<settimeofday>() возвращают 0, или -1 в случае ошибки (I<errno> устанавливается в соответствующее значение)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:156
msgid "One of I<tv> or I<tz> pointed outside the accessible address space."
msgstr "Одно из значений в I<tv> или I<tz> находится вне доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:161
msgid "(B<settimeofday>()): I<timezone> is invalid."
msgstr "(B<settimeofday>()): неверное значение I<timezone>."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:168
msgid ""
"(B<settimeofday>()): I<tv.tv_sec> is negative or I<tv.tv_usec> is outside "
"the range [0..999,999]."
msgstr "(B<settimeofday>()): I<tv.tv_sec> отрицательно или I<tv.tv_usec> вне диапазона [0..999,999]."

#. type: TP
#: man-pages/man2/gettimeofday.2:168
#, no-wrap
msgid "B<EINVAL> (since Linux 4.3)"
msgstr "B<EINVAL> (начиная с Linux 4.3)"

#.  commit e1d7ba8735551ed79c7a0463a042353574b96da3
#. type: Plain text
#: man-pages/man2/gettimeofday.2:177
msgid ""
"(B<settimeofday>()): An attempt was made to set the time to a value less "
"than the current value of the B<CLOCK_MONOTONIC> clock (see "
"B<clock_gettime>(2))."
msgstr "(B<settimeofday>()): выполнялась попытка установки времени в значение меньше текущего значения часов B<CLOCK_MONOTONIC> (смотрите B<clock_gettime>(2))."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:184
msgid ""
"The calling process has insufficient privilege to call B<settimeofday>(); "
"under Linux the B<CAP_SYS_TIME> capability is required."
msgstr "У вызывающего процесса недостаточно прав для вызова B<settimeofday>(); в Linux для этого требуется мандат B<CAP_SYS_TIME>."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:195
msgid ""
"SVr4, 4.3BSD.  POSIX.1-2001 describes B<gettimeofday>()  but not "
"B<settimeofday>().  POSIX.1-2008 marks B<gettimeofday>()  as obsolete, "
"recommending the use of B<clock_gettime>(2)  instead."
msgstr "SVr4, 4.3BSD. В POSIX.1-2001 описан B<gettimeofday>(), но нет B<settimeofday>(). В POSIX.1-2008 вызов B<gettimeofday>() помечен как устаревший, вместо него рекомендуется использовать B<clock_gettime>(2)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:203
msgid ""
"The time returned by B<gettimeofday>()  I<is> affected by discontinuous "
"jumps in the system time (e.g., if the system administrator manually changes"
" the system time).  If you need a monotonically increasing clock, see "
"B<clock_gettime>(2)."
msgstr "На время, возвращаемое B<gettimeofday>(), I<влияют> скачки в системном времени (например, если системный администратор вручную изменил системное время). Если вам требуются однообразно увеличивающееся время, смотрите B<clock_gettime>(2)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:208
msgid ""
"Macros for operating on I<timeval> structures are described in "
"B<timeradd>(3)."
msgstr "Для работы со структурой I<timeval> существуют макросы, описанные в B<timeradd>(3)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:214
msgid "Traditionally, the fields of I<struct timeval> were of type I<long>."
msgstr "Обычно, поля I<struct timeval> имеют тип I<long>."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:220
msgid ""
"On some architectures, an implementation of B<gettimeofday>()  is provided "
"in the B<vdso>(7)."
msgstr "На некоторых архитектурах реализация B<gettimeofday>() находится в B<vdso>(7)."

#. type: SS
#: man-pages/man2/gettimeofday.2:220
#, no-wrap
msgid "The tz_dsttime field"
msgstr "Поле tz_dsttime"

#.  it has not
#.  been and will not be supported by libc or glibc.
#.  Each and every occurrence of this field in the kernel source
#.  (other than the declaration) is a bug.
#. type: Plain text
#: man-pages/man2/gettimeofday.2:245
msgid ""
"On a non-Linux kernel, with glibc, the I<tz_dsttime> field of I<struct "
"timezone> will be set to a nonzero value by B<gettimeofday>()  if the "
"current timezone has ever had or will have a daylight saving rule applied.  "
"In this sense it exactly mirrors the meaning of B<daylight>(3)  for the "
"current zone.  On Linux, with glibc, the setting of the I<tz_dsttime> field "
"of I<struct timezone> has never been used by B<settimeofday>()  or "
"B<gettimeofday>().  Thus, the following is purely of historical interest."
msgstr "В системах с не ядрами Linux, но с glibc, полю I<tz_dsttime> из I<struct timezone> вызов B<gettimeofday>() присвоит ненулевое значение, если в текущем часовом поясе уже применялось или будет применяться правило перехода на летнее время. В этом смысле это зеркально отражает назначение B<daylight>(3) для текущего пояса. В Linux с glibc значение поля I<tz_dsttime> из I<struct timezone> никогда не используется в B<settimeofday>() или B<gettimeofday>(). Таким образом, следующий абзац представляет только исторический интерес."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:255
msgid ""
"On old systems, the field I<tz_dsttime> contains a symbolic constant (values"
" are given below)  that indicates in which part of the year Daylight Saving "
"Time is in force.  (Note: this value is constant throughout the year: it "
"does not indicate that DST is in force, it just selects an algorithm.)  The "
"daylight saving time algorithms defined are as follows:"
msgstr "В старых системах поле I<tz_dsttime> содержит символьную константу (значения приведены ниже), которая включает в себя информацию о сезонной коррекции времени (Daylight Saving Time) (замечание: эта величина постоянна и указывает лишь на алгоритм коррекции). Существующие алгоритмы сезонной коррекции:"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:269
#, no-wrap
msgid ""
"B<DST_NONE>     /* not on DST */\n"
"B<DST_USA>      /* USA style DST */\n"
"B<DST_AUST>     /* Australian style DST */\n"
"B<DST_WET>      /* Western European DST */\n"
"B<DST_MET>      /* Middle European DST */\n"
"B<DST_EET>      /* Eastern European DST */\n"
"B<DST_CAN>      /* Canada */\n"
"B<DST_GB>       /* Great Britain and Eire */\n"
"B<DST_RUM>      /* Romania */\n"
"B<DST_TUR>      /* Turkey */\n"
"B<DST_AUSTALT>  /* Australian style with shift in 1986 */\n"
msgstr "B<DST_NONE>     /* нет DST */\nB<DST_USA>      /* американский DST */\nB<DST_AUST>     /* австралийский DST */\nB<DST_WET>      /* западноевропейский DST */\nB<DST_MET>      /* средневосточный DST */\nB<DST_EET>      /* восточноевропейский DST */\nB<DST_CAN>      /* Канада */\nB<DST_GB>       /* Великобритания и Ирландия */\nB<DST_RUM>      /* Румыния */\nB<DST_TUR>      /* Турция */\nB<DST_AUSTALT>  /* австралийский со сдвигом на 1986 год */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:279
msgid ""
"Of course it turned out that the period in which Daylight Saving Time is in "
"force cannot be given by a simple algorithm, one per country; indeed, this "
"period is determined by unpredictable political decisions.  So this method "
"of representing timezones has been abandoned."
msgstr "Разумеется, коррекцию для каждой страны нельзя описать простым алгоритмом, так как этот фактор может зависеть даже от непредсказуемых политических решений. Поэтому этот метод представления часовых поясов больше не используется."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:290
msgid ""
"B<date>(1), B<adjtimex>(2), B<clock_gettime>(2), B<time>(2), B<ctime>(3), "
"B<ftime>(3), B<timeradd>(3), B<capabilities>(7), B<time>(7), B<vdso>(7), "
"B<hwclock>(8)"
msgstr "B<date>(1), B<adjtimex>(2), B<clock_gettime>(2), B<time>(2), B<ctime>(3), B<ftime>(3), B<timeradd>(3), B<capabilities>(7), B<time>(7), B<vdso>(7), B<hwclock>(8)"

#. type: TH
#: man-pages/man2/getresuid.2:28
#, no-wrap
msgid "GETRESUID"
msgstr "GETRESUID"

#. type: Plain text
#: man-pages/man2/getresuid.2:31
msgid "getresuid, getresgid - get real, effective and saved user/group IDs"
msgstr "getresuid, getresgid - получение действительного, эффективного и сохранённого идентификатора пользователя или группы"

#. type: Plain text
#: man-pages/man2/getresuid.2:33
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man2/getresuid.2:37
msgid ""
"B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"
msgstr "B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"

#. type: Plain text
#: man-pages/man2/getresuid.2:39
msgid ""
"B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"
msgstr "B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"

#. type: Plain text
#: man-pages/man2/getresuid.2:50
msgid ""
"B<getresuid>()  returns the real UID, the effective UID, and the saved set-"
"user-ID of the calling process, in the arguments I<ruid>, I<euid>, and "
"I<suid>, respectively.  B<getresgid>()  performs the analogous task for the "
"process's group IDs."
msgstr "B<getresuid>() возвращает действительный (real), эффективный (effective) и сохранённый (saved) set-user-ID идентификатор пользователя вызывающего процесса в аргументах I<ruid>, I<euid> и I<suid>, соответственно. B<getresgid>() выполняет аналогичную задачу для идентификаторов группы процесса."

#. type: Plain text
#: man-pages/man2/getresuid.2:60
msgid ""
"One of the arguments specified an address outside the calling program's "
"address space."
msgstr "В одном из аргументов задан адрес вне области адресного пространства вызывающей программы."

#. type: Plain text
#: man-pages/man2/getresuid.2:62
msgid "These system calls appeared on Linux starting with kernel 2.1.44."
msgstr "Данные системные вызовы появились в Linux, начиная с ядра версии 2.1.44."

#. type: Plain text
#: man-pages/man2/getresuid.2:67
msgid ""
"The prototypes are given by glibc since version 2.3.2, provided "
"B<_GNU_SOURCE> is defined."
msgstr "В glibc прототипы появились в версии 2.3.2, они предоставляются при определении B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man2/getresuid.2:70
msgid ""
"These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr "Это нестандартные вызовы; также они есть в HP-UX и некоторых BSD."

#. type: Plain text
#: man-pages/man2/getresuid.2:86
msgid ""
"The original Linux B<getresuid>()  and B<getresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<getresuid32>()  and B<getresgid32>(), supporting 32-bit IDs.  The glibc "
"B<getresuid>()  and B<getresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr "Первоначальные версии системных вызовов B<getresuid>() и B<getresgid>() в Linux поддерживали только 16-битные идентификаторы пользователей и групп. Позднее в Linux 2.4 были добавлены вызовы B<getresuid32>() и B<getresgid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<getresuid>() и B<getresgid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getresuid.2:91
msgid ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<credentials>(7)"
msgstr "B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr "GET_MEMPOLICY"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a thread"
msgstr "get_mempolicy - возвращает политику работы с памятью NUMA для нити"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr "B<#include E<lt>numaif.hE<gt>>"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<long get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, void *>I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr "B<long get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\nB<                  unsigned long >I<maxnode>B<, void *>I<addr>B<,>\nB<                  unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:39
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "Компонуется при указании параметра I<-lnuma>.\n"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling thread or of a "
"memory address, depending on the setting of I<flags>."
msgstr "Вызов B<get_mempolicy>() возвращает политику NUMA вызывающей нити или адреса памяти (в зависимости от значения I<flags>)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:50
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the thread."
msgstr "Машина с NUMA имеет различные контроллеры памяти с различными расстояниями до определённых ЦП. Политикой памяти задаётся узел, на котором выделяется память для нити."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:72
msgid ""
"If I<flags> is specified as 0, then information about the calling thread's "
"default policy (as set by B<set_mempolicy>(2))  is returned, in the buffers "
"pointed to by I<mode> and I<nodemask>.  The value returned in these "
"arguments may be used to restore the thread's policy to its state at the "
"time of the call to B<get_mempolicy>()  using B<set_mempolicy>(2).  When "
"I<flags> is 0, I<addr> must be specified as NULL."
msgstr "Если значение I<flags> равно 0, то в буферы, указанные в I<mode> и I<nodemask>, возвращается информация о политике по умолчанию для вызывающей нити (которая была задана с помощью B<set_mempolicy>(2)). Полученное значение может использоваться для восстановления политики нити в её состояние на время вызова B<get_mempolicy>() с помощью B<set_mempolicy>(2). Если значение I<flags> равно 0, то значение I<addr> должно быть равно NULL."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:94
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24),"
" the I<mode> argument is ignored and the set of nodes (memories) that the "
"thread is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  (in the absence of any I<mode flags>)  is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr "Если I<flags> равно B<MPOL_F_MEMS_ALLOWED> (доступно, начиная с Linux 2.6.24), то аргумент I<mode> игнорируется и набор узлов (их памяти), которые разрешено указывать нити в последующих вызовах B<mbind>(2) или B<set_mempolicy>(2) (в отсутствии любых значений I<флагов режима>), возвращается в I<nodemask>. Не разрешено объединять B<MPOL_F_MEMS_ALLOWED> с B<MPOL_F_ADDR> или B<MPOL_F_NODE>."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:108
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the"
" policy governing the memory address given in I<addr>.  This policy may be "
"different from the thread's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr "Если I<flags> равно B<MPOL_F_ADDR>, то возвращается информация об управляющей политике адреса памяти, указанного в I<addr>. Эта политика может отличаться от политики нити по умолчанию, если B<mbind>(2) или одна из вспомогательных функций, описанных в B<numa>(3), были использованы при установлении политики для диапазона памяти, содержащего I<addr>."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:129
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the"
" policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned\\ long)*8>."
msgstr "Если аргумент I<mode> не равен NULL, то B<get_mempolicy>() сохранит режим политики и все необязательные I<флаги режима> запрашиваемой политики NUMA в место, указанное этим аргументом. Если I<nodemask> не равно NULL, то значение nodemask, связанной с политикой, будет сохранено в место, указанное этим аргументом. В I<maxnode> задаётся количество идентификаторов узлов, которые могут быть сохранены в I<nodemask> \\(em то есть, максимальный идентификатор узла плюс один. Значение, указанное в I<maxnode>, всегда округляется до кратного I<sizeof(unsigned\\ long)*8>."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:146
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address"
" I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the thread had performed a read (load) access to that "
"address, and return the ID of the node where that page was allocated."
msgstr "Если в I<flags> указано B<MPOL_F_NODE> и B<MPOL_F_ADDR>, то B<get_mempolicy>() вернёт идентификатор узла, на котором расположен адрес I<addr> в расположение, заданное I<mode>. Если для указанного адреса страница ещё не выделена, то B<get_mempolicy>() выделит страницу, как если бы нить выполнила чтение (загрузку) по этому адресу, и вернёт идентификатор узла, на котором была размещена страница."

#.  Note:  code returns next interleave node via 'mode' argument -Lee
#. Schermerhorn
#. type: Plain text
#: man-pages/man2/get_mempolicy.2:171
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"thread's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  will"
" return in the location pointed to by a non-NULL I<mode> argument, the node "
"ID of the next node that will be used for interleaving of internal kernel "
"pages allocated on behalf of the thread.  These allocations include pages "
"for memory-mapped files in process memory ranges mapped using the B<mmap>(2)"
"  call with the B<MAP_PRIVATE> flag for read accesses, and in memory ranges "
"mapped with the B<MAP_SHARED> flag for all accesses."
msgstr "Если I<flags> содержит B<MPOL_F_NODE>, но не B<MPOL_F_ADDR>, и значение текущей политики нити равно B<MPOL_INTERLEAVE>, то B<get_mempolicy>() вернёт в расположение, указанное в аргументе I<mode> (не равно NULL), идентификатор узла следующего узла, который будет использован при чередовании внутренних страниц ядра, выделяемых для нити. Эти выделения содержат страницы памяти отображённых файлов в диапазоне памяти процесса, отображённых с помощью вызова B<mmap>(2) с флагом B<MAP_PRIVATE> для чтения, и в диапазонах памяти, отображённых с флагом B<MAP_SHARED>, для всех операций."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:173
msgid "Other flag values are reserved."
msgstr "Другие значения флагов зарезервированы."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:176
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr "Обзор возможных политик смотрите в B<set_mempolicy>(2)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:183
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<get_mempolicy>() возвращает 0; при ошибке \\(em -1, а в I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:191
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr "Часть всего диапазона памяти, заданная в I<nodemask> и I<maxnode>, указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:235
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current thread policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> specified"
" B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or B<MPOL_F_NODE>.  (And "
"there are other B<EINVAL> cases.)"
msgstr "Значение, указанное в I<maxnode>, меньше количества идентификаторов узлов, поддерживаемых системой. Или в I<flags> указаны значения, отличные от B<MPOL_F_NODE> или B<MPOL_F_ADDR>; или в I<flags> указано B<MPOL_F_ADDR> и I<addr> равно NULL, или в I<flags> не указано B<MPOL_F_ADDR> и I<addr> не равно NULL. Или в I<flags> указано B<MPOL_F_NODE>, но не B<MPOL_F_ADDR> и значение текущей политики нити не равно B<MPOL_INTERLEAVE>. Или в I<flags> указано B<MPOL_F_MEMS_ALLOWED> вместе с B<MPOL_F_ADDR> или B<MPOL_F_NODE> (и есть другие случаи возврата B<EINVAL>)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:239
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version"
" 2.6.7."
msgstr "Системный вызов B<get_mempolicy>() был добавлен в ядро Linux версии 2.6.7."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:244
msgid "For information on library support, see B<numa>(7)."
msgstr "Информация о библиотеке доступна в B<numa>(7)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:251
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr "B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), B<numa>(7), B<numactl>(8)"

#. type: TH
#: man-pages/man2/get_robust_list.2:30
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr "GET_ROBUST_LIST"

#. type: TH
#: man-pages/man2/get_robust_list.2:30
#, no-wrap
msgid "Linux System Calls"
msgstr "Системные вызовы Linux"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:33
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr "get_robust_list, set_robust_list - возвращает/назначает список надёжных фьютексов (futexes)"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:38
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr "B<#include E<lt>linux/futex.hE<gt>>\nB<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>syscall.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:42
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head **>I<head_ptr>B<,>\n"
"B<                     size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t >I<len>B<);>\n"
msgstr "B<long get_robust_list(int >I<pid>B<, struct robust_list_head **>I<head_ptr>B<,>\nB<                     size_t *>I<len_ptr>B<);>\nB<long set_robust_list(struct robust_list_head *>I<head>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:54
msgid ""
"These system calls deal with per-thread robust futex lists.  These lists are"
" managed in user space: the kernel knows only about the location of the head"
" of the list.  A thread can inform the kernel of the location of its robust "
"futex list using B<set_robust_list>().  The address of a thread's robust "
"futex list can be obtained using B<get_robust_list>()."
msgstr "Данные системные вызовы служат для ведения понетевых списков надёжных фьютексов. Данные списки управляются из пользовательского пространства: ядро знает только расположение начала списка. Нить может информировать ядро о расположении своего списка надёжных фьютексов с помощью B<set_robust_list>(). Адрес списка надёжных фьютексов нити можно получить с помощью B<get_robust_list>()."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:66
msgid ""
"The purpose of the robust futex list is to ensure that if a thread "
"accidentally fails to unlock a futex before terminating or calling "
"B<execve>(2), another thread that is waiting on that futex is notified that "
"the former owner of the futex has died.  This notification consists of two "
"pieces: the B<FUTEX_OWNER_DIED> bit is set in the futex word, and the kernel"
" performs a B<futex>(2)  B<FUTEX_WAKE> operation on one of the threads "
"waiting on the futex."
msgstr "Предназначением списка надёжных фьютексов является гарантия того, что если нить неожиданно из-за ошибки не разблокирует фьютекс перед завершением или вызовом B<execve>(2), другая ожидающая этот фьютекс нить получит уведомление о том, что бывший владелец фьютекса прекратил работу. Данное уведомление состоит из двух частей: установленного бита B<FUTEX_OWNER_DIED> в слове фьютекса и выполнение ядром B<futex>(2) с операцией B<FUTEX_WAKE> для одной из нитей, ожидающих фьютекс."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:82
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr "Системный вызов B<get_robust_list>() возвращает начало списка надёжных фьютексов нити, идентификатор которой указан в I<pid>. Если значение I<pid> равно 0, то возвращается начало списка вызывающей нити. Начало списка сохраняется в расположение, указанное I<head_ptr>. Размер объекта, указываемый I<**head_ptr>, сохраняется в I<len_ptr>."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:89
msgid ""
"Permission to employ B<get_robust_list>()  is governed by a ptrace access "
"mode B<PTRACE_MODE_READ_REALCREDS> check; see B<ptrace>(2)."
msgstr "Право вызывать B<get_robust_list>() определяется проверкой режима доступа ptrace B<PTRACE_MODE_READ_REALCREDS>; смотрите B<ptrace>(2)."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:101
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head"
" of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be "
"I<sizeof(*head)>."
msgstr "Системный вызов B<set_robust_list>() запрашивает ядро записать начало списка надёжных фьютексов, принадлежащего вызывающей нити. Аргумент I<head> содержит начало списка для записи. Аргумент I<len> должен быть равен I<sizeof(*head)>."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:108
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero"
" when the operation is successful, an error code otherwise."
msgstr "Системные вызовы B<set_robust_list>() и B<get_robust_list>() возвращают ноль при успешном выполнении и код ошибки в противном случае."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:112
msgid ""
"The B<set_robust_list>()  system call can fail with the following error:"
msgstr "Системный вызов B<pthread_setcancelstate>() может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:117
msgid "I<len> does not equal I<sizeof(struct\\ robust_list_head)>."
msgstr "Значение I<len> не равно I<sizeof(struct\\ robust_list_head)>."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:121
msgid ""
"The B<get_robust_list>()  system call can fail with the following errors:"
msgstr "Системный вызов B<get_robust_list>() может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:129
msgid ""
"The calling process does not have permission to see the robust futex list of"
" the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr "Вызывающий процесс не имеет прав на просмотр списка надёжных фьютексов нити с идентификатором I<pid> и не имеет мандата B<CAP_SYS_PTRACE>."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:134
msgid "No thread with the thread ID I<pid> could be found."
msgstr "Нить с идентификатором I<pid> не найдена."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:138
msgid ""
"The head of the robust futex list can't be stored at the location I<head>."
msgstr "Начало списка надёжных фьютексов невозможно сохранить в расположение I<head>."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:140
msgid "These system calls were added in Linux 2.6.17."
msgstr "Данные системные вызовы были добавлены в Linux 2.6.17."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:145
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc.  In the unlikely event that you want to call them"
" directly, use B<syscall>(2)."
msgstr "Эти системные вызовы не нужны обычным приложениям. Поддержка в glibc отсутствует. В маловероятном случае, когда вы хотите вызвать их напрямую, используйте B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:149
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr "В нити может быть только один список надёжных фьютексов; поэтому приложения, которым требуется данное свойство, должны использовать мьютексы, предоставляемые glibc."

#.  commit 8141c7f3e7aee618312fa1c15109e1219de784a7
#. type: Plain text
#: man-pages/man2/get_robust_list.2:157
msgid ""
"In the initial implementation, a thread waiting on a futex was notified that"
" the owner had died only if the owner terminated.  Starting with Linux "
"2.6.28, notification was extended to include the case where the owner "
"performs an B<execve>(2)."
msgstr "В первоначальной реализации нить, ожидающая фьютекс, уведомлялась о кончине владельца только, если владелец прекращал работу. Начиная с Linux 2.6.28 уведомление также посылается при выполнении владельцем B<execve>(2)."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:164
msgid ""
"The thread IDs mentioned in the main text are I<kernel> thread IDs of the "
"kind returned by B<clone>(2)  and B<gettid>(2)."
msgstr "Идентификаторы нитей, упоминаемые в основном тексте, являются I<ядерными> идентификаторами нити, которые возвращаются из B<clone>(2) и B<gettid>(2)."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:167
msgid "B<futex>(2), B<pthread_mutexattr_setrobust>(3)"
msgstr "B<futex>(2), B<pthread_mutexattr_setrobust>(3)"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:171
msgid ""
"I<Documentation/robust-futexes.txt> and I<Documentation/robust-futex-"
"ABI.txt> in the Linux kernel source tree"
msgstr "Файлы I<Documentation/robust-futexes.txt> и I<Documentation/robust-futex-ABI.txt> в дереве исходного кода ядра Linux"

#. type: TH
#: man-pages/man2/getuid.2:26
#, no-wrap
msgid "GETUID"
msgstr "GETUID"

#. type: Plain text
#: man-pages/man2/getuid.2:29
msgid "getuid, geteuid - get user identity"
msgstr "getuid, geteuid - получить идентификатор пользователя"

#. type: Plain text
#: man-pages/man2/getuid.2:35
msgid "B<uid_t getuid(void);>"
msgstr "B<uid_t getuid(void);>"

#. type: Plain text
#: man-pages/man2/getuid.2:37
msgid "B<uid_t geteuid(void);>"
msgstr "B<uid_t geteuid(void);>"

#. type: Plain text
#: man-pages/man2/getuid.2:40
msgid "B<getuid>()  returns the real user ID of the calling process."
msgstr "B<getuid>() возвращает фактический идентификатор (ID) пользователя вызывающего процесса. "

#. type: Plain text
#: man-pages/man2/getuid.2:43
msgid "B<geteuid>()  returns the effective user ID of the calling process."
msgstr "B<geteuid>() возвращает эффективный идентификатор пользователя вызывающего процесса."

#. type: SS
#: man-pages/man2/getuid.2:48
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man2/getuid.2:57
msgid ""
"In UNIX\\ V6 the B<getuid>()  call returned I<(euid E<lt>E<lt> 8) + uid>.  "
"UNIX\\ V7 introduced separate calls B<getuid>()  and B<geteuid>()."
msgstr "В UNIX\\ V6 вызов B<getuid>() возвращал I<(euid E<lt>E<lt> 8) + uid>. В UNIX\\ V7 появились отдельные вызовы B<getuid>() и B<geteuid>()."

#. type: Plain text
#: man-pages/man2/getuid.2:73
msgid ""
"The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
"only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
"B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
"B<geteuid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr "Первоначальные версии системных вызовов B<getuid>() и B<geteuid>() в Linux поддерживали только 16-битные идентификаторы пользователей и групп. Позднее в Linux 2.4 были добавлены вызовы B<getuid32>() и B<geteuid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<getuid>() и B<geteuid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getuid.2:89
msgid ""
"On Alpha, instead of a pair of B<getuid>()  and B<geteuid>()  system calls, "
"a single B<getxuid>()  system call is provided, which returns a pair of real"
" and effective UIDs.  The glibc B<getuid>()  and B<geteuid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr "На Alpha вместо пары системных вызовов B<getuid>() и B<geteuid>() предоставляется один B<getxuid>(), который возвращает пару реальный и эффективный UID. Обёрточные функции glibc B<getuid>() и B<geteuid>() скрывают это. Подробности об отображении регистров смотрите в B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/getuid.2:93
msgid "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"
msgstr "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/getdomainname.2:29
#, no-wrap
msgid "GETDOMAINNAME"
msgstr "GETDOMAINNAME"

#. type: Plain text
#: man-pages/man2/getdomainname.2:32
msgid "getdomainname, setdomainname - get/set NIS domain name"
msgstr "getdomainname, setdomainname - получить/установить имя домена NIS"

#. type: Plain text
#: man-pages/man2/getdomainname.2:36
msgid "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/getdomainname.2:38
msgid "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/getdomainname.2:47
msgid "B<getdomainname>(), B<setdomainname>():"
msgstr "B<getdomainname>(), B<setdomainname>():"

#. type: Plain text
#: man-pages/man2/getdomainname.2:60
msgid ""
"These functions are used to access or to change the NIS domain name of the "
"host system."
msgstr "Эти функции используются для доступа к имени узла домена NIS или для его изменения."

#. type: Plain text
#: man-pages/man2/getdomainname.2:71
msgid ""
"B<setdomainname>()  sets the domain name to the value given in the character"
" array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr "B<setdomainname>() изменяет доменное имя на значение, указанное в массиве символов I<name>. В аргументе I<len> задаётся количество байт в I<name>. (То есть I<name> может не завершаться байтом с null.)"

#. type: Plain text
#: man-pages/man2/getdomainname.2:81
msgid ""
"B<getdomainname>()  returns the null-terminated domain name in the character"
" array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"domain name requires more than I<len> bytes, B<getdomainname>()  returns the"
" first I<len> bytes (glibc) or gives an error (libc)."
msgstr "B<getdomainname>() возвращает доменное имя с null на конце в массиве символов I<name>, который имеет длину I<len> байт. Если для доменного имени с null на конце требуется больше чем I<len> байт, то B<getdomainname>() возвращает первые I<len> байт (glibc) или возвращает ошибку (libc)."

#. type: Plain text
#: man-pages/man2/getdomainname.2:89
msgid "B<setdomainname>()  can fail with the following errors:"
msgstr "B<setdomainname>() может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man2/getdomainname.2:93
msgid "I<name> pointed outside of user address space."
msgstr "I<name> указывает за пределы пользовательского адресного пространства."

#. type: Plain text
#: man-pages/man2/getdomainname.2:97
msgid "I<len> was negative or too large."
msgstr "Значение I<len> отрицательно или слишком большое."

#. type: Plain text
#: man-pages/man2/getdomainname.2:103
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in the user "
"namespace associated with its UTS namespace (see B<namespaces>(7))."
msgstr "У вызывающего нет мандата B<CAP_SYS_ADMIN> в пользовательском пространстве имён, связанном с его пространством имён UTS (смотрите B<namespaces>(7))."

#. type: Plain text
#: man-pages/man2/getdomainname.2:106
msgid "B<getdomainname>()  can fail with the following errors:"
msgstr "B<getdomainname>() может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man2/getdomainname.2:117
msgid ""
"For B<getdomainname>()  under libc: I<name> is NULL or I<name> is longer "
"than I<len> bytes."
msgstr "Для B<getdomainname>() в libc: значение I<name> равно NULL или I<name> длиннее чем I<len> байт."

#.  But they appear on most systems...
#. type: Plain text
#: man-pages/man2/getdomainname.2:120
msgid "POSIX does not specify these calls."
msgstr "В POSIX нет этих вызовов."

#. type: Plain text
#: man-pages/man2/getdomainname.2:124
msgid ""
"Since Linux 1.0, the limit on the length of a domain name, including the "
"terminating null byte, is 64 bytes.  In older kernels, it was 8 bytes."
msgstr "Начиная с Linux 1.0, длина доменного имени, включая завершающий байт с null, ограничена 64 байтами. В более старых ядрах ограничение было 8 байт."

#. type: Plain text
#: man-pages/man2/getdomainname.2:134
msgid ""
"On most Linux architectures (including x86), there is no B<getdomainname>()"
"  system call; instead, glibc implements B<getdomainname>()  as a library "
"function that returns a copy of the I<domainname> field returned from a call"
" to B<uname>(2)."
msgstr "На большинстве архитектур Linux (включая x86), системный вызов B<getdomainname>() отсутствует; вместо него в библиотеке glibc реализована функция B<getdomainname>(), которая возвращает копию поля I<domainname>, которую возвращает вызов B<uname>(2)."

#. type: Plain text
#: man-pages/man2/getdomainname.2:137
msgid "B<gethostname>(2), B<sethostname>(2), B<uname>(2)"
msgstr "B<gethostname>(2), B<sethostname>(2), B<uname>(2)"

#. type: TH
#: man-pages/man2/get_kernel_syms.2:10
#, no-wrap
msgid "GET_KERNEL_SYMS"
msgstr "GET_KERNEL_SYMS"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:13
msgid "get_kernel_syms - retrieve exported kernel and module symbols"
msgstr "get_kernel_syms - получить экспортируемые символы ядра и модулей"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:16
#, no-wrap
msgid "B<#include E<lt>linux/module.hE<gt>>\n"
msgstr "B<#include E<lt>linux/module.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:18
#, no-wrap
msgid "B<int get_kernel_syms(struct kernel_sym *>I<table>B<);>\n"
msgstr "B<int get_kernel_syms(struct kernel_sym *>I<table>B<);>\n"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:22
msgid ""
"I<Note>: No declaration of this system call is provided in glibc headers; "
"see NOTES."
msgstr "I<Замечание>: В заголовочных файлах glibc этой системный вызов отсутствует; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:25
msgid "B<Note>: This system call is present only in kernels before Linux 2.6."
msgstr "B<Замечание>: Данный системный вызов доступен только в ядрах до Linux 2.6."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:32
msgid ""
"If I<table> is NULL, B<get_kernel_syms>()  returns the number of symbols "
"available for query.  Otherwise, it fills in a table of structures:"
msgstr "Если I<table> равно NULL, то B<get_kernel_syms>() возвращает количество символов доступных для запроса. Иначе таблица заполняется структурами:"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:39
#, no-wrap
msgid ""
"struct kernel_sym {\n"
"    unsigned long value;\n"
"    char          name[60];\n"
"};\n"
msgstr "struct kernel_sym {\n    unsigned long value;\n    char          name[60];\n};\n"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:47
msgid ""
"The symbols are interspersed with magic symbols of the form B<#>I<module-"
"name> with the kernel having an empty name.  The value associated with a "
"symbol of this form is the address at which the module is loaded."
msgstr "Символы вида B<#>I<module-name> представляют собой ссылки на модули. Значение, связанное с таким символом, содержит адрес, по которому загружен модуль."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:51
msgid ""
"The symbols exported from each module follow their magic module tag and the "
"modules are returned in the reverse of the order in which they were loaded."
msgstr "К символам, экспортируемым из модуля, добавляется метка модуля, а модули возвращаются в обратном порядке, в котором были загружены."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:57
msgid ""
"On success, returns the number of symbols copied to I<table>.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr "При успешном выполнении возвращается количество символов, скопированных в I<table>. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:59
msgid "There is only one possible error return:"
msgstr "Может возвращаться только одна ошибка:"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:63
msgid "B<get_kernel_syms>()  is not supported in this version of the kernel."
msgstr "Вызов B<get_kernel_syms>() не поддерживается в этой версии ядра."

#.  Removed in Linux 2.5.48
#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:67
msgid ""
"This system call is present on Linux only up until kernel 2.4; it was "
"removed in Linux 2.6."
msgstr "Данный системный вызов есть только в Linux до версии 2.4; он был удалён в Linux 2.6."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:70
msgid "B<get_kernel_syms>()  is Linux-specific."
msgstr "Вызов B<get_kernel_syms>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:78
msgid ""
"This obsolete system call is not supported by glibc.  No declaration is "
"provided in glibc headers, but, through a quirk of history, glibc versions "
"before 2.23 did export an ABI for this system call.  Therefore, in order to "
"employ this system call, it was sufficient to manually declare the interface"
" in your code; alternatively, you could invoke the system call using "
"B<syscall>(2)."
msgstr "Устаревший системный вызов, не поддерживается glibc. В заголовочных файлах glibc он не объявлен, но в недавнем прошлом версии glibc до 2.23 экспортировали ABI для этого системного вызова. Поэтому, чтобы получить данный системный вызов достаточно вручную объявить интерфейс в своём коде; или же можно вызвать его через B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:83
msgid ""
"There is no way to indicate the size of the buffer allocated for I<table>.  "
"If symbols have been added to the kernel since the program queried for the "
"symbol table size, memory will be corrupted."
msgstr "Нет способа указать размер буфера, выделенного для I<table>. Если символы были добавлены в ядро после того, как программа запросила размер таблицы символов, то это вызовет повреждение данных в памяти."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:85
msgid "The length of exported symbol names is limited to 59 characters."
msgstr "Длина имён экспортируемых символов ограничена 59 знаками."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:91
msgid ""
"Because of these limitations, this system call is deprecated in favor of "
"B<query_module>(2)  (which is itself nowadays deprecated in favor of other "
"interfaces described on its manual page)."
msgstr "Из-за этих ограничений вместо данного системного вызова рекомендуется использовать B<query_module>(2) (который, в настоящее время, тоже устарел и заменён на другие интерфейсы, перечисленные в конце этой справочной страницы)."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:95
msgid ""
"B<create_module>(2), B<delete_module>(2), B<init_module>(2), "
"B<query_module>(2)"
msgstr "B<create_module>(2), B<delete_module>(2), B<init_module>(2), B<query_module>(2)"

#. type: TH
#: man-pages/man5/group.5:26
#, no-wrap
msgid "GROUP"
msgstr "GROUP"

#. type: Plain text
#: man-pages/man5/group.5:29
msgid "group - user group file"
msgstr "group - файл групп пользователей"

#. type: Plain text
#: man-pages/man5/group.5:34
msgid ""
"The I</etc/group> file is a text file that defines the groups on the system."
"  There is one entry per line, with the following format:"
msgstr "В текстовом файле I</etc/group> описаны группы в системе. В каждой строке файла содержится одна запись следующего формата:"

#. type: Plain text
#: man-pages/man5/group.5:38
#, no-wrap
msgid "group_name:password:GID:user_list\n"
msgstr "group_name:password:GID:user_list\n"

#. type: Plain text
#: man-pages/man5/group.5:42
msgid "The fields are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man5/group.5:42
#, no-wrap
msgid "I<group_name>"
msgstr "I<group_name>"

#. type: Plain text
#: man-pages/man5/group.5:45
msgid "the name of the group."
msgstr "имя группы"

#. type: TP
#: man-pages/man5/group.5:45
#, no-wrap
msgid "I<password>"
msgstr "I<password>"

#. type: Plain text
#: man-pages/man5/group.5:49
msgid ""
"the (encrypted) group password.  If this field is empty, no password is "
"needed."
msgstr "пароль группы (в зашифрованном виде). Если это поле пустое, то пароль не нужен."

#. type: TP
#: man-pages/man5/group.5:49
#, no-wrap
msgid "I<GID>"
msgstr "I<GID>"

#. type: Plain text
#: man-pages/man5/group.5:52
msgid "the numeric group ID."
msgstr "числовой идентификатор (ID) группы."

#. type: TP
#: man-pages/man5/group.5:52
#, no-wrap
msgid "I<user_list>"
msgstr "I<user_list>"

#. type: Plain text
#: man-pages/man5/group.5:55
msgid ""
"a list of the usernames that are members of this group, separated by commas."
msgstr "разделённые запятыми имена всех пользователей, которые являются членами данной группы."

#. type: SH
#: man-pages/man5/group.5:55
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man5/group.5:57
msgid "I</etc/group>"
msgstr "I</etc/group>"

#. type: Plain text
#: man-pages/man5/group.5:63
msgid ""
"As the 4.2BSD B<initgroups>(3)  man page says: no one seems to keep "
"I</etc/group> up-to-date."
msgstr "Согласно справочной страницы 4.2BSD B<initgroups>(3): похоже, никто не поддерживает актуальность I</etc/group>."

#. type: Plain text
#: man-pages/man5/group.5:74
msgid ""
"B<chgrp>(1), B<gpasswd>(1), B<groups>(1), B<login>(1), B<newgrp>(1), "
"B<sg>(1), B<getgrent>(3), B<getgrnam>(3), B<gshadow>(5), B<passwd>(5), "
"B<vigr>(8)"
msgstr "B<chgrp>(1), B<gpasswd>(1), B<groups>(1), B<login>(1), B<newgrp>(1), B<sg>(1), B<getgrent>(3), B<getgrnam>(3), B<gshadow>(5), B<passwd>(5), B<vigr>(8)"

#. type: TH
#: man-pages/man5/gai.conf.5:19
#, no-wrap
msgid "GAI.CONF"
msgstr "GAI.CONF"

#. type: TH
#: man-pages/man5/gai.conf.5:19
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: man-pages/man5/gai.conf.5:22
msgid "gai.conf - getaddrinfo(3) configuration file"
msgstr "gai.conf - файл настройки getaddrinfo(3)"

#. type: Plain text
#: man-pages/man5/gai.conf.5:36
msgid ""
"A call to B<getaddrinfo>(3)  might return multiple answers.  According to "
"RFC\\ 3484 these answers must be sorted so that the answer with the highest "
"success rate is first in the list.  The RFC provides an algorithm for the "
"sorting.  The static rules are not always adequate, though.  For this "
"reason, the RFC also requires that system administrators should have the "
"possibility to dynamically change the sorting.  For the glibc "
"implementation, this can be achieved with the I</etc/gai.conf> file."
msgstr "Вызов B<getaddrinfo>(3) может вернуть несколько результатов. Согласно RFC\\ 3484 эти результаты должны быть отсортированы так, что первым в списке будет ответ с высшим показателем достоверности (success rate). В RFC имеется алгоритм сортировки. Но статические правила не всегда приемлемы. По этой причине в RFC также требуется, чтобы системный администратор имел возможность динамически изменять сортировку. В реализации glibc это можно делать через файл I</etc/gai.conf>."

#. type: Plain text
#: man-pages/man5/gai.conf.5:40
msgid ""
"Each line in the configuration file consists of a keyword and its "
"parameters.  White spaces in any place are ignored.  Lines starting with "
"\\(aq#\\(aq are comments and are ignored."
msgstr "Каждая строка файла настройки состоит из ключевого слова и его параметров. Пробельные символы в любом месте игнорируются. Строки, начинающиеся с \\(aq#\\(aq, являются комментариями и игнорируются."

#. type: Plain text
#: man-pages/man5/gai.conf.5:42
msgid "The keywords currently recognized are:"
msgstr "Распознаваемые ключевые слова:"

#. type: TP
#: man-pages/man5/gai.conf.5:42
#, no-wrap
msgid "B<label> I<netmask> I<precedence>"
msgstr "B<label> I<маска_сети> I<приоритет>"

#. type: Plain text
#: man-pages/man5/gai.conf.5:51
msgid ""
"The value is added to the label table used in the RFC\\ 3484 sorting.  If "
"any B<label> definition is present in the configuration file, the default "
"table is not used.  All the label definitions of the default table which are"
" to be maintained have to be duplicated.  Following the keyword, the line "
"has to contain a network mask and a precedence value."
msgstr "Значение, добавляемое в таблицу ярлыков (label), используемую в RFC\\ 3484 при сортировке. Если определение B<label>, имеющееся в файле настройке, существует, то таблица по умолчанию не используется. Все определения ярлыков таблицы по умолчанию, которые нужно поддерживать, будут являться дублями. За ключевым словом указывается маска сети и значение приоритета."

#. type: TP
#: man-pages/man5/gai.conf.5:51
#, no-wrap
msgid "B<precedence> I<netmask> I<precedence>"
msgstr "B<precedence> I<маска_сети> I<приоритет>"

#. type: Plain text
#: man-pages/man5/gai.conf.5:58
msgid ""
"This keyword is similar to B<label>, but instead the value is added to the "
"precedence table as specified in RFC\\ 3484.  Once again, the presence of a "
"single B<precedence> line in the configuration file causes the default table"
" to not be used."
msgstr "Данное ключевое слово подобно B<label>, но значение добавляется в таблицу приоритетов (precedence), как описано в RFC\\ 3484. И здесь наличие единственной строки B<precedence> в файле настройки отключает использование таблицы по умолчанию."

#. type: TP
#: man-pages/man5/gai.conf.5:58
#, no-wrap
msgid "B<reload> E<lt>B<yes>|B<no>E<gt>"
msgstr "B<reload> E<lt>B<yes>|B<no>E<gt>"

#. type: Plain text
#: man-pages/man5/gai.conf.5:67
msgid ""
"This keyword controls whether a process checks whether the configuration "
"file has been changed since the last time it was read.  If the value is "
"\"B<yes>\", the file is reread.  This might cause problems in multithreaded "
"applications and is generally a bad idea.  The default is \"B<no>\"."
msgstr "Данное ключевое слово определяет будет ли процесс проверять изменился ли файл настройки с момента последнего чтения. Если значение B<yes>, то файл перечитывается. Это может привести к проблемам в многонитевых приложениях. Значение по умолчанию B<no>."

#. type: TP
#: man-pages/man5/gai.conf.5:67
#, no-wrap
msgid "B<scopev4> I<mask> I<value>"
msgstr "B<scopev4> I<маска> I<значение>"

#. type: Plain text
#: man-pages/man5/gai.conf.5:72
msgid ""
"Add another rule to the RFC\\ 3484 scope table for IPv4 address.  By "
"default, the scope IDs described in section 3.2 in RFC\\ 3438 are used.  "
"Changing these defaults should hardly ever be necessary."
msgstr "Добавляет новое правило в таблицу областей RFC\\ 3484 для адресов IPv4. По умолчанию используются ID областей, описанные в разделе 3.2 RFC\\ 3438. Изменять значения по умолчанию почти никогда не требуется."

#. type: Plain text
#: man-pages/man5/gai.conf.5:74
msgid "I</etc/gai.conf>"
msgstr "I</etc/gai.conf>"

#.  Added in 2006
#. type: Plain text
#: man-pages/man5/gai.conf.5:79
msgid "The I<gai.conf> file is supported by glibc since version 2.5."
msgstr "Файл I<gai.conf> поддерживается glibc начиная с версии 2.5."

#. type: Plain text
#: man-pages/man5/gai.conf.5:82
msgid ""
"The default table according to RFC\\ 3484 would be specified with the "
"following configuration file:"
msgstr "Таблица по умолчанию согласно RFC\\ 3484 должна задаваться следующим файлом настройки:"

#. type: Plain text
#: man-pages/man5/gai.conf.5:95
#, no-wrap
msgid ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"
msgstr "label  ::1/128       0\nlabel  ::/0          1\nlabel  2002::/16     2\nlabel ::/96          3\nlabel ::ffff:0:0/96  4\nprecedence  ::1/128       50\nprecedence  ::/0          40\nprecedence  2002::/16     30\nprecedence ::/96          20\nprecedence ::ffff:0:0/96  10\n"

#. type: Plain text
#: man-pages/man5/gai.conf.5:102
msgid "B<getaddrinfo>(3), RFC\\ 3484"
msgstr "B<getaddrinfo>(3), RFC\\ 3484"

#. type: TH
#: man-pages/man3/gethostbyname.3:38
#, no-wrap
msgid "GETHOSTBYNAME"
msgstr "GETHOSTBYNAME"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:46
msgid ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - get network host entry"
msgstr "gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, gethostbyname_r, gethostent_r - получение записи о сетевом узле"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:50
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\nB<extern int h_errno;>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:52
#, no-wrap
msgid "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"
msgstr "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:56
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>       /* for AF_INET */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>       /* для AF_INET */\nB<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\nB<                              socklen_t >I<len>B<, int >I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:58
#, no-wrap
msgid "B<void sethostent(int >I<stayopen>B<);>\n"
msgstr "B<void sethostent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:60
#, no-wrap
msgid "B<void endhostent(void);>\n"
msgstr "B<void endhostent(void);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:62
#, no-wrap
msgid "B<void herror(const char *>I<s>B<);>\n"
msgstr "B<void herror(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:64
#, no-wrap
msgid "B<const char *hstrerror(int >I<err>B<);>\n"
msgstr "B<const char *hstrerror(int >I<err>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:67
#, no-wrap
msgid ""
"/* System V/POSIX extension */\n"
"B<struct hostent *gethostent(void);>\n"
msgstr "/* расширение System V/POSIX */\nB<struct hostent *gethostent(void);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:70
#, no-wrap
msgid ""
"/* GNU extensions */\n"
"B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"
msgstr "/* расширения GNU */\nB<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:74
#, no-wrap
msgid ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostent_r(>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:78
#, no-wrap
msgid ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:82
#, no-wrap
msgid ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostbyname_r(const char *>I<name>B<,>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:86
#, no-wrap
msgid ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:100
msgid ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"
msgstr "B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), B<gethostbyname_r>(), B<gethostbyname2_r>():"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:104 man-pages/man3/gethostbyname.3:117
msgid "_DEFAULT_SOURCE"
msgstr "_DEFAULT_SOURCE"

#. type: TP
#: man-pages/man3/gethostbyname.3:104
#, no-wrap
msgid "Glibc versions up to and including 2.19:"
msgstr "Версии glibc по 2.19 включительно:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:107 man-pages/man3/gethostbyname.3:120
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:113
msgid "B<herror>(), B<hstrerror>():"
msgstr "B<herror>(), B<hstrerror>():"

#. type: TP
#: man-pages/man3/gethostbyname.3:117
#, no-wrap
msgid "Glibc 2.8 to 2.19:"
msgstr "Версии glibc с 2.8 по 2.19:"

#. type: TP
#: man-pages/man3/gethostbyname.3:120
#, no-wrap
msgid "Before glibc 2.8:"
msgstr "До glibc 2.8:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:123 man-pages/man3/gethostbyname.3:138
msgid "none"
msgstr "ни одного"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:128
msgid "B<h_errno>:"
msgstr "B<h_errno>:"

#. type: TP
#: man-pages/man3/gethostbyname.3:129
#, no-wrap
msgid "Since glibc 2.19"
msgstr "Начиная с glibc 2.19"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:132
msgid "_DEFAULT_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr "_DEFAULT_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"

#. type: TP
#: man-pages/man3/gethostbyname.3:132
#, no-wrap
msgid "Glibc 2.12 to 2.19:"
msgstr "Версии glibc с 2.12 по 2.19:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:135
msgid "_BSD_SOURCE || _SVID_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"

#. type: TP
#: man-pages/man3/gethostbyname.3:135
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:155
msgid ""
"The B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>(), and "
"B<hstrerror>()  functions are obsolete.  Applications should use "
"B<getaddrinfo>(3), B<getnameinfo>(3), and B<gai_strerror>(3)  instead."
msgstr "Функции B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>() и B<hstrerror>() являются устаревшими. Вместо них в  приложениях следует использовать B<getaddrinfo>(3), B<getnameinfo>(3) и B<gai_strerror>(3)."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:194
msgid ""
"The B<gethostbyname>()  function returns a structure of type I<hostent> for "
"the given host I<name>.  Here I<name> is either a hostname or an IPv4 "
"address in standard dot notation (as for B<inet_addr>(3)).  If I<name> is an"
" IPv4 address, no lookup is performed and B<gethostbyname>()  simply copies "
"I<name> into the I<h_name> field and its I<struct in_addr> equivalent into "
"the I<h_addr_list[0]> field of the returned I<hostent> structure.  If "
"I<name> doesn't end in a dot and the environment variable B<HOSTALIASES> is "
"set, the alias file pointed to by B<HOSTALIASES> will first be searched for "
"I<name> (see B<hostname>(7)  for the file format).  The current domain and "
"its parents are searched unless I<name> ends in a dot."
msgstr "Функция B<gethostbyname>() возвращает структуру типа I<hostent> для узла I<name>. Значением I<name> может быть или имя узла, или адрес IPv4 в стандартной точечной записи (как в B<inet_addr>(3)). Если I<name> — адрес IPv4, то поиск не выполняется и B<gethostbyname>() просто копирует I<name> в поле I<h_name>, а его эквивалент I<struct in_addr> — в поле I<h_addr_list[0]> возвращаемой структуры I<hostent> Если I<name> не оканчивается точкой и установлена переменная окружения B<HOSTALIASES>, то I<name> сначала ищется в файле псевдонимов, указанном в B<HOSTALIASES> (формат файла описан в B<hostname>(7)). Если I<name> не оканчивается точкой, то поиск производится с текущем доменом и его предками."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:210
msgid ""
"The B<gethostbyaddr>()  function returns a structure of type I<hostent> for "
"the given host address I<addr> of length I<len> and address type I<type>.  "
"Valid address types are B<AF_INET> and B<AF_INET6>.  The host address "
"argument is a pointer to a struct of a type depending on the address type, "
"for example a I<struct in_addr *> (probably obtained via a call to "
"B<inet_addr>(3))  for address type B<AF_INET>."
msgstr "Функция B<gethostbyaddr>() возвращает структуру типа I<hostent> для адреса узла I<addr> длинной I<len> и типом адреса I<type>. Допустимые типы адресов — B<AF_INET> и B<AF_INET6>. Аргумент адреса узла — указатель на структуру с типом, зависящим от типа адреса, например для типа адреса B<AF_INET> используется I<struct in_addr *> (возможно, полученная из вызова B<inet_addr>(3))."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:217
msgid ""
"The B<sethostent>()  function specifies, if I<stayopen> is true (1), that a "
"connected TCP socket should be used for the name server queries and that the"
" connection should remain open during successive queries.  Otherwise, name "
"server queries will use UDP datagrams."
msgstr "Функция B<sethostent>() задаёт (при I<stayopen> равным истине (1)), что для опроса сервера имён должен использоваться подключённый сокет TCP и что соединение должно остаться открытым для последующих запросов. В противном случае для опроса сервера имён будут использоваться дейтаграммы UDP."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:222
msgid ""
"The B<endhostent>()  function ends the use of a TCP connection for name "
"server queries."
msgstr "Функция B<endhostent>() закрывает использованное для опросов сервера имён соединение TCP."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:227
msgid ""
"The (obsolete)  B<herror>()  function prints the error message associated "
"with the current value of I<h_errno> on I<stderr>."
msgstr "Функция B<herror>() (устарела) печатает в I<stderr> сообщение об ошибке в соответствии с текущим значением I<h_errno>."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:232
msgid ""
"The (obsolete)  B<hstrerror>()  function takes an error number (typically "
"I<h_errno>) and returns the corresponding message string."
msgstr "Функция B<hstrerror>() (устарела) принимает номер ошибки (обычно, I<h_errno>) и возвращает соответствующую строку с сообщением об ошибке."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:246
msgid ""
"The domain name queries carried out by B<gethostbyname>()  and "
"B<gethostbyaddr>()  rely on the Name Service Switch (B<nsswitch.conf>(5))  "
"configured sources or a local name server (B<named>(8)).  The default action"
" is to query the Name Service Switch (B<nsswitch.conf(5))> configured "
"sources, failing that, a local name server (B<named>(8))."
msgstr "Запросы доменного имени, выполняемые B<gethostbyname>() и B<gethostbyaddr>(), полагаются на настроенные источники диспетчера службы имён (B<nsswitch.conf>(5)) или локальный сервер имён (B<named>(8)). Действием по умолчанию является запрос к настроенным источникам диспетчера службы имён (B<nsswitch.conf(5))>, при ошибке — к локальному серверу имён (B<named>(8))."

#. type: SS
#: man-pages/man3/gethostbyname.3:246
#, no-wrap
msgid "Historical"
msgstr "Историческая справка"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:250
msgid ""
"The B<nsswitch.conf>(5)  file is the modern way of controlling the order of "
"host lookups."
msgstr "Современным способом управления порядком поиска узлов является файл B<nsswitch.conf>(5)."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:256
msgid ""
"In glibc 2.4 and earlier, the I<order> keyword was used to control the order"
" of host lookups as defined in I</etc/host.conf> (B<host.conf>(5))."
msgstr "В glibc 2.4 и старее, ключевое слово I<order> использовалось для управления порядком поиска узла в I</etc/host.conf> (B<host.conf>(5))."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:259
msgid ""
"The I<hostent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "Структура I<hostent> определена в I<E<lt>netdb.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:270
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* for backward compatibility */\n"
msgstr "struct hostent {\n    char  *h_name;            /* официальное имя узла */\n    char **h_aliases;         /* список псевдонимов */\n    int    h_addrtype;        /* тип адреса узла */\n    int    h_length;          /* длина адреса */\n    char **h_addr_list;       /* список адресов */\n}\n#define h_addr h_addr_list[0] /* для обратной совместимости */\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:274
msgid "The members of the I<hostent> structure are:"
msgstr "Члены структуры I<hostent>:"

#. type: TP
#: man-pages/man3/gethostbyname.3:274
#, no-wrap
msgid "I<h_name>"
msgstr "I<h_name>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:277
msgid "The official name of the host."
msgstr "Официальное имя узла."

#. type: TP
#: man-pages/man3/gethostbyname.3:277
#, no-wrap
msgid "I<h_aliases>"
msgstr "I<h_aliases>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:280
msgid ""
"An array of alternative names for the host, terminated by a null pointer."
msgstr "Массив альтернативных имён узла, заканчивается указателем null."

#. type: TP
#: man-pages/man3/gethostbyname.3:280
#, no-wrap
msgid "I<h_addrtype>"
msgstr "I<h_addrtype>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:287
msgid "The type of address; always B<AF_INET> or B<AF_INET6> at present."
msgstr "Тип адреса; B<AF_INET> или B<AF_INET6>."

#. type: TP
#: man-pages/man3/gethostbyname.3:287
#, no-wrap
msgid "I<h_length>"
msgstr "I<h_length>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:290
msgid "The length of the address in bytes."
msgstr "Длина адреса в байтах."

#. type: TP
#: man-pages/man3/gethostbyname.3:290
#, no-wrap
msgid "I<h_addr_list>"
msgstr "I<h_addr_list>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:294
msgid ""
"An array of pointers to network addresses for the host (in network byte "
"order), terminated by a null pointer."
msgstr "Массив указателей сетевых адресов узла (в сетевом порядке байт), заканчивается указателем null."

#. type: TP
#: man-pages/man3/gethostbyname.3:294
#, no-wrap
msgid "I<h_addr>"
msgstr "I<h_addr>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:297
msgid "The first address in I<h_addr_list> for backward compatibility."
msgstr "Первый адрес из I<h_addr_list>, для обратной совместимости."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:309
msgid ""
"The B<gethostbyname>()  and B<gethostbyaddr>()  functions return the "
"I<hostent> structure or a null pointer if an error occurs.  On error, the "
"I<h_errno> variable holds an error number.  When non-NULL, the return value "
"may point at static data, see the notes below."
msgstr "Функции B<gethostbyname>() и B<gethostbyaddr>() возвращают структуру I<hostent> или указатель null при ошибке. При ошибке переменная I<h_errno> содержит номер ошибки. Если получен не NULL, то возвращаемое значение может указывать на статические данные, смотрите замечание далее."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:311
msgid "The variable I<h_errno> can have the following values:"
msgstr "Переменная I<h_errno> может содержать следующие значения:"

#. type: TP
#: man-pages/man3/gethostbyname.3:311
#, no-wrap
msgid "B<HOST_NOT_FOUND>"
msgstr "B<HOST_NOT_FOUND>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:314
msgid "The specified host is unknown."
msgstr "Заданный узел неизвестен."

#. type: TP
#: man-pages/man3/gethostbyname.3:314
#, no-wrap
msgid "B<NO_DATA>"
msgstr "B<NO_DATA>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:323
msgid ""
"The requested name is valid but does not have an IP address.  Another type "
"of request to the name server for this domain may return an answer.  The "
"constant B<NO_ADDRESS> is a synonym for B<NO_DATA>."
msgstr "Запрашиваемое имя корректно, но не имеет IP-адреса. При другом типе запроса для этого домена сервер имён может вернуть ответ. Синонимом B<NO_DATA> является константа B<NO_ADDRESS>."

#. type: TP
#: man-pages/man3/gethostbyname.3:323
#, no-wrap
msgid "B<NO_RECOVERY>"
msgstr "B<NO_RECOVERY>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:326
msgid "A nonrecoverable name server error occurred."
msgstr "Произошла неисправимая ошибка сервера имён."

#. type: TP
#: man-pages/man3/gethostbyname.3:326
#, no-wrap
msgid "B<TRY_AGAIN>"
msgstr "B<TRY_AGAIN>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:330
msgid ""
"A temporary error occurred on an authoritative name server.  Try again "
"later."
msgstr "Произошла временная ошибка у авторитативного сервера имён. Попробуйте позже."

#. type: TP
#: man-pages/man3/gethostbyname.3:331
#, no-wrap
msgid "I</etc/host.conf>"
msgstr "I</etc/host.conf>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:334
msgid "resolver configuration file"
msgstr "файл с настройками резолвера"

#. type: TP
#: man-pages/man3/gethostbyname.3:334
#, no-wrap
msgid "I</etc/hosts>"
msgstr "I</etc/hosts>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:337
msgid "host database file"
msgstr "файл базы данных узлов"

#. type: TP
#: man-pages/man3/gethostbyname.3:337
#, no-wrap
msgid "I</etc/nsswitch.conf>"
msgstr "I</etc/nsswitch.conf>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:340
msgid "name service switch configuration"
msgstr "настройки диспетчера службы имён"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:350
#, no-wrap
msgid "B<gethostbyname>()"
msgstr "B<gethostbyname>()"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:352
#, no-wrap
msgid "MT-Unsafe race:hostbyname env\n"
msgstr "MT-Unsafe race:hostbyname env\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:352 man-pages/man3/gethostbyname.3:359
#: man-pages/man3/gethostbyname.3:364 man-pages/man3/gethostbyname.3:366
#: man-pages/man3/gethostbyname.3:370 man-pages/man3/gethostbyname.3:375
#: man-pages/man3/gethostbyname.3:382 man-pages/man3/gethostbyname.3:389
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:354 man-pages/man3/gethostbyname.3:361
#: man-pages/man3/gethostbyname.3:372
#, no-wrap
msgid "locale"
msgstr "locale"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:357
#, no-wrap
msgid "B<gethostbyaddr>()"
msgstr "B<gethostbyaddr>()"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:359
#, no-wrap
msgid "MT-Unsafe race:hostbyaddr env\n"
msgstr "MT-Unsafe race:hostbyaddr env\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:364
#, no-wrap
msgid "B<sethostent>(),\n"
msgstr "B<sethostent>(),\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:366
#, no-wrap
msgid "B<endhostent>(),\n"
msgstr "B<endhostent>(),\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:368
#, no-wrap
msgid "B<gethostent_r>()"
msgstr "B<gethostent_r>()"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:370
#, no-wrap
msgid "MT-Unsafe race:hostent env\n"
msgstr "MT-Unsafe race:hostent env\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:375
#, no-wrap
msgid "B<herror>(),\n"
msgstr "B<herror>(),\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:377
#, no-wrap
msgid "B<hstrerror>()"
msgstr "B<hstrerror>()"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:380
#, no-wrap
msgid "B<gethostent>()"
msgstr "B<gethostent>()"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:382
#, no-wrap
msgid "MT-Unsafe race:hostent\n"
msgstr "MT-Unsafe race:hostent\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:384
#, no-wrap
msgid "race:hostentbuf env locale"
msgstr "race:hostentbuf env locale"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:387
#, no-wrap
msgid "B<gethostbyname2>()"
msgstr "B<gethostbyname2>()"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:389
#, no-wrap
msgid "MT-Unsafe race:hostbyname2\n"
msgstr "MT-Unsafe race:hostbyname2\n"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:391
#, no-wrap
msgid "env locale"
msgstr "env locale"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:396
#, no-wrap
msgid ""
"B<gethostbyaddr_r>(),\n"
"B<gethostbyname_r>(),\n"
"B<gethostbyname2_r>()"
msgstr "B<gethostbyaddr_r>(),\nB<gethostbyname_r>(),\nB<gethostbyname2_r>()"

#. type: tbl table
#: man-pages/man3/gethostbyname.3:396
#, no-wrap
msgid "MT-Safe env locale"
msgstr "MT-Safe env locale"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:411
msgid ""
"In the above table, I<hostent> in I<race:hostent> signifies that if any of "
"the functions B<sethostent>(), B<gethostent>(), B<gethostent_r>(), or "
"B<endhostent>()  are used in parallel in different threads of a program, "
"then data races could occur."
msgstr "В приведённой выше таблице I<hostent> в I<race:hostent> означает, что если в нескольких нитях программы одновременно используются функции B<sethostent>(), B<gethostent>(), B<gethostent_r>() или B<endhostent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:435
msgid ""
"POSIX.1-2001 specifies B<gethostbyname>(), B<gethostbyaddr>(), "
"B<sethostent>(), B<endhostent>(), B<gethostent>(), and I<h_errno>; "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno> are marked "
"obsolescent in that standard.  POSIX.1-2008 removes the specifications of "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno>, recommending the use"
" of B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr "В POSIX.1-2001 определены B<gethostbyname>(), B<gethostbyaddr>(), B<sethostent>(), B<endhostent>(), B<gethostent>() и I<h_errno>; функции B<gethostbyname>(), B<gethostbyaddr>() и I<h_errno> помечены как устаревшие. В POSIX.1-2008 удалены определения B<gethostbyname>(), B<gethostbyaddr>() и I<h_errno>; вместо них рекомендуется использовать B<getaddrinfo>(3) и B<getnameinfo>(3)."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:445
msgid ""
"The functions B<gethostbyname>()  and B<gethostbyaddr>()  may return "
"pointers to static data, which may be overwritten by later calls.  Copying "
"the I<struct hostent> does not suffice, since it contains pointers; a deep "
"copy is required."
msgstr "Функции B<gethostbyname>() и B<gethostbyaddr>() могут возвращать указатели на статические данные, которые могут быть перезаписаны при последующих вызовах. Копирования I<struct hostent> недостаточно, так как она содержит указатели; требуется глубокое копирование."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:469
msgid ""
"In the original BSD implementation the I<len> argument of B<gethostbyname>()"
"  was an I<int>.  The SUSv2 standard is buggy and declares the I<len> "
"argument of B<gethostbyaddr>()  to be of type I<size_t>.  (That is wrong, "
"because it has to be I<int>, and I<size_t> is not.  POSIX.1-2001 makes it "
"I<socklen_t>, which is OK.)  See also B<accept>(2)."
msgstr "В первой реализации BSD аргумент I<len> у B<gethostbyname>() имел тип I<int>. Стандарт SUSv2 содержит ошибку и объявляет аргумент I<len> у B<gethostbyaddr>() с типом I<size_t> (это неправильно, так как он должен быть I<int>, а не I<size_t>. В POSIX.1-2001 указанный тип — I<socklen_t>, который подходит). Смотрите также B<accept>(2)."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:475
msgid ""
"The BSD prototype for B<gethostbyaddr>()  uses I<const char\\ *> for the "
"first argument."
msgstr "У прототипа BSD B<gethostbyaddr>() первый аргумент имеет тип I<const char\\ *>."

#. type: SS
#: man-pages/man3/gethostbyname.3:475
#, no-wrap
msgid "System V/POSIX extension"
msgstr "Расширение System V/POSIX"

#.  e.g., Linux, FreeBSD, UnixWare, HP-UX
#.  e.g., FreeBSD, AIX
#. type: Plain text
#: man-pages/man3/gethostbyname.3:492
msgid ""
"POSIX requires the B<gethostent>()  call, which should return the next entry"
" in the host data base.  When using DNS/BIND this does not make much sense, "
"but it may be reasonable if the host data base is a file that can be read "
"line by line.  On many systems, a routine of this name reads from the file "
"I</etc/hosts>.  It may be available only when the library was built without "
"DNS support.  The glibc version will ignore ipv6 entries.  This function is "
"not reentrant, and glibc adds a reentrant version B<gethostent_r>()."
msgstr "В POSIX требуется вызов B<gethostent>(), который должен возвращать следующий элемент из базы данных узлов. При использовании DNS/BIND это не имеет смысла, но допустимо, если база данных узлов — файл, который можно читать строку за строкой. На многих системах процедура с таким именем выполняет чтение из файла I</etc/hosts>. Она может быть доступна только когда библиотека собрана без поддержки DNS. Версия glibc игнорирует записи ipv6. Эта функция не реентерабельна; в glibc добавлена реентерабельная версия B<gethostent_r>()."

#. type: SS
#: man-pages/man3/gethostbyname.3:492
#, no-wrap
msgid "GNU extensions"
msgstr "Расширения GNU"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:498
msgid ""
"Glibc2 also has a B<gethostbyname2>()  that works like B<gethostbyname>(), "
"but permits to specify the address family to which the address must belong."
msgstr "В glibc2 также имеется B<gethostbyname2>(), работающая подобно B<gethostbyname>(), но позволяющая задать адресное семейство, которому должен принадлежать адрес."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:532
msgid ""
"Glibc2 also has reentrant versions B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>()  and B<gethostbyname2_r>().  The caller supplies a "
"I<hostent> structure I<ret> which will be filled in on success, and a "
"temporary work buffer I<buf> of size I<buflen>.  After the call, I<result> "
"will point to the result on success.  In case of an error or if no entry is "
"found I<result> will be NULL.  The functions return 0 on success and a "
"nonzero error number on failure.  In addition to the errors returned by the "
"nonreentrant versions of these functions, if I<buf> is too small, the "
"functions will return B<ERANGE>, and the call should be retried with a "
"larger buffer.  The global variable I<h_errno> is not modified, but the "
"address of a variable in which to store error numbers is passed in "
"I<h_errnop>."
msgstr "В glibc2 также имеются реентерабельные версии B<gethostent_r>(), B<gethostbyaddr_r>(), B<gethostbyname_r>() и B<gethostbyname2_r>(). Вызывающий передаёт структуру I<hostent> I<ret>, которая будет заполнена, и временный рабочий буфер I<buf> размера I<buflen>. После вызова I<result> будет указывать на результат. В случае ошибки или при отсутствии записи I<result> будет NULL. При успешном выполнении функция возвращает 0 и ненулевой номер ошибки при сбое. Если I<buf> слишком мал, то кроме ошибок, возвращаемых нереентерабельными версиями этих функций, возвращается B<ERANGE>, и вызов нужно повторить с большим буфером. Глобальная переменная I<h_errno> не изменяется, но адрес переменной, в которой хранятся номера ошибок, передаётся в I<h_errnop>."

#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=482973
#. type: Plain text
#: man-pages/man3/gethostbyname.3:537
msgid ""
"B<gethostbyname>()  does not recognize components of a dotted IPv4 address "
"string that are expressed in hexadecimal."
msgstr "Функция B<gethostbyname>() не работает с частями строки адреса IPv4 в точечном формате, если они записаны шестнадцатеричными числами."

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: man-pages/man3/gethostbyname.3:549
msgid ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"

#. type: TH
#: man-pages/man3/getpwnam.3:37
#, no-wrap
msgid "GETPWNAM"
msgstr "GETPWNAM"

#. type: TH
#: man-pages/man3/getpwnam.3:37
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/getpwnam.3:40
msgid "getpwnam, getpwnam_r, getpwuid, getpwuid_r - get password file entry"
msgstr "getpwnam, getpwnam_r, getpwuid, getpwuid_r - получает записи из файла паролей"

#. type: Plain text
#: man-pages/man3/getpwnam.3:44
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:46
#, no-wrap
msgid "B<struct passwd *getpwnam(const char *>I<name>B<);>\n"
msgstr "B<struct passwd *getpwnam(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:48
#, no-wrap
msgid "B<struct passwd *getpwuid(uid_t >I<uid>B<);>\n"
msgstr "B<struct passwd *getpwuid(uid_t >I<uid>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:51
#, no-wrap
msgid ""
"B<int getpwnam_r(const char *>I<name>B<, struct passwd *>I<pwd>B<,>\n"
"B<               char *>I<buf>B<, size_t >I<buflen>B<, struct passwd **>I<result>B<);>\n"
msgstr "B<int getpwnam_r(const char *>I<name>B<, struct passwd *>I<pwd>B<,>\nB<               char *>I<buf>B<, size_t >I<buflen>B<, struct passwd **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:54
#, no-wrap
msgid ""
"B<int getpwuid_r(uid_t >I<uid>B<, struct passwd *>I<pwd>B<,>\n"
"B<               char *>I<buf>B<, size_t >I<buflen>B<, struct passwd **>I<result>B<);>\n"
msgstr "B<int getpwuid_r(uid_t >I<uid>B<, struct passwd *>I<pwd>B<,>\nB<               char *>I<buf>B<, size_t >I<buflen>B<, struct passwd **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:64
msgid "B<getpwnam_r>(), B<getpwuid_r>():"
msgstr "B<getpwnam_r>(), B<getpwuid_r>():"

#. type: Plain text
#: man-pages/man3/getpwnam.3:67
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "_POSIX_C_SOURCE\n    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:79
msgid ""
"The B<getpwnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the password database (e.g., the local "
"password file I</etc/passwd>, NIS, and LDAP)  that matches the username "
"I<name>."
msgstr "Функция B<getpwnam>() возвращает указатель на структуру, содержащую разделённую на поля запись из базы данных паролей (например, из локального файла паролей I</etc/passwd>, NIS и LDAP), которая соответствует имени пользователя I<name>."

#. type: Plain text
#: man-pages/man3/getpwnam.3:86
msgid ""
"The B<getpwuid>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the password database that matches the "
"user ID I<uid>."
msgstr "Функция B<getpwuid>() возвращает указатель на структуру, содержащую разделённую на поля запись из базы данных паролей, которая соответствует идентификатору пользователя I<uid>."

#. type: Plain text
#: man-pages/man3/getpwnam.3:88
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr "Структура I<passwd> определена в I<E<lt>pwd.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/getpwnam.3:100
#, no-wrap
msgid ""
"struct passwd {\n"
"    char   *pw_name;       /* username */\n"
"    char   *pw_passwd;     /* user password */\n"
"    uid_t   pw_uid;        /* user ID */\n"
"    gid_t   pw_gid;        /* group ID */\n"
"    char   *pw_gecos;      /* user information */\n"
"    char   *pw_dir;        /* home directory */\n"
"    char   *pw_shell;      /* shell program */\n"
"};\n"
msgstr "struct passwd {\n    char   *pw_name;       /* имя пользователя */\n    char   *pw_passwd;     /* пароль пользователя */\n    uid_t   pw_uid;        /* идентификатор пользователя */\n    gid_t   pw_gid;        /* идентификатор группы */\n    char   *pw_gecos;      /* информация о пользователе */\n    char   *pw_dir;        /* домашний каталог */\n    char   *pw_shell;      /* программная оболочка */\n};\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:106
msgid "See B<passwd>(5)  for more information about these fields."
msgstr "Подробней об этих полях смотрите в B<passwd>(5)."

#. type: Plain text
#: man-pages/man3/getpwnam.3:128
msgid ""
"The B<getpwnam_r>()  and B<getpwuid_r>()  functions obtain the same "
"information as B<getpwnam>()  and B<getpwuid>(), but store the retrieved "
"I<passwd> structure in the space pointed to by I<pwd>.  The string fields "
"pointed to by the members of the I<passwd> structure are stored in the "
"buffer I<buf> of size I<buflen>.  A pointer to the result (in case of "
"success) or NULL (in case no entry was found or an error occurred) is stored"
" in I<*result>."
msgstr "Функции B<getpwnam_r>() и B<getpwuid_r>() принимают ту же информацию что и B<getpwnam>() и B<getpwuid>(), но сохраняют полученную структуру I<passwd> в пространство, указанное I<pwd>. Строковые поля членов структуры I<passwd> сохраняются в буфере I<buf> размера I<buflen>. Указатель на результат (при успешном выполнении) или NULL (если записи отсутствуют или произошла ошибка) сохраняется в I<*result>."

#. type: Plain text
#: man-pages/man3/getpwnam.3:130
msgid "The call"
msgstr "Вызов"

#. type: Plain text
#: man-pages/man3/getpwnam.3:132
#, no-wrap
msgid "    sysconf(_SC_GETPW_R_SIZE_MAX)\n"
msgstr "    sysconf(_SC_GETPW_R_SIZE_MAX)\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:141
msgid ""
"returns either -1, without changing I<errno>, or an initial suggested size "
"for I<buf>.  (If this size is too small, the call fails with B<ERANGE>, in "
"which case the caller can retry with a larger buffer.)"
msgstr "возвращает или -1 без изменения I<errno> или начальный предполагаемый размер I<buf> (если этот размер мал, то вызов завершается B<ERANGE>; в этом случае вызывающий может повторить вызов с большим буфером)."

#. type: Plain text
#: man-pages/man3/getpwnam.3:156
msgid ""
"The B<getpwnam>()  and B<getpwuid>()  functions return a pointer to a "
"I<passwd> structure, or NULL if the matching entry is not found or an error "
"occurs.  If an error occurs, I<errno> is set appropriately.  If one wants to"
" check I<errno> after the call, it should be set to zero before the call."
msgstr "Функции B<getpwnam>() и B<getpwuid>() возвращают указатель на структуру I<passwd> или NULL, если подходящих записей не найдено или возникла ошибка. При ошибке I<errno> устанавливается в соответствующее значение. Если нужно проверять переменную I<errno> после вызова, то перед этим нужно присвоить ей нулевое значение."

#. type: Plain text
#: man-pages/man3/getpwnam.3:165
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getpwent>(3), B<getpwnam>(), or B<getpwuid>().  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr "Возвращаемое значение может указывать на статическую область и может быть перезаписано при последующих вызовах B<getpwent>(3), B<getpwnam>() или B<getpwuid>() (не передавайте полученный указатель B<free>(3))."

#. type: Plain text
#: man-pages/man3/getpwnam.3:179
msgid ""
"On success, B<getpwnam_r>()  and B<getpwuid_r>()  return zero, and set "
"I<*result> to I<pwd>.  If no matching password record was found, these "
"functions return 0 and store NULL in I<*result>.  In case of error, an error"
" number is returned, and NULL is stored in I<*result>."
msgstr "При успешном выполнении B<getpwnam_r>() и B<getpwuid_r>() возвращают ноль, и устанавливают I<*result> в I<pwd>. Если совпадений не найдено, то эти функции возвращают 0 и сохраняют NULL в I<*result>. При ошибке возвращается её номер и в I<*result> сохраняется NULL."

#. type: TP
#: man-pages/man3/getpwnam.3:180
#, no-wrap
msgid "B<0> or B<ENOENT> or B<ESRCH> or B<EBADF> or B<EPERM> or ... "
msgstr "B<0> или B<ENOENT> или B<ESRCH> или B<EBADF> или B<EPERM> или … "

#. type: Plain text
#: man-pages/man3/getpwnam.3:187
msgid "The given I<name> or I<uid> was not found."
msgstr "Указанное значение I<name> или I<uid> не найдено."

#. type: Plain text
#: man-pages/man3/getpwnam.3:191
msgid "A signal was caught; see B<signal>(7)."
msgstr "Поступил сигнал; смотрите B<signal>(7)."

#. type: TP
#: man-pages/man3/getpwnam.3:191
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:194
msgid "I/O error."
msgstr "Ошибка ввода-вывода."

#. type: TP
#: man-pages/man3/getpwnam.3:194
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:197
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "Было достигнуто ограничение по количеству открытых файловых дескрипторов на процесс."

#. type: TP
#: man-pages/man3/getpwnam.3:197
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:200
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#.  not in POSIX
#.  This structure is static, allocated 0 or 1 times. No memory leak. (libc45)
#. type: Plain text
#: man-pages/man3/getpwnam.3:207
msgid "Insufficient memory to allocate I<passwd> structure."
msgstr "Недостаточно памяти для структуры I<passwd>."

#. type: Plain text
#: man-pages/man3/getpwnam.3:210
msgid "Insufficient buffer space supplied."
msgstr "Недостаточно места в буфере."

#. type: TP
#: man-pages/man3/getpwnam.3:211
#, no-wrap
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:214
msgid "local password database file"
msgstr "файл, содержащий локальную базу паролей"

#. type: tbl table
#: man-pages/man3/getpwnam.3:224
#, no-wrap
msgid "B<getpwnam>()"
msgstr "B<getpwnam>()"

#. type: tbl table
#: man-pages/man3/getpwnam.3:224
#, no-wrap
msgid "MT-Unsafe race:pwnam locale"
msgstr "MT-Unsafe race:pwnam locale"

#. type: tbl table
#: man-pages/man3/getpwnam.3:227
#, no-wrap
msgid "B<getpwuid>()"
msgstr "B<getpwuid>()"

#. type: tbl table
#: man-pages/man3/getpwnam.3:227
#, no-wrap
msgid "MT-Unsafe race:pwuid locale"
msgstr "MT-Unsafe race:pwuid locale"

#. type: tbl table
#: man-pages/man3/getpwnam.3:230
#, no-wrap
msgid "B<getpwnam_r>(),\n"
msgstr "B<getpwnam_r>(),\n"

#. type: tbl table
#: man-pages/man3/getpwnam.3:232
#, no-wrap
msgid "B<getpwuid_r>()"
msgstr "B<getpwuid_r>()"

#. type: tbl table
#: man-pages/man3/getpwnam.3:232
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#. type: Plain text
#: man-pages/man3/getpwnam.3:239
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  The I<pw_gecos> field is not "
"specified in POSIX, but is present on most implementations."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD. Поле I<pw_gecos> не определено в стандарте POSIX, но присутствует в большинстве реализаций."

#.  more precisely:
#.  AIX 5.1 - gives ESRCH
#.  OSF1 4.0g - gives EWOULDBLOCK
#.  libc, glibc up to version 2.6, Irix 6.5 - give ENOENT
#.  glibc since version 2.7 - give 0
#.  FreeBSD 4.8, OpenBSD 3.2, NetBSD 1.6 - give EPERM
#.  SunOS 5.8 - gives EBADF
#.  Tru64 5.1b, HP-UX-11i, SunOS 5.7 - give 0
#. type: Plain text
#: man-pages/man3/getpwnam.3:260
msgid ""
"The formulation given above under \"RETURN VALUE\" is from POSIX.1-2001.  It"
" does not call \"not found\" an error, and hence does not specify what value"
" I<errno> might have in this situation.  But that makes it impossible to "
"recognize errors.  One might argue that according to POSIX I<errno> should "
"be left unchanged if an entry is not found.  Experiments on various UNIX-"
"like systems show that lots of different values occur in this situation: 0, "
"ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM, and probably others."
msgstr "Описание «ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ», приведённого выше, взято из POSIX.1-2001. В нём «не найдено» не считается ошибкой и поэтому не указано, каким может быть значение I<errno> в этом случае. Но это делает невозможным определить тип ошибки. Из описание POSIX можно посчитать, что I<errno> не должно измениться, если запись не найдена. Эксперименты в различных UNIX-подобных системах показывают, что в этой ситуации возвращается много разных значений: 0, ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM и, возможно, другие."

#. type: Plain text
#: man-pages/man3/getpwnam.3:278
msgid ""
"The I<pw_dir> field contains the name of the initial working directory of "
"the user.  Login programs use the value of this field to initialize the "
"B<HOME> environment variable for the login shell.  An application that wants"
" to determine its user's home directory should inspect the value of B<HOME> "
"(rather than the value I<getpwuid(getuid())-E<gt>pw_dir>)  since this allows"
" the user to modify their notion of \"the home directory\" during a login "
"session.  To determine the (initial) home directory of another user, it is "
"necessary to use I<getpwnam(\"username\")-E<gt>pw_dir> or similar."
msgstr "В поле I<pw_dir> содержится имя первого рабочего каталога пользователя. Программы входа используют это значение для инициализации переменной окружения B<HOME> для регистрационной оболочки. Приложение, которое хочет определить имя домашнего каталога пользователя должно проверять значение B<HOME> (а не значение I<getpwuid(getuid())-E<gt>pw_dir>), так как это позволяет пользователю изменять их понятие о «домашнем каталоге» в течении сеанса. Для определения (начального) домашнего каталога другого пользователя необходимо использовать I<getpwnam(\"имя пользователя\")-E<gt>pw_dir> или похожий вызов."

#. type: Plain text
#: man-pages/man3/getpwnam.3:283
msgid ""
"The program below demonstrates the use of B<getpwnam_r>()  to find the full "
"username and user ID for the username supplied as a command-line argument."
msgstr "Представленная ниже программа использует B<getpwnam_r>() при поиске полного имени пользователя и его ID согласно указанному имени в аргументе командной строки."

#. type: Plain text
#: man-pages/man3/getpwnam.3:290
#, no-wrap
msgid ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr "#include E<lt>pwd.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:299
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct passwd pwd;\n"
"    struct passwd *result;\n"
"    char *buf;\n"
"    size_t bufsize;\n"
"    int s;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct passwd pwd;\n    struct passwd *result;\n    char *buf;\n    size_t bufsize;\n    int s;\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:304
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s username\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s имя\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:308
#, no-wrap
msgid ""
"    bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n"
"    if (bufsize == -1)          /* Value was indeterminate */\n"
"        bufsize = 16384;        /* Should be more than enough */\n"
msgstr "    bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n    if (bufsize == -1)          /* значение не указано */\n        bufsize = 16384;        /* должно быть достаточно */\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:314
#, no-wrap
msgid ""
"    buf = malloc(bufsize);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    buf = malloc(bufsize);\n    if (buf == NULL) {\n        perror(\"malloc\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:325
#, no-wrap
msgid ""
"    s = getpwnam_r(argv[1], &pwd, buf, bufsize, &result);\n"
"    if (result == NULL) {\n"
"        if (s == 0)\n"
"            printf(\"Not found\\en\");\n"
"        else {\n"
"            errno = s;\n"
"            perror(\"getpwnam_r\");\n"
"        }\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    s = getpwnam_r(argv[1], &pwd, buf, bufsize, &result);\n    if (result == NULL) {\n        if (s == 0)\n            printf(\"Не найдено\\en\");\n        else {\n            errno = s;\n            perror(\"getpwnam_r\");\n        }\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:329
#, no-wrap
msgid ""
"    printf(\"Name: %s; UID: %ld\\en\", pwd.pw_gecos, (long) pwd.pw_uid);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    printf(\"Имя: %s; UID: %ld\\en\", pwd.pw_gecos, (long) pwd.pw_uid);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:339
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getgrnam>(3), B<getpw>(3), "
"B<getpwent>(3), B<getspnam>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"
msgstr "B<endpwent>(3), B<fgetpwent>(3), B<getgrnam>(3), B<getpw>(3), B<getpwent>(3), B<getspnam>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getservent_r.3:26
#, no-wrap
msgid "GETSERVENT_R"
msgstr "GETSERVENT_R"

#. type: Plain text
#: man-pages/man3/getservent_r.3:30
msgid ""
"getservent_r, getservbyname_r, getservbyport_r - get service entry "
"(reentrant)"
msgstr "getservent_r, getservbyname_r, getservbyport_r - возвращает запись о службе (реентерабельные версии)"

#. type: Plain text
#: man-pages/man3/getservent_r.3:33
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:36
#, no-wrap
msgid ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr "B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:40
#, no-wrap
msgid ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr "B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\nB<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:44
#, no-wrap
msgid ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr "B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\nB<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:59
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getservent_r>(),\nB<getservbyname_r>(),\nB<getservbyport_r>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:77
msgid ""
"The B<getservent_r>(), B<getservbyname_r>(), and B<getservbyport_r>()  "
"functions are the reentrant equivalents of, respectively, B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  They differ in the way that "
"the I<servent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr "Функции B<getservent_r>(), B<getservbyname_r>() и B<getservbyport_r>() являются реентерабельными эквивалентами B<getservent>(3), B<getservbyname>(3) и B<getservbyport>(3), соответственно. Они отличаются способом возврата структуры I<servent> и списком параметров и типом возвращаемого значения. В этой справочной странице описаны только различия с нереентерабельными функциями."

#. type: Plain text
#: man-pages/man3/getservent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<servent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr "Вместо возврата указателя на статически выделенную структуру I<servent> в качестве результата эти функции копируют структуру в расположение, указанное I<result_buf>."

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getservent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<servent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr "Массив I<buf> используется для хранения строковых полей из возвращаемой структуры I<servent> (нереентерабельные функции выделяют эти строки из статического хранилища). Размер данного массива задаётся в I<buflen>. Если I<buf> слишком мал, то вызов завершается с ошибкой B<ERANGE>, вызывающий должен его повторить с большим буфером (для большинства приложений должно быть достаточно буфера длиной 1024 байт)."

#. type: Plain text
#: man-pages/man3/getservent_r.3:108
msgid ""
"If the function call successfully obtains a service record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr "Если вызов получил запись о службе, то  I<*result> указывает на I<result_buf>; в противном случае I<*result> устанавливается в NULL."

#. type: Plain text
#: man-pages/man3/getservent_r.3:111
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in errors."
msgstr "При успешном выполнении эти функции возвращают 0. При ошибке возвращается одно из положительных значений ошибок."

#. type: Plain text
#: man-pages/man3/getservent_r.3:119
msgid ""
"On error, record not found (B<getservbyname_r>(), B<getservbyport_r>()), or "
"end of input (B<getservent_r>())  I<result> is set to NULL."
msgstr "При ошибке, отсутствии записи (B<getservbyname_r>(), B<getservbyport_r>()) или конце данных (B<getservent_r>()) значение I<result> равно NULL."

#. type: Plain text
#: man-pages/man3/getservent_r.3:124
msgid "(B<getservent_r>())  No more records in database."
msgstr "(B<getservent_r>()) Больше нет записей в базе данных."

#. type: Plain text
#: man-pages/man3/getservent_r.3:131
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr "Размер I<buf> слишком мал. Попробуйте ещё раз с большим буфером (и увеличенным значением I<buflen>)."

#. type: tbl table
#: man-pages/man3/getservent_r.3:144
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>()"
msgstr "B<getservent_r>(),\nB<getservbyname_r>(),\nB<getservbyport_r>()"

#. type: Plain text
#: man-pages/man3/getservent_r.3:151
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr "Эти функции являются расширениями GNU. Функции с похожими именами есть и в других системах, хотя и с другим набором параметров."

#. type: Plain text
#: man-pages/man3/getservent_r.3:165
msgid ""
"The program below uses B<getservbyport_r>()  to retrieve the service record "
"for the port and protocol named in its first command-line argument.  If a "
"third (integer) command-line argument is supplied, it is used as the initial"
" value for I<buflen>; if B<getservbyport_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr "Программа, представленная ниже, использует B<getservbyport_r>() для получения записи о службе для заданного порта и протокола, указанных в командной строке. Если задан и третий параметр (целое), то он используется как начальное значение I<buflen>; если B<getservbyport_r>() завершается с ошибкой B<ERANGE>, то программа повторяет попытки с большими значениями буфера. Пара примеров работы в сеансовой оболочке:"

#. type: Plain text
#: man-pages/man3/getservent_r.3:175
#, no-wrap
msgid ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"
msgstr "$B< ./a.out 7 tcp 1>\nERANGE! Повтор с большим буфером\ngetservbyport_r() returned: 0 (success)  (buflen=87)\ns_name=echo; s_proto=tcp; s_port=7; aliases=\n$B< ./a.out 77777 tcp>\ngetservbyport_r() returned: 0 (success)  (buflen=1024)\nОшибка вызова/запись не найдена\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:187
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>ctype.hE<gt>\n#include E<lt>netdb.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>errno.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:189
#, no-wrap
msgid "#define MAX_BUF 10000\n"
msgstr "#define MAX_BUF 10000\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:199
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
"    char **p;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int buflen, erange_cnt, port, s;\n    struct servent result_buf;\n    struct servent *result;\n    char buf[MAX_BUF];\n    char *protop;\n    char **p;\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:204
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 3) {\n        printf(\"Использование: %s ном-порта имя-прото [длина-буф]\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:208
#, no-wrap
msgid ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"              strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"
msgstr "    port = htons(atoi(argv[1]));\n    protop = (strcmp(argv[2], \"null\") == 0 ||\n              strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:212
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"
msgstr "    buflen = 1024;\n    if (argc E<gt> 3)\n        buflen = atoi(argv[3]);\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:217
#, no-wrap
msgid ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (buflen E<gt> MAX_BUF) {\n        printf(\"Превышен размер буфера (%d)\\en\", MAX_BUF);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:226
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr "    erange_cnt = 0;\n    do {\n        s = getservbyport_r(port, protop, &result_buf,\n                     buf, buflen, &result);\n        if (s == ERANGE) {\n            if (erange_cnt == 0)\n                printf(\"ERANGE! Повтор с большим буфером\\en\");\n            erange_cnt++;\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:229
#, no-wrap
msgid ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"
msgstr "            /* Увеличиваем по байту за раз для того, чтобы мы могли\n               точно узнать какой размер буфера требуется */\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:231
#, no-wrap
msgid "            buflen++;\n"
msgstr "            buflen++;\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:238
#, no-wrap
msgid ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"
msgstr "            if (buflen E<gt> MAX_BUF) {\n                printf(\"Превышен размер буфера (%d)\\en\", MAX_BUF);\n                exit(EXIT_FAILURE);\n            }\n        }\n    } while (s == ERANGE);\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:242
#, no-wrap
msgid ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr "    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n            strerror(s), buflen);\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:247
#, no-wrap
msgid ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (s != 0 || result == NULL) {\n        printf(\"Ошибка вызова/запись не найдена\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:254
#, no-wrap
msgid ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr "    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n                result_buf.s_name, result_buf.s_proto,\n                ntohs(result_buf.s_port));\n    for (p = result_buf.s_aliases; *p != NULL; p++)\n        printf(\"%s \", *p);\n    printf(\"\\en\");\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:260
msgid "B<getservent>(3), B<services>(5)"
msgstr "B<getservent>(3), B<services>(5)"

#. type: TH
#: man-pages/man3/gethostid.3:29
#, no-wrap
msgid "GETHOSTID"
msgstr "GETHOSTID"

#. type: Plain text
#: man-pages/man3/gethostid.3:32
msgid ""
"gethostid, sethostid - get or set the unique identifier of the current host"
msgstr "gethostid, sethostid - возвращает или назначает уникальный идентификатор текущего узла"

#. type: Plain text
#: man-pages/man3/gethostid.3:36
msgid "B<long gethostid(void);>"
msgstr "B<long gethostid(void);>"

#. type: Plain text
#: man-pages/man3/gethostid.3:38
msgid "B<int sethostid(long >I<hostid>B<);>"
msgstr "B<int sethostid(long >I<hostid>B<);>"

#. type: Plain text
#: man-pages/man3/gethostid.3:47
msgid "B<gethostid>():"
msgstr "B<gethostid>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/gethostid.3:50
msgid "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/gethostid.3:52
msgid "B<sethostid>():"
msgstr "B<sethostid>():"

#. type: Plain text
#: man-pages/man3/gethostid.3:73
msgid ""
"B<gethostid>()  and B<sethostid>()  respectively get or set a unique 32-bit "
"identifier for the current machine.  The 32-bit identifier is intended to be"
" unique among all UNIX systems in existence.  This normally resembles the "
"Internet address for the local machine, as returned by B<gethostbyname>(3), "
"and thus usually never needs to be set."
msgstr "Функции B<gethostid>() и B<sethostid>(), соответственно, возвращают и устанавливают уникальный 32-битный идентификатор текущей машины. Данный 32-битный идентификатор считается уникальным среди всех существующих систем UNIX. Обычно это напоминает Интернет-адрес локальной машины, возвращаемый B<gethostbyname>(3), и поэтому, как правило, его не нужно изменять."

#. type: Plain text
#: man-pages/man3/gethostid.3:77
msgid "The B<sethostid>()  call is restricted to the superuser."
msgstr "Только суперпользователь может вызывать B<sethostid>()."

#. type: Plain text
#: man-pages/man3/gethostid.3:81
msgid ""
"B<gethostid>()  returns the 32-bit identifier for the current host as set by"
" B<sethostid>()."
msgstr "Функция B<gethostid>() возвращает 32-битный идентификатор текущего узла, установленный B<sethostid>()."

#. type: Plain text
#: man-pages/man3/gethostid.3:87
msgid ""
"On success, B<sethostid>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<sethostid>() возвращает 0; при ошибке — -1, а в I<errno> задаётся код ошибки."

#. type: Plain text
#: man-pages/man3/gethostid.3:90
msgid "B<sethostid>()  can fail with the following errors:"
msgstr "Вызов B<sethostid>() может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man3/gethostid.3:94
msgid ""
"The caller did not have permission to write to the file used to store the "
"host ID."
msgstr "Вызывающий не имеет прав на запись в файл, используемый для хранения ID узла."

#. type: Plain text
#: man-pages/man3/gethostid.3:98
msgid ""
"The calling process's effective user or group ID is not the same as its "
"corresponding real ID."
msgstr "Эффективный идентификатор пользователя или группы вызывающего процесса не совпадает с его соответствующим реальным идентификатором."

#. type: tbl table
#: man-pages/man3/gethostid.3:108
#, no-wrap
msgid "B<gethostid>()"
msgstr "B<gethostid>()"

#. type: tbl table
#: man-pages/man3/gethostid.3:108
#, no-wrap
msgid "MT-Safe hostid env locale"
msgstr "MT-Safe hostid env locale"

#. type: tbl table
#: man-pages/man3/gethostid.3:111
#, no-wrap
msgid "B<sethostid>()"
msgstr "B<sethostid>()"

#. type: tbl table
#: man-pages/man3/gethostid.3:111
#, no-wrap
msgid "MT-Unsafe const:hostid"
msgstr "MT-Unsafe const:hostid"

#. type: Plain text
#: man-pages/man3/gethostid.3:120
msgid ""
"4.2BSD; these functions were dropped in 4.4BSD.  SVr4 includes "
"B<gethostid>()  but not B<sethostid>()."
msgstr "42BSD; эти функции удалены в 4.4BSD. В SVr4 содержится B<gethostid>(), но отсутствует B<sethostid>()."

#. type: Plain text
#: man-pages/man3/gethostid.3:125
msgid ""
"POSIX.1-2001 and POSIX.1-2008 specify B<gethostid>()  but not "
"B<sethostid>()."
msgstr "В POSIX.1-2001 и POSIX.1-2008 определена B<gethostid>(), но отсутствует B<sethostid>()."

#.  libc5 used /etc/hostid; libc4 didn't have these functions
#. type: Plain text
#: man-pages/man3/gethostid.3:134
msgid ""
"In the glibc implementation, the I<hostid> is stored in the file "
"I</etc/hostid>.  (In glibc versions before 2.2, the file I</var/adm/hostid> "
"was used.)"
msgstr "В реализации glibc I<hostid> сохраняет значение в файле I</etc/hostid> (в glibc до версии 2.2 используется файл I</var/adm/hostid>)."

#. type: Plain text
#: man-pages/man3/gethostid.3:145
msgid ""
"In the glibc implementation, if B<gethostid>()  cannot open the file "
"containing the host ID, then it obtains the hostname using "
"B<gethostname>(2), passes that hostname to B<gethostbyname_r>(3)  in order "
"to obtain the host's IPv4 address, and returns a value obtained by bit-"
"twiddling the IPv4 address.  (This value may not be unique.)"
msgstr "В реализации glibc, если B<gethostid>() не может открыть файл, содержащий ID узла, она получает имя узла с помощью B<gethostname>(2), передаёт это имя B<gethostbyname_r>(3) для получения адреса IPv4 узла, и возвращает значение, получаемое преобразованием битов полученного адреса IPv4 (такое значение может быть не уникально)."

#. type: Plain text
#: man-pages/man3/gethostid.3:147
msgid "It is impossible to ensure that the identifier is globally unique."
msgstr "Невозможно достоверно сказать, что идентификатор является глобально уникальным."

#. type: Plain text
#: man-pages/man3/gethostid.3:149
msgid "B<hostid>(1), B<gethostbyname>(3)"
msgstr "B<hostid>(1), B<gethostbyname>(3)"

#. type: TH
#: man-pages/man3/getgrouplist.3:29
#, no-wrap
msgid "GETGROUPLIST"
msgstr "GETGROUPLIST"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:32
msgid "getgrouplist - get list of groups to which a user belongs"
msgstr "getgrouplist - возвращает список групп, в которые входит пользователь"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:36
msgid "B<int getgrouplist(const char *>I<user>B<, gid_t >I<group>B<,>"
msgstr "B<int getgrouplist(const char *>I<user>B<, gid_t >I<group>B<,>"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:38
msgid "B< gid_t *>I<groups>B<, int *>I<ngroups>B<);>"
msgstr "B< gid_t *>I<groups>B<, int *>I<ngroups>B<);>"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:49
#, no-wrap
msgid ""
"B<getgrouplist>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr "B<getgrouplist>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:61
msgid ""
"The B<getgrouplist>()  function scans the group database (see B<group>(5))  "
"to obtain the list of groups that I<user> belongs to.  Up to I<*ngroups> of "
"these groups are returned in the array I<groups>."
msgstr "Функция B<getgrouplist>() просматривает базу данных групп (смотрите B<group>(5)) для составления списка групп, в которые входит пользователь I<user>. В возвращаемом массиве I<groups> может быть до I<*ngroups> групп."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:71
msgid ""
"If it was not among the groups defined for I<user> in the group database, "
"then I<group> is included in the list of groups returned by "
"B<getgrouplist>(); typically this argument is specified as the group ID from"
" the password record for I<user>."
msgstr "Если в базе данных групп отсутствуют группы, определённые для I<user>, то в список групп, возвращаемый B<getgrouplist>(), включается I<group>; обычно, это аргумент задаётся в виде ID группы из записи пароля I<user>."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:81
msgid ""
"The I<ngroups> argument is a value-result argument: on return it always "
"contains the number of groups found for I<user>, including I<group>; this "
"value may be greater than the number of groups stored in I<groups>."
msgstr "Аргумент I<ngroups> является аргументом-результатом: при возврате в нём всегда содержится количество группы, найденных для I<user> включая I<group>; данное значение может быть больше, чем количество групп, хранящихся в I<groups>."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:89
msgid ""
"If the number of groups of which I<user> is a member is less than or equal "
"to I<*ngroups>, then the value I<*ngroups> is returned."
msgstr "Если количество групп, в которых I<user> является членом, меньше или равно I<*ngroups>, то возвращается значение I<*ngroups>."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:99
msgid ""
"If the user is a member of more than I<*ngroups> groups, then "
"B<getgrouplist>()  returns -1.  In this case, the value returned in "
"I<*ngroups> can be used to resize the buffer passed to a further call "
"B<getgrouplist>()."
msgstr "Если пользователь является членом более чем I<*ngroups> групп, то B<getgrouplist>() возвращает -1. В этом случае значение, возвращаемое в I<*ngroups>, можно использовать для подстройки размера буфера, передаваемого в последующий вызов B<getgrouplist>()."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:101
msgid "This function is present since glibc 2.2.4."
msgstr "Эта функция доступна в glibc с версии 2.2.4."

#. type: tbl table
#: man-pages/man3/getgrouplist.3:111
#, no-wrap
msgid "B<getgrouplist>()"
msgstr "B<getgrouplist>()"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:115
msgid "This function is nonstandard; it appears on most BSDs."
msgstr "Эта функция является нестандартной; она присутствует в большинстве BSD."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:124
msgid ""
"In glibc versions before 2.3.3, the implementation of this function contains"
" a buffer-overrun bug: it returns the complete list of groups for I<user> in"
" the array I<groups>, even when the number of groups exceeds I<*ngroups>."
msgstr "В glibc до версии 2.3.3 в реализации этой функции содержится ошибка переполнения буфера: она возвращает полный список групп для I<user> в массиве I<groups> даже когда количество групп превышает I<*ngroups>."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:133
msgid ""
"The program below displays the group list for the user named in its first "
"command-line argument.  The second command-line argument specifies the "
"I<ngroups> value to be supplied to B<getgrouplist>().  The following shell "
"session shows examples of the use of this program:"
msgstr "Программа, показанная далее, печатает список групп для пользователя из первого аргумента командной строки. Во втором аргументе задаётся значение I<ngroups>, передаваемое B<getgrouplist>(). Вот примеры работы этой программы:"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:143
#, no-wrap
msgid ""
"$B< ./a.out cecilia 0>\n"
"getgrouplist() returned -1; ngroups = 3\n"
"$B< ./a.out cecilia 3>\n"
"ngroups = 3\n"
"16 (dialout)\n"
"33 (video)\n"
"100 (users)\n"
msgstr "$B< ./a.out cecilia 0>\ngetgrouplist() вернула -1; ngroups = 3\n$B< ./a.out cecilia 3>\nngroups = 3\n16 (dialout)\n33 (video)\n100 (users)\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:152
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>grp.hE<gt>\n"
"#include E<lt>pwd.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>grp.hE<gt>\n#include E<lt>pwd.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:160
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, ngroups;\n"
"    gid_t *groups;\n"
"    struct passwd *pw;\n"
"    struct group *gr;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int j, ngroups;\n    gid_t *groups;\n    struct passwd *pw;\n    struct group *gr;\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:165
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>userE<gt> E<lt>ngroupsE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 3) {\n        fprintf(stderr, \"Использование: %s E<lt>пользовательE<gt> E<lt>ngroupsE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:167
#, no-wrap
msgid "    ngroups = atoi(argv[2]);\n"
msgstr "    ngroups = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:173
#, no-wrap
msgid ""
"    groups = malloc(ngroups * sizeof (gid_t));\n"
"    if (groups == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    groups = malloc(ngroups * sizeof (gid_t));\n    if (groups == NULL) {\n        perror(\"malloc\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:175
#, no-wrap
msgid "    /* Fetch passwd structure (contains first group ID for user) */\n"
msgstr "    /* получаем структуру passwd (содержит ID первичной группы\n       пользователя) */\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:181
#, no-wrap
msgid ""
"    pw = getpwnam(argv[1]);\n"
"    if (pw == NULL) {\n"
"        perror(\"getpwnam\");\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr "    pw = getpwnam(argv[1]);\n    if (pw == NULL) {\n        perror(\"getpwnam\");\n        exit(EXIT_SUCCESS);\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:183
#, no-wrap
msgid "    /* Retrieve group list */\n"
msgstr "    /* получаем список групп */\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:189
#, no-wrap
msgid ""
"    if (getgrouplist(argv[1], pw-E<gt>pw_gid, groups, &ngroups) == -1) {\n"
"        fprintf(stderr, \"getgrouplist() returned -1; ngroups = %d\\en\",\n"
"                ngroups);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (getgrouplist(argv[1], pw-E<gt>pw_gid, groups, &ngroups) == -1) {\n        fprintf(stderr, \"getgrouplist() вернула -1; ngroups = %d\\en\",\n                ngroups);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:191
#, no-wrap
msgid "    /* Display list of retrieved groups, along with group names */\n"
msgstr "    /* печатаем список полученных групп вместе с именами групп */\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:200
#, no-wrap
msgid ""
"    fprintf(stderr, \"ngroups = %d\\en\", ngroups);\n"
"    for (j = 0; j E<lt> ngroups; j++) {\n"
"        printf(\"%d\", groups[j]);\n"
"        gr = getgrgid(groups[j]);\n"
"        if (gr != NULL)\n"
"            printf(\" (%s)\", gr-E<gt>gr_name);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr "    fprintf(stderr, \"ngroups = %d\\en\", ngroups);\n    for (j = 0; j E<lt> ngroups; j++) {\n        printf(\"%d\", groups[j]);\n        gr = getgrgid(groups[j]);\n        if (gr != NULL)\n            printf(\" (%s)\", gr-E<gt>gr_name);\n        printf(\"\\en\");\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:210
msgid ""
"B<getgroups>(2), B<setgroups>(2), B<getgrent>(3), B<group_member>(3), "
"B<group>(5), B<passwd>(5)"
msgstr "B<getgroups>(2), B<setgroups>(2), B<getgrent>(3), B<group_member>(3), B<group>(5), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getw.3:25
#, no-wrap
msgid "GETW"
msgstr "GETW"

#. type: Plain text
#: man-pages/man3/getw.3:28
msgid "getw, putw - input and output of words (ints)"
msgstr "getw, putw - ввод и вывод слов (int)"

#. type: Plain text
#: man-pages/man3/getw.3:31
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getw.3:33
#, no-wrap
msgid "B<int getw(FILE *>I<stream>B<);>\n"
msgstr "B<int getw(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getw.3:35
#, no-wrap
msgid "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getw.3:44
msgid "B<getw>(), B<putw>():"
msgstr "B<getw>(), B<putw>():"

#. type: TP
#: man-pages/man3/getw.3:47
#, no-wrap
msgid "Since glibc 2.3.3:"
msgstr "Начиная с glibc 2.3.3:"

#. type: Plain text
#: man-pages/man3/getw.3:52
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: TP
#: man-pages/man3/getw.3:52
#, no-wrap
msgid "Before glibc 2.3.3:"
msgstr "До glibc 2.3.3:"

#. type: Plain text
#: man-pages/man3/getw.3:55
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: man-pages/man3/getw.3:65
msgid ""
"B<getw>()  reads a word (that is, an I<int>) from I<stream>.  It's provided "
"for compatibility with SVr4.  We recommend you use B<fread>(3)  instead."
msgstr "Функция B<getw>() читает слово (то есть, I<int>) из I<stream>. Она предоставляется для совместимости с SVr4. Вместо неё рекомендуется использовать B<fread>(3)."

#. type: Plain text
#: man-pages/man3/getw.3:72
msgid ""
"B<putw>()  writes the word I<w> (that is, an I<int>) to I<stream>.  It is "
"provided for compatibility with SVr4, but we recommend you use B<fwrite>(3)"
"  instead."
msgstr "Функция B<putw>() записывает слово I<w> (то есть, I<int>) в I<stream>. Она предоставляется для совместимости с SVr4; вместо неё рекомендуется использовать B<fwrite>(3)."

#. type: Plain text
#: man-pages/man3/getw.3:79
msgid ""
"Normally, B<getw>()  returns the word read, and B<putw>()  returns 0.  On "
"error, they return B<EOF>."
msgstr "Обычно, B<getw>() возвращает прочитанное слово, а B<putw>() возвращает 0. При ошибках они возвращают B<EOF>."

#. type: tbl table
#: man-pages/man3/getw.3:90
#, no-wrap
msgid ""
"B<getw>(),\n"
"B<putw>()"
msgstr "B<getw>(),\nB<putw>()"

#. type: Plain text
#: man-pages/man3/getw.3:95
msgid "SVr4, SUSv2.  Not present in POSIX.1."
msgstr "SVr4, SUSv2. Отсутствуют в POSIX.1."

#. type: Plain text
#: man-pages/man3/getw.3:99
msgid ""
"The value returned on error is also a legitimate data value.  B<ferror>(3)  "
"can be used to distinguish between the two cases."
msgstr "Значение, возвращаемое при ошибке, также является корректным значением. Для точного определения ошибки можно использовать B<ferror>(3)."

#. type: Plain text
#: man-pages/man3/getw.3:104
msgid "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"
msgstr "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"

#. type: TH
#: man-pages/man3/getpwent.3:33
#, no-wrap
msgid "GETPWENT"
msgstr "GETPWENT"

#. type: Plain text
#: man-pages/man3/getpwent.3:36
msgid "getpwent, setpwent, endpwent - get password file entry"
msgstr "getpwent, setpwent, endpwent - получает запись из файла паролей"

#. type: Plain text
#: man-pages/man3/getpwent.3:42
#, no-wrap
msgid "B<struct passwd *getpwent(void);>\n"
msgstr "B<struct passwd *getpwent(void);>\n"

#. type: Plain text
#: man-pages/man3/getpwent.3:44
#, no-wrap
msgid "B<void setpwent(void);>\n"
msgstr "B<void setpwent(void);>\n"

#. type: Plain text
#: man-pages/man3/getpwent.3:46
#, no-wrap
msgid "B<void endpwent(void);>\n"
msgstr "B<void endpwent(void);>\n"

#. type: Plain text
#: man-pages/man3/getpwent.3:57
msgid "B<getpwent>(), B<setpwent>(), B<endpwent>():"
msgstr "B<getpwent>(), B<setpwent>(), B<endpwent>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getpwent.3:62
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* версии gibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getpwent.3:76
msgid ""
"The B<getpwent>()  function returns a pointer to a structure containing the "
"broken-out fields of a record from the password database (e.g., the local "
"password file I</etc/passwd>, NIS, and LDAP).  The first time B<getpwent>()"
"  is called, it returns the first entry; thereafter, it returns successive "
"entries."
msgstr "Функция B<getpwent>() возвращает указатель на структуру, содержащую разделённую на поля запись базы данных паролей (например, локального файла паролей I</etc/passwd>, NIS и LDAP). При первом вызове B<getpwent>() возвращает первую запись; при следующих последовательно возвращаются остальные записи."

#. type: Plain text
#: man-pages/man3/getpwent.3:81
msgid ""
"The B<setpwent>()  function rewinds to the beginning of the password "
"database."
msgstr "Функция B<setpwent>() возвращается к началу базы данных паролей."

#. type: Plain text
#: man-pages/man3/getpwent.3:86
msgid ""
"The B<endpwent>()  function is used to close the password database after all"
" processing has been performed."
msgstr "Функция B<endpwent>() используется для закрытия базы данных паролей при завершении процесса обработки."

#. type: Plain text
#: man-pages/man3/getpwent.3:105
msgid ""
"For more information about the fields of this structure, see B<passwd>(5)."
msgstr "Подробней о полях этой структуры смотрите в B<passwd>(5)."

#. type: Plain text
#: man-pages/man3/getpwent.3:118
msgid ""
"The B<getpwent>()  function returns a pointer to a I<passwd> structure, or "
"NULL if there are no more entries or an error occurred.  If an error occurs,"
" I<errno> is set appropriately.  If one wants to check I<errno> after the "
"call, it should be set to zero before the call."
msgstr "Функция B<getpwent>() возвращает указатель на структуру I<passwd> или NULL, если подходящих записей не найдено или возникла ошибка. При ошибке I<errno> устанавливается в соответствующее значение. Если нужно проверять переменную I<errno> после вызова, то перед этим нужно присвоить ей нулевое значение."

#. type: Plain text
#: man-pages/man3/getpwent.3:127
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getpwent>(), B<getpwnam>(3), or B<getpwuid>(3).  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr "Возвращаемое значение может указывать на статическую область и может быть перезаписано при последующих вызовах B<getpwent>(), B<getpwnam>(3) или B<getpwuid>(3) (не передавайте полученный указатель B<free>(3))."

#. type: tbl table
#: man-pages/man3/getpwent.3:165
#, no-wrap
msgid "B<getpwent>()"
msgstr "B<getpwent>()"

#. type: tbl table
#: man-pages/man3/getpwent.3:167
#, no-wrap
msgid "MT-Unsafe race:pwent\n"
msgstr "MT-Unsafe race:pwent\n"

#. type: tbl table
#: man-pages/man3/getpwent.3:169
#, no-wrap
msgid "race:pwentbuf locale"
msgstr "race:pwentbuf locale"

#. type: tbl table
#: man-pages/man3/getpwent.3:172
#, no-wrap
msgid "B<setpwent>(),\n"
msgstr "B<setpwent>(),\n"

#. type: tbl table
#: man-pages/man3/getpwent.3:174
#, no-wrap
msgid "B<endpwent>()"
msgstr "B<endpwent>()"

#. type: tbl table
#: man-pages/man3/getpwent.3:174
#, no-wrap
msgid "MT-Unsafe race:pwent locale"
msgstr "MT-Unsafe race:pwent locale"

#. type: Plain text
#: man-pages/man3/getpwent.3:188
msgid ""
"In the above table, I<pwent> in I<race:pwent> signifies that if any of the "
"functions B<setpwent>(), B<getpwent>(), or B<endpwent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr "В приведённой выше таблице I<pwent> в I<race:pwgent> означает, что если в нескольких нитях программы одновременно используются функции B<setpwent>(), B<getpwent>() или B<endpwent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getpwent.3:200
msgid ""
"B<fgetpwent>(3), B<getpw>(3), B<getpwent_r>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"
msgstr "B<fgetpwent>(3), B<getpw>(3), B<getpwent_r>(3), B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getnameinfo.3:10
#, no-wrap
msgid "GETNAMEINFO"
msgstr "GETNAMEINFO"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:13
msgid ""
"getnameinfo - address-to-name translation in protocol-independent manner"
msgstr "getnameinfo - перевод адреса в имя не зависящим от протокола способом"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:17
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\nB<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:21
#, no-wrap
msgid ""
"B<int getnameinfo(const struct sockaddr *>I<addr>B<, socklen_t >I<addrlen>B<,>\n"
"B<                char *>I<host>B<, socklen_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, socklen_t >I<servlen>B<, int >I<flags>B<);>\n"
msgstr "B<int getnameinfo(const struct sockaddr *>I<addr>B<, socklen_t >I<addrlen>B<,>\nB<                char *>I<host>B<, socklen_t >I<hostlen>B<,>\nB<                char *>I<serv>B<, socklen_t >I<servlen>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:32
#, no-wrap
msgid ""
"B<getnameinfo>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 201112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr "B<getnameinfo>():\n    начиная с glibc 2.22: _POSIX_C_SOURCE E<gt>= 201112L\n    в glibc 2.21 и старее: _POSIX_C_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:48
msgid ""
"The B<getnameinfo>()  function is the inverse of B<getaddrinfo>(3): it "
"converts a socket address to a corresponding host and service, in a "
"protocol-independent manner.  It combines the functionality of "
"B<gethostbyaddr>(3)  and B<getservbyport>(3), but unlike those functions, "
"B<getnameinfo>()  is reentrant and allows programs to eliminate IPv4-versus-"
"IPv6 dependencies."
msgstr "Функция B<getnameinfo>() выполняет операцию, обратную B<getaddrinfo>(3); она преобразует адрес сокета в соответствующие узел и службу, способом, который не зависит от протокола. Она сочетает в себе действия функций B<gethostbyaddr>(3) и B<getservbyport>(3), но в отличии от этих функций B<getnameinfo>() реентерабельна и позволяет программам не зависеть от типа IPv4 и IPv6."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:71
msgid ""
"The I<addr> argument is a pointer to a generic socket address structure (of "
"type I<sockaddr_in> or I<sockaddr_in6>)  of size I<addrlen> that holds the "
"input IP address and port number.  The arguments I<host> and I<serv> are "
"pointers to caller-allocated buffers (of size I<hostlen> and I<servlen> "
"respectively) into which B<getnameinfo>()  places null-terminated strings "
"containing the host and service names respectively."
msgstr "Аргумент I<addr> — это указатель на обобщённую структуру адреса сокета (типа I<sockaddr_in> или I<sockaddr_in6>) размером I<addrlen>, которая содержит IP-адрес и номер порта. Аргументы I<host> и I<serv> указывают на выделенные вызывающим буферы (размером I<hostlen> и I<servlen>, соответственно), в которые B<getnameinfo>() помещает строки (заканчивающееся null), содержащие имя узла и службы, соответственно."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:84
msgid ""
"The caller can specify that no hostname (or no service name)  is required by"
" providing a NULL I<host> (or I<serv>)  argument or a zero I<hostlen> (or "
"I<servlen>)  argument.  However, at least one of hostname or service name "
"must be requested."
msgstr "Вызывающий может указать, что имя узла (или службы) не требуется, указав в аргументе I<host> (или I<serv>) NULL или в I<hostlen> (или I<servlen>) значение 0. Однако, по крайней мере один параметр, имя узла или службы, должно быть запрошено."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:90
msgid ""
"The I<flags> argument modifies the behavior of B<getnameinfo>()  as follows:"
msgstr "Аргумент I<flags> меняет поведение функции B<getnameinfo>() следующим образом:"

#. type: TP
#: man-pages/man3/getnameinfo.3:90
#, no-wrap
msgid "B<NI_NAMEREQD>"
msgstr "B<NI_NAMEREQD>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:93
msgid ""
"If set, then an error is returned if the hostname cannot be determined."
msgstr "Если этот флаг установлен, то возвращается ошибка, если имя машины не может быть определено."

#. type: TP
#: man-pages/man3/getnameinfo.3:93
#, no-wrap
msgid "B<NI_DGRAM>"
msgstr "B<NI_DGRAM>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:99
msgid ""
"If set, then the service is datagram (UDP) based rather than stream (TCP) "
"based.  This is required for the few ports (512\\(en514)  that have "
"different services for UDP and TCP."
msgstr "Если этот флаг установлен, то сначала используется имя службы на основе дейтаграмм (UDP), а не потоков (TCP). Это требуется для немногих портов (512\\(en514), которые имеют различные службы для UDP и TCP."

#. type: TP
#: man-pages/man3/getnameinfo.3:99
#, no-wrap
msgid "B<NI_NOFQDN>"
msgstr "B<NI_NOFQDN>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:103
msgid ""
"If set, return only the hostname part of the fully qualified domain name for"
" local hosts."
msgstr "Если этот флаг установлен, то возвращается только часть имени машины от полностью определённого доменного имени (FQDN) для локальных машин."

#. type: TP
#: man-pages/man3/getnameinfo.3:103
#, no-wrap
msgid "B<NI_NUMERICHOST>"
msgstr "B<NI_NUMERICHOST>"

#.  For example, by calling
#.  .BR inet_ntop ()
#.  instead of
#.  .BR gethostbyaddr ().
#.  POSIX.1-2003 has NI_NUMERICSCOPE, but glibc doesn't have it.
#. type: Plain text
#: man-pages/man3/getnameinfo.3:113
msgid ""
"If set, then the numeric form of the hostname is returned.  (When not set, "
"this will still happen in case the node's name cannot be determined.)"
msgstr "Если этот флаг установлен, то имя узла возвращается в числовой форме (если этот флаг не установлен, то это также произойдёт в случае, когда имя узла невозможно определить)."

#. type: TP
#: man-pages/man3/getnameinfo.3:113
#, no-wrap
msgid "B<NI_NUMERICSERV>"
msgstr "B<NI_NUMERICSERV>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:118
msgid ""
"If set, then the numeric form of the service address is returned.  (When not"
" set, this will still happen in case the service's name cannot be "
"determined.)"
msgstr "Если этот флаг установлен, тогда имя службы возвращается в числовой форме (если этот флаг не установлен, то это также произойдёт в случае, когда имя узла невозможно определить)."

#. type: SS
#: man-pages/man3/getnameinfo.3:118
#, no-wrap
msgid "Extensions to getnameinfo() for Internationalized Domain Names"
msgstr "Расширения getnameinfo() для интернациональных доменных имён"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:127
msgid ""
"Starting with glibc 2.3.4, B<getnameinfo>()  has been extended to "
"selectively allow hostnames to be transparently converted to and from the "
"Internationalized Domain Name (IDN) format (see RFC 3490, "
"I<Internationalizing Domain Names in Applications (IDNA)>).  Three new flags"
" are defined:"
msgstr "Начиная с glibc 2.3.4, B<getnameinfo>() была расширена для выборочного прозрачного разрешения имён для формата интернациональных доменных имён (IDN) (смотрите RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>). Было определено четыре новых флага:"

#. type: TP
#: man-pages/man3/getnameinfo.3:127
#, no-wrap
msgid "B<NI_IDN>"
msgstr "B<NI_IDN>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:133
msgid ""
"If this flag is used, then the name found in the lookup process is converted"
" from IDN format to the locale's encoding if necessary.  ASCII-only names "
"are not affected by the conversion, which makes this flag usable in existing"
" programs and environments."
msgstr "Если этот флаг установлен, то при необходимости искомое имя преобразуется из формата IDN в кодировку локали. Имена из только ASCI-символов не меняются при преобразовании, из-за чего данный флаг можно использовать в существующих программах и средах."

#. type: TP
#: man-pages/man3/getnameinfo.3:133
#, no-wrap
msgid "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"
msgstr "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:140
msgid ""
"Setting these flags will enable the IDNA_ALLOW_UNASSIGNED (allow unassigned "
"Unicode code points) and IDNA_USE_STD3_ASCII_RULES (check output to make "
"sure it is a STD3 conforming hostname)  flags respectively to be used in the"
" IDNA handling."
msgstr "Установка этих флагов включает IDNA_ALLOW_UNASSIGNED (разрешать не назначенные кодовые точки Юникода) и IDNA_USE_STD3_ASCII_RULES (проверять вывод на соответствие имени узла STD3) соответственно для возможности работы с IDNA."

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getnameinfo(); they need to
#.  be documented.
#.      #ifdef __USE_GNU
#.      #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.      #define EAI_CANCELED    -101  /* Request canceled.  */
#.      #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.      #define EAI_ALLDONE     -103  /* All requests done.  */
#.      #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.      #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.      #endif
#. type: Plain text
#: man-pages/man3/getnameinfo.3:157
msgid ""
"On success, 0 is returned, and node and service names, if requested, are "
"filled with null-terminated strings, possibly truncated to fit the specified"
" buffer lengths.  On error, one of the following nonzero error codes is "
"returned:"
msgstr "При успешном выполнении возвращается 0, а строки (оканчивающееся null) имени узла и службы (если запрашивались) записываются в соответствующий буфер заданной длины. При ошибке возвращается одно из следующих ненулевых значений ошибки:"

#. type: TP
#: man-pages/man3/getnameinfo.3:157
#, no-wrap
msgid "B<EAI_AGAIN>"
msgstr "B<EAI_AGAIN>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:161
msgid "The name could not be resolved at this time.  Try again later."
msgstr "Имя не может быть определено в настоящий момент. Попробуйте повторить попытку позже."

#. type: TP
#: man-pages/man3/getnameinfo.3:161
#, no-wrap
msgid "B<EAI_BADFLAGS>"
msgstr "B<EAI_BADFLAGS>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:166
msgid "The I<flags> argument has an invalid value."
msgstr "Параметр I<flags> имеет неверное значение."

#. type: TP
#: man-pages/man3/getnameinfo.3:166
#, no-wrap
msgid "B<EAI_FAIL>"
msgstr "B<EAI_FAIL>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:169
msgid "A nonrecoverable error occurred."
msgstr "Произошла неисправимая ошибка."

#. type: TP
#: man-pages/man3/getnameinfo.3:169
#, no-wrap
msgid "B<EAI_FAMILY>"
msgstr "B<EAI_FAMILY>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:173
msgid ""
"The address family was not recognized, or the address length was invalid for"
" the specified family."
msgstr "Не распознано семейство адресов, или для данного семейства была указана неверно длина адреса."

#. type: TP
#: man-pages/man3/getnameinfo.3:173
#, no-wrap
msgid "B<EAI_MEMORY>"
msgstr "B<EAI_MEMORY>"

#. type: TP
#: man-pages/man3/getnameinfo.3:176
#, no-wrap
msgid "B<EAI_NONAME>"
msgstr "B<EAI_NONAME>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:182
msgid ""
"The name does not resolve for the supplied arguments.  B<NI_NAMEREQD> is set"
" and the host's name cannot be located, or neither hostname nor service name"
" were requested."
msgstr "Имя не может быть определено для указанных параметров. Установлен флаг B<NI_NAMEREQD> и имя машины не может быть определено, или не было запрошено не имя машины и не имя службы."

#. type: TP
#: man-pages/man3/getnameinfo.3:182
#, no-wrap
msgid "B<EAI_OVERFLOW>"
msgstr "B<EAI_OVERFLOW>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:189
msgid "The buffer pointed to by I<host> or I<serv> was too small."
msgstr "Размер буфера, на который указывает I<host> или I<serv> слишком мал."

#. type: TP
#: man-pages/man3/getnameinfo.3:189
#, no-wrap
msgid "B<EAI_SYSTEM>"
msgstr "B<EAI_SYSTEM>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:194
msgid "A system error occurred.  The error code can be found in I<errno>."
msgstr "Произошла системная ошибка. Код системной ошибки можно найти в переменной I<errno>."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:199
msgid ""
"The B<gai_strerror>(3)  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr "Функция B<gai_strerror>(3) транслирует эти коды ошибок в читаемый формат, подходящий для сообщений об ошибке."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:205
msgid "I</etc/resolv.conf>"
msgstr "I</etc/resolv.conf>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:208
msgid "B<getnameinfo>()  is provided in glibc since version 2.1."
msgstr "Функция B<getnameinfo>() появилась в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/getnameinfo.3:218
#, no-wrap
msgid "B<getnameinfo>()"
msgstr "B<getnameinfo>()"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:223
msgid "POSIX.1-2001, POSIX.1-2008, RFC\\ 2553."
msgstr "POSIX.1-2001, POSIX.1-2008, RFC\\ 2553."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:228
msgid ""
"In order to assist the programmer in choosing reasonable sizes for the "
"supplied buffers, I<E<lt>netdb.hE<gt>> defines the constants"
msgstr "Чтобы помочь программисту выбрать нужный размер буферов в I<E<lt>netdb.hE<gt>> определены константы"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:233
#, no-wrap
msgid ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"
msgstr "#define NI_MAXHOST      1025\n#define NI_MAXSERV      32\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:246
msgid ""
"Since glibc 2.8, these definitions are exposed only if suitable feature test"
" macros are defined, namely: B<_GNU_SOURCE>, B<_DEFAULT_SOURCE> (since glibc"
" 2.19), or (in glibc versions up to and including 2.19)  B<_BSD_SOURCE> or "
"B<_SVID_SOURCE>."
msgstr "Начиная с glibc 2.8, эти определения доступны только, если определён подходящий макрос тестирования свойств: B<_GNU_SOURCE>, B<_DEFAULT_SOURCE> (начиная с glibc 2.19) или (в версиях glibc с 2.19 включительно) B<_BSD_SOURCE> или B<_SVID_SOURCE>."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:254
msgid ""
"The former is the constant B<MAXDNAME> in recent versions of BIND's "
"I<E<lt>arpa/nameser.hE<gt>> header file.  The latter is a guess based on the"
" services listed in the current Assigned Numbers RFC."
msgstr "Первая — это константа B<MAXDNAME> из новых версий заголовочного файла I<E<lt>arpa/nameser.hE<gt>>  BIND. Последняя — вычислена на основе служб, перечисленных в текущем RFC «Assigned Numbers»."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:261
msgid ""
"Before glibc version 2.2, the I<hostlen> and I<servlen> arguments were typed"
" as I<size_t>."
msgstr "В glibc до версии 2.2 аргументы I<hostlen> и I<servlen> имели тип I<size_t>."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:266
msgid ""
"The following code tries to get the numeric hostname and service name, for a"
" given socket address.  Note that there is no hardcoded reference to a "
"particular address family."
msgstr "Следующий код пытается получить имя машины и службы в числовой форме для указанного адреса сокета. Обратите внимание, что здесь нет прямых упоминаний определённого семейства адресов."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:272
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"
msgstr "struct sockaddr *addr;     /* входные */\nsocklen_t addrlen;         /* входные */\nchar hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:276
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"
msgstr "if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf), sbuf,\n            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:281
msgid ""
"The following version checks if the socket address has a reverse address "
"mapping."
msgstr "Следующая версия проверяет, имеет ли адрес сокета обратное отображение адреса."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:287
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"
msgstr "struct sockaddr *addr;     /* входные */\nsocklen_t addrlen;         /* входные */\nchar hbuf[NI_MAXHOST];\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:293
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"
msgstr "if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf),\n            NULL, 0, NI_NAMEREQD))\n    printf(\"не удалось определить имя узла\");\nelse\n    printf(\"host=%s\\en\", hbuf);\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:300
msgid ""
"An example program using B<getnameinfo>()  can be found in "
"B<getaddrinfo>(3)."
msgstr "Пример программы, использующей B<getnameinfo>(), можно найти в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:315
msgid ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), "
"B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"
msgstr "B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), B<hostname>(7), B<named>(8)"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:319
msgid ""
"R.\\& Gilligan, S.\\& Thomson, J.\\& Bound and W.\\& Stevens, I<Basic Socket"
" Interface Extensions for IPv6>, RFC\\ 2553, March 1999."
msgstr "R.\\& Gilligan, S.\\& Thomson, J.\\& Bound and W.\\& Stevens, I<Basic Socket Interface Extensions for IPv6>, RFC\\ 2553, March 1999."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:325
msgid ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR ftp://ftp.ietf.org"
"\\:/internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"
msgstr "Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped Addresses>, черновик E<.UR ftp://ftp.ietf.org\\:/internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:330
msgid ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"
msgstr "Craig Metz, I<Protocol Independence Using the Sockets API>, Продолжение темы freenix: 2000 USENIX ежегодной технической конференции, июнь 2000"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:332
msgid ""
"E<.UR "
"http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/usenix2000\\:/freenix\\:/metzprotocol.html>"
" E<.UE .>"
msgstr "E<.UR http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/usenix2000\\:/freenix\\:/metzprotocol.html> E<.UE .>"

#. type: TH
#: man-pages/man3/getgrent.3:30
#, no-wrap
msgid "GETGRENT"
msgstr "GETGRENT"

#. type: Plain text
#: man-pages/man3/getgrent.3:33
msgid "getgrent, setgrent, endgrent - get group file entry"
msgstr "getgrent, setgrent, endgrent - возвращает запись из файла групп"

#. type: Plain text
#: man-pages/man3/getgrent.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>grp.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>grp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:39
#, no-wrap
msgid "B<struct group *getgrent(void);>\n"
msgstr "B<struct group *getgrent(void);>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:41
#, no-wrap
msgid "B<void setgrent(void);>\n"
msgstr "B<void setgrent(void);>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:43
#, no-wrap
msgid "B<void endgrent(void);>\n"
msgstr "B<void endgrent(void);>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:53
msgid "B<setgrent>():"
msgstr "B<setgrent>():"

#. type: Plain text
#: man-pages/man3/getgrent.3:62
msgid "B<getgrent>(), B<endgrent>():"
msgstr "B<getgrent>(), B<endgrent>():"

#.         || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getgrent.3:67
#, no-wrap
msgid ""
"Since glibc 2.22:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _DEFAULT_SOURCE\n"
msgstr "начиная с glibc 2.22:\n    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        _DEFAULT_SOURCE\n"

#.         || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getgrent.3:73
#, no-wrap
msgid ""
"Glibc 2.21 and earlier\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"        || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "в glibc 2.21 и старее\n    _XOPEN_SOURCE\\ E<gt>=\\ 500\n        || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n        || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:88
msgid ""
"The B<getgrent>()  function returns a pointer to a structure containing the "
"broken-out fields of a record in the group database (e.g., the local group "
"file I</etc/group>, NIS, and LDAP).  The first time B<getgrent>()  is "
"called, it returns the first entry; thereafter, it returns successive "
"entries."
msgstr "Функция B<getgrent>() возвращает указатель на структуру, содержащую разделённую на поля запись базы данных групп (например, локального файла групп I</etc/group>, NIS и LDAP). При первом вызове B<getgrent>() возвращает первую запись; при следующих последовательно возвращаются остальные записи."

#. type: Plain text
#: man-pages/man3/getgrent.3:93
msgid ""
"The B<setgrent>()  function rewinds to the beginning of the group database, "
"to allow repeated scans."
msgstr "Функция B<setgrent>() возвращается к началу базы данных групп, позволяя выполнять повторное сканирование."

#. type: Plain text
#: man-pages/man3/getgrent.3:98
msgid ""
"The B<endgrent>()  function is used to close the group database after all "
"processing has been performed."
msgstr "Функция B<endgrent>() используется для закрытия базы данных групп при завершении процесса обработки."

#. type: Plain text
#: man-pages/man3/getgrent.3:100
msgid "The I<group> structure is defined in I<E<lt>grp.hE<gt>> as follows:"
msgstr "Структура I<group> определена в I<E<lt>grp.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/getgrent.3:110
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;        /* group name */\n"
"    char   *gr_passwd;      /* group password */\n"
"    gid_t   gr_gid;         /* group ID */\n"
"    char  **gr_mem;         /* NULL-terminated array of pointers\n"
"                               to names of group members */\n"
"};\n"
msgstr "struct group {\n    char   *gr_name;        /* имя группы */\n    char   *gr_passwd;      /* пароль группы */\n    gid_t   gr_gid;         /* ID группы */\n    char  **gr_mem;         /* массив, указателей\n                               имён членов группы, оканчивающийся NULL */\n};\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:115
msgid ""
"For more information about the fields of this structure, see B<group>(5)."
msgstr "Подробней о полях этой структуры смотрите в B<group>(5)."

#. type: Plain text
#: man-pages/man3/getgrent.3:122
msgid ""
"The B<getgrent>()  function returns a pointer to a I<group> structure, or "
"NULL if there are no more entries or an error occurs."
msgstr "Функция B<getgrent>() возвращает указатель на структуру I<group> или NULL, если записи закончились или произошла ошибка."

#. type: Plain text
#: man-pages/man3/getgrent.3:129
msgid ""
"Upon error, I<errno> may be set.  If one wants to check I<errno> after the "
"call, it should be set to zero before the call."
msgstr "При ошибке может измениться значение I<errno>. Если нужно проверять переменную I<errno> после вызова, то перед этим нужно присвоить ей нулевое значение."

#. type: Plain text
#: man-pages/man3/getgrent.3:138
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getgrent>(), B<getgrgid>(3), or B<getgrnam>(3).  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr "Возвращаемое значение может указывать на статическую область и может быть перезаписано при последующих вызовах B<getgrent>(), B<getgrgid>(3) или B<getgrnam>(3) (не передавайте полученный указатель B<free>(3))."

#. type: Plain text
#: man-pages/man3/getgrent.3:144
msgid ""
"The service was temporarily unavailable; try again later.  For NSS backends "
"in glibc this indicates a temporary error talking to the backend.  The error"
" may correct itself, retrying later is suggested."
msgstr "Служба временно недоступна; попробуйте позднее. Для NSS из glibc это указывает на временную ошибку обмена с сервером. Ошибка может исчезнуть самостоятельно, предлагается попробовать повторить вызов позднее."

#. type: Plain text
#: man-pages/man3/getgrent.3:162
msgid ""
"A necessary input file cannot be found.  For NSS backends in glibc this "
"indicates the backend is not correctly configured."
msgstr "Необходимый входной файл не найден. Для NSS в glibc это указывает на то, что служба некорректно настроена."

#.  not in POSIX
#. type: Plain text
#: man-pages/man3/getgrent.3:168
msgid "Insufficient memory to allocate I<group> structure."
msgstr "Недостаточно памяти для структуры I<group>."

#. type: Plain text
#: man-pages/man3/getgrent.3:175
msgid "local group database file"
msgstr "локальный файл базы данных групп"

#. type: tbl table
#: man-pages/man3/getgrent.3:185
#, no-wrap
msgid "B<getgrent>()"
msgstr "B<getgrent>()"

#. type: tbl table
#: man-pages/man3/getgrent.3:187
#, no-wrap
msgid "MT-Unsafe race:grent\n"
msgstr "MT-Unsafe race:grent\n"

#. type: tbl table
#: man-pages/man3/getgrent.3:189
#, no-wrap
msgid "race:grentbuf locale"
msgstr "race:grentbuf locale"

#. type: tbl table
#: man-pages/man3/getgrent.3:193
#, no-wrap
msgid ""
"B<setgrent>(),\n"
"B<endgrent>()"
msgstr "B<setgrent>(),\nB<endgrent>()"

#. type: tbl table
#: man-pages/man3/getgrent.3:193
#, no-wrap
msgid "MT-Unsafe race:grent locale"
msgstr "MT-Unsafe race:grent locale"

#. type: Plain text
#: man-pages/man3/getgrent.3:207
msgid ""
"In the above table, I<grent> in I<race:grent> signifies that if any of the "
"functions B<setgrent>(), B<getgrent>(), or B<endgrent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr "В приведённой выше таблице I<grent> в I<race:grent> означает, что если в нескольких нитях программы одновременно используются функции B<setgrent>(), B<getgrent>() или B<endgrent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getgrent.3:209
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/getgrent.3:216
msgid ""
"B<fgetgrent>(3), B<getgrent_r>(3), B<getgrgid>(3), B<getgrnam>(3), "
"B<getgrouplist>(3), B<putgrent>(3), B<group>(5)"
msgstr "B<fgetgrent>(3), B<getgrent_r>(3), B<getgrgid>(3), B<getgrnam>(3), B<getgrouplist>(3), B<putgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/getauxval.3:27
#, no-wrap
msgid "GETAUXVAL"
msgstr "GETAUXVAL"

#. type: Plain text
#: man-pages/man3/getauxval.3:30
msgid "getauxval - retrieve a value from the auxiliary vector"
msgstr "getauxval - возвращает значение из вспомогательного вектора"

#. type: Plain text
#: man-pages/man3/getauxval.3:33
#, no-wrap
msgid "B<#include E<lt>sys/auxv.hE<gt>>\n"
msgstr "B<#include E<lt>sys/auxv.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getauxval.3:35
#, no-wrap
msgid "B<unsigned long getauxval(unsigned long >I<type>B<);>\n"
msgstr "B<unsigned long getauxval(unsigned long >I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/getauxval.3:43
msgid ""
"The B<getauxval>()  function retrieves values from the auxiliary vector, a "
"mechanism that the kernel's ELF binary loader uses to pass certain "
"information to user space when a program is executed."
msgstr "Функция B<getauxval>() возвращает значения из вспомогательного вектора — механизма, с помощью которого ядерный загрузчик двоичных файлов ELF передаёт информацию в пользовательское пространство при выполнении программы."

#. type: Plain text
#: man-pages/man3/getauxval.3:51
msgid ""
"Each entry in the auxiliary vector consists of a pair of values: a type that"
" identifies what this entry represents, and a value for that type.  Given "
"the argument I<type>, B<getauxval>()  returns the corresponding value."
msgstr "Каждая запись в вспомогательном векторе состоит из пары значений: типа — которым определяется смысл записи и значением этого типа. Согласно аргументу I<type>, B<getauxval>() возвращает соответствующее значение."

#. type: Plain text
#: man-pages/man3/getauxval.3:58
msgid ""
"The value returned for each I<type> is given in the following list.  Not all"
" I<type> values are present on all architectures."
msgstr "Значения для типов для I<type> представлены в списке далее. Не все значения I<type> есть для всех архитектур."

#. type: TP
#: man-pages/man3/getauxval.3:58
#, no-wrap
msgid "B<AT_BASE>"
msgstr "B<AT_BASE>"

#. type: Plain text
#: man-pages/man3/getauxval.3:61
msgid ""
"The base address of the program interpreter (usually, the dynamic linker)."
msgstr "Основной (base) адрес программного интерпретатора (обычно, динамического компоновщика)."

#. type: TP
#: man-pages/man3/getauxval.3:61
#, no-wrap
msgid "B<AT_BASE_PLATFORM>"
msgstr "B<AT_BASE_PLATFORM>"

#. type: Plain text
#: man-pages/man3/getauxval.3:66
msgid ""
"A string identifying the real platform; may differ from B<AT_PLATFORM> "
"(PowerPC only)."
msgstr "Строка, определяющая реальную платформу; может отличаться от B<AT_PLATFORM> (только для PowerPC)."

#. type: TP
#: man-pages/man3/getauxval.3:66
#, no-wrap
msgid "B<AT_CLKTCK>"
msgstr "B<AT_CLKTCK>"

#. type: Plain text
#: man-pages/man3/getauxval.3:73
msgid ""
"The frequency with which B<times>(2)  counts.  This value can also be "
"obtained via I<sysconf(_SC_CLK_TCK)>."
msgstr "Частота, с которой считает B<times>(2). Это значение также может быть получено с помощью I<sysconf(_SC_CLK_TCK)>."

#. type: TP
#: man-pages/man3/getauxval.3:73
#, no-wrap
msgid "B<AT_DCACHEBSIZE>"
msgstr "B<AT_DCACHEBSIZE>"

#. type: Plain text
#: man-pages/man3/getauxval.3:76
msgid "The data cache block size."
msgstr "Размер блока кэша данных."

#. type: TP
#: man-pages/man3/getauxval.3:76
#, no-wrap
msgid "B<AT_EGID>"
msgstr "B<AT_EGID>"

#. type: Plain text
#: man-pages/man3/getauxval.3:79
msgid "The effective group ID of the thread."
msgstr "Эффективный идентификатор группы нити."

#. type: TP
#: man-pages/man3/getauxval.3:79
#, no-wrap
msgid "B<AT_ENTRY>"
msgstr "B<AT_ENTRY>"

#. type: Plain text
#: man-pages/man3/getauxval.3:82
msgid "The entry address of the executable."
msgstr "Адрес точки старта (entry address) исполняемого файла."

#. type: TP
#: man-pages/man3/getauxval.3:82
#, no-wrap
msgid "B<AT_EUID>"
msgstr "B<AT_EUID>"

#. type: Plain text
#: man-pages/man3/getauxval.3:85
msgid "The effective user ID of the thread."
msgstr "Эффективный идентификатор пользователя нити."

#. type: TP
#: man-pages/man3/getauxval.3:85
#, no-wrap
msgid "B<AT_EXECFD>"
msgstr "B<AT_EXECFD>"

#. type: Plain text
#: man-pages/man3/getauxval.3:88
msgid "File descriptor of program."
msgstr "Файловый дескриптор программы."

#. type: TP
#: man-pages/man3/getauxval.3:88
#, no-wrap
msgid "B<AT_EXECFN>"
msgstr "B<AT_EXECFN>"

#. type: Plain text
#: man-pages/man3/getauxval.3:91
msgid "Pathname used to execute program."
msgstr "Путь, использованный для запуска программы."

#. type: TP
#: man-pages/man3/getauxval.3:91
#, no-wrap
msgid "B<AT_FLAGS>"
msgstr "B<AT_FLAGS>"

#. type: Plain text
#: man-pages/man3/getauxval.3:94
msgid "Flags (unused)."
msgstr "Флаги (не используется)."

#. type: TP
#: man-pages/man3/getauxval.3:94
#, no-wrap
msgid "B<AT_FPUCW>"
msgstr "B<AT_FPUCW>"

#. type: Plain text
#: man-pages/man3/getauxval.3:99
msgid ""
"Used FPU control word (SuperH architecture only).  This gives some "
"information about the FPU initialization performed by the kernel."
msgstr "Используемое слово управления FPU (только для SuperH). Оно даёт некоторую информацию о нагрузке FPU, выполняемой ядром."

#. type: TP
#: man-pages/man3/getauxval.3:99
#, no-wrap
msgid "B<AT_GID>"
msgstr "B<AT_GID>"

#. type: Plain text
#: man-pages/man3/getauxval.3:102
msgid "The real group ID of the thread."
msgstr "Реальный идентификатор группы нити."

#. type: TP
#: man-pages/man3/getauxval.3:102
#, no-wrap
msgid "B<AT_HWCAP>"
msgstr "B<AT_HWCAP>"

#. type: Plain text
#: man-pages/man3/getauxval.3:113
msgid ""
"An architecture and ABI dependent bit-mask whose settings indicate detailed "
"processor capabilities.  The contents of the bit mask are hardware dependent"
" (for example, see the kernel source file "
"I<arch/x86/include/asm/cpufeature.h> for details relating to the Intel x86 "
"architecture; the value returned is the first 32-bit word of the array "
"described there).  A human-readable version of the same information is "
"available via I</proc/cpuinfo>."
msgstr "Битовая маска, зависящая от архитектуры и двоичного программного интерфейса, подробно описывает возможности процессора. Содержимое битовой маски зависит от аппаратуры (например, в файле исходного кода ядра I<arch/x86/include/asm/cpufeature.h> описана маска для архитектуры Intel x86; возвращаемое значение — первое 32-битное слово описываемого здесь массива). Эта же информация в формате, понятном человеку, доступна в файле I</proc/cpuinfo>."

#. type: TP
#: man-pages/man3/getauxval.3:113
#, no-wrap
msgid "B<AT_HWCAP2> (since glibc 2.18)"
msgstr "B<AT_HWCAP2> (начиная с glibc 2.18)"

#. type: Plain text
#: man-pages/man3/getauxval.3:116
msgid "Further machine-dependent hints about processor capabilities."
msgstr "Дополнительные упоминания о возможностях процессора."

#. type: TP
#: man-pages/man3/getauxval.3:116
#, no-wrap
msgid "B<AT_ICACHEBSIZE>"
msgstr "B<AT_ICACHEBSIZE>"

#.  .TP
#.  .BR AT_IGNORE
#.  .TP
#.  .BR AT_IGNOREPPC
#.  .TP
#.  .BR AT_NOTELF
#. type: Plain text
#: man-pages/man3/getauxval.3:125
msgid "The instruction cache block size."
msgstr "Размер блока кэша инструкций."

#. type: TP
#: man-pages/man3/getauxval.3:125
#, no-wrap
msgid "B<AT_PAGESZ>"
msgstr "B<AT_PAGESZ>"

#. type: Plain text
#: man-pages/man3/getauxval.3:129
msgid ""
"The system page size (the same value returned by I<sysconf(_SC_PAGESIZE)>)."
msgstr "Размер системной страницы (это же значение возвращается I<sysconf(_SC_PAGESIZE)>)."

#. type: TP
#: man-pages/man3/getauxval.3:129
#, no-wrap
msgid "B<AT_PHDR>"
msgstr "B<AT_PHDR>"

#. type: Plain text
#: man-pages/man3/getauxval.3:132
msgid "The address of the program headers of the executable."
msgstr "Адрес заголовков программы исполняемого файла."

#. type: TP
#: man-pages/man3/getauxval.3:132
#, no-wrap
msgid "B<AT_PHENT>"
msgstr "B<AT_PHENT>"

#. type: Plain text
#: man-pages/man3/getauxval.3:135
msgid "The size of program header entry."
msgstr "Размер элемента заголовка программы."

#. type: TP
#: man-pages/man3/getauxval.3:135
#, no-wrap
msgid "B<AT_PHNUM>"
msgstr "B<AT_PHNUM>"

#. type: Plain text
#: man-pages/man3/getauxval.3:138
msgid "The number of program headers."
msgstr "Количество заголовков программы."

#. type: TP
#: man-pages/man3/getauxval.3:138
#, no-wrap
msgid "B<AT_PLATFORM>"
msgstr "B<AT_PLATFORM>"

#. type: Plain text
#: man-pages/man3/getauxval.3:145
msgid ""
"A pointer to a string that identifies the hardware platform that the program"
" is running on.  The dynamic linker uses this in the interpretation of "
"I<rpath> values."
msgstr "Указатель на строку, описывающую аппаратную платформу, на которой выполняется программа. Динамический компоновщик использует её при рассмотрении значений I<rpath>."

#. type: TP
#: man-pages/man3/getauxval.3:145
#, no-wrap
msgid "B<AT_RANDOM>"
msgstr "B<AT_RANDOM>"

#. type: Plain text
#: man-pages/man3/getauxval.3:148
msgid "The address of sixteen bytes containing a random value."
msgstr "Адрес 16 байт, содержащих произвольное значение."

#. type: TP
#: man-pages/man3/getauxval.3:148
#, no-wrap
msgid "B<AT_SECURE>"
msgstr "B<AT_SECURE>"

#. type: Plain text
#: man-pages/man3/getauxval.3:165
msgid ""
"Has a nonzero value if this executable should be treated securely.  Most "
"commonly, a nonzero value indicates that the process is executing a set-"
"user-ID or set-group-ID binary (so that its real and effective UIDs or GIDs "
"differ from one another), or that it gained capabilities by executing a "
"binary file that has capabilities (see B<capabilities>(7)).  Alternatively, "
"a nonzero value may be triggered by a Linux Security Module.  When this "
"value is nonzero, the dynamic linker disables the use of certain environment"
" variables (see B<ld-linux.so>(8))  and glibc changes other aspects of its "
"behavior.  (See also B<secure_getenv>(3).)"
msgstr "Содержит ненулевое значение, если исполняемый файл должен считаться безопасным. Чаще всего, ненулевое значение означает, что процесс выполняет программу с установленным set-user-ID или set-group-ID битом (то есть его реальный и эффективный UID или GID отличаются от начального) или же он получает мандаты, запуская двоичный файл с другими мандатами (смотрите B<capabilities>(7)). Также ненулевое значение может выставляться Linux Security Module. Если значение не ноль, то динамический компоновщик прекращает использовать определённые переменные окружения (смотрите B<ld-linux.so>(8)) и изменяется некоторое поведение glibc (также смотрите B<secure_getenv>(3))."

#. type: TP
#: man-pages/man3/getauxval.3:165
#, no-wrap
msgid "B<AT_SYSINFO>"
msgstr "B<AT_SYSINFO>"

#. type: Plain text
#: man-pages/man3/getauxval.3:169
msgid ""
"The entry point to the system call function in the vDSO.  Not present/needed"
" on all architectures (e.g., absent on x86-64)."
msgstr "Точка входа в функцию системного вызова в vDSO. Отсутствует/не нужна для всех архитектур (например, отсутствует на x86-64)."

#. type: TP
#: man-pages/man3/getauxval.3:169
#, no-wrap
msgid "B<AT_SYSINFO_EHDR>"
msgstr "B<AT_SYSINFO_EHDR>"

#. type: Plain text
#: man-pages/man3/getauxval.3:174
msgid ""
"The address of a page containing the virtual Dynamic Shared Object (vDSO)  "
"that the kernel creates in order to provide fast implementations of certain "
"system calls."
msgstr "Адрес страницы, содержащий виртуальный Динамический Общий Объект (Dynamic Shared Object, vDSO), который ядро создаёт для предоставления более быстрой реализации некоторых системных вызовов."

#. type: TP
#: man-pages/man3/getauxval.3:174
#, no-wrap
msgid "B<AT_UCACHEBSIZE>"
msgstr "B<AT_UCACHEBSIZE>"

#. type: Plain text
#: man-pages/man3/getauxval.3:177
msgid "The unified cache block size."
msgstr "Размер блока универсального кэша."

#. type: TP
#: man-pages/man3/getauxval.3:177
#, no-wrap
msgid "B<AT_UID>"
msgstr "B<AT_UID>"

#. type: Plain text
#: man-pages/man3/getauxval.3:180
msgid "The real user ID of the thread."
msgstr "Реальный идентификатор пользователя нити."

#. type: Plain text
#: man-pages/man3/getauxval.3:188
msgid ""
"On success, B<getauxval>()  returns the value corresponding to I<type>.  If "
"I<type> is not found, 0 is returned."
msgstr "При успешном выполнении B<getauxval>() возвращает значение, соответствующее I<type>.Если I<type> не найден, то возвращается 0."

#. type: TP
#: man-pages/man3/getauxval.3:189
#, no-wrap
msgid "B<ENOENT> (since glibc 2.19)"
msgstr "B<ENOENT> (начиная с glibc 2.19)"

#.  commit b9ab448f980e296eac21ac65f53783967cc6037b
#. type: Plain text
#: man-pages/man3/getauxval.3:195
msgid ""
"No entry corresponding to I<type> could be found in the auxiliary vector."
msgstr "В вспомогательном векторе не найдено значение, соответствующее I<type>."

#. type: Plain text
#: man-pages/man3/getauxval.3:199
msgid "The B<getauxval>()  function was added to glibc in version 2.16."
msgstr "Функция B<getauxval>() впервые появилась в glibc 2.16."

#. type: tbl table
#: man-pages/man3/getauxval.3:209
#, no-wrap
msgid "B<getauxval>()"
msgstr "B<getauxval>()"

#. type: Plain text
#: man-pages/man3/getauxval.3:213
msgid "This function is a nonstandard glibc extension."
msgstr "Эта функция является нестандартным расширением glibc."

#. type: Plain text
#: man-pages/man3/getauxval.3:222
msgid ""
"The primary consumer of the information in the auxiliary vector is the "
"dynamic linker B<ld-linux.so>(8).  The auxiliary vector is a convenient and "
"efficient shortcut that allows the kernel to communicate a certain set of "
"standard information that the dynamic linker usually or always needs.  In "
"some cases, the same information could be obtained by system calls, but "
"using the auxiliary vector is cheaper."
msgstr "Основным пользователем информации из вспомогательного вектора является динамический компоновщик B<ld-linux.so>(8). Вспомогательный вектор удобное и эффективное средство для предоставления ядром некоторого набора стандартной информации, которая обычно или всегда требуется динамическому компоновщику. В некоторых случаях эта информация может быть получена через системные вызовы, но использование вспомогательного вектора экономичней."

#. type: Plain text
#: man-pages/man3/getauxval.3:228
msgid ""
"The auxiliary vector resides just above the argument list and environment in"
" the process address space.  The auxiliary vector supplied to a program can "
"be viewed by setting the B<LD_SHOW_AUXV> environment variable when running a"
" program:"
msgstr "Вспомогательный вектор располагается выше списка аргументов и окружения в адресном пространстве процесса. Переданный программе вектор можно просмотреть установив переменную окружения B<LD_SHOW_AUXV> и запустив программу:"

#. type: Plain text
#: man-pages/man3/getauxval.3:232
#, no-wrap
msgid "$ LD_SHOW_AUXV=1 sleep 1\n"
msgstr "$ LD_SHOW_AUXV=1 sleep 1\n"

#. type: Plain text
#: man-pages/man3/getauxval.3:241
msgid ""
"The auxiliary vector of any process can (subject to file permissions)  be "
"obtained via I</proc/[pid]/auxv>; see B<proc>(5)  for more information."
msgstr "Вспомогательный вектор любого процесса может быть получен (при наличии прав доступа) через I</proc/[pid]/auxv>; подробней смотрите в B<proc>(5)."

#. type: Plain text
#: man-pages/man3/getauxval.3:250
msgid ""
"Before the addition of the B<ENOENT> error in glibc 2.19, there was no way "
"to unambiguously distinguish the case where I<type> could not be found from "
"the case where the value corresponding to I<type> was zero."
msgstr "До того как ошибка B<ENOENT> не была добавлена в glibc 2.19, не было способа достоверно определить, что I<type> не найден, если значение I<type> равно нулю."

#. type: Plain text
#: man-pages/man3/getauxval.3:253
msgid "B<secure_getenv>(3), B<vdso>(7), B<ld-linux.so>(8)"
msgstr "B<secure_getenv>(3), B<vdso>(7), B<ld-linux.so>(8)"

#. type: TH
#: man-pages/man3/getpass.3:24
#, no-wrap
msgid "GETPASS"
msgstr "GETPASS"

#. type: Plain text
#: man-pages/man3/getpass.3:27
msgid "getpass - get a password"
msgstr "getpass - запрашивает пароль"

#. type: Plain text
#: man-pages/man3/getpass.3:31
msgid "B<char *getpass(const char *>I<prompt>B<);>"
msgstr "B<char *getpass(const char *>I<prompt>B<);>"

#. type: Plain text
#: man-pages/man3/getpass.3:38
msgid "B<getpass>():"
msgstr "B<getpass>():"

#. type: TP
#: man-pages/man3/getpass.3:41
#, no-wrap
msgid "Since glibc 2.2.2:"
msgstr "Начиная с glibc 2.2.2:"

#. type: Plain text
#: man-pages/man3/getpass.3:47
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr "_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: TP
#: man-pages/man3/getpass.3:48
#, no-wrap
msgid "Before glibc 2.2.2:"
msgstr "До glibc 2.2.2:"

#. type: Plain text
#: man-pages/man3/getpass.3:62
msgid ""
"This function is obsolete.  Do not use it.  If you want to read input "
"without terminal echoing enabled, see the description of the I<ECHO> flag in"
" B<termios>(3)."
msgstr "Эта функция устарела. Не используйте её. Если вы хотите читать вводимые данные без вывода на терминал, смотрите описание флага I<ECHO> в B<termios>(3)."

#. type: Plain text
#: man-pages/man3/getpass.3:73
msgid ""
"The B<getpass>()  function opens I</dev/tty> (the controlling terminal of "
"the process), outputs the string I<prompt>, turns off echoing, reads one "
"line (the \"password\"), restores the terminal state and closes I</dev/tty> "
"again."
msgstr "Функция B<getpass>() открывает I</dev/tty> (управляющий терминал процесса), выводит строку I<prompt>, выключает показ выводимых символов, читает одну строку («пароль»), восстанавливает состояние терминала и закрывает I</dev/tty>."

#. type: Plain text
#: man-pages/man3/getpass.3:84
msgid ""
"The function B<getpass>()  returns a pointer to a static buffer containing "
"(the first B<PASS_MAX> bytes of) the password without the trailing newline, "
"terminated by a null byte (\\(aq\\e0\\(aq).  This buffer may be overwritten "
"by a following call.  On error, the terminal state is restored, I<errno> is "
"set appropriately, and NULL is returned."
msgstr "Функция B<getpass>() возвращает указатель на статический буфер, содержащий (первые B<PASS_MAX> байтов) пароль без символа новой строки, оканчивающийся нулевым байтом («\\e0»). Этот буфер может быть перезаписан следующим вызовом. При ошибке, состояние терминала восстанавливается, значение I<errno> устанавливается соответствующим образом и возвращается NULL."

#. type: Plain text
#: man-pages/man3/getpass.3:86
msgid "The function may fail if"
msgstr "Эта функция может завершаться с ошибками:"

#. type: TP
#: man-pages/man3/getpass.3:86
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man3/getpass.3:89
msgid "The process does not have a controlling terminal."
msgstr "Процесс не имеет управляющего терминала."

#.  .SH HISTORY
#.  A
#.  .BR getpass ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: man-pages/man3/getpass.3:95
msgid "I</dev/tty>"
msgstr "I</dev/tty>"

#. type: tbl table
#: man-pages/man3/getpass.3:105
#, no-wrap
msgid "B<getpass>()"
msgstr "B<getpass>()"

#. type: tbl table
#: man-pages/man3/getpass.3:105
#, no-wrap
msgid "MT-Unsafe term"
msgstr "MT-Unsafe term"

#. type: Plain text
#: man-pages/man3/getpass.3:110
msgid "Present in SUSv2, but marked LEGACY.  Removed in POSIX.1-2001."
msgstr "Есть в SUSv2, но помечена как УСТАРЕВШАЯ. Удалена из POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/getpass.3:140
msgid ""
"In the GNU C library implementation, if I</dev/tty> cannot be opened, the "
"prompt is written to I<stderr> and the password is read from I<stdin>.  "
"There is no limit on the length of the password.  Line editing is not "
"disabled."
msgstr "В реализации библиотеки GNU C, если файл I</dev/tty> не может быть открыт, то строка приглашения выводится в поток ошибок I<stderr>, а пароль читается из стандартного потока ввода I<stdin>. Ограничения на длину пароля нет и строку можно редактировать."

#.  Libc4 and libc5 have never supported
#.  .B PASS_MAX
#.  or
#.  .BR _SC_PASS_MAX .
#. type: Plain text
#: man-pages/man3/getpass.3:162
msgid ""
"According to SUSv2, the value of B<PASS_MAX> must be defined in "
"I<E<lt>limits.hE<gt>> in case it is smaller than 8, and can in any case be "
"obtained using I<sysconf(_SC_PASS_MAX)>.  However, POSIX.2 withdraws the "
"constants B<PASS_MAX> and B<_SC_PASS_MAX>, and the function B<getpass>().  "
"The glibc version accepts B<_SC_PASS_MAX> and returns B<BUFSIZ> (e.g., "
"8192)."
msgstr "Согласно SUSv2 значение B<PASS_MAX> должно быть определено в I<E<lt>limits.hE<gt>>, если оно меньше 8, и в любом случае может быть получено с помощью I<sysconf(_SC_PASS_MAX)>. Однако, из стандарта POSIX.2 константы B<PASS_MAX>, B<_SC_PASS_MAX> и функция B<getpass>() убраны. В glibc учитывается B<_SC_PASS_MAX> и возвращается B<BUFSIZ> (например, 8192)."

#. type: Plain text
#: man-pages/man3/getpass.3:165
msgid ""
"The calling process should zero the password as soon as possible to avoid "
"leaving the cleartext password visible in the process's address space."
msgstr "Вызывающий процесс должен как можно скорее обнулить пароль во избежание возможности просмотра незашифрованного пароля в адресном пространстве процесса."

#. type: Plain text
#: man-pages/man3/getpass.3:166
msgid "B<crypt>(3)"
msgstr "B<crypt>(3)"

#. type: TH
#: man-pages/man3/getpwent_r.3:24
#, no-wrap
msgid "GETPWENT_R"
msgstr "GETPWENT_R"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:27
msgid "getpwent_r, fgetpwent_r - get passwd file entry reentrantly"
msgstr "getpwent_r, fgetpwent_r - получает запись из файла паролей (реентерабельные версии)"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:30
#, no-wrap
msgid "B<#include E<lt>pwd.hE<gt>>\n"
msgstr "B<#include E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:33
#, no-wrap
msgid ""
"B<int getpwent_r(struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\n"
"B<               size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"
msgstr "B<int getpwent_r(struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\nB<               size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:36
#, no-wrap
msgid ""
"B<int fgetpwent_r(FILE *>I<stream>B<, struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"
msgstr "B<int fgetpwent_r(FILE *>I<stream>B<, struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:48
#, no-wrap
msgid ""
"B<getpwent_r>(),\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getpwent_r>(),\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:54
#, no-wrap
msgid ""
"B<fgetpwent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr "B<fgetpwent_r>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:67
msgid ""
"The functions B<getpwent_r>()  and B<fgetpwent_r>()  are the reentrant "
"versions of B<getpwent>(3)  and B<fgetpwent>(3).  The former reads the next "
"passwd entry from the stream initialized by B<setpwent>(3).  The latter "
"reads the next passwd entry from I<stream>."
msgstr "Функции B<getpwent_r>() и B<fgetpwent_r>() являются реентерабельными версиями B<getpwent>(3) и B<fgetpwent>(3). Первая читает следующую запись паролей из потока, инициализированного B<setpwent>(3). Последняя читает следующую запись паролей из потока I<stream>."

#. type: Plain text
#: man-pages/man3/getpwent_r.3:83
#, no-wrap
msgid ""
"struct passwd {\n"
"    char    *pw_name;      /* username */\n"
"    char    *pw_passwd;    /* user password */\n"
"    uid_t    pw_uid;       /* user ID */\n"
"    gid_t    pw_gid;       /* group ID */\n"
"    char    *pw_gecos;     /* user information */\n"
"    char    *pw_dir;       /* home directory */\n"
"    char    *pw_shell;     /* shell program */\n"
"};\n"
msgstr "struct passwd {\n    char   *pw_name;       /* имя пользователя */\n    char   *pw_passwd;     /* пароль пользователя */\n    uid_t   pw_uid;        /* идентификатор пользователя */\n    gid_t   pw_gid;        /* идентификатор группы */\n    char   *pw_gecos;      /* информация о пользователе */\n    char   *pw_dir;        /* домашний каталог */\n    char   *pw_shell;      /* программная оболочка */\n};\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:107
msgid ""
"The nonreentrant functions return a pointer to static storage, where this "
"static storage contains further pointers to user name, password, gecos "
"field, home directory and shell.  The reentrant functions described here "
"return all of that in caller-provided buffers.  First of all there is the "
"buffer I<pwbuf> that can hold a I<struct passwd>.  And next the buffer "
"I<buf> of size I<buflen> that can hold additional strings.  The result of "
"these functions, the I<struct passwd> read from the stream, is stored in the"
" provided buffer I<*pwbuf>, and a pointer to this I<struct passwd> is "
"returned in I<*pwbufp>."
msgstr "Нереентерабельные версии возвращают указатель на статическое хранилище, в котором хранятся другие указатели на имя пользователя, пароль, поле gecos, домашний каталог и оболочку. Реентерабельные функции, описанные здесь, возвращают всю информацию в буферах, предоставленных вызывающим. Основным буфером является I<pwbuf>, в котором может храниться I<struct passwd>. В дополнительном буфере I<buf> размера I<buflen> могут храниться дополнительные строки. Результат этих функций, прочитанная из потока I<struct passwd>, сохраняется в предоставляемый буфер I<*pwbuf>, и указатель на эту I<struct passwd> возвращается в I<*pwbufp>."

#. type: Plain text
#: man-pages/man3/getpwent_r.3:114
msgid ""
"On success, these functions return 0 and I<*pwbufp> is a pointer to the "
"I<struct passwd>.  On error, these functions return an error value and "
"I<*pwbufp> is NULL."
msgstr "При успешном выполнении эти функции возвращают 0 и I<*pwbufp> указывает на I<struct passwd>. При ошибке возвращается значение ошибки и I<*pwbufp> равен NULL."

#. type: Plain text
#: man-pages/man3/getpwent_r.3:118
msgid "No more entries."
msgstr "Больше записей нет."

#. type: Plain text
#: man-pages/man3/getpwent_r.3:122
msgid "Insufficient buffer space supplied.  Try again with larger buffer."
msgstr "Недостаточно места в буфере. Попробуйте ещё раз с большим буфером."

#. type: tbl table
#: man-pages/man3/getpwent_r.3:132
#, no-wrap
msgid "B<getpwent_r>()"
msgstr "B<getpwent_r>()"

#. type: tbl table
#: man-pages/man3/getpwent_r.3:135
#, no-wrap
msgid "B<fgetpwent_r>()"
msgstr "B<fgetpwent_r>()"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:150
msgid ""
"In the above table, I<pwent> in I<race:pwent> signifies that if any of the "
"functions B<setpwent>(), B<getpwent>(), B<endpwent>(), or B<getpwent_r>()  "
"are used in parallel in different threads of a program, then data races "
"could occur."
msgstr "В приведённой выше таблице I<pwent> в I<race:pwent> означает, что если в нескольких нитях программы одновременно используются функции B<setpwent>(), B<getpwent>(), B<endpwent>() или B<getpwent_r>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getpwent_r.3:155
msgid ""
"These functions are GNU extensions, done in a style resembling the POSIX "
"version of functions like B<getpwnam_r>(3).  Other systems use the prototype"
msgstr "Эти функции являются расширениями GNU; они выполнены похожими на POSIX-версию функции B<getpwnam_r>(3). В других системах используется прототип"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:160
#, no-wrap
msgid ""
"struct passwd *\n"
"getpwent_r(struct passwd *pwd, char *buf, int buflen);\n"
msgstr "struct passwd *\ngetpwent_r(struct passwd *pwd, char *buf, int buflen);\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:164
msgid "or, better,"
msgstr "или, лучше,"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:170
#, no-wrap
msgid ""
"int\n"
"getpwent_r(struct passwd *pwd, char *buf, int buflen,\n"
"           FILE **pw_fp);\n"
msgstr "int\ngetpwent_r(struct passwd *pwd, char *buf, int buflen,\n           FILE **pw_fp);\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:177
msgid ""
"The function B<getpwent_r>()  is not really reentrant since it shares the "
"reading position in the stream with all other threads."
msgstr "Функция B<getpwent_r>() не совсем реентерабельна, так как она использует общую позицию чтения в потоке с другими нитями."

#. type: Plain text
#: man-pages/man3/getpwent_r.3:183
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#define BUFLEN 4096\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>pwd.hE<gt>\n#include E<lt>stdio.hE<gt>\n#define BUFLEN 4096\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:190
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct passwd pw, *pwp;\n"
"    char buf[BUFLEN];\n"
"    int i;\n"
msgstr "int\nmain(void)\n{\n    struct passwd pw, *pwp;\n    char buf[BUFLEN];\n    int i;\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:202
#, no-wrap
msgid ""
"    setpwent();\n"
"    while (1) {\n"
"        i = getpwent_r(&pw, buf, BUFLEN, &pwp);\n"
"        if (i)\n"
"            break;\n"
"        printf(\"%s (%d)\\etHOME %s\\etSHELL %s\\en\", pwp-E<gt>pw_name,\n"
"               pwp-E<gt>pw_uid, pwp-E<gt>pw_dir, pwp-E<gt>pw_shell);\n"
"    }\n"
"    endpwent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    setpwent();\n    while (1) {\n        i = getpwent_r(&pw, buf, BUFLEN, &pwp);\n        if (i)\n            break;\n        printf(\"%s (%d)\\etHOME %s\\etSHELL %s\\en\", pwp-E<gt>pw_name,\n               pwp-E<gt>pw_uid, pwp-E<gt>pw_dir, pwp-E<gt>pw_shell);\n    }\n    endpwent();\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:219
msgid ""
"B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"
msgstr "B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getservent.3:34
#, no-wrap
msgid "GETSERVENT"
msgstr "GETSERVENT"

#. type: Plain text
#: man-pages/man3/getservent.3:38
msgid ""
"getservent, getservbyname, getservbyport, setservent, endservent - get "
"service entry"
msgstr "getservent, getservbyname, getservbyport, setservent, endservent - возвращают запись о службе"

#. type: Plain text
#: man-pages/man3/getservent.3:43
#, no-wrap
msgid "B<struct servent *getservent(void);>\n"
msgstr "B<struct servent *getservent(void);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:45
#, no-wrap
msgid ""
"B<struct servent *getservbyname(const char *>I<name>B<, const char "
"*>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyname(const char *>I<name>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:47
#, no-wrap
msgid ""
"B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:49
#, no-wrap
msgid "B<void setservent(int >I<stayopen>B<);>\n"
msgstr "B<void setservent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:51
#, no-wrap
msgid "B<void endservent(void);>\n"
msgstr "B<void endservent(void);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:62
msgid ""
"The B<getservent>()  function reads the next entry from the services "
"database (see B<services>(5))  and returns a I<servent> structure containing"
" the broken-out fields from the entry.  A connection is opened to the "
"database if necessary."
msgstr "Функция B<getservent>() считывает следующую запись из файла, содержащего базу служб (смотрите B<services>(5)), и возвращает структуру I<servent>, содержащую поля из этой записи. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getservent.3:77
msgid ""
"The B<getservbyname>()  function returns a I<servent> structure for the "
"entry from the database that matches the service I<name> using protocol "
"I<proto>.  If I<proto> is NULL, any protocol will be matched.  A connection "
"is opened to the database if necessary."
msgstr "Функция B<getservbyname>() возвращает структуру I<servent> элемента из базы данных, который совпадает со службой I<name> и использующей протокол I<proto>. Если значение I<proto> равно NULL, то подойдёт любой протокол. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getservent.3:93
msgid ""
"The B<getservbyport>()  function returns a I<servent> structure for the "
"entry from the database that matches the port I<port> (given in network byte"
" order)  using protocol I<proto>.  If I<proto> is NULL, any protocol will be"
" matched.  A connection is opened to the database if necessary."
msgstr "Функция B<getservbyport>() возвращает структуру I<servent> элемента из базы данных, который совпадает с портом I<port> (значение имеет сетевой порядок байт) и использующей протокол I<proto>. Если значение I<proto> равно NULL, то подойдёт любой протокол. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getservent.3:105
msgid ""
"The B<setservent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getserv*>()  functions."
msgstr "Функция B<setservent>() открывает соединение к базе и устанавливает следующую запись к первой записи. Если I<stayopen> не равен нулю, то подключение к базе между вызовами нескольких функций B<getserv*>() не будет закрыто."

#. type: Plain text
#: man-pages/man3/getservent.3:109
msgid "The B<endservent>()  function closes the connection to the database."
msgstr "Функция B<endservent>() закрывает подключение к базе."

#. type: Plain text
#: man-pages/man3/getservent.3:115
msgid ""
"The I<servent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "Структура I<servent> определена в I<E<lt>netdb.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/getservent.3:124
#, no-wrap
msgid ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"
msgstr "struct servent {\n    char  *s_name;       /* официальное имя службы */\n    char **s_aliases;    /* список псевдонимов */\n    int    s_port;       /* номер порта */\n    char  *s_proto;      /* используемый протокол */\n}\n"

#. type: Plain text
#: man-pages/man3/getservent.3:130
msgid "The members of the I<servent> structure are:"
msgstr "Члены структуры I<servent>:"

#. type: TP
#: man-pages/man3/getservent.3:130
#, no-wrap
msgid "I<s_name>"
msgstr "I<s_name>"

#. type: Plain text
#: man-pages/man3/getservent.3:133
msgid "The official name of the service."
msgstr "Официальное название службы."

#. type: TP
#: man-pages/man3/getservent.3:133
#, no-wrap
msgid "I<s_aliases>"
msgstr "I<s_aliases>"

#. type: Plain text
#: man-pages/man3/getservent.3:136
msgid "A NULL-terminated list of alternative names for the service."
msgstr "Список альтернативных имён службы, завершающийся NULL."

#. type: TP
#: man-pages/man3/getservent.3:136
#, no-wrap
msgid "I<s_port>"
msgstr "I<s_port>"

#. type: Plain text
#: man-pages/man3/getservent.3:139
msgid "The port number for the service given in network byte order."
msgstr "Номер порта службы, задаваемый в сетевом порядке байт."

#. type: TP
#: man-pages/man3/getservent.3:139
#, no-wrap
msgid "I<s_proto>"
msgstr "I<s_proto>"

#. type: Plain text
#: man-pages/man3/getservent.3:142
msgid "The name of the protocol to use with this service."
msgstr "Имя протокола, используемого с данной службой."

#. type: Plain text
#: man-pages/man3/getservent.3:153
msgid ""
"The B<getservent>(), B<getservbyname>()  and B<getservbyport>()  functions "
"return a pointer to a statically allocated I<servent> structure, or NULL if "
"an error occurs or the end of the file is reached."
msgstr "Функции B<getservent>(), B<getservbyname>() и B<getservbyport>() возвращают указатель на статически выделенную структуру I<servent> или NULL при ошибке или достижении конца файла."

#. type: TP
#: man-pages/man3/getservent.3:154
#, no-wrap
msgid "I</etc/services>"
msgstr "I</etc/services>"

#. type: Plain text
#: man-pages/man3/getservent.3:157
msgid "services database file"
msgstr "файл базы данных служб"

#. type: tbl table
#: man-pages/man3/getservent.3:167
#, no-wrap
msgid "B<getservent>()"
msgstr "B<getservent>()"

#. type: tbl table
#: man-pages/man3/getservent.3:169 man-pages/man3/getservent.3:192
#, no-wrap
msgid "MT-Unsafe race:servent\n"
msgstr "MT-Unsafe race:servent\n"

#. type: tbl table
#: man-pages/man3/getservent.3:171
#, no-wrap
msgid "race:serventbuf locale"
msgstr "race:serventbuf locale"

#. type: tbl table
#: man-pages/man3/getservent.3:174
#, no-wrap
msgid "B<getservbyname>()"
msgstr "B<getservbyname>()"

#. type: tbl table
#: man-pages/man3/getservent.3:176
#, no-wrap
msgid "MT-Unsafe race:servbyname\n"
msgstr "MT-Unsafe race:servbyname\n"

#. type: tbl table
#: man-pages/man3/getservent.3:181
#, no-wrap
msgid "B<getservbyport>()"
msgstr "B<getservbyport>()"

#. type: tbl table
#: man-pages/man3/getservent.3:183
#, no-wrap
msgid "MT-Unsafe race:servbyport\n"
msgstr "MT-Unsafe race:servbyport\n"

#. type: tbl table
#: man-pages/man3/getservent.3:188
#, no-wrap
msgid "B<setservent>(),\n"
msgstr "B<setservent>(),\n"

#. type: tbl table
#: man-pages/man3/getservent.3:190
#, no-wrap
msgid "B<endservent>()"
msgstr "B<endservent>()"

#. type: Plain text
#: man-pages/man3/getservent.3:208
msgid ""
"In the above table, I<servent> in I<race:servent> signifies that if any of "
"the functions B<setservent>(), B<getservent>(), or B<endservent>()  are used"
" in parallel in different threads of a program, then data races could occur."
msgstr "В приведённой выше таблице I<servent> в I<race:servent> означает, что если в нескольких нитях программы одновременно используются функции B<setservent>(), B<getservent>() или B<endservent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getservent.3:214
msgid "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"
msgstr "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"

#. type: TH
#: man-pages/man3/getfsent.3:27
#, no-wrap
msgid "GETFSENT"
msgstr "GETFSENT"

#. type: Plain text
#: man-pages/man3/getfsent.3:30
msgid ""
"getfsent, getfsspec, getfsfile, setfsent, endfsent - handle fstab entries"
msgstr "getfsent, getfsspec, getfsfile, setfsent, endfsent - для работы с записями fstab"

#. type: Plain text
#: man-pages/man3/getfsent.3:32
msgid "B<#include E<lt>fstab.hE<gt>>"
msgstr "B<#include E<lt>fstab.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getfsent.3:34
msgid "B<void endfsent(void);>"
msgstr "B<void endfsent(void);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:36
msgid "B<struct fstab *getfsent(void);>"
msgstr "B<struct fstab *getfsent(void);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:38
msgid "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"
msgstr "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:40
msgid "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"
msgstr "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:42
msgid "B<int setfsent(void);>"
msgstr "B<int setfsent(void);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:48
msgid ""
"These functions read from the file I</etc/fstab>.  The I<struct fstab> is "
"defined by:"
msgstr "Эти функции читают файл I</etc/fstab>. Структура I<struct fstab> определена следующим образом:"

#. type: Plain text
#: man-pages/man3/getfsent.3:60
#, no-wrap
msgid ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"
msgstr "struct fstab {\n    char       *fs_spec;       /* имя блочного устройства */\n    char       *fs_file;       /* точка монтирования */\n    char       *fs_vfstype;    /* тип файловой системы */\n    char       *fs_mntops;     /* параметры монтирования */\n    const char *fs_type;       /* параметр rw/rq/ro/sw/xx */\n    int         fs_freq;       /* периодичность запуска dump, в днях */\n    int         fs_passno;     /* номер прохода при параллельном dump */\n};\n"

#. type: Plain text
#: man-pages/man3/getfsent.3:68
msgid ""
"Here the field I<fs_type> contains (on a *BSD system)  one of the five "
"strings \"rw\", \"rq\", \"ro\", \"sw\", \"xx\" (read-write, read-write with "
"quota, read-only, swap, ignore)."
msgstr "Здесь поле I<fs_type> содержит (в системах *BSD) одну из пяти строк: «rw», «rq», «ro», «sw», «xx» (чтение-запись, чтение-запись с квотами, только-чтение, подкачка, игнорировать)."

#. type: Plain text
#: man-pages/man3/getfsent.3:72
msgid ""
"The function B<setfsent>()  opens the file when required and positions it at"
" the first line."
msgstr "Функция B<setfsent>() открывает файл при необходимости и устанавливает указатель на первую строку."

#. type: Plain text
#: man-pages/man3/getfsent.3:77
msgid ""
"The function B<getfsent>()  parses the next line from the file.  (After "
"opening it when required.)"
msgstr "Функция B<getfsent>() обрабатывает следующую строку из файла (открыв файл, если требуется)."

#. type: Plain text
#: man-pages/man3/getfsent.3:81
msgid "The function B<endfsent>()  closes the file when required."
msgstr "Функция B<endfsent>() закрывает файл, если требуется."

#. type: Plain text
#: man-pages/man3/getfsent.3:90
msgid ""
"The function B<getfsspec>()  searches the file from the start and returns "
"the first entry found for which the I<fs_spec> field matches the "
"I<special_file> argument."
msgstr "Функция B<getfsspec>() ищет с начала файла запись, для которой поле I<fs_spec> соответствует аргументу I<special_file> и возвращает её."

#. type: Plain text
#: man-pages/man3/getfsent.3:99
msgid ""
"The function B<getfsfile>()  searches the file from the start and returns "
"the first entry found for which the I<fs_file> field matches the "
"I<mount_point> argument."
msgstr "Функция B<getfsfile>() ищет с начала файла запись, для которой поле I<fs_file> соответствует аргументу I<mount_point> и возвращает её."

#.  .SH HISTORY
#.  The
#.  .BR getfsent ()
#.  function appeared in 4.0BSD; the other four functions appeared in 4.3BSD.
#. type: Plain text
#: man-pages/man3/getfsent.3:115
msgid ""
"Upon success, the functions B<getfsent>(), B<getfsfile>(), and "
"B<getfsspec>()  return a pointer to a I<struct fstab>, while B<setfsent>()  "
"returns 1.  Upon failure or end-of-file, these functions return NULL and 0, "
"respectively."
msgstr "При успешном выполнении функции B<getfsent>(), B<getfsfile>() и B<getfsspec>() возвращают указатель на структуру  I<struct fstab>, а B<setfsent>() возвращает 1. При ошибке или обнаружении конца файла эти функции возвращают, соответственно, NULL или 0."

#. type: tbl table
#: man-pages/man3/getfsent.3:125
#, no-wrap
msgid "B<endfsent>(),\n"
msgstr "B<endfsent>(),\n"

#. type: tbl table
#: man-pages/man3/getfsent.3:127
#, no-wrap
msgid "B<setfsent>()"
msgstr "B<setfsent>()"

#. type: tbl table
#: man-pages/man3/getfsent.3:127
#, no-wrap
msgid "MT-Unsafe race:fsent"
msgstr "MT-Unsafe race:fsent"

#. type: tbl table
#: man-pages/man3/getfsent.3:130
#, no-wrap
msgid "B<getfsent>(),\n"
msgstr "B<getfsent>(),\n"

#. type: tbl table
#: man-pages/man3/getfsent.3:132
#, no-wrap
msgid "B<getfsspec>(),\n"
msgstr "B<getfsspec>(),\n"

#. type: tbl table
#: man-pages/man3/getfsent.3:134
#, no-wrap
msgid "B<getfsfile>()"
msgstr "B<getfsfile>()"

#. type: tbl table
#: man-pages/man3/getfsent.3:134
#, no-wrap
msgid "MT-Unsafe race:fsent locale"
msgstr "MT-Unsafe race:fsent locale"

#. type: Plain text
#: man-pages/man3/getfsent.3:148
msgid ""
"These functions are not in POSIX.1.  Several operating systems have them, "
"for example, *BSD, SunOS, Digital UNIX, AIX (which also has a "
"B<getfstype>()).  HP-UX has functions of the same names, that however use a "
"I<struct checklist> instead of a I<struct fstab>, and calls these functions "
"obsolete, superseded by B<getmntent>(3)."
msgstr "Эти функции не включены в POSIX.1. Они имеются в некоторых операционных системах, например *BSD, SunOS, Digital UNIX, AIX (в котором также есть B<getfstype>()). В HP-UX есть функции с тем же именем, но вместо структуры I<struct fstab> они используют структуру I<struct checklist>, и вызовы этих функций устарели, они заменены на B<getmntent>(3)."

#. type: Plain text
#: man-pages/man3/getfsent.3:150
msgid "These functions are not thread-safe."
msgstr "Эти функции нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/getfsent.3:160
msgid ""
"Since Linux allows mounting a block special device in several places, and "
"since several devices can have the same mount point, where the last device "
"with a given mount point is the interesting one, while B<getfsfile>()  and "
"B<getfsspec>()  only return the first occurrence, these two functions are "
"not suitable for use under Linux."
msgstr "Так как Linux позволяет монтировать специальное блочное устройство в несколько разных точек, а также так как несколько устройств могут иметь одну точку монтирования, то неясно, будет ли результат (первая запись), возвращенный функциями B<getfsfile>() и B<getfsspec>() именно тем, что и ожидался. Поэтому эти две функции не подходят для использования под Linux."

#. type: Plain text
#: man-pages/man3/getfsent.3:162
msgid "B<getmntent>(3), B<fstab>(5)"
msgstr "B<getmntent>(3), B<fstab>(5)"

#. type: TH
#: man-pages/man3/getumask.3:28
#, no-wrap
msgid "GETUMASK"
msgstr "GETUMASK"

#. type: Plain text
#: man-pages/man3/getumask.3:31
msgid "getumask - get file creation mask"
msgstr "getumask - возвращает маску создания файла"

#. type: Plain text
#: man-pages/man3/getumask.3:37
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr "B<#include E<lt>sys/stat.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getumask.3:39
msgid "B<mode_t getumask(void);>"
msgstr "B<mode_t getumask(void);>"

#. type: Plain text
#: man-pages/man3/getumask.3:42
msgid ""
"This function returns the current file creation mask.  It is equivalent to"
msgstr "Функция возвращает текущую маску создания файла. Она эквивалентна"

#. type: Plain text
#: man-pages/man3/getumask.3:51
#, no-wrap
msgid ""
"mode_t getumask(void)\n"
"{\n"
"    mode_t mask = umask( 0 );\n"
"    umask(mask);\n"
"    return mask;\n"
"}\n"
msgstr "mode_t getumask(void)\n{\n    mode_t mask = umask( 0 );\n    umask(mask);\n    return mask;\n}\n"

#. type: Plain text
#: man-pages/man3/getumask.3:58
msgid ""
"except that it is documented to be thread-safe (that is, shares a lock with "
"the B<umask>(2)  library call)."
msgstr "за исключением того, что без проблем может использоваться нитях (то есть использует общую блокировку с библиотечным вызовом B<umask>(2))."

#. type: Plain text
#: man-pages/man3/getumask.3:60
msgid "This is a vaporware GNU extension."
msgstr "Это «дутое» расширение GNU."

#. type: Plain text
#: man-pages/man3/getumask.3:66
msgid ""
"This function is documented in the glibc manual, but, as at glibc version "
"2.24, it is not implemented on Linux.  (See B<umask>(2)  for a thread-safe "
"method of discovering a process's umask.)"
msgstr "Эта функция описана в руководстве glibc, но на момент версии glibc 2.24, оно не реализовано для Linux (смотрите в B<umask>(2) нитебезопасный метод определения umask процесса)."

#. type: Plain text
#: man-pages/man3/getumask.3:67
msgid "B<umask>(2)"
msgstr "B<umask>(2)"

#. type: TH
#: man-pages/man3/getdate.3:30
#, no-wrap
msgid "GETDATE"
msgstr "GETDATE"

#. type: Plain text
#: man-pages/man3/getdate.3:33
msgid ""
"getdate, getdate_r - convert a date-plus-time string to broken-down time"
msgstr "getdate, getdate_r - разделяет строку дата+время на отдельные части"

#. type: Plain text
#: man-pages/man3/getdate.3:35 man-pages/man3/getdate.3:41
msgid "B<#include E<lt>time.hE<gt>>"
msgstr "B<#include E<lt>time.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getdate.3:37
msgid "B<struct tm *getdate(const char *>I<string>B<);>"
msgstr "B<struct tm *getdate(const char *>I<string>B<);>"

#. type: Plain text
#: man-pages/man3/getdate.3:39
msgid "B<extern int getdate_err;>"
msgstr "B<extern int getdate_err;>"

#. type: Plain text
#: man-pages/man3/getdate.3:43
msgid "B<int getdate_r(const char *>I<string>B<, struct tm *>I<res>B<);>"
msgstr "B<int getdate_r(const char *>I<string>B<, struct tm *>I<res>B<);>"

#. type: Plain text
#: man-pages/man3/getdate.3:50
msgid "B<getdate>():"
msgstr "B<getdate>():"

#. type: Plain text
#: man-pages/man3/getdate.3:57
msgid "B<getdate_r>():"
msgstr "B<getdate_r>():"

#. type: Plain text
#: man-pages/man3/getdate.3:60
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getdate.3:78
msgid ""
"The function B<getdate>()  converts a string representation of a date and "
"time, contained in the buffer pointed to by I<string>, into a broken-down "
"time.  The broken-down time is stored in a I<tm> structure, and a pointer to"
" this structure is returned as the function result.  This I<tm> structure is"
" allocated in static storage, and consequently it will be overwritten by "
"further calls to B<getdate>()."
msgstr "Функция B<getdate>() преобразует строковое представление даты и времени из буфера, на который указывает I<string> в разделённое на компоненты время. Разделённое время сохраняется в структуре I<tm> и указатель на неё возвращается в качестве результата. Структура I<tm> находится в статической области и, таким образом, будет перезаписана при следующих вызовах B<getdate>()."

#. type: Plain text
#: man-pages/man3/getdate.3:90
msgid ""
"In contrast to B<strptime>(3), (which has a I<format> argument), "
"B<getdate>()  uses the formats found in the file whose full pathname is "
"given in the environment variable B<DATEMSK>.  The first line in the file "
"that matches the given input string is used for the conversion."
msgstr "В отличие от B<strptime>(3), (которая имеет аргумент I<format>), функция B<getdate>() использует форматы, содержащиеся в файле, полный путь к которому содержится в переменной окружения B<DATEMSK>. Первая строка файла, которая совпадает с полученной входной строкой, будет использована для преобразования."

#. type: Plain text
#: man-pages/man3/getdate.3:94
msgid ""
"The matching is done case insensitively.  Superfluous whitespace, either in "
"the pattern or in the string to be converted, is ignored."
msgstr "Проверка на совпадение производится без учета регистра. Лишние пробелы как в шаблоне, так и в преобразуемой строке игнорируются."

#. type: Plain text
#: man-pages/man3/getdate.3:98
msgid ""
"The conversion specifications that a pattern can contain are those given for"
" B<strptime>(3).  One more conversion specification is specified in "
"POSIX.1-2001:"
msgstr "Описатели преобразования, которые могут быть указаны в шаблоне, соответствуют используемым в B<strptime>(3). Кроме того, понимается ещё один описатель POSIX.1-2001:"

#. type: TP
#: man-pages/man3/getdate.3:98
#, no-wrap
msgid "B<%Z>"
msgstr "B<%Z>"

#.  FIXME Is it (still) true that %Z is not supported in glibc?
#.  Looking at the glibc 2.21 source code, where the implementation uses
#.  strptime(), suggests that it might be supported.
#. type: Plain text
#: man-pages/man3/getdate.3:105
msgid "Timezone name.  This is not implemented in glibc."
msgstr "Имя часового пояса. Не реализован в glibc."

#. type: Plain text
#: man-pages/man3/getdate.3:114
msgid ""
"When B<%Z> is given, the structure containing the broken-down time is "
"initialized with values corresponding to the current time in the given "
"timezone.  Otherwise, the structure is initialized to the broken-down time "
"corresponding to the current local time (as by a call to B<localtime>(3))."
msgstr "Если указан B<%Z>, то структура с разделённым временем инициализируется значениями в соответствие с текущим временем указанного часового пояса. В противном случае, структура инициализируется разделённым временем в соответствии с текущим местным временем (как при вызове B<localtime>(3))."

#. type: Plain text
#: man-pages/man3/getdate.3:118
msgid ""
"When only the day of the week is given, the day is taken to be the first "
"such day on or after today."
msgstr "Если указан только день недели, то берётся ближайший день или завтрашний."

#. type: Plain text
#: man-pages/man3/getdate.3:122
msgid ""
"When only the month is given (and no year), the month is taken to be the "
"first such month equal to or after the current month.  If no day is given, "
"it is the first day of the month."
msgstr "Если указан только месяц (и не указан год), то берётся первый месяц, эквивалентный заданному, или следующий. Если не указан день, то это будет первый день месяца."

#. type: Plain text
#: man-pages/man3/getdate.3:125
msgid ""
"When no hour, minute and second are given, the current hour, minute and "
"second are taken."
msgstr "Если не указаны часы, минуты и секунды, то берётся текущий час, минута и секунда."

#. type: Plain text
#: man-pages/man3/getdate.3:128
msgid ""
"If no date is given, but we know the hour, then that hour is taken to be the"
" first such hour equal to or after the current hour."
msgstr "Если не указана дата, но мы знаем час, то будет взят первый час, равный заданному, начиная с текущего часа."

#. type: Plain text
#: man-pages/man3/getdate.3:138
msgid ""
"B<getdate_r>()  is a GNU extension that provides a reentrant version of "
"B<getdate>().  Rather than using a global variable to report errors and a "
"static buffer to return the broken down time, it returns errors via the "
"function result value, and returns the resulting broken-down time in the "
"caller-allocated buffer pointed to by the argument I<res>."
msgstr "Функция B<getdate_r>() является расширением GNU и предоставляет реентерабельную версию B<getdate>(). Она не использует глобальную переменную для сообщения об ошибках и статический буфер для возвращаемого разделённого времени, она возвращает ошибки как результат функции, а разделённое время возвращается в выделенном вызывающем буфере, на который указывает аргумент I<res>."

#. type: Plain text
#: man-pages/man3/getdate.3:149
msgid ""
"When successful, B<getdate>()  returns a pointer to a I<struct tm>.  "
"Otherwise, it returns NULL and sets the global variable I<getdate_err> to "
"one of the error numbers shown below.  Changes to I<errno> are unspecified."
msgstr "При успешном выполнении B<getdate>() возвращает указатель на I<struct tm>. В противном случае возвращается NULL, а глобальная переменная I<getdate_err> содержит один из номеров ошибок, перечисленных ниже. Изменения I<errno> не определены."

#. type: Plain text
#: man-pages/man3/getdate.3:154
msgid ""
"On success B<getdate_r>()  returns 0; on error it returns one of the error "
"numbers shown below."
msgstr "При успешном выполнении B<getdate_r>() возвращает 0; при ошибке возвращается одно из значений ошибки, перечисленных далее."

#. type: Plain text
#: man-pages/man3/getdate.3:161
msgid ""
"The following errors are returned via I<getdate_err> (for B<getdate>())  or "
"as the function result (for B<getdate_r>()):"
msgstr "Следующие ошибки возвращаются в I<getdate_err> (для B<getdate>()) или как результат функции (для B<getdate_r>()):"

#. type: Plain text
#: man-pages/man3/getdate.3:166
msgid ""
"The B<DATEMSK> environment variable is not defined, or its value is an empty"
" string."
msgstr "Переменная окружения B<DATEMSK> не определена или её значение — пустая строка."

#. type: Plain text
#: man-pages/man3/getdate.3:171
msgid ""
"The template file specified by B<DATEMSK> cannot be opened for reading."
msgstr "Файл шаблонов, заданный  B<DATEMSK>, не может быть открыт на чтение."

#.  stat()
#. type: Plain text
#: man-pages/man3/getdate.3:175
msgid "Failed to get file status information."
msgstr "Не удалось получить информацию о состоянии файла."

#. type: TP
#: man-pages/man3/getdate.3:175
#, no-wrap
msgid "B<4>"
msgstr "B<4>"

#. type: Plain text
#: man-pages/man3/getdate.3:178
msgid "The template file is not a regular file."
msgstr "Файл шаблонов не является обычным файлом."

#. type: TP
#: man-pages/man3/getdate.3:178
#, no-wrap
msgid "B<5>"
msgstr "B<5>"

#. type: Plain text
#: man-pages/man3/getdate.3:181
msgid "An error was encountered while reading the template file."
msgstr "Произошла ошибка при чтении файла шаблонов."

#. type: TP
#: man-pages/man3/getdate.3:181
#, no-wrap
msgid "B<6>"
msgstr "B<6>"

#.  Error 6 doesn't seem to occur in glibc
#. type: Plain text
#: man-pages/man3/getdate.3:185
msgid "Memory allocation failed (not enough memory available)."
msgstr "Не удалось выделить память (недостаточно памяти)."

#. type: TP
#: man-pages/man3/getdate.3:185
#, no-wrap
msgid "B<7>"
msgstr "B<7>"

#. type: Plain text
#: man-pages/man3/getdate.3:188
msgid "There is no line in the file that matches the input."
msgstr "В файле нет строки, совпавшей с входной."

#. type: TP
#: man-pages/man3/getdate.3:188
#, no-wrap
msgid "B<8>"
msgstr "B<8>"

#. type: Plain text
#: man-pages/man3/getdate.3:191
msgid "Invalid input specification."
msgstr "Неверный формат входной строки."

#. type: SH
#: man-pages/man3/getdate.3:191
#, no-wrap
msgid "ENVIRONMENT"
msgstr "ОКРУЖЕНИЕ"

#. type: TP
#: man-pages/man3/getdate.3:192
#, no-wrap
msgid "B<DATEMSK>"
msgstr "B<DATEMSK>"

#. type: Plain text
#: man-pages/man3/getdate.3:195
msgid "File containing format patterns."
msgstr "Файл, содержащий шаблоны форматирования."

#. type: TP
#: man-pages/man3/getdate.3:195
#, no-wrap
msgid "B<TZ>, B<LC_TIME>"
msgstr "B<TZ>, B<LC_TIME>"

#. type: Plain text
#: man-pages/man3/getdate.3:199
msgid "Variables used by B<strptime>(3)."
msgstr "Переменные, используемые B<strptime>(3)."

#. type: tbl table
#: man-pages/man3/getdate.3:209
#, no-wrap
msgid "B<getdate>()"
msgstr "B<getdate>()"

#. type: tbl table
#: man-pages/man3/getdate.3:209
#, no-wrap
msgid "MT-Unsafe race:getdate env locale"
msgstr "MT-Unsafe race:getdate env locale"

#. type: tbl table
#: man-pages/man3/getdate.3:212
#, no-wrap
msgid "B<getdate_r>()"
msgstr "B<getdate_r>()"

#. type: Plain text
#: man-pages/man3/getdate.3:216
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/getdate.3:230
msgid ""
"The POSIX.1 specification for B<strptime>(3)  contains conversion "
"specifications using the B<%E> or B<%O> modifier, while such specifications "
"are not given for B<getdate>().  In glibc, B<getdate>()  is implemented "
"using B<strptime>(3), so that precisely the same conversions are supported "
"by both."
msgstr "В описании POSIX.1 для B<strptime>(3) содержится преобразуемые описатели использующие модификатор B<%E> или B<%O>, хотя эти описатели не указаны для B<getdate>(). В glibc, B<getdate>() реализована посредством B<strptime>(3), таким образом поддерживаются все возможные описатели."

#. type: Plain text
#: man-pages/man3/getdate.3:238
msgid ""
"The program below calls B<getdate>()  for each of its command-line "
"arguments, and for each call displays the values in the fields of the "
"returned I<tm> structure.  The following shell session demonstrates the "
"operation of the program:"
msgstr "Программа, представленная далее, вызывает B<getdate>() для каждого своего аргумента командной строки и при каждом вызове печатаются значения полей полученной структуры I<tm>. Следующий сеанс показывает работу программы:"

#. type: Plain text
#: man-pages/man3/getdate.3:279
#, no-wrap
msgid ""
"$B< TFILE=$PWD/tfile>\n"
"$B< echo \\(aq%A\\(aq E<gt> $TFILE >      # Full name of the day of the week\n"
"$B< echo \\(aq%T\\(aq E<gt>E<gt> $TFILE>      # ISO date (YYYY-MM-DD)\n"
"$B< echo \\(aq%F\\(aq E<gt>E<gt> $TFILE>      # Time (HH:MM:SS)\n"
"$B< date>\n"
"$B< export DATEMSK=$TFILE>\n"
"$B< ./a.out Tuesday \\(aq2009-12-28\\(aq \\(aq12:22:33\\(aq>\n"
"Sun Sep  7 06:03:36 CEST 2008\n"
"Call 1 (\"Tuesday\") succeeded:\n"
"    tm_sec   = 36\n"
"    tm_min   = 3\n"
"    tm_hour  = 6\n"
"    tm_mday  = 9\n"
"    tm_mon   = 8\n"
"    tm_year  = 108\n"
"    tm_wday  = 2\n"
"    tm_yday  = 252\n"
"    tm_isdst = 1\n"
"Call 2 (\"2009-12-28\") succeeded:\n"
"    tm_sec   = 36\n"
"    tm_min   = 3\n"
"    tm_hour  = 6\n"
"    tm_mday  = 28\n"
"    tm_mon   = 11\n"
"    tm_year  = 109\n"
"    tm_wday  = 1\n"
"    tm_yday  = 361\n"
"    tm_isdst = 0\n"
"Call 3 (\"12:22:33\") succeeded:\n"
"    tm_sec   = 33\n"
"    tm_min   = 22\n"
"    tm_hour  = 12\n"
"    tm_mday  = 7\n"
"    tm_mon   = 8\n"
"    tm_year  = 108\n"
"    tm_wday  = 0\n"
"    tm_yday  = 250\n"
"    tm_isdst = 1\n"
msgstr "$B< TFILE=$PWD/tfile>\n$B< echo \\(aq%A\\(aq E<gt> $TFILE >      # полное название дня недели\n$B< echo \\(aq%T\\(aq E<gt>E<gt> $TFILE>      # дата ISO (YYYY-MM-DD)\n$B< echo \\(aq%F\\(aq E<gt>E<gt> $TFILE>      # время (HH:MM:SS)\n$B< date>\n$B< export DATEMSK=$TFILE>\n$B< ./a.out Tuesday \\(aq2009-12-28\\(aq \\(aq12:22:33\\(aq>\nSun Sep  7 06:03:36 CEST 2008\nCall 1 (\"Tuesday\"):\n    tm_sec   = 36\n    tm_min   = 3\n    tm_hour  = 6\n    tm_mday  = 9\n    tm_mon   = 8\n    tm_year  = 108\n    tm_wday  = 2\n    tm_yday  = 252\n    tm_isdst = 1\nCall 2 (\"2009-12-28\"):\n    tm_sec   = 36\n    tm_min   = 3\n    tm_hour  = 6\n    tm_mday  = 28\n    tm_mon   = 11\n    tm_year  = 109\n    tm_wday  = 1\n    tm_yday  = 361\n    tm_isdst = 0\nCall 3 (\"12:22:33\"):\n    tm_sec   = 33\n    tm_min   = 22\n    tm_hour  = 12\n    tm_mday  = 7\n    tm_mon   = 8\n    tm_year  = 108\n    tm_wday  = 0\n    tm_yday  = 250\n    tm_isdst = 1\n"

#. type: Plain text
#: man-pages/man3/getdate.3:288
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>time.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getdate.3:294
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct tm *tmp;\n"
"    int j;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct tm *tmp;\n    int j;\n"

#. type: Plain text
#: man-pages/man3/getdate.3:297
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++) {\n"
"        tmp = getdate(argv[j]);\n"
msgstr "    for (j = 1; j E<lt> argc; j++) {\n        tmp = getdate(argv[j]);\n"

#. type: Plain text
#: man-pages/man3/getdate.3:303
#, no-wrap
msgid ""
"        if (tmp == NULL) {\n"
"            printf(\"Call %d failed; getdate_err = %d\\en\",\n"
"                   j, getdate_err);\n"
"            continue;\n"
"        }\n"
msgstr "        if (tmp == NULL) {\n            printf(\"Ошибка вызова %d; getdate_err = %d\\en\",\n                   j, getdate_err);\n            continue;\n        }\n"

#. type: Plain text
#: man-pages/man3/getdate.3:315
#, no-wrap
msgid ""
"        printf(\"Call %d (\\e\"%s\\e\") succeeded:\\en\", j, argv[j]);\n"
"        printf(\"    tm_sec   = %d\\en\", tmp-E<gt>tm_sec);\n"
"        printf(\"    tm_min   = %d\\en\", tmp-E<gt>tm_min);\n"
"        printf(\"    tm_hour  = %d\\en\", tmp-E<gt>tm_hour);\n"
"        printf(\"    tm_mday  = %d\\en\", tmp-E<gt>tm_mday);\n"
"        printf(\"    tm_mon   = %d\\en\", tmp-E<gt>tm_mon);\n"
"        printf(\"    tm_year  = %d\\en\", tmp-E<gt>tm_year);\n"
"        printf(\"    tm_wday  = %d\\en\", tmp-E<gt>tm_wday);\n"
"        printf(\"    tm_yday  = %d\\en\", tmp-E<gt>tm_yday);\n"
"        printf(\"    tm_isdst = %d\\en\", tmp-E<gt>tm_isdst);\n"
"    }\n"
msgstr "        printf(\"Вызов %d (\\e\"%s\\e\"):\\en\", j, argv[j]);\n        printf(\"    tm_sec   = %d\\en\", tmp-E<gt>tm_sec);\n        printf(\"    tm_min   = %d\\en\", tmp-E<gt>tm_min);\n        printf(\"    tm_hour  = %d\\en\", tmp-E<gt>tm_hour);\n        printf(\"    tm_mday  = %d\\en\", tmp-E<gt>tm_mday);\n        printf(\"    tm_mon   = %d\\en\", tmp-E<gt>tm_mon);\n        printf(\"    tm_year  = %d\\en\", tmp-E<gt>tm_year);\n        printf(\"    tm_wday  = %d\\en\", tmp-E<gt>tm_wday);\n        printf(\"    tm_yday  = %d\\en\", tmp-E<gt>tm_yday);\n        printf(\"    tm_isdst = %d\\en\", tmp-E<gt>tm_isdst);\n    }\n"

#. type: Plain text
#: man-pages/man3/getdate.3:324
msgid ""
"B<time>(2), B<localtime>(3), B<setlocale>(3), B<strftime>(3), B<strptime>(3)"
msgstr "B<time>(2), B<localtime>(3), B<setlocale>(3), B<strftime>(3), B<strptime>(3)"

#. type: TH
#: man-pages/man3/getopt.3:41
#, no-wrap
msgid "GETOPT"
msgstr "GETOPT"

#. type: Plain text
#: man-pages/man3/getopt.3:45
msgid ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - "
"Parse command-line options"
msgstr "getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - разбираю параметры командной строки"

#. type: Plain text
#: man-pages/man3/getopt.3:48
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:51
#, no-wrap
msgid ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"
msgstr "B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\nB<           const char *>I<optstring>B<);>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:54
#, no-wrap
msgid ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"
msgstr "B<extern char *>I<optarg>B<;>\nB<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:56
#, no-wrap
msgid "B<#include E<lt>getopt.hE<gt>>\n"
msgstr "B<#include E<lt>getopt.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:60
#, no-wrap
msgid ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr "B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\nB<           const char *>I<optstring>B<,>\nB<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:64
#, no-wrap
msgid ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr "B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\nB<           const char *>I<optstring>B<,>\nB<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:74
msgid "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"

#. type: Plain text
#: man-pages/man3/getopt.3:78
msgid "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"
msgstr "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getopt.3:99
msgid ""
"The B<getopt>()  function parses the command-line arguments.  Its arguments "
"I<argc> and I<argv> are the argument count and array as passed to the "
"I<main>()  function on program invocation.  An element of I<argv> that "
"starts with \\(aq-\\(aq (and is not exactly \"-\" or \"--\")  is an option "
"element.  The characters of this element (aside from the initial "
"\\(aq-\\(aq) are option characters.  If B<getopt>()  is called repeatedly, "
"it returns successively each of the option characters from each of the "
"option elements."
msgstr "Функция B<getopt>() разбирает аргументы командной строки. Её аргументы I<argc> и I<argv> являются счётчиком и массивом аргументов, которые передаются функции I<main>() при запуске программы. Элемент I<argv>, начинающийся с «-» (и не являющийся «-» или «--»), считается параметром. Символы этого элемента (не считая начального «-») являются символами параметра. При каждом повторном вызове B<getopt>() возвращают следующий символ параметра и так для каждого следующего параметра."

#. type: Plain text
#: man-pages/man3/getopt.3:108
msgid ""
"The variable I<optind> is the index of the next element to be processed in "
"I<argv>.  The system initializes this value to 1.  The caller can reset it "
"to 1 to restart scanning of the same I<argv>, or when scanning a new "
"argument vector."
msgstr "Переменная I<optind> — это индекс следующего обрабатываемого элемента I<argv>. Система инициализирует это значение 1. Вызывающий может сбросить его в 1 для перезапуска сканирования того же I<argv>, или при сканировании нового вектора аргументов."

#. type: Plain text
#: man-pages/man3/getopt.3:118
msgid ""
"If B<getopt>()  finds another option character, it returns that character, "
"updating the external variable I<optind> and a static variable I<nextchar> "
"so that the next call to B<getopt>()  can resume the scan with the following"
" option character or I<argv>-element."
msgstr "Если B<getopt>() встречает символ другого параметра, она возвращает этот символ, обновляя внешнюю переменную I<optind> и статическую переменную I<nextchar>, так что следующий вызов B<getopt>() может продолжить проверку с символа следующего параметра или элемента I<argv>."

#. type: Plain text
#: man-pages/man3/getopt.3:124
msgid ""
"If there are no more option characters, B<getopt>()  returns -1.  Then "
"I<optind> is the index in I<argv> of the first I<argv>-element that is not "
"an option."
msgstr "Если символов параметров больше нет, то B<getopt>() возвращает -1. При этом I<optind> станет индексом первого элемента I<argv>, не являющегося параметром."

#. type: Plain text
#: man-pages/man3/getopt.3:151
msgid ""
"I<optstring> is a string containing the legitimate option characters.  If "
"such a character is followed by a colon, the option requires an argument, so"
" B<getopt>()  places a pointer to the following text in the same "
"I<argv>-element, or the text of the following I<argv>-element, in I<optarg>."
"  Two colons mean an option takes an optional arg; if there is text in the "
"current I<argv>-element (i.e., in the same word as the option name itself, "
"for example, \"-oarg\"), then it is returned in I<optarg>, otherwise "
"I<optarg> is set to zero.  This is a GNU extension.  If I<optstring> "
"contains B<W> followed by a semicolon, then B<-W foo> is treated as the long"
" option B<--foo>.  (The B<-W> option is reserved by POSIX.2 for "
"implementation extensions.)  This behavior is a GNU extension, not available"
" with libraries before glibc 2."
msgstr "Аргумент I<optstring> является строкой, содержащей допустимые символы параметров. Если за таким символом стоит двоеточие, то параметр требует указания аргумента. При этом B<getopt>() помещает указатель на следующий за символом параметра текст в тот же элемент I<argv>, или на текст следующего элемента I<argv> в I<optarg>. Два двоеточия означают, что параметр имеет необязательный аргумент; если текущий элемент I<argv> содержит текст (то есть в самом имени слова, например «-oarg»), то он возвращается в I<optarg>, в противном случае I<optarg> содержит ноль. Это является расширением GNU. Если I<optstring> содержит B<W>, за которой следует точка с запятой, то B<-W foo> рассматривается как длинный параметр B<--foo> (параметр B<-W> зарезервирован POSIX.2 для реализации расширений). Такое поведение является расширением GNU и недоступно в библиотеках до glibc 2."

#. type: Plain text
#: man-pages/man3/getopt.3:169
msgid ""
"By default, B<getopt>()  permutes the contents of I<argv> as it scans, so "
"that eventually all the nonoptions are at the end.  Two other modes are also"
" implemented.  If the first character of I<optstring> is \\(aq+\\(aq or the "
"environment variable B<POSIXLY_CORRECT> is set, then option processing stops"
" as soon as a nonoption argument is encountered.  If the first character of "
"I<optstring> is \\(aq-\\(aq, then each nonoption I<argv>-element is handled "
"as if it were the argument of an option with character code 1.  (This is "
"used by programs that were written to expect options and other "
"I<argv>-elements in any order and that care about the ordering of the two.)"
"  The special argument \"--\" forces an end of option-scanning regardless of"
" the scanning mode."
msgstr "По умолчанию B<getopt>() переставляет элементы содержимого I<argv> в процессе поиска, так что в конечном счёте все аргументы, не являющиеся параметрами, оказываются в конце. Реализованы также два других режима. Если первым символом I<optstring> является «+» или задана переменная окружения B<POSIXLY_CORRECT>, то обработка параметров прерывается сразу, как только находится символ не параметра. Если первым символом I<optstring> является «-», то каждый элемент I<argv>, не являющийся параметром, обрабатывается так, как если бы он был аргументом параметра с символом, имеющим код 1 (это используется программами, которые требуют параметры и другие элементы I<argv> в любом порядке и их порядок важен). Специальный аргумент «--» служит для обозначения конца параметров независимо от режима."

#. type: Plain text
#: man-pages/man3/getopt.3:178
msgid ""
"While processing the option list, B<getopt>()  can detect two kinds of "
"errors: (1) an option character that was not specified in I<optstring> and "
"(2) a missing option argument (i.e., an option at the end of the command "
"line without an expected argument).  Such errors are handled and reported as"
" follows:"
msgstr "При обработке списка параметров B<getopt>() может определить два типа ошибок: (1) — символ параметра, не заданный в I<optstring> и (2) — отсутствующий аргумент параметра (т. е., параметра в конце командной строки без ожидаемого аргумента). Эти ошибки обрабатываются и о них сообщается следующем образом:"

#. type: Plain text
#: man-pages/man3/getopt.3:185
msgid ""
"By default, B<getopt>()  prints an error message on standard error, places "
"the erroneous option character in I<optopt>, and returns \\(aq?\\(aq as the "
"function result."
msgstr "По умолчанию, B<getopt>() печатает сообщение об ошибке в стандартный поток ошибок, помещает ошибочный символ параметра в I<optopt> и возвращает \\(aq?\\(aq как результат функции."

#. type: Plain text
#: man-pages/man3/getopt.3:196
msgid ""
"If the caller has set the global variable I<opterr> to zero, then "
"B<getopt>()  does not print an error message.  The caller can determine that"
" there was an error by testing whether the function return value is "
"\\(aq?\\(aq.  (By default, I<opterr> has a nonzero value.)"
msgstr "Если вызывающий присвоил глобальной переменной I<opterr> значение 0, то B<getopt>() не печатает сообщение об ошибке. Вызывающий может определить, что произошла ошибка, сравнив возвращаемое значение функции с \\(aq?\\(aq (по умолчанию I<opterr> имеет ненулевое значение)."

#. type: Plain text
#: man-pages/man3/getopt.3:207
msgid ""
"If the first character (following any optional \\(aq+\\(aq or \\(aq-\\(aq "
"described above)  of I<optstring> is a colon (\\(aq:\\(aq), then B<getopt>()"
"  likewise does not print an error message.  In addition, it returns "
"\\(aq:\\(aq instead of \\(aq?\\(aq to indicate a missing option argument.  "
"This allows the caller to distinguish the two different types of errors."
msgstr "Если первый символ (после необязательных \\(aq+\\(aq или \\(aq-\\(aq, описанных выше) I<optstring> — двоеточие (\\(aq:\\(aq), то B<getopt>() также не печатает сообщение об ошибке. При этом возвращается \\(aq:\\(aq вместо \\(aq?\\(aq, что показывает отсутствие аргумента параметра. Это позволяет вызывающему отличить один тип ошибок от другого."

#. type: SS
#: man-pages/man3/getopt.3:207
#, no-wrap
msgid "getopt_long() and getopt_long_only()"
msgstr "getopt_long() и getopt_long_only()"

#. type: Plain text
#: man-pages/man3/getopt.3:223
msgid ""
"The B<getopt_long>()  function works like B<getopt>()  except that it also "
"accepts long options, started with two dashes.  (If the program accepts only"
" long options, then I<optstring> should be specified as an empty string "
"(\"\"), not NULL.)  Long option names may be abbreviated if the abbreviation"
" is unique or is an exact match for some defined option.  A long option may "
"take a parameter, of the form B<--arg=param> or B<--arg param>."
msgstr "Функция B<getopt_long>() работает так же, как B<getopt>(), за исключением того, что она воспринимает и длинные параметры, начинающиеся с двух дефисов (если программа принимает только длинные параметры, то значение I<optstring> должно быть равно пустой строке (\"\"), не NULL). Длинные параметры можно сокращать, если сокращение сохраняет уникальность параметра или полностью совпадает с одним из определённых параметров. Длинный параметр может иметь значение вида B<--параметр=значение> или B<--параметр значение>."

#. type: Plain text
#: man-pages/man3/getopt.3:230
msgid ""
"I<longopts> is a pointer to the first element of an array of I<struct "
"option> declared in I<E<lt>getopt.hE<gt>> as"
msgstr "Аргумент I<longopts> является указателем на первый элемент массива структур I<struct option>, объявленного в I<E<lt>getopt.hE<gt>> следующим образом"

#. type: Plain text
#: man-pages/man3/getopt.3:239
#, no-wrap
msgid ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"
msgstr "struct option {\n    const char *name;\n    int         has_arg;\n    int        *flag;\n    int         val;\n};\n"

#. type: Plain text
#: man-pages/man3/getopt.3:243
msgid "The meanings of the different fields are:"
msgstr "Значения различных полей:"

#. type: TP
#: man-pages/man3/getopt.3:243
#, no-wrap
msgid "I<name>"
msgstr "I<name>"

#. type: Plain text
#: man-pages/man3/getopt.3:246
msgid "is the name of the long option."
msgstr "имя длинного параметра"

#. type: TP
#: man-pages/man3/getopt.3:246
#, no-wrap
msgid "I<has_arg>"
msgstr "I<has_arg>"

#. type: Plain text
#: man-pages/man3/getopt.3:252
msgid ""
"is: B<no_argument> (or 0) if the option does not take an argument; "
"B<required_argument> (or 1) if the option requires an argument; or "
"B<optional_argument> (or 2) if the option takes an optional argument."
msgstr "может быть: B<no_argument> (или 0), если параметр не требует значения; B<required_argument> (или 1), если параметр требует значения; B<optional_argument> (или 2), если параметр может иметь необязательное значение."

#. type: TP
#: man-pages/man3/getopt.3:252
#, no-wrap
msgid "I<flag>"
msgstr "I<flag>"

#. type: Plain text
#: man-pages/man3/getopt.3:266
msgid ""
"specifies how results are returned for a long option.  If I<flag> is NULL, "
"then B<getopt_long>()  returns I<val>.  (For example, the calling program "
"may set I<val> to the equivalent short option character.)  Otherwise, "
"B<getopt_long>()  returns 0, and I<flag> points to a variable which is set "
"to I<val> if the option is found, but left unchanged if the option is not "
"found."
msgstr "способ возвращения результатов для длинного параметра. Если I<flag> равен NULL, то B<getopt_long>() возвращает I<val> (например, вызывающая программа может назначить I<val> эквивалентом символа короткого параметра). В противном случае B<getopt_long>() возвращает 0, а I<flag> указывает на переменную, устанавливаемое значение которой равно I<val>, если параметр найден; и оставляемую без изменений, если параметр не найден."

#. type: TP
#: man-pages/man3/getopt.3:266
#, no-wrap
msgid "I<val>"
msgstr "I<val>"

#. type: Plain text
#: man-pages/man3/getopt.3:270
msgid ""
"is the value to return, or to load into the variable pointed to by I<flag>."
msgstr "значение, которое возвращается или загружается в переменную, на которую указывает I<flag>."

#. type: Plain text
#: man-pages/man3/getopt.3:272
msgid "The last element of the array has to be filled with zeros."
msgstr "Последний элемент массива должен быть заполнен нулями."

#. type: Plain text
#: man-pages/man3/getopt.3:276
msgid ""
"If I<longindex> is not NULL, it points to a variable which is set to the "
"index of the long option relative to I<longopts>."
msgstr "Если I<longindex> не равен NULL, то он указывает на переменную, содержащую индекс длинного параметра в соответствии с I<longopts>."

#. type: Plain text
#: man-pages/man3/getopt.3:285
msgid ""
"B<getopt_long_only>()  is like B<getopt_long>(), but \\(aq-\\(aq as well as "
"\"--\" can indicate a long option.  If an option that starts with "
"\\(aq-\\(aq (not \"--\") doesn't match a long option, but does match a short"
" option, it is parsed as a short option instead."
msgstr "Функция B<getopt_long_only>() работает так же, как B<getopt_long>(), но в качестве указателя длинного параметра может служить не только «--», но и «-». Если параметр, начинающийся с «-» (не с «--»), не совпадает с длинным параметром, но совпадает с коротким, то он обрабатывается как короткий параметр."

#. type: Plain text
#: man-pages/man3/getopt.3:303
msgid ""
"If an option was successfully found, then B<getopt>()  returns the option "
"character.  If all command-line options have been parsed, then B<getopt>()  "
"returns -1.  If B<getopt>()  encounters an option character that was not in "
"I<optstring>, then \\(aq?\\(aq is returned.  If B<getopt>()  encounters an "
"option with a missing argument, then the return value depends on the first "
"character in I<optstring>: if it is \\(aq:\\(aq, then \\(aq:\\(aq is "
"returned; otherwise \\(aq?\\(aq is returned."
msgstr "Если параметр найден, то B<getopt>() возвращает символ параметра. Если все параметры командной строки обработаны, то B<getopt>() возвращает -1. Если B<getopt>() находит символ, которого нет в I<optstring>, то возвращается «?». Если B<getopt>() находит символ с отсутствующим аргументом, то возвращаемое значение зависит от первого символа I<optstring>: если это «:», то возвращается «:», в противном случае возвращается «?»."

#. type: Plain text
#: man-pages/man3/getopt.3:315
msgid ""
"B<getopt_long>()  and B<getopt_long_only>()  also return the option "
"character when a short option is recognized.  For a long option, they return"
" I<val> if I<flag> is NULL, and 0 otherwise.  Error and -1 returns are the "
"same as for B<getopt>(), plus \\(aq?\\(aq for an ambiguous match or an "
"extraneous parameter."
msgstr "Функции B<getopt_long>() и B<getopt_long_only>() также возвращают символ параметра, если распознан короткий параметр. Для длинного параметра они возвращают I<val>, если I<flag> равен NULL, и 0 в противном случае. Возвращаемые ошибки и -1 имеют то же значение, что и для B<getopt>(), кроме того, «?» возвращается при двусмысленном толковании параметра."

#. type: TP
#: man-pages/man3/getopt.3:316
#, no-wrap
msgid "B<POSIXLY_CORRECT>"
msgstr "B<POSIXLY_CORRECT>"

#. type: Plain text
#: man-pages/man3/getopt.3:320
msgid ""
"If this is set, then option processing stops as soon as a nonoption argument"
" is encountered."
msgstr "Если установлена эта переменная, то обработка параметров прерывается на первом аргументе, не являющемся параметром."

#. type: TP
#: man-pages/man3/getopt.3:320
#, no-wrap
msgid "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"
msgstr "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"

#. type: Plain text
#: man-pages/man3/getopt.3:329
msgid ""
"This variable was used by B<bash>(1)  2.0 to communicate to glibc which "
"arguments are the results of wildcard expansion and so should not be "
"considered as options.  This behavior was removed in B<bash>(1)  version "
"2.01, but the support remains in glibc."
msgstr "Эта переменная использовалась B<bash>(1) 2.0 для связи с glibc, аргументы которой являются результатом раскрытия шаблонов и, таким образом, не должны рассматриваться как параметры. Такое поведение было удалено из B<bash>(1) версии 2.01, но поддержка осталась в glibc."

#. type: tbl table
#: man-pages/man3/getopt.3:341
#, no-wrap
msgid ""
"B<getopt>(),\n"
"B<getopt_long>(),\n"
"B<getopt_long_only>()"
msgstr "B<getopt>(),\nB<getopt_long>(),\nB<getopt_long_only>()"

#. type: tbl table
#: man-pages/man3/getopt.3:341
#, no-wrap
msgid "MT-Unsafe race:getopt env"
msgstr "MT-Unsafe race:getopt env"

#. type: TP
#: man-pages/man3/getopt.3:344
#, no-wrap
msgid "B<getopt>():"
msgstr "B<getopt>():"

#. type: Plain text
#: man-pages/man3/getopt.3:356
msgid ""
"POSIX.1-2001, POSIX.1-2008, and POSIX.2, provided the environment variable "
"B<POSIXLY_CORRECT> is set.  Otherwise, the elements of I<argv> aren't really"
" I<const>, because we permute them.  We pretend they're I<const> in the "
"prototype to be compatible with other systems."
msgstr "В POSIX.1-2001, POSIX.1-2008 и POSIX.2 описана переменная окружения B<POSIXLY_CORRECT>. В противном случае элементы I<argv> на самом деле не являются I<const>, потому что мы изменяем их порядок. Мы будем считать их I<const> в прототипах для совместимости этих прототипов с другими операционными системами."

#. type: Plain text
#: man-pages/man3/getopt.3:360
msgid "The use of \\(aq+\\(aq and \\(aq-\\(aq in I<optstring> is a GNU extension."
msgstr "Использование «+» и «-» в I<optstring> является расширением GNU."

#. type: Plain text
#: man-pages/man3/getopt.3:374
msgid ""
"On some older implementations, B<getopt>()  was declared in "
"I<E<lt>stdio.hE<gt>>.  SUSv1 permitted the declaration to appear in either "
"I<E<lt>unistd.hE<gt>> or I<E<lt>stdio.hE<gt>>.  POSIX.1-1996 marked the use "
"of I<E<lt>stdio.hE<gt>> for this purpose as LEGACY.  POSIX.1-2001 does not "
"require the declaration to appear in I<E<lt>stdio.hE<gt>>."
msgstr "В некоторых старых реализациях B<getopt>() объявлялась в I<E<lt>stdio.hE<gt>>. В SUSv1 разрешено её объявлять в I<E<lt>unistd.hE<gt>> или I<E<lt>stdio.hE<gt>>. В POSIX.1-1996 отмечено, что использование I<E<lt>stdio.hE<gt>> УСТАРЕЛО. В POSIX.1-2001 не требуется объявлять эту функцию в I<E<lt>stdio.hE<gt>>."

#. type: TP
#: man-pages/man3/getopt.3:374
#, no-wrap
msgid "B<getopt_long>() and B<getopt_long_only>():"
msgstr "B<getopt_long>() и B<getopt_long_only>():"

#. type: Plain text
#: man-pages/man3/getopt.3:377
msgid "These functions are GNU extensions."
msgstr "Эти функции являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/getopt.3:396
msgid ""
"A program that scans multiple argument vectors, or rescans the same vector "
"more than once, and wants to make use of GNU extensions such as \\(aq+\\(aq "
"and \\(aq-\\(aq at the start of I<optstring>, or changes the value of "
"B<POSIXLY_CORRECT> between scans, must reinitialize B<getopt>()  by "
"resetting I<optind> to 0, rather than the traditional value of 1.  "
"(Resetting to 0 forces the invocation of an internal initialization routine "
"that rechecks B<POSIXLY_CORRECT> and checks for GNU extensions in "
"I<optstring>.)"
msgstr "В программе, где анализируется несколько векторов параметров, или разбирается один вектор более одного раза и нужно использовать расширения GNU «+» и «-» в начале I<optstring> или изменять значение B<POSIXLY_CORRECT> между разборами, должна повторно инициализировать B<getopt>() сбрасывая I<optind> в 0, а не в обычное значение 1 (сброс в 0 вызывает принудительный вызов внутренней процедуры, повторно проверяющей B<POSIXLY_CORRECT> и расширения GNU в I<optstring>)."

#. type: SS
#: man-pages/man3/getopt.3:397
#, no-wrap
msgid "getopt()"
msgstr "getopt()"

#. type: Plain text
#: man-pages/man3/getopt.3:405
msgid ""
"The following trivial example program uses B<getopt>()  to handle two "
"program options: I<-n>, with no associated value; and I<-t val>, which "
"expects an associated value."
msgstr "В приведённом ниже пример программы B<getopt>() используется два параметра программы: I<-n> без значения и I<-t значение> со значением."

#. type: Plain text
#: man-pages/man3/getopt.3:410
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:416
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int flags, opt;\n    int nsecs, tfnd;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:435
#, no-wrap
msgid ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr "    nsecs = 0;\n    tfnd = 0;\n    flags = 0;\n    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n        switch (opt) {\n        case \\(aqn\\(aq:\n            flags = 1;\n            break;\n        case \\(aqt\\(aq:\n            nsecs = atoi(optarg);\n            tfnd = 1;\n            break;\n        default: /* \\(aq?\\(aq */\n            fprintf(stderr, \"Использование: %s [-t nsecs] [-n] имя\\en\",\n                    argv[0]);\n            exit(EXIT_FAILURE);\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/getopt.3:438
#, no-wrap
msgid ""
"    printf(\"flags=%d; tfnd=%d; nsecs=%d; optind=%d\\en\",\n"
"            flags, tfnd, nsecs, optind);\n"
msgstr "    printf(\"flags=%d; tfnd=%d; nsecs=%d; optind=%d\\en\",\n            flags, tfnd, nsecs, optind);\n"

#. type: Plain text
#: man-pages/man3/getopt.3:443
#, no-wrap
msgid ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (optind E<gt>= argc) {\n        fprintf(stderr, \"После параметра требуется значение\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getopt.3:445
#, no-wrap
msgid "    printf(\"name argument = %s\\en\", argv[optind]);\n"
msgstr "    printf(\"параметр = %s\\en\", argv[optind]);\n"

#. type: Plain text
#: man-pages/man3/getopt.3:447
#, no-wrap
msgid "    /* Other code omitted */\n"
msgstr "    /* остальной код не показан */\n"

#. type: SS
#: man-pages/man3/getopt.3:451
#, no-wrap
msgid "getopt_long()"
msgstr "getopt_long()"

#. type: Plain text
#: man-pages/man3/getopt.3:455
msgid ""
"The following example program illustrates the use of B<getopt_long>()  with "
"most of its features."
msgstr "Приведённый ниже пример программы иллюстрирует использование большинства возможностей B<getopt_long>()."

#. type: Plain text
#: man-pages/man3/getopt.3:460
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>     /* для printf */\n#include E<lt>stdlib.hE<gt>    /* для exit */\n#include E<lt>getopt.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:466
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int c;\n"
"    int digit_optind = 0;\n"
msgstr "int\nmain(int argc, char **argv)\n{\n    int c;\n    int digit_optind = 0;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:479
#, no-wrap
msgid ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"
msgstr "    while (1) {\n        int this_option_optind = optind ? optind : 1;\n        int option_index = 0;\n        static struct option long_options[] = {\n            {\"add\",     required_argument, 0,  0 },\n            {\"append\",  no_argument,       0,  0 },\n            {\"delete\",  required_argument, 0,  0 },\n            {\"verbose\", no_argument,       0,  0 },\n            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n            {\"file\",    required_argument, 0,  0 },\n            {0,         0,                 0,  0 }\n        };\n"

#. type: Plain text
#: man-pages/man3/getopt.3:484
#, no-wrap
msgid ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"
msgstr "        c = getopt_long(argc, argv, \"abc:d:012\",\n                 long_options, &option_index);\n        if (c == -1)\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:492
#, no-wrap
msgid ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"
msgstr "        switch (c) {\n        case 0:\n            printf(\"параметр %s\", long_options[option_index].name);\n            if (optarg)\n                printf(\" со значением %s\", optarg);\n            printf(\"\\en\");\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:501
#, no-wrap
msgid ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"
msgstr "        case \\(aq0\\(aq:\n        case \\(aq1\\(aq:\n        case \\(aq2\\(aq:\n            if (digit_optind != 0 && digit_optind != this_option_optind)\n              printf(\"Встречена цифра в двух различных элементах argv.\\en\");\n            digit_optind = this_option_optind;\n            printf(\"параметр %c\\en\", c);\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:505
#, no-wrap
msgid ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"
msgstr "        case \\(aqa\\(aq:\n            printf(\"параметр a\\en\");\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:509
#, no-wrap
msgid ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"
msgstr "        case \\(aqb\\(aq:\n            printf(\"параметр b\\en\");\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:513
#, no-wrap
msgid ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr "        case \\(aqc\\(aq:\n            printf(\"параметр c со значением «%s»\\en\", optarg);\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:517
#, no-wrap
msgid ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr "        case \\(aqd\\(aq:\n            printf(\"параметр d со значением «%s»\\en\", optarg);\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:520
#, no-wrap
msgid ""
"        case \\(aq?\\(aq:\n"
"            break;\n"
msgstr "        case \\(aq?\\(aq:\n            break;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:525
#, no-wrap
msgid ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"
msgstr "        default:\n            printf(\"?? getopt вернула код символа 0%o ??\\en\", c);\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/getopt.3:532
#, no-wrap
msgid ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr "    if (optind E<lt> argc) {\n        printf(\"элементы ARGV не параметры: \");\n        while (optind E<lt> argc)\n            printf(\"%s \", argv[optind++]);\n        printf(\"\\en\");\n    }\n"

#. type: Plain text
#: man-pages/man3/getopt.3:538
msgid "B<getopt>(1), B<getsubopt>(3)"
msgstr "B<getopt>(1), B<getsubopt>(3)"

#. type: TH
#: man-pages/man3/getnetent_r.3:26
#, no-wrap
msgid "GETNETENT_R"
msgstr "GETNETENT_R"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:30
msgid ""
"getnetent_r, getnetbyname_r, getnetbyaddr_r - get network entry (reentrant)"
msgstr "getnetent_r, getnetbyname_r, getnetbyaddr_r - возвращают запись о сети (реентерабельные версии)"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:37
#, no-wrap
msgid ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr "B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\nB<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:42
#, no-wrap
msgid ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr "B<int getnetbyname_r(const char *>I<name>B<,>\nB<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\nB<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:47
#, no-wrap
msgid ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr "B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\nB<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\nB<                int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:62
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getnetent_r>(),\nB<getnetbyname_r>(),\nB<getnetbyaddr_r>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:80
msgid ""
"The B<getnetent_r>(), B<getnetbyname_r>(), and B<getnetbyaddr_r>()  "
"functions are the reentrant equivalents of, respectively, B<getnetent>(3), "
"B<getnetbyname>(3), and B<getnetbynumber>(3).  They differ in the way that "
"the I<netent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr "Функции B<getnetent_r>(), B<getnetbyname_r>() и B<getnetbyaddr_r>() являются реентерабельными эквивалентами B<getnetent>(3), B<getnetbyname>(3) и B<getnetbynumber>(3), соответственно. Они отличаются способом возврата структуры I<netent> и списком параметров и типом возвращаемого значения. В этой справочной странице описаны только различия с нереентерабельными функциями."

#. type: Plain text
#: man-pages/man3/getnetent_r.3:86
msgid ""
"Instead of returning a pointer to a statically allocated I<netent> structure"
" as the function result, these functions copy the structure into the "
"location pointed to by I<result_buf>."
msgstr "Вместо возврата указателя на статически выделенную структуру I<netent> в качестве результата эти функции копируют структуру в расположение, указанное I<result_buf>."

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getnetent_r.3:103
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<netent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr "Массив I<buf> используется для хранения строковых полей из возвращаемой структуры I<netent> (нереентерабельные функции выделяют эти строки из статического хранилища). Размер данного массива задаётся в I<buflen>. Если I<buf> слишком мал, то вызов завершается с ошибкой B<ERANGE>, вызывающий должен его повторить с большим буфером (для большинства приложений должно быть достаточно буфера длиной 1024 байт)."

#. type: Plain text
#: man-pages/man3/getnetent_r.3:111
msgid ""
"If the function call successfully obtains a network record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr "Если вызов получил запись о сети, то  I<*result> указывает на I<result_buf>; в противном случае I<*result> устанавливается в NULL."

#.  getnetent.3 doesn't document any use of h_errno, but nevertheless
#.  the nonreentrant functions no seem to set h_errno.
#. type: Plain text
#: man-pages/man3/getnetent_r.3:119
msgid ""
"The buffer pointed to by I<h_errnop> is used to return the value that would "
"be stored in the global variable I<h_errno> by the nonreentrant versions of "
"these functions."
msgstr "Буфер, указанный I<h_errnop>, используется для возврата значения, которое бы сохранилось в глобальной переменной I<h_errno> нереентерабельными версиями этих функций."

#. type: Plain text
#: man-pages/man3/getnetent_r.3:122
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr "При успешном выполнении эти функции возвращают 0. При ошибке возвращается одно из положительных значений, перечисленных В разделе ОШИБКИ."

#. type: Plain text
#: man-pages/man3/getnetent_r.3:130
msgid ""
"On error, record not found (B<getnetbyname_r>(), B<getnetbyaddr_r>()), or "
"end of input (B<getnetent_r>())  I<result> is set to NULL."
msgstr "При ошибке, отсутствии записи (B<getnetbyname_r>(), B<getnetbyaddr_r>()) или конце данных (B<getnetent_r>()) значение I<result> равно NULL."

#. type: Plain text
#: man-pages/man3/getnetent_r.3:135
msgid "(B<getnetent_r>())  No more records in database."
msgstr "(B<getnetent_r>()) Больше нет записей в базе данных."

#. type: tbl table
#: man-pages/man3/getnetent_r.3:155
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>()"
msgstr "B<getnetent_r>(),\nB<getnetbyname_r>(),\nB<getnetbyaddr_r>()"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:164
msgid "B<getnetent>(3), B<networks>(5)"
msgstr "B<getnetent>(3), B<networks>(5)"

#. type: TH
#: man-pages/man3/getmntent.3:32
#, no-wrap
msgid "GETMNTENT"
msgstr "GETMNTENT"

#. type: Plain text
#: man-pages/man3/getmntent.3:36
msgid ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - get "
"filesystem descriptor file entry"
msgstr "getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - возвращают запись из файла описания файловых систем"

#. type: Plain text
#: man-pages/man3/getmntent.3:40
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\nB<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:42
#, no-wrap
msgid ""
"B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:44
#, no-wrap
msgid "B<struct mntent *getmntent(FILE *>I<stream>B<);>\n"
msgstr "B<struct mntent *getmntent(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:46
#, no-wrap
msgid "B<int addmntent(FILE *>I<stream>B<, const struct mntent *>I<mnt>B<);>\n"
msgstr "B<int addmntent(FILE *>I<stream>B<, const struct mntent *>I<mnt>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:48
#, no-wrap
msgid "B<int endmntent(FILE *>I<streamp>B<);>\n"
msgstr "B<int endmntent(FILE *>I<streamp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:50
#, no-wrap
msgid ""
"B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"
msgstr "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:53
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr "/* Расширение GNU */\nB<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:56
#, no-wrap
msgid ""
"B<struct mntent *getmntent_r(FILE *>I<streamp>B<, struct mntent *>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr "B<struct mntent *getmntent_r(FILE *>I<streamp>B<, struct mntent *>I<mntbuf>B<,>\nB<                           char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:68
#, no-wrap
msgid ""
"B<getmntent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getmntent_r>(),\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:73
msgid ""
"These routines are used to access the filesystem description file "
"I</etc/fstab> and the mounted filesystem description file I</etc/mtab>."
msgstr "Эти функции используются для доступа к файлу описаний файловых систем I</etc/fstab> и к файлу описаний смонтированных файловых систем I</etc/mtab>."

#. type: Plain text
#: man-pages/man3/getmntent.3:91
msgid ""
"The B<setmntent>()  function opens the filesystem description file "
"I<filename> and returns a file pointer which can be used by B<getmntent>()."
"  The argument I<type> is the type of access required and can take the same "
"values as the I<mode> argument of B<fopen>(3).  The returned stream should "
"be closed using B<endmntent>()  rather than B<fclose>(3)."
msgstr "Функция B<setmntent>() открывает файл описаний файловых систем I<filename> и возвращает указатель на файл, который может быть использован B<getmntent>(). В аргументе I<type> указывается требуемый тип доступа и и могут задаваться те же значения, что и в аргументе I<mode> функции B<fclose>(3). Возвращаемый поток должен закрываться с помощью B<endmntent>(), а не B<fclose>(3)."

#. type: Plain text
#: man-pages/man3/getmntent.3:103
msgid ""
"The B<getmntent>()  function reads the next line of the filesystem "
"description file from I<stream> and returns a pointer to a structure "
"containing the broken out fields from a line in the file.  The pointer "
"points to a static area of memory which is overwritten by subsequent calls "
"to B<getmntent>()."
msgstr "Функция B<getmntent>() считывает следующую строку из файла описаний файловых систем I<stream> и возвращает указатель на структуру, содержащую поля строки файла. Указатель ссылается на статическую область памяти, которая перезаписывается последующими вызовами B<getmntent>()."

#. type: Plain text
#: man-pages/man3/getmntent.3:113
msgid ""
"The B<addmntent>()  function adds the I<mntent> structure I<mnt> to the end "
"of the open I<stream>."
msgstr "Функция B<addmntent>() добавляет структуру I<mnt> типа I<mntent> к концу открытого I<stream>."

#. type: Plain text
#: man-pages/man3/getmntent.3:119
msgid ""
"The B<endmntent>()  function closes the I<stream> associated with the "
"filesystem description file."
msgstr "Функция B<endmntent>() закрывает I<stream>, связанный с файл описаний файловых систем."

#. type: Plain text
#: man-pages/man3/getmntent.3:136
msgid ""
"The B<hasmntopt>()  function scans the I<mnt_opts> field (see below)  of the"
" I<mntent> structure I<mnt> for a substring that matches I<opt>.  See "
"I<E<lt>mntent.hE<gt>> and B<mount>(8)  for valid mount options."
msgstr "Функция B<hashmntopt>() ищет в полях I<mnt_opts> (смотрите ниже) структуры I<mnt> типа I<mntent> подстроку, совпадающую с I<opt>. Список возможных параметров монтирования приведён в I<E<lt>mntent.hE<gt>> и B<mount>(8)."

#. type: Plain text
#: man-pages/man3/getmntent.3:150
msgid ""
"The reentrant B<getmntent_r>()  function is similar to B<getmntent>(), but "
"stores the I<struct mount> in the provided I<*mntbuf> and stores the strings"
" pointed to by the entries in that struct in the provided array I<buf> of "
"size I<buflen>."
msgstr "Реентерабельная функция B<getmntent_r>() подобна B<getmntent>(), но сохраняет I<struct mount> в предоставляемом I<*mntbuf>, а строки элементов этой структуры — в предоставляемый массив I<buf> размера I<buflen>."

#. type: Plain text
#: man-pages/man3/getmntent.3:156
msgid ""
"The I<mntent> structure is defined in I<E<lt>mntent.hE<gt>> as follows:"
msgstr "Структура I<mntent> определена в I<E<lt>mntent.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/getmntent.3:167
#, no-wrap
msgid ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted filesystem */\n"
"    char *mnt_dir;      /* filesystem path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"
msgstr "struct mntent {\n    char *mnt_fsname;   /* название смонтированной файловой системы */\n    char *mnt_dir;      /* префикс пути к файловой системе */\n    char *mnt_type;     /* тип монтирования (смотрите mntent.h) */\n    char *mnt_opts;     /* параметры монтирования (смотрите mntent.h) */\n    int   mnt_freq;     /* периодичность запуска dump, в днях */\n    int   mnt_passno;   /* номер прохода при параллельном fsck */\n};\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:184
msgid ""
"Since fields in the mtab and fstab files are separated by whitespace, octal "
"escapes are used to represent the characters space (\\e040), tab (\\e011), "
"newline (\\e012), and backslash (\\e\\e) in those files when they occur in "
"one of the four strings in a I<mntent> structure.  The routines "
"B<addmntent>()  and B<getmntent>()  will convert from string representation "
"to escaped representation and back.  When converting from escaped "
"representation, the sequence \\e134 is also converted to a backslash."
msgstr "Так как поля в файлах mtab и fstab разделяются пробельными символами, то для их записи в одной из четырёх строках структуры I<mntent> используются их экранированные последовательности в восьмеричном коде: пробел (\\e040), табуляция (\\e011), новая строка (\\e012) и обратная косая черта (\\e\\e). Функции B<addmntent>() и B<getmntent>() выполнят преобразование экранированных строк и обратно. При преобразовании из экранированного представления, последовательность \\e134 также преобразуется в символ обратной косой черты."

#. type: Plain text
#: man-pages/man3/getmntent.3:193
msgid ""
"The B<getmntent>()  and B<getmntent_r>()  functions return a pointer to the "
"I<mntent> structure or NULL on failure."
msgstr "Функции B<getmntent>() и B<getmntent_r>() возвращают указатель на структуру типа I<mntent> или NULL при ошибке."

#. type: Plain text
#: man-pages/man3/getmntent.3:197
msgid "The B<addmntent>()  function returns 0 on success and 1 on failure."
msgstr "Функция B<addmntent>() возвращает 0 при успешном выполнении и 1 при ошибке."

#. type: Plain text
#: man-pages/man3/getmntent.3:201
msgid "The B<endmntent>()  function always returns 1."
msgstr "Функция B<endmntent>() всегда возвращает 1."

#. type: Plain text
#: man-pages/man3/getmntent.3:206
msgid ""
"The B<hasmntopt>()  function returns the address of the substring if a match"
" is found and NULL otherwise."
msgstr "Функция B<hasmntopt>() возвращает адрес подстроки, если она была найдена, в противном случае NULL."

#. type: TP
#: man-pages/man3/getmntent.3:207
#, no-wrap
msgid "I</etc/fstab>"
msgstr "I</etc/fstab>"

#. type: Plain text
#: man-pages/man3/getmntent.3:210
msgid "filesystem description file"
msgstr "файл описаний файловых систем"

#. type: TP
#: man-pages/man3/getmntent.3:210
#, no-wrap
msgid "I</etc/mtab>"
msgstr "I</etc/mtab>"

#. type: Plain text
#: man-pages/man3/getmntent.3:213
msgid "mounted filesystem description file"
msgstr "файл описаний смонтированных файловых систем"

#. type: tbl table
#: man-pages/man3/getmntent.3:226
#, no-wrap
msgid ""
"B<setmntent>(),\n"
"B<endmntent>(),\n"
"B<hasmntopt>()"
msgstr "B<setmntent>(),\nB<endmntent>(),\nB<hasmntopt>()"

#. type: tbl table
#: man-pages/man3/getmntent.3:229
#, no-wrap
msgid "B<getmntent>()"
msgstr "B<getmntent>()"

#. type: tbl table
#: man-pages/man3/getmntent.3:229
#, no-wrap
msgid "MT-Unsafe race:mntentbuf locale"
msgstr "MT-Unsafe race:mntentbuf locale"

#. type: tbl table
#: man-pages/man3/getmntent.3:232
#, no-wrap
msgid "B<addmntent>()"
msgstr "B<addmntent>()"

#. type: tbl table
#: man-pages/man3/getmntent.3:232
#, no-wrap
msgid "MT-Safe race:stream locale"
msgstr "MT-Safe race:stream locale"

#. type: tbl table
#: man-pages/man3/getmntent.3:235
#, no-wrap
msgid "B<getmntent_r>()"
msgstr "B<getmntent_r>()"

#. type: Plain text
#: man-pages/man3/getmntent.3:244
msgid ""
"The nonreentrant functions are from SunOS 4.1.3.  A routine B<getmntent_r>()"
"  was introduced in HP-UX 10, but it returns an int.  The prototype shown "
"above is glibc-only."
msgstr "Нереентерабельные функции появились из SunOS 4.1.3. Функция B<getmntent_r>() появилась из HP-UX 10, но она возвращает int. Показанный здесь прототип есть только в glibc."

#. type: Plain text
#: man-pages/man3/getmntent.3:256
msgid ""
"System V also has a B<getmntent>()  function but the calling sequence "
"differs, and the returned structure is different.  Under System V "
"I</etc/mnttab> is used.  4.4BSD and Digital UNIX have a routine "
"B<getmntinfo>(), a wrapper around the system call B<getfsstat>()."
msgstr "В System V также имеется функция B<getmntent>(), однако последовательность вызова и возвращаемая структура отличаются от остальных. В System V используется I</etc/mnttab>. В BSD 4.4 и Digital UNIX есть функция B<getmntinfo>(), обёртка над системным вызовом B<getfsstat>()."

#. type: Plain text
#: man-pages/man3/getmntent.3:259
msgid "B<fopen>(3), B<fstab>(5), B<mount>(8)"
msgstr "B<fopen>(3), B<fstab>(5), B<mount>(8)"

#. type: TH
#: man-pages/man3/getprotoent.3:30
#, no-wrap
msgid "GETPROTOENT"
msgstr "GETPROTOENT"

#. type: Plain text
#: man-pages/man3/getprotoent.3:34
msgid ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - "
"get protocol entry"
msgstr "getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - возвращают запись о протоколе"

#. type: Plain text
#: man-pages/man3/getprotoent.3:39
#, no-wrap
msgid "B<struct protoent *getprotoent(void);>\n"
msgstr "B<struct protoent *getprotoent(void);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:41
#, no-wrap
msgid "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"
msgstr "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:43
#, no-wrap
msgid "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"
msgstr "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:45
#, no-wrap
msgid "B<void setprotoent(int >I<stayopen>B<);>\n"
msgstr "B<void setprotoent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:47
#, no-wrap
msgid "B<void endprotoent(void);>\n"
msgstr "B<void endprotoent(void);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:58
msgid ""
"The B<getprotoent>()  function reads the next entry from the protocols "
"database (see B<protocols>(5))  and returns a I<protoent> structure "
"containing the broken-out fields from the entry.  A connection is opened to "
"the database if necessary."
msgstr "Функция B<getprotoent>() считывает следующую запись из файла, содержащего базу протоколов (смотрите B<protocols>(5)), и возвращает структуру I<protoent>, содержащую поля из этой записи. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getprotoent.3:68
msgid ""
"The B<getprotobyname>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol name I<name>.  A "
"connection is opened to the database if necessary."
msgstr "Функция B<getprotobyname>() возвращает структуру I<protoent> элемента из базы данных, который совпадает с именем протокола I<name>. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getprotoent.3:78
msgid ""
"The B<getprotobynumber>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol number I<number>.  A "
"connection is opened to the database if necessary."
msgstr "Функция B<getprotobynumber>() возвращает структуру I<protoent> элемента из базы данных, который совпадает с номером протокола I<number>. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getprotoent.3:90
msgid ""
"The B<setprotoent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getproto*>()  functions."
msgstr "Функция B<setprotoent>() открывает соединение к базе и устанавливает следующую запись к первой записи. Если I<stayopen> не равен нулю, то подключение к базе между вызовами нескольких функций B<getproto*>() не будет закрыто."

#. type: Plain text
#: man-pages/man3/getprotoent.3:94
msgid "The B<endprotoent>()  function closes the connection to the database."
msgstr "Функция B<endprotoent>() закрывает подключение к базе."

#. type: Plain text
#: man-pages/man3/getprotoent.3:100
msgid ""
"The I<protoent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "Структура I<protoent> определена в I<E<lt>netdb.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/getprotoent.3:108
#, no-wrap
msgid ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"
msgstr "struct protoent {\n    char  *p_name;       /* официальное имя протокола */\n    char **p_aliases;    /* список псевдонимов */\n    int    p_proto;      /* номер протокола */\n}\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:114
msgid "The members of the I<protoent> structure are:"
msgstr "Члены структуры I<protoent>:"

#. type: TP
#: man-pages/man3/getprotoent.3:114
#, no-wrap
msgid "I<p_name>"
msgstr "I<p_name>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:117
msgid "The official name of the protocol."
msgstr "Официальное название протокола."

#. type: TP
#: man-pages/man3/getprotoent.3:117
#, no-wrap
msgid "I<p_aliases>"
msgstr "I<p_aliases>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:120
msgid "A NULL-terminated list of alternative names for the protocol."
msgstr "Список альтернативных имён протокола, завершающийся NULL."

#. type: TP
#: man-pages/man3/getprotoent.3:120
#, no-wrap
msgid "I<p_proto>"
msgstr "I<p_proto>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:123
msgid "The protocol number."
msgstr "Номер протокола."

#. type: Plain text
#: man-pages/man3/getprotoent.3:134
msgid ""
"The B<getprotoent>(), B<getprotobyname>()  and B<getprotobynumber>()  "
"functions return a pointer to a statically allocated I<protoent> structure, "
"or a null pointer if an error occurs or the end of the file is reached."
msgstr "Функции B<getprotoent>(), B<getprotobyname>() и B<getprotobynumber>() возвращают указатель на статически выделенную структуру I<protoent> или указатель null при ошибке или достижении конца файла."

#. type: TP
#: man-pages/man3/getprotoent.3:136
#, no-wrap
msgid "I</etc/protocols>"
msgstr "I</etc/protocols>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:139
msgid "protocol database file"
msgstr "файл, содержащий базу протоколов"

#. type: tbl table
#: man-pages/man3/getprotoent.3:150
#, no-wrap
msgid "B<getprotoent>()"
msgstr "B<getprotoent>()"

#. type: tbl table
#: man-pages/man3/getprotoent.3:152 man-pages/man3/getprotoent.3:175
#, no-wrap
msgid "MT-Unsafe race:protoent\n"
msgstr "MT-Unsafe race:protoent\n"

#. type: tbl table
#: man-pages/man3/getprotoent.3:154
#, no-wrap
msgid "race:protoentbuf locale"
msgstr "race:protoentbuf locale"

#. type: tbl table
#: man-pages/man3/getprotoent.3:157
#, no-wrap
msgid "B<getprotobyname>()"
msgstr "B<getprotobyname>()"

#. type: tbl table
#: man-pages/man3/getprotoent.3:159
#, no-wrap
msgid "MT-Unsafe race:protobyname\n"
msgstr "MT-Unsafe race:protobyname\n"

#. type: tbl table
#: man-pages/man3/getprotoent.3:164
#, no-wrap
msgid "B<getprotobynumber>()"
msgstr "B<getprotobynumber>()"

#. type: tbl table
#: man-pages/man3/getprotoent.3:166
#, no-wrap
msgid "MT-Unsafe race:protobynumber\n"
msgstr "MT-Unsafe race:protobynumber\n"

#. type: tbl table
#: man-pages/man3/getprotoent.3:171
#, no-wrap
msgid "B<setprotoent>(),\n"
msgstr "B<setprotoent>(),\n"

#. type: tbl table
#: man-pages/man3/getprotoent.3:173
#, no-wrap
msgid "B<endprotoent>()"
msgstr "B<endprotoent>()"

#. type: Plain text
#: man-pages/man3/getprotoent.3:191
msgid ""
"In the above table, I<protoent> in I<race:protoent> signifies that if any of"
" the functions B<setprotoent>(), B<getprotoent>(), or B<endprotoent>()  are "
"used in parallel in different threads of a program, then data races could "
"occur."
msgstr "В приведённой выше таблице I<protoent> в I<race:protoent> означает, что если в нескольких нитях программы одновременно используются функции B<setprotoent>(), B<getprotoent>() или B<endprotoent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getprotoent.3:197
msgid ""
"B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"
msgstr "B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"

#. type: TH
#: man-pages/man3/getutent.3:31
#, no-wrap
msgid "GETUTENT"
msgstr "GETUTENT"

#. type: Plain text
#: man-pages/man3/getutent.3:35
msgid ""
"getutent, getutid, getutline, pututline, setutent, endutent, utmpname - "
"access utmp file entries"
msgstr "getutent, getutid, getutline, pututline, setutent, endutent, utmpname - доступ к записям файла utmp"

#. type: Plain text
#: man-pages/man3/getutent.3:37
msgid "B<#include E<lt>utmp.hE<gt>>"
msgstr "B<#include E<lt>utmp.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getutent.3:39
msgid "B<struct utmp *getutent(void);>"
msgstr "B<struct utmp *getutent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:41
msgid "B<struct utmp *getutid(const struct utmp *>I<ut>B<);>"
msgstr "B<struct utmp *getutid(const struct utmp *>I<ut>B<);>"

#. type: Plain text
#: man-pages/man3/getutent.3:43
msgid "B<struct utmp *getutline(const struct utmp *>I<ut>B<);>"
msgstr "B<struct utmp *getutline(const struct utmp *>I<ut>B<);>"

#. type: Plain text
#: man-pages/man3/getutent.3:45
msgid "B<struct utmp *pututline(const struct utmp *>I<ut>B<);>"
msgstr "B<struct utmp *pututline(const struct utmp *>I<ut>B<);>"

#. type: Plain text
#: man-pages/man3/getutent.3:47
msgid "B<void setutent(void);>"
msgstr "B<void setutent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:49
msgid "B<void endutent(void);>"
msgstr "B<void endutent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:51
msgid "B<int utmpname(const char *>I<file>B<);>"
msgstr "B<int utmpname(const char *>I<file>B<);>"

#. type: Plain text
#: man-pages/man3/getutent.3:54
msgid ""
"New applications should use the POSIX.1-specified \"utmpx\" versions of "
"these functions; see CONFORMING TO."
msgstr "В новых приложениях нужно использовать определённые в POSIX.1 «utmpx» версии этих функций; смотрите СООТВЕТСТВИЕ СТАНДАРТАМ."

#. type: Plain text
#: man-pages/man3/getutent.3:63
msgid ""
"B<utmpname>()  sets the name of the utmp-format file for the other utmp "
"functions to access.  If B<utmpname>()  is not used to set the filename "
"before the other functions are used, they assume B<_PATH_UTMP>, as defined "
"in I<E<lt>paths.hE<gt>>."
msgstr "Функция B<utmpname>() задаёт имя файла в формате utmp для других функций utmp. Если B<utmpname>() не используется для указания имени файла перед работой с другими функциями, то они будут использовать имя из B<_PATH_UTMP>, определённое в I<E<lt>paths.hE<gt>>."

#. type: Plain text
#: man-pages/man3/getutent.3:68
msgid ""
"B<setutent>()  rewinds the file pointer to the beginning of the utmp file.  "
"It is generally a good idea to call it before any of the other functions."
msgstr "Функция B<setutent>() переносит указатель начало файла utmp. Вообще, оптимальным вариантом считается вызывать эту функцию перед вызовом остальных."

#. type: Plain text
#: man-pages/man3/getutent.3:73
msgid ""
"B<endutent>()  closes the utmp file.  It should be called when the user code"
" is done accessing the file with the other functions."
msgstr "Функция B<endutent>() закрывает файл utmp. Она должна быть вызвана, когда будет завершена работа с файлом посредством других функций."

#. type: Plain text
#: man-pages/man3/getutent.3:80
msgid ""
"B<getutent>()  reads a line from the current file position in the utmp file."
"  It returns a pointer to a structure containing the fields of the line.  "
"The definition of this structure is shown in B<utmp>(5)."
msgstr "Функция B<getutent>() считывает строку, начиная с текущей позиции файла в файле utmp. Она возвращает указатель на структуру, содержащую поля этой строки. Определение структуры приведено в B<utmp>(5)."

#. type: Plain text
#: man-pages/man3/getutent.3:96
msgid ""
"B<getutid>()  searches forward from the current file position in the utmp "
"file based upon I<ut>.  If I<ut-E<gt>ut_type> is one of B<RUN_LVL>, "
"B<BOOT_TIME>, B<NEW_TIME>, or B<OLD_TIME>, B<getutid>()  will find the first"
" entry whose I<ut_type> field matches I<ut-E<gt>ut_type>.  If "
"I<ut-E<gt>ut_type> is one of B<INIT_PROCESS>, B<LOGIN_PROCESS>, "
"B<USER_PROCESS>, or B<DEAD_PROCESS>, B<getutid>()  will find the first entry"
" whose I<ut_id> field matches I<ut-E<gt>ut_id>."
msgstr "Функция B<getutid>() производит прямой поиск, начиная с текущей позиции файла в файле utmp, основываясь на данных I<ut>. Если значение I<ut-E<gt>ut_type> равно B<RUN_LVL>, B<BOOT_TIME>, B<NEW_TIME> или B<OLD_TIME>, то B<getutid>() найдёт первую запись, поле I<ut_type> которой совпадает с I<ut-E<gt>ut_type>. Если I<ut-E<gt>ut_type> равно B<INIT_PROCESS>, B<LOGIN_PROCESS>, B<USER_PROCESS> или B<DEAD_PROCESS>, то B<getutid>() найдёт первую запись, поле I<ut_id> которой совпадает с I<ut-E<gt>ut_id>."

#. type: Plain text
#: man-pages/man3/getutent.3:106
msgid ""
"B<getutline>()  searches forward from the current file position in the utmp "
"file.  It scans entries whose I<ut_type> is B<USER_PROCESS> or "
"B<LOGIN_PROCESS> and returns the first one whose I<ut_line> field matches "
"I<ut-E<gt>ut_line>."
msgstr "Функция B<getutline>() производит прямой поиск, начиная с текущей позиции файла в файле utmp. Она просматривает записи, у которых поле I<ut_type> совпадает с B<USER_PROCESS> или B<LOGIN_PROCESS>, и возвращает первую запись, поле I<ut_line> которой совпадает с I<ut-E<gt>ut_line>."

#. type: Plain text
#: man-pages/man3/getutent.3:118
msgid ""
"B<pututline>()  writes the I<utmp> structure I<ut> into the utmp file.  It "
"uses B<getutid>()  to search for the proper place in the file to insert the "
"new entry.  If it cannot find an appropriate slot for I<ut>, B<pututline>()"
"  will append the new entry to the end of the file."
msgstr "Функция B<pututline>() записывает структуру I<utmp> I<ut> в файл utmp. Для поиска места в файле, необходимого для вставки новой записи, используется B<getutid>() . Если такое место не найдено, то B<pututline>() добавит запись в конец файла."

#. type: Plain text
#: man-pages/man3/getutent.3:127
msgid ""
"B<getutent>(), B<getutid>(), and B<getutline>()  return a pointer to a "
"I<struct utmp> on success, and NULL on failure (which includes the \"record "
"not found\" case).  This I<struct utmp> is allocated in static storage, and "
"may be overwritten by subsequent calls."
msgstr "При успешном выполнении функции B<getutent>(), B<getutid>() и B<getutline>() возвращают указатель на I<struct utmp> и NULL при ошибке (к ним относится и случай «запись не найдена»). Структура I<struct utmp> располагается в статическом хранилище и может быть изменена последующими вызовами."

#. type: Plain text
#: man-pages/man3/getutent.3:133
msgid "On success B<pututline>()  returns I<ut>; on failure, it returns NULL."
msgstr "При успешном выполнении B<pututline>() возвращает I<ut>; при ошибке возвращается NULL."

#. type: Plain text
#: man-pages/man3/getutent.3:136
msgid ""
"B<utmpname>()  returns 0 if the new name was successfully stored, or -1 on "
"failure."
msgstr "При успешном назначении нового имени функция B<utmpname>() возвращает 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/getutent.3:140
msgid ""
"In the event of an error, these functions I<errno> set to indicate the "
"cause."
msgstr "В случае ошибки эти функции изменяют значение I<errno> соответствующим образом."

#. type: Plain text
#: man-pages/man3/getutent.3:147
msgid "Record not found."
msgstr "Запись не найдена."

#. type: Plain text
#: man-pages/man3/getutent.3:154
msgid ""
"B<setutent>(), B<pututline>(), and the B<getut*>()  functions can also fail "
"for the reasons described in B<open>(2)."
msgstr "Функции B<setutent>(), B<pututline>() и B<getut*>() также могут завершиться с ошибкой по причинам, описанным в B<open>(2)."

#. type: TP
#: man-pages/man3/getutent.3:155
#, no-wrap
msgid "I</var/run/utmp>"
msgstr "I</var/run/utmp>"

#. type: Plain text
#: man-pages/man3/getutent.3:158
msgid "database of currently logged-in users"
msgstr "база данных пользователей, находящихся в системе в данный момент"

#. type: TP
#: man-pages/man3/getutent.3:158
#, no-wrap
msgid "I</var/log/wtmp>"
msgstr "I</var/log/wtmp>"

#. type: Plain text
#: man-pages/man3/getutent.3:161
msgid "database of past user logins"
msgstr "база данных предыдущих пользовательских входов в систему"

#. type: tbl table
#: man-pages/man3/getutent.3:171
#, no-wrap
msgid "B<getutent>()"
msgstr "B<getutent>()"

#. type: tbl table
#: man-pages/man3/getutent.3:173 man-pages/man3/getutent.3:182
#, no-wrap
msgid "MT-Unsafe init race:utent\n"
msgstr "MT-Unsafe init race:utent\n"

#. type: tbl table
#: man-pages/man3/getutent.3:175
#, no-wrap
msgid "race:utentbuf sig:ALRM timer"
msgstr "race:utentbuf sig:ALRM timer"

#. type: tbl table
#: man-pages/man3/getutent.3:178
#, no-wrap
msgid "B<getutid>(),\n"
msgstr "B<getutid>(),\n"

#. type: tbl table
#: man-pages/man3/getutent.3:180
#, no-wrap
msgid "B<getutline>()"
msgstr "B<getutline>()"

#. type: tbl table
#: man-pages/man3/getutent.3:184 man-pages/man3/getutent.3:191
#, no-wrap
msgid "sig:ALRM timer"
msgstr "sig:ALRM timer"

#. type: tbl table
#: man-pages/man3/getutent.3:187
#, no-wrap
msgid "B<pututline>()"
msgstr "B<pututline>()"

#. type: tbl table
#: man-pages/man3/getutent.3:189
#, no-wrap
msgid "MT-Unsafe race:utent\n"
msgstr "MT-Unsafe race:utent\n"

#. type: tbl table
#: man-pages/man3/getutent.3:194
#, no-wrap
msgid "B<setutent>(),\n"
msgstr "B<setutent>(),\n"

#. type: tbl table
#: man-pages/man3/getutent.3:196
#, no-wrap
msgid "B<endutent>(),\n"
msgstr "B<endutent>(),\n"

#. type: tbl table
#: man-pages/man3/getutent.3:198
#, no-wrap
msgid "B<utmpname>()"
msgstr "B<utmpname>()"

#. type: tbl table
#: man-pages/man3/getutent.3:198
#, no-wrap
msgid "MT-Unsafe race:utent"
msgstr "MT-Unsafe race:utent"

#. type: Plain text
#: man-pages/man3/getutent.3:216
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(), B<getutent>(), B<getutid>(), B<getutline>(), "
"B<pututline>(), B<utmpname>(), or B<endutent>()  are used in parallel in "
"different threads of a program, then data races could occur."
msgstr "В приведённой выше таблице I<utent> в I<race:utent> означает, что если в нескольких нитях программы одновременно используются функции B<setutent>(), B<getutent>(), B<getutid>(), B<getutline>(), B<pututline>(), B<utmpname>() или B<endutent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getutent.3:218
msgid "XPG2, SVr4."
msgstr "XPG2, SVr4."

#. type: Plain text
#: man-pages/man3/getutent.3:227
msgid ""
"In XPG2 and SVID 2 the function B<pututline>()  is documented to return "
"void, and that is what it does on many systems (AIX, HP-UX).  HP-UX "
"introduces a new function B<_pututline>()  with the prototype given above "
"for B<pututline>()."
msgstr "Согласно XPG2 и SVID 2 функция B<pututline>() возвращает тип void и такое поведение можно встретить во многих системах (AIX, HP-UX). В HP-UX представлена новая функция B<_pututline>() с прототипом приведённым выше для B<pututline>()."

#. type: Plain text
#: man-pages/man3/getutent.3:231
msgid ""
"All these functions are obsolete now on non-Linux systems.  POSIX.1-2001 and"
" POSIX.1-2008, following SUSv1, does not have any of these functions, but "
"instead uses"
msgstr "Эти функции являются устаревшими в не Linux системах. POSIX.1-2001 и POSIX.1-2008, следуя SUSv1, не содержит эти функции, вместо них используются"

#. type: Plain text
#: man-pages/man3/getutent.3:235
#, no-wrap
msgid "B<#include E<lt>utmpx.hE<gt>>\n"
msgstr "B<#include E<lt>utmpx.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:242
#, no-wrap
msgid ""
"B<struct utmpx *getutxent(void);>\n"
"B<struct utmpx *getutxid(const struct utmpx *);>\n"
"B<struct utmpx *getutxline(const struct utmpx *);>\n"
"B<struct utmpx *pututxline(const struct utmpx *);>\n"
"B<void setutxent(void);>\n"
"B<void endutxent(void);>\n"
msgstr "B<struct utmpx *getutxent(void);>\nB<struct utmpx *getutxid(const struct utmpx *);>\nB<struct utmpx *getutxline(const struct utmpx *);>\nB<struct utmpx *pututxline(const struct utmpx *);>\nB<void setutxent(void);>\nB<void endutxent(void);>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:253
msgid ""
"These functions are provided by glibc, and perform the same task as their "
"equivalents without the \"x\", but use I<struct utmpx>, defined on Linux to "
"be the same as I<struct utmp>.  For completeness, glibc also provides "
"B<utmpxname>(), although this function is not specified by POSIX.1."
msgstr "Эти функции предоставляются glibc и выполняют те же задачи что и их аналоги без «x»\", но используют I<struct utmpx>, определённую в Linux подобно I<struct utmp>. Для завершённости, в glibc также есть B<utmpxname>(), хотя эта функция отсутствует в POSIX.1."

#. type: Plain text
#: man-pages/man3/getutent.3:261
msgid ""
"On some other systems, the I<utmpx> structure is a superset of the I<utmp> "
"structure, with additional fields, and larger versions of the existing "
"fields, and parallel files are maintained, often I</var/*/utmpx> and "
"I</var/*/wtmpx>."
msgstr "В некоторых других системах структура I<utmpx> представляет собой I<utmp> с дополнительными полями и увеличенными размерами одинаковых полей, а также параллельно обслуживаются обе версии файлов, часто I</var/*/utmpx> и I</var/*/wtmpx>."

#. type: Plain text
#: man-pages/man3/getutent.3:269
msgid ""
"Linux glibc on the other hand does not use a parallel I<utmpx> file since "
"its I<utmp> structure is already large enough.  The \"x\" functions listed "
"above are just aliases for their counterparts without the \"x\" (e.g., "
"B<getutxent>()  is an alias for B<getutent>())."
msgstr "С другой стороны, в Linux glibc не используется второй файл I<utmpx>, так как её структура I<utmp> имеет достаточный размер. Функции с «x», перечисленные выше, являются просто псевдонимами их аналогов без «x» (например, B<getutxent>() псевдоним B<getutent>())."

#. type: SS
#: man-pages/man3/getutent.3:270
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#. type: Plain text
#: man-pages/man3/getutent.3:273
msgid ""
"The above functions are not thread-safe.  Glibc adds reentrant versions"
msgstr "Перечисленные выше функции нельзя использовать в нескольких нитях одновременно. В glibc добавлены реентерабельные версии."

#. type: Plain text
#: man-pages/man3/getutent.3:277
#, no-wrap
msgid "B<#include E<lt>utmp.hE<gt>>\n"
msgstr "B<#include E<lt>utmp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:279
#, no-wrap
msgid "B<int getutent_r(struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr "B<int getutent_r(struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:282
#, no-wrap
msgid ""
"B<int getutid_r(struct utmp *>I<ut>B<,>\n"
"B<              struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr "B<int getutid_r(struct utmp *>I<ut>B<,>\nB<              struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:285
#, no-wrap
msgid ""
"B<int getutline_r(struct utmp *>I<ut>B<,>\n"
"B<                struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr "B<int getutline_r(struct utmp *>I<ut>B<,>\nB<                struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:294
msgid "B<getutent_r>(), B<getutid_r>(), B<getutline_r>():"
msgstr "B<getutent_r>(), B<getutid_r>(), B<getutline_r>():"

#. type: Plain text
#: man-pages/man3/getutent.3:298
#, no-wrap
msgid ""
"    _GNU_SOURCE\n"
"    || /* since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* glibc E<lt>= 2.19: */    _SVID_SOURCE || _BSD_SOURCE\n"
msgstr "    _GNU_SOURCE\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* glibc E<lt>= 2.19: */    _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getutent.3:310
msgid ""
"These functions are GNU extensions, analogs of the functions of the same "
"name without the _r suffix.  The I<ubuf> argument gives these functions a "
"place to store their result.  On success, they return 0, and a pointer to "
"the result is written in I<*ubufp>.  On error, these functions return -1.  "
"There are no utmpx equivalents of the above functions.  (POSIX.1 does not "
"specify such functions.)"
msgstr "Эти функции являются расширениями GNU, они аналогичны функциям с тем же именем без суффикса _r. В аргумент I<ubuf>, передаваемый этим функциям, помещается результат. При успешном выполнении они возвращают 0 и указатель на результат записывается в I<*ubufp>. При ошибке эти функции возвращают -1. Среди этих функций отсутствует эквиваленты utmpx (в POSIX.1 такие функции отсутствуют)."

#. type: Plain text
#: man-pages/man3/getutent.3:318
msgid ""
"The following example adds and removes a utmp record, assuming it is run "
"from within a pseudo terminal.  For usage in a real application, you should "
"check the return values of B<getpwuid>(3)  and B<ttyname>(3)."
msgstr "Нижеследующий пример добавляет и удаляет запись utmp, предполагается, что программа запущена с псевдотерминала. Для использования в реальном приложении необходимо проверять значения, возвращаемые B<getpwuid>(3) и B<ttyname>(3)."

#. type: Plain text
#: man-pages/man3/getutent.3:325
#, no-wrap
msgid ""
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>utmp.hE<gt>\n"
msgstr "#include E<lt>string.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>pwd.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>utmp.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:330
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct utmp entry;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct utmp entry;\n"

#. type: Plain text
#: man-pages/man3/getutent.3:332
#, no-wrap
msgid "    system(\"echo before adding entry:;who\");\n"
msgstr "    system(\"echo перед добавлением записи:;who\");\n"

#. type: Plain text
#: man-pages/man3/getutent.3:344
#, no-wrap
msgid ""
"    entry.ut_type = USER_PROCESS;\n"
"    entry.ut_pid = getpid();\n"
"    strcpy(entry.ut_line, ttyname(STDIN_FILENO) + strlen(\"/dev/\"));\n"
"    /* only correct for ptys named /dev/tty[pqr][0-9a-z] */\n"
"    strcpy(entry.ut_id, ttyname(STDIN_FILENO) + strlen(\"/dev/tty\"));\n"
"    time(&entry.ut_time);\n"
"    strcpy(entry.ut_user, getpwuid(getuid())-E<gt>pw_name);\n"
"    memset(entry.ut_host, 0, UT_HOSTSIZE);\n"
"    entry.ut_addr = 0;\n"
"    setutent();\n"
"    pututline(&entry);\n"
msgstr "    entry.ut_type = USER_PROCESS;\n    entry.ut_pid = getpid();\n    strcpy(entry.ut_line, ttyname(STDIN_FILENO) + strlen(\"/dev/\"));\n    /* правильные имена ptys только /dev/tty[pqr][0-9a-z] */\n    strcpy(entry.ut_id, ttyname(STDIN_FILENO) + strlen(\"/dev/tty\"));\n    time(&entry.ut_time);\n    strcpy(entry.ut_user, getpwuid(getuid())-E<gt>pw_name);\n    memset(entry.ut_host, 0, UT_HOSTSIZE);\n    entry.ut_addr = 0;\n    setutent();\n    pututline(&entry);\n"

#. type: Plain text
#: man-pages/man3/getutent.3:346
#, no-wrap
msgid "    system(\"echo after adding entry:;who\");\n"
msgstr "    system(\"echo после добавления записи:;who\");\n"

#. type: Plain text
#: man-pages/man3/getutent.3:353
#, no-wrap
msgid ""
"    entry.ut_type = DEAD_PROCESS;\n"
"    memset(entry.ut_line, 0, UT_LINESIZE);\n"
"    entry.ut_time = 0;\n"
"    memset(entry.ut_user, 0, UT_NAMESIZE);\n"
"    setutent();\n"
"    pututline(&entry);\n"
msgstr "    entry.ut_type = DEAD_PROCESS;\n    memset(entry.ut_line, 0, UT_LINESIZE);\n    entry.ut_time = 0;\n    memset(entry.ut_user, 0, UT_NAMESIZE);\n    setutent();\n    pututline(&entry);\n"

#. type: Plain text
#: man-pages/man3/getutent.3:355
#, no-wrap
msgid "    system(\"echo after removing entry:;who\");\n"
msgstr "    system(\"echo после удаления записи:;who\");\n"

#. type: Plain text
#: man-pages/man3/getutent.3:359
#, no-wrap
msgid ""
"    endutent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    endutent();\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getutent.3:362
msgid "B<getutmp>(3), B<utmp>(5)"
msgstr "B<getutmp>(3), B<utmp>(5)"

#. type: TH
#: man-pages/man3/getrpcport.3:8
#, no-wrap
msgid "GETRPCPORT"
msgstr "GETRPCPORT"

#. type: Plain text
#: man-pages/man3/getrpcport.3:11
msgid "getrpcport - get RPC port number"
msgstr "getrpcport - получение номера порта RPC"

#. type: Plain text
#: man-pages/man3/getrpcport.3:14
#, no-wrap
msgid "B<#include E<lt>rpc/rpc.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/rpc.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getrpcport.3:17
#, no-wrap
msgid ""
"B<int getrpcport(const char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<               unsigned long >I<versnum>B<, unsigned >I<proto>B<);>\n"
msgstr "B<int getrpcport(const char *>I<host>B<, unsigned long >I<prognum>B<,>\nB<               unsigned long >I<versnum>B<, unsigned >I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcport.3:38
msgid ""
"B<getrpcport>()  returns the port number for version I<versnum> of the RPC "
"program I<prognum> running on I<host> and using protocol I<proto>.  It "
"returns 0 if it cannot contact the portmapper, or if I<prognum> is not "
"registered.  If I<prognum> is registered but not with version I<versnum>, it"
" will still return a port number (for some version of the program)  "
"indicating that the program is indeed registered.  The version mismatch will"
" be detected upon the first call to the service."
msgstr "Функция B<getrpcport>() возвращает номер порта для версии I<versnum> RPC-программы I<prognum>, работающей на I<host> и использующей протокол I<proto>. Она возвращает 0, если не может связаться с portmapper или если I<prognum> не зарегистрирована. Если же I<prognum> зарегистрирована, но не с версией I<versnum>, она все равно будет возвращать номер порта (с версией программы), указывая на то, что программа действительно зарегистрирована. Несоответствие версий будет зарегистрировано при первой попытке вызвать службу."

#. type: tbl table
#: man-pages/man3/getrpcport.3:48
#, no-wrap
msgid "B<getrpcport>()"
msgstr "B<getrpcport>()"

#. type: Plain text
#: man-pages/man3/getrpcport.3:53
msgid "Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems."
msgstr "Нет в POSIX.1. Присутствует в BSD, Solaris и многих других системах."

#. type: TH
#: man-pages/man3/gcvt.3:30
#, no-wrap
msgid "GCVT"
msgstr "GCVT"

#. type: Plain text
#: man-pages/man3/gcvt.3:33
msgid "gcvt - convert a floating-point number to a string"
msgstr "gcvt - преобразовать число с плавающей точкой в строку"

#. type: Plain text
#: man-pages/man3/gcvt.3:36
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/gcvt.3:38
#, no-wrap
msgid "B<char *gcvt(double >I<number>B<, int >I<ndigit>B<, char *>I<buf>B<);>\n"
msgstr "B<char *gcvt(double >I<number>B<, int >I<ndigit>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/gcvt.3:46
msgid "B<gcvt>():"
msgstr "B<gcvt>():"

#. type: TP
#: man-pages/man3/gcvt.3:49
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/gcvt.3:55
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr "(_XOPEN_SOURCE\\ E<gt>=\\ 500) ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* в версии glibc E<lt>= 2.19: */ _SVID_SOURCE\n"

#.     || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/gcvt.3:60
msgid "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/gcvt.3:71
msgid ""
"The B<gcvt>()  function converts I<number> to a minimal length null-"
"terminated ASCII string and stores the result in I<buf>.  It produces "
"I<ndigit> significant digits in either B<printf>(3)  F format or E format."
msgstr "Функция B<gcvt>() преобразует I<number> в строку ASCII (с null в конце) минимальной длины и сохраняет результат в I<buf>. Она выдаёт I<ndigit> цифр со знаком в F или E формате, описанных в B<printf>(3)."

#. type: Plain text
#: man-pages/man3/gcvt.3:76
msgid ""
"The B<gcvt>()  function returns the address of the string pointed to by "
"I<buf>."
msgstr "Функция B<gcvt>() возвращает адрес строки, на которую указывает I<buf>."

#. type: tbl table
#: man-pages/man3/gcvt.3:86
#, no-wrap
msgid "B<gcvt>()"
msgstr "B<gcvt>()"

#. type: Plain text
#: man-pages/man3/gcvt.3:98
msgid ""
"Marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the specification of"
" B<gcvt>(), recommending the use of B<sprintf>(3)  instead (though "
"B<snprintf>(3)  may be preferable)."
msgstr "Отмечена в POSIX.1-2001 как УСТАРЕВШАЯ. В POSIX.1-2008 спецификация B<gcvt>() удалена, вместо них рекомендуется использовать B<sprintf>(3) (однако B<snprintf>(3) может быть предпочтительнее)."

#. type: Plain text
#: man-pages/man3/gcvt.3:101
msgid "B<ecvt>(3), B<fcvt>(3), B<sprintf>(3)"
msgstr "B<ecvt>(3), B<fcvt>(3), B<sprintf>(3)"

#. type: TH
#: man-pages/man3/getcontext.3:25
#, no-wrap
msgid "GETCONTEXT"
msgstr "GETCONTEXT"

#. type: Plain text
#: man-pages/man3/getcontext.3:28
msgid "getcontext, setcontext - get or set the user context"
msgstr "getcontext, setcontext - получить или установить пользовательский контекст"

#. type: Plain text
#: man-pages/man3/getcontext.3:30
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr "B<#include E<lt>ucontext.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getcontext.3:32
msgid "B<int getcontext(ucontext_t *>I<ucp>B<);>"
msgstr "B<int getcontext(ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: man-pages/man3/getcontext.3:34
msgid "B<int setcontext(const ucontext_t *>I<ucp>B<);>"
msgstr "B<int setcontext(const ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: man-pages/man3/getcontext.3:49
msgid ""
"In a System V-like environment, one has the two types I<mcontext_t> and "
"I<ucontext_t> defined in I<E<lt>ucontext.hE<gt>> and the four functions "
"B<getcontext>(), B<setcontext>(), B<makecontext>(3), and B<swapcontext>(3)  "
"that allow user-level context switching between multiple threads of control "
"within a process."
msgstr "В окружении, подобном SysV, существует два типа данных —I<mcontext_t> и I<ucontext_t>, которые определены в файле I<E<lt>ucontext.hE<gt>> и четыре функции — B<getcontext>(), B<setcontext>(), B<makecontext>(3) и B<swapcontext>(3), которые позволяют контексту пользовательского уровня переключаться между несколькими нитями внутри одного процесса."

#. type: Plain text
#: man-pages/man3/getcontext.3:57
msgid ""
"The I<mcontext_t> type is machine-dependent and opaque.  The I<ucontext_t> "
"type is a structure that has at least the following fields:"
msgstr "Тип I<mcontext_t> является машинно-зависимым и примитивным типом данных. Тип I<ucontext_t> является структурой, которая по крайней мере имеет следующие поля:"

#. type: Plain text
#: man-pages/man3/getcontext.3:67
#, no-wrap
msgid ""
"typedef struct ucontext_t {\n"
"    struct ucontext_t *uc_link;\n"
"    sigset_t          uc_sigmask;\n"
"    stack_t           uc_stack;\n"
"    mcontext_t        uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"
msgstr "typedef struct ucontext_t {\n    struct ucontext_t *uc_link;\n    sigset_t          uc_sigmask;\n    stack_t           uc_stack;\n    mcontext_t        uc_mcontext;\n    ...\n} ucontext_t;\n"

#. type: Plain text
#: man-pages/man3/getcontext.3:94
msgid ""
"with I<sigset_t> and I<stack_t> defined in I<E<lt>signal.hE<gt>>.  Here "
"I<uc_link> points to the context that will be resumed when the current "
"context terminates (in case the current context was created using "
"B<makecontext>(3)), I<uc_sigmask> is the set of signals blocked in this "
"context (see B<sigprocmask>(2)), I<uc_stack> is the stack used by this "
"context (see B<sigaltstack>(2)), and I<uc_mcontext> is the machine-specific "
"representation of the saved context, that includes the calling thread's "
"machine registers."
msgstr "где I<sigset_t> и I<stack_t> определены в файле I<E<lt>signal.hE<gt>>. В этой структуре I<uc_link> указывает на контекст, к которому будет осуществлён переход, когда завершается текущий контекст (в случае, если текущий контекст был создан с помощью  B<makecontext>(3)), в I<uc_sigmask> задаётся список сигналов, которые блокируются в этом контексте (см. B<sigprocmask>(2)), I<uc_stack> \\(em это стек, который используется этим контекстом (см. B<sigaltstack>(2)), а I<uc_mcontext> является машинно-зависимым представлением сохранённого контекста, который содержит регистры вызываемой нити."

#. type: Plain text
#: man-pages/man3/getcontext.3:101
msgid ""
"The function B<getcontext>()  initializes the structure pointed at by I<ucp>"
" to the currently active context."
msgstr "Функция B<getcontext>() инициализирует вышеописанную структуру, указывая через I<ucp> на текущий активный контекст."

#. type: Plain text
#: man-pages/man3/getcontext.3:114
msgid ""
"The function B<setcontext>()  restores the user context pointed at by "
"I<ucp>.  A successful call does not return.  The context should have been "
"obtained by a call of B<getcontext>(), or B<makecontext>(3), or passed as "
"third argument to a signal handler."
msgstr "Функция B<setcontext>() восстанавливает пользовательский контекст, на который указывает I<ucp>. При успешном вызове управление не возвращается обратно. Контекст должен быть получен с помощью вызова B<getcontext>() или B<makecontext>(3) или передан как третий аргумент обработчика сигнала."

#. type: Plain text
#: man-pages/man3/getcontext.3:118
msgid ""
"If the context was obtained by a call of B<getcontext>(), program execution "
"continues as if this call just returned."
msgstr "Если контекст был получен через вызов B<getcontext>(), то выполнение программы продолжается как если бы этот вызов завершился простым возвратом."

#. type: Plain text
#: man-pages/man3/getcontext.3:135
msgid ""
"If the context was obtained by a call of B<makecontext>(3), program "
"execution continues by a call to the function I<func> specified as the "
"second argument of that call to B<makecontext>(3).  When the function "
"I<func> returns, we continue with the I<uc_link> member of the structure "
"I<ucp> specified as the first argument of that call to B<makecontext>(3).  "
"When this member is NULL, the thread exits."
msgstr "Если контекст был получен через вызов B<makecontext>(3), выполнение программы продолжается с помощью вызова функции I<func>, которая задаётся как второй аргумент вызова B<makecontext>(3). Когда происходит возврат из функции I<func>, выполнение продолжается с поля I<uc_link> структуры I<ucp>, которая задаётся как первый аргумент вызова B<makecontext>(3). Если это поле равно NULL, осуществляется выход из нити."

#. type: Plain text
#: man-pages/man3/getcontext.3:142
msgid ""
"If the context was obtained by a call to a signal handler, then old standard"
" text says that \"program execution continues with the program instruction "
"following the instruction interrupted by the signal\".  However, this "
"sentence was removed in SUSv2, and the present verdict is \"the result is "
"unspecified\"."
msgstr "Если контекст был получен с помощью вызова обработчика сигнала, то старый текст стандарта говорит, что \"выполнение программы продолжается с инструкции программы, которая следует за инструкцией, прерванной сигналом\". Однако, этот текст был удалён в SUSv2 с вердиктом \"результат не определён\"."

#. type: Plain text
#: man-pages/man3/getcontext.3:151
msgid ""
"When successful, B<getcontext>()  returns 0 and B<setcontext>()  does not "
"return.  On error, both return -1 and set I<errno> appropriately."
msgstr "В случае успеха B<getcontext>() возвращает 0, а B<setcontext>() не возвращает ничего. В случае ошибки, возвращается -1 и значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man3/getcontext.3:153
msgid "None defined."
msgstr "Не определены. "

#. type: tbl table
#: man-pages/man3/getcontext.3:164
#, no-wrap
msgid ""
"B<getcontext>(),\n"
"B<setcontext>()"
msgstr "B<getcontext>(),\nB<setcontext>()"

#. type: tbl table
#: man-pages/man3/getcontext.3:164
#, no-wrap
msgid "MT-Safe race:ucp"
msgstr "MT-Safe race:ucp"

#. type: Plain text
#: man-pages/man3/getcontext.3:172
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<getcontext>(), citing portability issues, and recommending that "
"applications be rewritten to use POSIX threads instead."
msgstr "SUSv2, POSIX.1-2001. В POSIX.1-2008 удалено определение B<getcontext>() со ссылкой на проблемы с переносимостью и рекомендацией переписать приложение с использование нитей POSIX."

#. type: Plain text
#: man-pages/man3/getcontext.3:189
msgid ""
"The earliest incarnation of this mechanism was the "
"B<setjmp>(3)/B<longjmp>(3)  mechanism.  Since that does not define the "
"handling of the signal context, the next stage was the "
"B<sigsetjmp>(3)/B<siglongjmp>(3)  pair.  The present mechanism gives much "
"more control.  On the other hand, there is no easy way to detect whether a "
"return from B<getcontext>()  is from the first call, or via a "
"B<setcontext>()  call.  The user has to invent her own bookkeeping device, "
"and a register variable won't do since registers are restored."
msgstr "В ранних версиях этого механизма использовался механизм B<setjmp>(3)/B<longjmp>(3). Так как в нём нет обработки контекста сигнала, было решено использовать следующий вариант пары B<sigsetjmp>(3)/B<siglongjmp>(3). Текущий механизм даёт много больше контроля. С другой стороны, не существует лёгкого способа определить какое из двух значений возвращает при первом запуске вызов B<getcontext>() или вызов B<setcontext>(). Пользователь должен придумать собственный способ и через регистровую переменную это сделать нельзя, так как значения регистров восстанавливаются."

#. type: Plain text
#: man-pages/man3/getcontext.3:200
msgid ""
"When a signal occurs, the current user context is saved and a new context is"
" created by the kernel for the signal handler.  Do not leave the handler "
"using B<longjmp>(3): it is undefined what would happen with contexts.  Use "
"B<siglongjmp>(3)  or B<setcontext>()  instead."
msgstr "Если возникнет сигнал, текущий пользовательский контекст сохраняется и для обработчика сигнала ядром создаётся новый контекст. Не выходите из этого обработчика, используя B<longjmp>(3) \\(em неизвестно, что может случиться с контекстами. Вместо этого используйте вызовы B<siglongjmp>(3) или B<setcontext>()."

#. type: Plain text
#: man-pages/man3/getcontext.3:206
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), "
"B<makecontext>(3), B<sigsetjmp>(3)"
msgstr "B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), B<makecontext>(3), B<sigsetjmp>(3)"

#. type: TH
#: man-pages/man3/grantpt.3:5
#, no-wrap
msgid "GRANTPT"
msgstr "GRANTPT"

#. type: Plain text
#: man-pages/man3/grantpt.3:8
msgid "grantpt - grant access to the slave pseudoterminal"
msgstr "grantpt - разрешает доступ для подчинённому псевдотерминалу"

#. type: Plain text
#: man-pages/man3/grantpt.3:10
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/grantpt.3:12
msgid "B<int grantpt(int >I<fd>B<);>"
msgstr "B<int grantpt(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man3/grantpt.3:20
msgid "B<grantpt>():"
msgstr "B<grantpt>():"

#. type: Plain text
#: man-pages/man3/grantpt.3:25
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"
msgstr "начиная с glibc 2.24:\n    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"

#. type: Plain text
#: man-pages/man3/grantpt.3:28
#, no-wrap
msgid ""
"Glibc 2.23 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr "glibc 2.23 и старее:\n    _XOPEN_SOURCE\n"

#. type: Plain text
#: man-pages/man3/grantpt.3:40
msgid ""
"The B<grantpt>()  function changes the mode and owner of the slave "
"pseudoterminal device corresponding to the master pseudoterminal referred to"
" by I<fd>.  The user ID of the slave is set to the real UID of the calling "
"process.  The group ID is set to an unspecified value (e.g., I<tty>).  The "
"mode of the slave is set to 0620 (crw--w----)."
msgstr "Функция B<grantpt>() изменяет режим и владельца для устройства подчинённого псевдотерминала, соответствующего основному псевдотерминалу, на который ссылается I<fd>. Идентификатор пользователя подчинённого устанавливается в действительный UID вызывающего процесса. Идентификатор группы устанавливается в неопределенное значение (например, I<tty>). Права доступа к подчинённому псевдотерминала назначаются как 0620 (crw--w----)."

#. type: Plain text
#: man-pages/man3/grantpt.3:46
msgid ""
"The behavior of B<grantpt>()  is unspecified if a signal handler is "
"installed to catch B<SIGCHLD> signals."
msgstr "Поведение B<grantpt>() не определено, если установлен обработчик сигналов для перехвата сигналов B<SIGCHLD>."

#. type: Plain text
#: man-pages/man3/grantpt.3:53
msgid ""
"When successful, B<grantpt>()  returns 0.  Otherwise, it returns -1 and sets"
" I<errno> appropriately."
msgstr "При успешном выполнении B<grantpt>() возвращает 0. Иначе возвращается -1 и переменная I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man3/grantpt.3:57
msgid "The corresponding slave pseudoterminal could not be accessed."
msgstr "Невозможно получить доступ к соответствующему подчинённому псевдотерминалу."

#. type: Plain text
#: man-pages/man3/grantpt.3:62
msgid "The I<fd> argument is not a valid open file descriptor."
msgstr "Аргумент I<fd> не является правильным открытым файловым дескриптором."

#. type: Plain text
#: man-pages/man3/grantpt.3:67
msgid ""
"The I<fd> argument is valid but not associated with a master pseudoterminal."
msgstr "Значение I<fd> корректно, но не связано с основным псевдотерминалом."

#. type: Plain text
#: man-pages/man3/grantpt.3:70
msgid "B<grantpt>()  is provided in glibc since version 2.1."
msgstr "Функция B<grantpt>() появилась в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/grantpt.3:80
#, no-wrap
msgid "B<grantpt>()"
msgstr "B<grantpt>()"

#. type: Plain text
#: man-pages/man3/grantpt.3:88
msgid "This is part of the UNIX 98 pseudoterminal support, see B<pts>(4)."
msgstr "Является частью поддержки псевдотерминалов UNIX 98 (смотрите B<pts>(4))."

#. type: Plain text
#: man-pages/man3/grantpt.3:100
msgid ""
"Many systems implement this function via a set-user-ID helper binary called "
"\"pt_chown\".  On Linux systems with a devpts filesystem (present since "
"Linux 2.2), the kernel normally sets the correct ownership and permissions "
"for the pseudoterminal slave when the master is opened (B<posix_openpt>(3)),"
" so that nothing must be done by B<grantpt>().  Thus, no such helper binary "
"is required (and indeed it is configured to be absent during the glibc build"
" that is typical on many systems)."
msgstr "Многие системы реализуют эту функцию через вспомогательный исполняемый файл с установленным битом SUID, называемый «pt_chown». Благодаря файловой системе Linux devpts (начиная с Linux 2.2), ядро обычным образом устанавливает корректные значения владельца и права на подчинённый псевдотерминал когда открывается основной (B<posix_openpt>(3)), поэтому B<grantpt>() делать ничего не нужно. Таким образом, подобный вспомогательный файл не требуется ( и действительно, это значение пусто при сборке glibc, которая используется во многих системах)."

#. type: Plain text
#: man-pages/man3/grantpt.3:106
msgid ""
"B<open>(2), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pts>(4), "
"B<pty>(7)"
msgstr "B<open>(2), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pts>(4), B<pty>(7)"

#. type: TH
#: man-pages/man3/getusershell.3:30
#, no-wrap
msgid "GETUSERSHELL"
msgstr "GETUSERSHELL"

#. type: Plain text
#: man-pages/man3/getusershell.3:33
msgid "getusershell, setusershell, endusershell - get permitted user shells"
msgstr "getusershell, setusershell, endusershell - возвращают разрешённые оболочки пользователя"

#. type: Plain text
#: man-pages/man3/getusershell.3:38
#, no-wrap
msgid "B<char *getusershell(void);>\n"
msgstr "B<char *getusershell(void);>\n"

#. type: Plain text
#: man-pages/man3/getusershell.3:40
#, no-wrap
msgid "B<void setusershell(void);>\n"
msgstr "B<void setusershell(void);>\n"

#. type: Plain text
#: man-pages/man3/getusershell.3:42
#, no-wrap
msgid "B<void endusershell(void);>\n"
msgstr "B<void endusershell(void);>\n"

#. type: Plain text
#: man-pages/man3/getusershell.3:53
msgid "B<getusershell>(), B<setusershell>(), B<endusershell>():"
msgstr "B<getusershell>(), B<setusershell>(), B<endusershell>():"

#. type: Plain text
#: man-pages/man3/getusershell.3:81
msgid ""
"The B<getusershell>()  function returns the next line from the file "
"I</etc/shells>, opening the file if necessary.  The line should contain the "
"pathname of a valid user shell.  If I</etc/shells> does not exist or is "
"unreadable, B<getusershell>()  behaves as if I</bin/sh> and I</bin/csh> were"
" listed in the file."
msgstr "Функция B<getusershell>() возвращает следующую строку из файла I</etc/shells>, открывая его в случае необходимости. Строка должна содержать путь к допустимой оболочке пользователя.Если I</etc/shells> не существует или недоступен для чтения, то B<getusershell>() ведёт себя так, как если бы в файле были перечислены I</bin/sh> и I</bin/csh>."

#. type: Plain text
#: man-pages/man3/getusershell.3:86
msgid "The B<setusershell>()  function rewinds I</etc/shells>."
msgstr "Функция B<setusershell>()  переходит к началу I</etc/shells>."

#. type: Plain text
#: man-pages/man3/getusershell.3:91
msgid "The B<endusershell>()  function closes I</etc/shells>."
msgstr "Функция B<endusershell>() закрывает I</etc/shells>."

#. type: Plain text
#: man-pages/man3/getusershell.3:95
msgid "The B<getusershell>()  function returns NULL on end-of-file."
msgstr "Функция B<getusershell>() возвращает NULL или конец файла."

#. type: Plain text
#: man-pages/man3/getusershell.3:98
#, no-wrap
msgid "/etc/shells\n"
msgstr "/etc/shells\n"

#. type: tbl table
#: man-pages/man3/getusershell.3:110
#, no-wrap
msgid ""
"B<getusershell>(),\n"
"B<setusershell>(),\n"
msgstr "B<getusershell>(),\nB<setusershell>(),\n"

#. type: tbl table
#: man-pages/man3/getusershell.3:112
#, no-wrap
msgid "B<endusershell>()"
msgstr "B<endusershell>()"

#. type: tbl table
#: man-pages/man3/getusershell.3:112
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: man-pages/man3/getusershell.3:116
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: man-pages/man3/getusershell.3:117
msgid "B<shells>(5)"
msgstr "B<shells>(5)"

#. type: TH
#: man-pages/man3/gsignal.3:27
#, no-wrap
msgid "GSIGNAL"
msgstr "GSIGNAL"

#. type: Plain text
#: man-pages/man3/gsignal.3:30
msgid "gsignal, ssignal - software signal facility"
msgstr "gsignal, ssignal - программная фабрика сигналов"

#. type: Plain text
#: man-pages/man3/gsignal.3:33
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:35
#, no-wrap
msgid "B<typedef void (*sighandler_t)(int);>\n"
msgstr "B<typedef void (*sighandler_t)(int);>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:37
#, no-wrap
msgid "B<int gsignal(int >I<signum>B<);>\n"
msgstr "B<int gsignal(int >I<signum>B<);>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:39
#, no-wrap
msgid "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"
msgstr "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:52
#, no-wrap
msgid ""
"B<gsignal>(),\n"
"B<ssignal>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr "B<gsignal>(),\nB<ssignal>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:60
msgid ""
"Don't use these functions under Linux.  Due to a historical mistake, under "
"Linux these functions are aliases for B<raise>(3)  and B<signal>(2), "
"respectively."
msgstr "Не используйте эти функции в Linux. Из-за исторической ошибки, в Linux эти функции являются псевдонимами B<raise>(3) и B<signal>(2), соответственно."

#. type: Plain text
#: man-pages/man3/gsignal.3:98
msgid ""
"Elsewhere, on System V-like systems, these functions implement software "
"signaling, entirely independent of the classical B<signal>(2)  and "
"B<kill>(2)  functions.  The function B<ssignal>()  defines the action to "
"take when the software signal with number I<signum> is raised using the "
"function B<gsignal>(), and returns the previous such action or B<SIG_DFL>.  "
"The function B<gsignal>()  does the following: if no action (or the action "
"B<SIG_DFL>)  was specified for I<signum>, then it does nothing and returns "
"0.  If the action B<SIG_IGN> was specified for I<signum>, then it does "
"nothing and returns 1.  Otherwise, it resets the action to B<SIG_DFL> and "
"calls the action function with argument I<signum>, and returns the value "
"returned by that function.  The range of possible values I<signum> varies "
"(often 1\\(en15 or 1\\(en17)."
msgstr "В остальных, System V-подобных системах, эти функции реализуют программные сигналы, абсолютно отличающиеся от классических вызовов B<signal>(2) и B<kill>(2). Функция B<ssignal>() определяет действие при получении программного сигнала с номером I<signum>,  выполняемое функцией B<gsignal>(), и возвращает предыдущее такое действие или B<SIG_DFL>. Функция B<gsignal>() делает следующее: если для сигнала I<signum> не было определено действие (или оно B<SIG_DFL>), то ничего не делается и возвращается 0. Если было определено действие B<SIG_IGN> для I<signum>, то ничего не делается и возвращается . Иначе, действие сбрасывается в B<SIG_DFL>, вызывается функция действия с параметром I<signum>, а также возвращается значение, возвращенное этой функцией. Диапазон возможных значений I<signum> различен (часто он равен 1\\(en15 или 1\\(en17)."

#. type: tbl table
#: man-pages/man3/gsignal.3:108
#, no-wrap
msgid "B<gsignal>()"
msgstr "B<gsignal>()"

#. type: tbl table
#: man-pages/man3/gsignal.3:111
#, no-wrap
msgid "B<ssignal>()"
msgstr "B<ssignal>()"

#. type: tbl table
#: man-pages/man3/gsignal.3:111
#, no-wrap
msgid "MT-Safe sigintr"
msgstr "MT-Safe sigintr"

#. type: Plain text
#: man-pages/man3/gsignal.3:122
msgid ""
"These functions are available under AIX, DG/UX, HP-UX, SCO, Solaris, Tru64."
"  They are called obsolete under most of these systems, and are broken under"
" Linux libc and glibc.  Some systems also have B<gsignal_r>()  and "
"B<ssignal_r>()."
msgstr "Эти функции доступны в AIX, DG-UX, HP-UX, SCO, Solaris, Tru64. Они определены, как устаревшие в большинстве этих систем, и некорректны в Linux libc и glibc. В некоторых системах также есть функции B<gsignal_r>() и B<ssignal_r>()."

#. type: Plain text
#: man-pages/man3/gsignal.3:125
msgid "B<kill>(2), B<signal>(2), B<raise>(3)"
msgstr "B<kill>(2), B<signal>(2), B<raise>(3)"

#. type: TH
#: man-pages/man3/getlogin.3:28
#, no-wrap
msgid "GETLOGIN"
msgstr "GETLOGIN"

#. type: Plain text
#: man-pages/man3/getlogin.3:31
msgid "getlogin, getlogin_r, cuserid - get username"
msgstr "getlogin, getlogin_r, cuserid - возвращает имя пользователя"

#. type: Plain text
#: man-pages/man3/getlogin.3:35
msgid "B<char *getlogin(void);>"
msgstr "B<char *getlogin(void);>"

#. type: Plain text
#: man-pages/man3/getlogin.3:37
msgid "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"
msgstr "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"

#. type: Plain text
#: man-pages/man3/getlogin.3:39
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getlogin.3:41
msgid "B<char *cuserid(char *>I<string>B<);>"
msgstr "B<char *cuserid(char *>I<string>B<);>"

#.  Deprecated: _REENTRANT ||
#. type: Plain text
#: man-pages/man3/getlogin.3:50
msgid "B<getlogin_r>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"
msgstr "B<getlogin_r>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"

#. type: Plain text
#: man-pages/man3/getlogin.3:52
msgid "B<cuserid>():"
msgstr "B<cuserid>():"

#. type: Plain text
#: man-pages/man3/getlogin.3:58
#, no-wrap
msgid ""
"    Since glibc 2.24:\n"
"        (_XOPEN_SOURCE && ! (_POSIX_C_SOURCE E<gt>= 200112L)\n"
"        || _GNU_SOURCE\n"
"    Up to and including glibc 2.23:\n"
"        _XOPEN_SOURCE\n"
msgstr "    Начиная с glibc 2.24:\n        (_XOPEN_SOURCE && ! (_POSIX_C_SOURCE E<gt>= 200112L)\n        || _GNU_SOURCE\n    До glibc 2.23 включительно:\n        _XOPEN_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getlogin.3:68
msgid ""
"B<getlogin>()  returns a pointer to a string containing the name of the user"
" logged in on the controlling terminal of the process, or a null pointer if "
"this information cannot be determined.  The string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<cuserid>()."
msgstr "Функция B<getlogin>() возвращает указатель на строку, содержащую имя пользователя, вошедшего в систему c терминала, который является управляющим для процесса, или указатель null, если эта информация не может быть получена. Строка выделяется статически и может быть перезаписана при последующих вызовах этой функции или B<cuserid>()."

#. type: Plain text
#: man-pages/man3/getlogin.3:74
msgid ""
"B<getlogin_r>()  returns this same username in the array I<buf> of size "
"I<bufsize>."
msgstr "Функция B<getlogin_r>() возвращает то же имя пользователя, но в массиве I<buf> размером I<bufsize>."

#. type: Plain text
#: man-pages/man3/getlogin.3:86
msgid ""
"B<cuserid>()  returns a pointer to a string containing a username associated"
" with the effective user ID of the process.  If I<string> is not a null "
"pointer, it should be an array that can hold at least B<L_cuserid> "
"characters; the string is returned in this array.  Otherwise, a pointer to a"
" string in a static area is returned.  This string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<getlogin>()."
msgstr "Функция B<cuserid>() возвращает указатель на строку, содержащую имя пользователя, связанное с идентификатором эффективного пользователя процесса. Если I<string> не равно указателю null, то значение должно быть массивом, который способен вместить как минимум B<L_cuserid> символов; строка возвращается в этом массиве. В противном случае возвращается указатель на строку в фиксированной области. Эта строка выделена статически и может быть перезаписана при последующих вызовах этой функции или функции B<getlogin>()."

#. type: Plain text
#: man-pages/man3/getlogin.3:90
msgid ""
"The macro B<L_cuserid> is an integer constant that indicates how long an "
"array you might need to store a username.  B<L_cuserid> is declared in "
"I<E<lt>stdio.hE<gt>>."
msgstr "Макрос B<L_cuserid> является целочисленной константой, показывающей длину массива, который может понадобиться для хранения имени пользователя. B<L_cuserid> описан в I<E<lt>stdio.hE<gt>>."

#. type: Plain text
#: man-pages/man3/getlogin.3:97
msgid ""
"These functions let your program identify positively the user who is running"
" (B<cuserid>())  or the user who logged in this session (B<getlogin>()).  "
"(These can differ when set-user-ID programs are involved.)"
msgstr "Эти функции позволяют программе точно определить работающего пользователя (B<cuserid>()) или пользователя этого сеанса (B<getlogin>()) (значения могут различаться, если у программы установлен бит set-user-ID)."

#. type: Plain text
#: man-pages/man3/getlogin.3:102
msgid ""
"For most purposes, it is more useful to use the environment variable "
"B<LOGNAME> to find out who the user is.  This is more flexible precisely "
"because the user can set B<LOGNAME> arbitrarily."
msgstr "В большинстве случаев для определения пользователя полезнее использовать переменную окружения B<LOGNAME>, потому что пользователь может установить B<LOGNAME> каким угодно."

#. type: Plain text
#: man-pages/man3/getlogin.3:110
msgid ""
"B<getlogin>()  returns a pointer to the username when successful, and NULL "
"on failure, with I<errno> set to indicate the cause of the error.  "
"B<getlogin_r>()  returns 0 when successful, and nonzero on failure."
msgstr "При успешном выполнении функция B<getlogin>() возвращает указатель на имя пользователя и NULL при ошибке, устанавливая в I<errno> значение ошибки. При успешном выполнении B<getlogin_r>() возвращается 0 и не ноль при ошибке."

#. type: Plain text
#: man-pages/man3/getlogin.3:112
msgid "POSIX specifies"
msgstr "В POSIX определены"

#. type: Plain text
#: man-pages/man3/getlogin.3:121
msgid "The calling process has no controlling terminal."
msgstr "У вызывающего процесса нет управляющего терминала."

#. type: Plain text
#: man-pages/man3/getlogin.3:127
msgid ""
"(getlogin_r)  The length of the username, including the terminating null "
"byte (\\(aq\\e0\\(aq), is larger than I<bufsize>."
msgstr "(getlogin_r) Длина имени пользователя, включая завершающий байт null (\\(aq\\e0\\(aq), больше чем I<bufsize>."

#. type: Plain text
#: man-pages/man3/getlogin.3:129
msgid "Linux/glibc also has"
msgstr "В Linux/glibc также есть"

#. type: Plain text
#: man-pages/man3/getlogin.3:132
msgid "There was no corresponding entry in the utmp-file."
msgstr "Нет соответствующей записи в файле utmp."

#. type: Plain text
#: man-pages/man3/getlogin.3:135
msgid "Insufficient memory to allocate passwd structure."
msgstr "Недостаточно памяти для выделения под структуру passwd."

#. type: TP
#: man-pages/man3/getlogin.3:135
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: man-pages/man3/getlogin.3:139
msgid "Standard input didn't refer to a terminal.  (See BUGS.)"
msgstr "Стандартный ввод не ссылается на терминал (смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man3/getlogin.3:143
msgid "password database file"
msgstr "файл, содержащий базу паролей"

#. type: Plain text
#: man-pages/man3/getlogin.3:147
msgid "(traditionally I</etc/utmp>; some libc versions used I</var/adm/utmp>)"
msgstr "(обычно, I</etc/utmp>; в некоторых версиях libc используется I</var/adm/utmp>)"

#. type: tbl table
#: man-pages/man3/getlogin.3:157
#, no-wrap
msgid "B<getlogin>()"
msgstr "B<getlogin>()"

#. type: tbl table
#: man-pages/man3/getlogin.3:159
#, no-wrap
msgid "MT-Unsafe race:getlogin race:utent\n"
msgstr "MT-Unsafe race:getlogin race:utent\n"

#. type: tbl table
#: man-pages/man3/getlogin.3:161
#, no-wrap
msgid "sig:ALRM timer locale"
msgstr "sig:ALRM timer locale"

#. type: tbl table
#: man-pages/man3/getlogin.3:164
#, no-wrap
msgid "B<getlogin_r>()"
msgstr "B<getlogin_r>()"

#. type: tbl table
#: man-pages/man3/getlogin.3:166
#, no-wrap
msgid "MT-Unsafe race:utent sig:ALRM timer\n"
msgstr "MT-Unsafe race:utent sig:ALRM timer\n"

#. type: tbl table
#: man-pages/man3/getlogin.3:171
#, no-wrap
msgid "B<cuserid>()"
msgstr "B<cuserid>()"

#. type: tbl table
#: man-pages/man3/getlogin.3:171
#, no-wrap
msgid "MT-Unsafe race:cuserid/!string locale"
msgstr "MT-Unsafe race:cuserid/!string locale"

#. type: Plain text
#: man-pages/man3/getlogin.3:190
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<getlogin>()  and B<getlogin_r>()  call those functions, so we use "
"race:utent to remind users."
msgstr "В приведённой выше таблице I<utent> в I<race:utent> означает, что если любая из функций B<setutent>(3), B<getutent>(3) или B<endutent>(3) используется одновременно в нескольких нитях программы, то может возникнуть состязательность по данным. Эти функции вызываются из B<getlogin>() и B<getlogin_r>() поэтому мы используем race:utent для напоминания."

#. type: Plain text
#: man-pages/man3/getlogin.3:195
msgid "B<getlogin>()  and B<getlogin_r>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<getlogin>() и B<getlogin_r>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/getlogin.3:206
msgid ""
"System V has a B<cuserid>()  function which uses the real user ID rather "
"than the effective user ID.  The B<cuserid>()  function was included in the "
"1988 version of POSIX, but removed from the 1990 version.  It was present in"
" SUSv2, but removed in POSIX.1-2001."
msgstr "В System V имеется функция B<cuserid>(), использующая идентификатор реального пользователя вместо идентификатора эффективного пользователя. Функция B<cuserid>() была включена в версию POSIX 1988 года, но удалена из версии 1990 года. Она имеется в SUSv2, но удалена из POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/getlogin.3:213
msgid ""
"OpenBSD has B<getlogin>()  and B<setlogin>(), and a username associated with"
" a session, even if it has no controlling terminal."
msgstr "В OpenBSD имеются B<getlogin>() и B<setlogin>(), а имя пользователя связывается с сеансом даже если не имеется управляющего терминала."

#. type: Plain text
#: man-pages/man3/getlogin.3:225
msgid ""
"Unfortunately, it is often rather easy to fool B<getlogin>().  Sometimes it "
"does not work at all, because some program messed up the utmp file.  Often, "
"it gives only the first 8 characters of the login name.  The user currently "
"logged in on the controlling terminal of our program need not be the user "
"who started it.  Avoid B<getlogin>()  for security-related purposes."
msgstr "К сожалению, зачастую довольно просто «обмануть» B<getlogin>(). Иногда она вообще не работает из-за того, что какая-то программа испортила содержимое файла utmp. Часто функция возвращает только первые 8 символов имени. Пользователь, вошедший в систему с терминала, который является управляющим для нашей программы, необязательно будет пользователем, запустившим программу. Избегайте использования B<getlogin>() из соображений безопасности."

#. type: Plain text
#: man-pages/man3/getlogin.3:235
msgid ""
"Note that glibc does not follow the POSIX specification and uses I<stdin> "
"instead of I</dev/tty>.  A bug.  (Other recent systems, like SunOS 5.8 and "
"HP-UX 11.11 and FreeBSD 4.8 all return the login name also when I<stdin> is "
"redirected.)"
msgstr "Заметим, что glibc не следует спецификации POSIX и использует I<stdin> вместо I</dev/tty>. Дефект ( в других современных системах, например SunOS 5.8, HP-UX 11.11 и FreeBSD 4.8, также возвращают имя пользователя если было перенаправление I<stdin>)."

#. type: Plain text
#: man-pages/man3/getlogin.3:245
msgid ""
"Nobody knows precisely what B<cuserid>()  does; avoid it in portable "
"programs.  Or avoid it altogether: use I<getpwuid(geteuid())> instead, if "
"that is what you meant.  B<Do not use> B<cuserid>()."
msgstr "Никто точно не знает что делает B<cuserid>(), поэтому не используйте её в переносимых программах. Вместо неё используйте I<getpwuid(geteuid())>, если это необходимо. B<Не используйте> B<cuserid>()."

#. type: Plain text
#: man-pages/man3/getlogin.3:249
msgid "B<logname>(1), B<geteuid>(2), B<getuid>(2), B<utmp>(5)"
msgstr "B<logname>(1), B<geteuid>(2), B<getuid>(2), B<utmp>(5)"

#. type: TH
#: man-pages/man3/getutmp.3:26
#, no-wrap
msgid "GETUTMP"
msgstr "GETUTMP"

#. type: TH
#: man-pages/man3/getutmp.3:26
#, no-wrap
msgid "2015-03-02"
msgstr "2015-03-02"

#. type: Plain text
#: man-pages/man3/getutmp.3:29
msgid "getutmp, getutmpx - copy utmp structure to utmpx, and vice versa"
msgstr "getutmp, getutmpx - копирование структуры utmp в utmpx и наоборот"

#. type: Plain text
#: man-pages/man3/getutmp.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>utmpx.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>             /* См. feature_test_macros(7) */\nB<#include E<lt>utmpx.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getutmp.3:36
#, no-wrap
msgid ""
"B< void getutmp(const struct utmpx *>I<ux>B<, struct utmp *>I<u>B<);>\n"
"B< void getutmpx(const struct utmp *>I<u>B<, struct utmpx *>I<ux>B<);>\n"
msgstr "B< void getutmp(const struct utmpx *>I<ux>B<, struct utmp *>I<u>B<);>\nB< void getutmpx(const struct utmp *>I<u>B<, struct utmpx *>I<ux>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutmp.3:51
msgid ""
"The B<getutmp>()  function copies the fields of the I<utmpx> structure "
"pointed to by I<ux> to the corresponding fields of the I<utmp> structure "
"pointed to by I<u>.  The B<getutmpx>()  function performs the converse "
"operation."
msgstr "Функция B<getutmp>() копирует поля структуры I<utmpx>, указанной в I<ux> в соответствующие поля структуры I<utmp>, указанной в I<u>. Функция B<getutmpx>() выполняет обратное действие."

#. type: Plain text
#: man-pages/man3/getutmp.3:53
msgid "These functions do not return a value."
msgstr "Данные функции не возвращают никаких значений."

#. type: Plain text
#: man-pages/man3/getutmp.3:55
msgid "These functions first appeared in glibc in version 2.1.1."
msgstr "Эти функции впервые появились в glibc 2.1.1."

#. type: tbl table
#: man-pages/man3/getutmp.3:66
#, no-wrap
msgid ""
"B<getutmp>(),\n"
"B<getutmpx>()"
msgstr "B<getutmp>(),\nB<getutmpx>()"

#. type: Plain text
#: man-pages/man3/getutmp.3:71
msgid ""
"These functions are nonstandard, but appear on a few other systems, such as "
"Solaris and NetBSD."
msgstr "Эти функции являются нестандартными, но имеются в некоторых системах, например в Solaris и NetBSD."

#.  e.g., on Solaris, the utmpx structure is rather larger than utmp.
#. type: Plain text
#: man-pages/man3/getutmp.3:82
msgid ""
"These functions exist primarily for compatibility with other systems where "
"the I<utmp> and I<utmpx> structures contain different fields, or the size of"
" corresponding fields differs.  On Linux, the two structures contain the "
"same fields, and the fields have the same sizes."
msgstr "В первую очередь, эти функции существуют для совместимости с другими системами, в которых структуры I<utmp> и I<utmpx> содержат разные поля или они разного размера. В Linux эти структуры содержат одинаковые поля и они одного размера."

#. type: Plain text
#: man-pages/man3/getutmp.3:85
msgid "B<utmpdump>(1), B<getutent>(3), B<utmp>(5)"
msgstr "B<utmpdump>(1), B<getutent>(3), B<utmp>(5)"

#. type: TH
#: man-pages/man3/gnu_get_libc_version.3:26
#, no-wrap
msgid "GNU_GET_LIBC_VERSION"
msgstr "GNU_GET_LIBC_VERSION"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:29
msgid ""
"gnu_get_libc_version, gnu_get_libc_release - get glibc version and release"
msgstr "gnu_get_libc_version, gnu_get_libc_release - возвращают идентификатор версии и выпуска glibc"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:32
#, no-wrap
msgid "B<#include E<lt>gnu/libc-version.hE<gt>>\n"
msgstr "B<#include E<lt>gnu/libc-version.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:35
#, no-wrap
msgid ""
"B<const char *gnu_get_libc_version(void);>\n"
"B<const char *gnu_get_libc_release(void);>\n"
msgstr "B<const char *gnu_get_libc_version(void);>\nB<const char *gnu_get_libc_release(void);>\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:40
msgid ""
"The function B<gnu_get_libc_version>()  returns a string that identifies the"
" glibc version available on the system."
msgstr "Функция B<gnu_get_libc_version>() возвращает строку, которая описывает версию glibc, установленную в системе."

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:47
msgid ""
"The function B<gnu_get_libc_release>()  returns a string indicates the "
"release status of the glibc version available on the system.  This will be a"
" string such as I<stable>."
msgstr "Функция B<gnu_get_libc_release>() возвращает строку, которая описывает состояние выпуска версии glibc, установленной в системе. Обычно, возвращается строка I<stable>."

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:49
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: tbl table
#: man-pages/man3/gnu_get_libc_version.3:60
#, no-wrap
msgid ""
"B<gnu_get_libc_version>(),\n"
"B<gnu_get_libc_release>()"
msgstr "B<gnu_get_libc_version>(),\nB<gnu_get_libc_release>()"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:64
msgid "These functions are glibc-specific."
msgstr "Эти функции есть только в glibc."

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:66
msgid "When run, the program below will produce output such as the following:"
msgstr "Нижеследующая программа выдает такие результаты:"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:72
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"GNU libc version: 2.8\n"
"GNU libc release: stable\n"
msgstr "$B< ./a.out>\nВерсия GNU libc: 2.8\nВыпуск GNU libc: stable\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:80
#, no-wrap
msgid ""
"#include E<lt>gnu/libc-version.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>gnu/libc-version.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:88
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"GNU libc version: %s\\en\", gnu_get_libc_version());\n"
"    printf(\"GNU libc release: %s\\en\", gnu_get_libc_release());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    printf(\"Версия GNU libc: %s\\en\", gnu_get_libc_version());\n    printf(\"Выпуск GNU libc: %s\\en\", gnu_get_libc_release());\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:90
msgid "B<confstr>(3)"
msgstr "B<confstr>(3)"

#. type: TH
#: man-pages/man3/getttyent.3:7
#, no-wrap
msgid "GETTTYENT"
msgstr "GETTTYENT"

#. type: Plain text
#: man-pages/man3/getttyent.3:10
msgid "getttyent, getttynam, setttyent, endttyent - get ttys file entry"
msgstr "getttyent, getttynam, setttyent, endttyent - возвращает запись из файла ttys"

#. type: Plain text
#: man-pages/man3/getttyent.3:12
msgid "B<#include E<lt>ttyent.hE<gt>>"
msgstr "B<#include E<lt>ttyent.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getttyent.3:14
msgid "B<struct ttyent *getttyent(void);>"
msgstr "B<struct ttyent *getttyent(void);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:16
msgid "B<struct ttyent *getttynam(const char *>I<name>B<);>"
msgstr "B<struct ttyent *getttynam(const char *>I<name>B<);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:18
msgid "B<int setttyent(void);>"
msgstr "B<int setttyent(void);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:20
msgid "B<int endttyent(void);>"
msgstr "B<int endttyent(void);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:25
msgid ""
"These functions provide an interface to the file B<_PATH_TTYS> (e.g., "
"I</etc/ttys>)."
msgstr "Эти функции предоставляют интерфейс к файлу из B<_PATH_TTYS> (например, I</etc/ttys>)."

#. type: Plain text
#: man-pages/man3/getttyent.3:29
msgid ""
"The function B<setttyent>()  opens the file or rewinds it if already open."
msgstr "Функция B<setttyent>() открывает файл или сбрасывает указатель чтения на начало, если он уже открыт."

#. type: Plain text
#: man-pages/man3/getttyent.3:33
msgid "The function B<endttyent>()  closes the file."
msgstr "Функция B<endttyent>() закрывает файл."

#. type: Plain text
#: man-pages/man3/getttyent.3:40
msgid ""
"The function B<getttynam>()  searches for a given terminal name in the file."
"  It returns a pointer to a I<ttyent> structure (description below)."
msgstr "Функция B<getttynam>() ищет заданное имя терминала в файле. Возвращается указатель на структуру I<ttyent> (описана далее)."

#. type: Plain text
#: man-pages/man3/getttyent.3:50
msgid ""
"The function B<getttyent>()  opens the file B<_PATH_TTYS> (if necessary) and"
" returns the first entry.  If the file is already open, the next entry.  The"
" I<ttyent> structure has the form:"
msgstr "Функция B<getttyent>() открывает файл из переменной B<_PATH_TTYS> (если требуется) и возвращает его первую запись. Если файл уже открыт, то возвращается его следующая запись. Структура I<ttyent>:"

#. type: Plain text
#: man-pages/man3/getttyent.3:61
#, no-wrap
msgid ""
"struct ttyent {\n"
"    char *ty_name;     /* terminal device name */\n"
"    char *ty_getty;    /* command to execute, usually getty */\n"
"    char *ty_type;     /* terminal type for termcap */\n"
"    int   ty_status;   /* status flags */\n"
"    char *ty_window;   /* command to start up window manager */\n"
"    char *ty_comment;  /* comment field */\n"
"};\n"
msgstr "struct ttyent {\n    char *ty_name;     /* имя устройства терминала */\n    char *ty_getty;    /* команда для исполнения, обычно getty */\n    char *ty_type;     /* тип терминала для termcap */\n    int   ty_status;   /* флаги состояния */\n    char *ty_window;   /* команда для запуска менеджера окон */\n    char *ty_comment;  /* поле комментария */\n};\n"

#. type: Plain text
#: man-pages/man3/getttyent.3:66
msgid "I<ty_status> can be:"
msgstr "Значением I<ty_status> может быть:"

#. type: Plain text
#: man-pages/man3/getttyent.3:71
#, no-wrap
msgid ""
"#define TTY_ON     0x01  /* enable logins (start ty_getty program) */\n"
"#define TTY_SECURE 0x02  /* allow UID 0 to login */\n"
msgstr "#define TTY_ON     0x01  /* разрешить регистрации\n                            (запускаемые программой ty_getty) */\n#define TTY_SECURE 0x02  /* разрешить регистрацию с UID 0 */\n"

#. type: tbl table
#: man-pages/man3/getttyent.3:86
#, no-wrap
msgid ""
"B<getttyent>(),\n"
"B<setttyent>(),\n"
"B<endttyent>(),\n"
"B<getttynam>()"
msgstr "B<getttyent>(),\nB<setttyent>(),\nB<endttyent>(),\nB<getttynam>()"

#. type: tbl table
#: man-pages/man3/getttyent.3:86
#, no-wrap
msgid "MT-Unsafe race:ttyent"
msgstr "MT-Unsafe race:ttyent"

#. type: Plain text
#: man-pages/man3/getttyent.3:91
msgid "Not in POSIX.1.  Present on the BSDs, and perhaps other systems."
msgstr "Нет в POSIX.1. Присутствует в BSD и, возможно, во многих других системах."

#. type: Plain text
#: man-pages/man3/getttyent.3:95
msgid ""
"Under Linux, the file I</etc/ttys>, and the functions described above, are "
"not used."
msgstr "В Linux файл I</etc/ttys> и описанные выше функции не используются."

#. type: Plain text
#: man-pages/man3/getttyent.3:97
msgid "B<ttyname>(3), B<ttyslot>(3)"
msgstr "B<ttyname>(3), B<ttyslot>(3)"

#. type: TH
#: man-pages/man3/group_member.3:25
#, no-wrap
msgid "GROUP_MEMBER"
msgstr "GROUP_MEMBER"

#. type: TH
#: man-pages/man3/group_member.3:25
#, no-wrap
msgid "2014-03-30"
msgstr "2014-03-30"

#. type: Plain text
#: man-pages/man3/group_member.3:28
msgid "group_member - test whether a process is in a group"
msgstr "group_member - проверяет присутствие процесса в группе"

#. type: Plain text
#: man-pages/man3/group_member.3:32
msgid "B<int group_member(gid_t >I<gid>B<);>"
msgstr "B<int group_member(gid_t >I<gid>B<);>"

#. type: Plain text
#: man-pages/man3/group_member.3:40
msgid "B<group_member>(): _GNU_SOURCE"
msgstr "B<group_member>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/group_member.3:48
msgid ""
"The B<group_member>()  function tests whether any of the caller's "
"supplementary group IDs (as returned by B<getgroups>(2))  matches I<gid>."
msgstr "Функция B<group_member>() проверяет, совпадает ли какой-либо ID дополнительных групп вызывающего (возвращаемые B<getgroups>(2)) с I<gid>."

#. type: Plain text
#: man-pages/man3/group_member.3:55
msgid ""
"The B<group_member>()  function returns nonzero if any of the caller's "
"supplementary group IDs matches I<gid>, and zero otherwise."
msgstr "Функция B<group_member>() возвращает не ноль, если какой-либо ID дополнительных групп совпал с I<gid>, и ноль в противном случае."

#. type: Plain text
#: man-pages/man3/group_member.3:57
msgid "This function is a nonstandard GNU extension."
msgstr "Эта функция является нестандартным расширением GNU."

#. type: Plain text
#: man-pages/man3/group_member.3:61
msgid "B<getgid>(2), B<getgroups>(2), B<getgrouplist>(3), B<group>(5)"
msgstr "B<getgid>(2), B<getgroups>(2), B<getgrouplist>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/getrpcent.3:8
#, no-wrap
msgid "GETRPCENT"
msgstr "GETRPCENT"

#. type: Plain text
#: man-pages/man3/getrpcent.3:12
msgid ""
"getrpcent, getrpcbyname, getrpcbynumber, setrpcent, endrpcent - get RPC "
"entry"
msgstr "getrpcent, getrpcbyname, getrpcbynumber, setrpcent, endrpcent - возвращают запись RPC"

#. type: Plain text
#: man-pages/man3/getrpcent.3:17
#, no-wrap
msgid "B<struct rpcent *getrpcent(void);>\n"
msgstr "B<struct rpcent *getrpcent(void);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:19
#, no-wrap
msgid "B<struct rpcent *getrpcbyname(const char *>I<name>B<);>\n"
msgstr "B<struct rpcent *getrpcbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:21
#, no-wrap
msgid "B<struct rpcent *getrpcbynumber(int >I<number>B<);>\n"
msgstr "B<struct rpcent *getrpcbynumber(int >I<number>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:23
#, no-wrap
msgid "B<void setrpcent(int >I<stayopen>B<);>\n"
msgstr "B<void setrpcent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:25
#, no-wrap
msgid "B<void endrpcent(void);>\n"
msgstr "B<void endrpcent(void);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:36
msgid ""
"The B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  functions "
"each return a pointer to an object with the following structure containing "
"the broken-out fields of an entry in the RPC program number data base."
msgstr "Функции B<getrpcent>(), B<getrpcbyname>() и B<getrpcbynumber>() возвращают указатель на объект с описанной ниже структурой, содержащую разделённую на поля запись из базы данных номеров программы RPC."

#. type: Plain text
#: man-pages/man3/getrpcent.3:44
#, no-wrap
msgid ""
"struct rpcent {\n"
"    char  *r_name;     /* name of server for this RPC program */\n"
"    char **r_aliases;  /* alias list */\n"
"    long   r_number;   /* RPC program number */\n"
"};\n"
msgstr "struct rpcent {\n    char  *r_name;     /* имя сервера для этой программы RPC */\n    char **r_aliases;  /* список псевдонимов */\n    long   r_number;   /* номер программы RPC */\n};\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:48
msgid "The members of this structure are:"
msgstr "Члены структуры:"

#. type: TP
#: man-pages/man3/getrpcent.3:49
#, no-wrap
msgid "I<r_name>"
msgstr "I<r_name>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:52
msgid "The name of the server for this RPC program."
msgstr "Имя сервера для этой программы RPC."

#. type: TP
#: man-pages/man3/getrpcent.3:52
#, no-wrap
msgid "I<r_aliases>"
msgstr "I<r_aliases>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:55
msgid "A NULL-terminated list of alternate names for the RPC program."
msgstr "Список альтернативных имён программы RPC, завершающийся NULL."

#. type: TP
#: man-pages/man3/getrpcent.3:55
#, no-wrap
msgid "I<r_number>"
msgstr "I<r_number>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:58
msgid "The RPC program number for this service."
msgstr "Номер программы RPC для этой службы."

#. type: Plain text
#: man-pages/man3/getrpcent.3:64
msgid ""
"The B<getrpcent>()  function reads the next entry from the database.  A "
"connection is opened to the database if necessary."
msgstr "Функция B<getrpcent>() считывает следующую запись из базы данных. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getrpcent.3:76
msgid ""
"The B<setrpcent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getrpc*>()  functions."
msgstr "Функция B<setrpcent>() открывает соединение к базе и устанавливает следующую запись к первой записи. Если I<stayopen> не равен нулю, то подключение к базе между вызовами нескольких функций B<getrpc*>() не будет закрыто."

#. type: Plain text
#: man-pages/man3/getrpcent.3:80
msgid "The B<endrpcent>()  function closes the connection to the database."
msgstr "Функция B<endrpcent>() закрывает подключение к базе."

#. type: Plain text
#: man-pages/man3/getrpcent.3:88
msgid ""
"The B<getrpcbyname>()  and B<getrpcbynumber>()  functions sequentially "
"search from the beginning of the file until a matching RPC program name or "
"program number is found, or until end-of-file is encountered."
msgstr "Функции B<getrpcbyname>() и B<getrpcbynumber>() выполняют последовательный поиск от начала файла до нахождения имени программы RPC, её номера или конца файла."

#. type: Plain text
#: man-pages/man3/getrpcent.3:98
msgid ""
"On success, B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  "
"return a pointer to a statically allocated I<rpcent> structure.  NULL is "
"returned on EOF or error."
msgstr "При успешном выполнении B<getrpcent>(), B<getrpcbyname>() и B<getrpcbynumber>() возвращают указатель на статически выделенную структуру I<rpcent>. При ошибке или EOF возвращается NULL."

#. type: TP
#: man-pages/man3/getrpcent.3:99
#, no-wrap
msgid "I</etc/rpc>"
msgstr "I</etc/rpc>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:102
msgid "RPC program number database."
msgstr "база данных программных номеров RPC"

#. type: tbl table
#: man-pages/man3/getrpcent.3:113
#, no-wrap
msgid ""
"B<getrpcent>(),\n"
"B<getrpcbyname>(),\n"
msgstr "B<getrpcent>(),\nB<getrpcbyname>(),\n"

#. type: tbl table
#: man-pages/man3/getrpcent.3:115
#, no-wrap
msgid "B<getrpcbynumber>()"
msgstr "B<getrpcbynumber>()"

#. type: tbl table
#: man-pages/man3/getrpcent.3:119
#, no-wrap
msgid ""
"B<setrpcent>(),\n"
"B<endrpcent>()"
msgstr "B<setrpcent>(),\nB<endrpcent>()"

#. type: Plain text
#: man-pages/man3/getrpcent.3:130
msgid ""
"All information is contained in a static area so it must be copied if it is "
"to be saved."
msgstr "Вся информация располагается в статической области, поэтому для сохранения должна быть скопирована."

#. type: Plain text
#: man-pages/man3/getrpcent.3:134
msgid "B<getrpcent_r>(3), B<rpc>(5), B<rpcinfo>(8), B<ypserv>(8)"
msgstr "B<getrpcent_r>(3), B<rpc>(5), B<rpcinfo>(8), B<ypserv>(8)"

#. type: TH
#: man-pages/man3/get_nprocs_conf.3:26
#, no-wrap
msgid "GET_NPROCS"
msgstr "GET_NPROCS"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:29
msgid "get_nprocs, get_nprocs_conf - get number of processors"
msgstr "get_nprocs, get_nprocs_conf - возвращает количество процессоров"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:31
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr "B<#include E<lt>sys/sysinfo.hE<gt>>"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:33
msgid "B<int get_nprocs(void);>"
msgstr "B<int get_nprocs(void);>"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:35
msgid "B<int get_nprocs_conf(void);>"
msgstr "B<int get_nprocs_conf(void);>"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:39
msgid ""
"The function B<get_nprocs_conf>()  returns the number of processors "
"configured by the operating system."
msgstr "Функция B<get_nprocs_conf>() возвращает количество процессоров, настроенных операционной системой."

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:46
msgid ""
"The function B<get_nprocs>()  returns the number of processors currently "
"available in the system.  This may be less than the number returned by "
"B<get_nprocs_conf>()  because processors may be offline (e.g., on "
"hotpluggable systems)."
msgstr "Функция B<get_nprocs>() возвращает количество процессоров, доступных в системе. Это значение может быть меньше чем возвращаемое B<get_nprocs_conf>(), так как процессоры могут быть выключены (например, в системах с подключением на ходу)."

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:48
msgid "As given in DESCRIPTION."
msgstr "Как указано в ОПИСАНИИ."

#. type: tbl table
#: man-pages/man3/get_nprocs_conf.3:58
#, no-wrap
msgid "B<get_nprocs>(),\n"
msgstr "B<get_nprocs>(),\n"

#. type: tbl table
#: man-pages/man3/get_nprocs_conf.3:60
#, no-wrap
msgid "B<get_nprocs_conf>()"
msgstr "B<get_nprocs_conf>()"

#.  glibc 2.15
#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:72
msgid ""
"The current implementation of these functions is rather expensive, since "
"they open and parse files in the I</sys> filesystem each time they are "
"called."
msgstr "Текущая реализация этих функций не оптимальна, так как при каждом вызове открываются и обрабатываются файлы в файловой системе I</sys>."

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:77
msgid ""
"The following B<sysconf>(3)  calls make use of the functions documented on "
"this page to return the same information."
msgstr "Следующие вызовы B<sysconf>(3) возвращают тоже что и описанные здесь функции."

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:82
#, no-wrap
msgid ""
"np = sysconf(_SC_NPROCESSORS_CONF);     /* processors configured */\n"
"np = sysconf(_SC_NPROCESSORS_ONLN);     /* processors available */\n"
msgstr "np = sysconf(_SC_NPROCESSORS_CONF);     /* настроенных процессоров */\nnp = sysconf(_SC_NPROCESSORS_ONLN);     /* доступных процессоров */\n"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:90
msgid ""
"The following example shows how B<get_nprocs>()  and B<get_nprocs_conf>()  "
"can be used."
msgstr "В следующем примере показано использование B<get_nprocs>() и B<get_nprocs_conf>()."

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:95
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>sys/sysinfo.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %d processors configured and \"\n"
"            \"%d processors available.\\en\",\n"
"            get_nprocs_conf(), get_nprocs());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    printf(\"В системе настроено %d процессоров и \"\n            \"%d процессоров доступно.\\en\",\n            get_nprocs_conf(), get_nprocs());\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:106
msgid "B<nproc>(1)"
msgstr "B<nproc>(1)"

#. type: TH
#: man-pages/man3/getifaddrs.3:36
#, no-wrap
msgid "GETIFADDRS"
msgstr "GETIFADDRS"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:39
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr "getifaddrs, freeifaddrs - возвращают адреса интерфейса"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>ifaddrs.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:45
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:47
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:58
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing"
" the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr "Функция B<getifaddrs>() создаёт связный список структур, описывающих сетевые интерфейсы локальной системы, и сохраняет адрес первого элемента списка в I<*ifap>. Список состоит из структур I<ifaddrs>:"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:77
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr "struct ifaddrs {\n    struct ifaddrs  *ifa_next;    /* след. элемент в списке */\n    char            *ifa_name;    /* имя интерфейса */\n    unsigned int     ifa_flags;   /* флаги из SIOCGIFFLAGS */\n    struct sockaddr *ifa_addr;    /* адрес интерфейса */\n    struct sockaddr *ifa_netmask; /* сетевая маска интерфейса */\n    union {\n        struct sockaddr *ifu_broadaddr;\n                         /* широковещательный адрес интерфейса */\n        struct sockaddr *ifu_dstaddr;\n                         /* адрес назначения точка-точка */\n    } ifa_ifu;\n#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n    void            *ifa_data;    /* спец. данные для адреса */\n};\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:84
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr "В поле I<ifa_next> содержится указатель на следующую структуру в списке или NULL, если это последний элемент в списке."

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: man-pages/man3/getifaddrs.3:91
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr "Поле I<ifa_name> указывает на имя интерфейса (заканчивающееся null)."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:100
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr "В поле I<ifa_flags> содержатся флаги интерфейса, полученные операцией B<SIOCGIFFLAGS> B<ioctl>(2) (список флагов приведён в B<netdevice>(7))."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:109
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)  This field may contain a null pointer."
msgstr "Поле I<ifa_addr> указывает на структуру, содержащую адрес интерфейса (для определения формата структуры адреса обратитесь к подполю I<sa_family>). Это поле может содержать указатель null."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:116
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family.  This "
"field may contain a null pointer."
msgstr "Поле I<ifa_netmask> указывает на структуру, содержащую маску сети для I<ifa_addr> (если она используется в адресном семействе). Это поле может содержать указатель null."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:131
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr "В зависимости от наличия флага B<IFF_BROADCAST> или B<IFF_POINTOPOINT> в I<ifa_flags> (может быть установлен какой-то один), в I<ifa_broadaddr> будет содержаться широковещательный адрес I<ifa_addr> (если он используется в адресном семействе) или I<ifa_dstaddr> будет содержать адрес назначения интерфейса типа точка-точка."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:136
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr "Поле I<ifa_data> указывает на буфер, содержащий данные, присущие адресному семейству; это поле может быть равно NULL, если данных для этого интерфейса нет."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:142
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be"
" freed using B<freeifaddrs>()  when no longer needed."
msgstr "Память под структуру данных, возвращаемая B<getifaddrs>(), выделяется динамически и должна освобождаться с помощью B<freeifaddrs>(), когда больше не нужна."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:149
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "При успешном выполнении B<getifaddrs>() возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:162
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), B<malloc>(3), or B<realloc>(3)."
msgstr "Функция B<getifaddrs>() может завершиться с ошибками и назначить переменной I<errno> значения, перечисленные в B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), B<sendto>(2), B<malloc>(3) или B<realloc>(3)."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:170
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation supported only IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is "
"available only on kernels that support netlink."
msgstr "Впервые функция B<getifaddrs>() появилась в glibc 2.3, но до glibc 2.3.3 реализация поддерживала только интерфейсы с адресами IPv4; поддержка IPv6 добавлена в glibc 2.3.3. Поддержка семейств адресов не IPv4 доступна только в ядрах, поддерживающих netlink."

#. type: tbl table
#: man-pages/man3/getifaddrs.3:181
#, no-wrap
msgid ""
"B<getifaddrs>(),\n"
"B<freeifaddrs>()"
msgstr "B<getifaddrs>(),\nB<freeifaddrs>()"

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: man-pages/man3/getifaddrs.3:204
msgid ""
"Not in POSIX.1.  This function first appeared in BSDi and is present on the "
"BSD systems, but with slightly different semantics documented\\(emreturning "
"one entry per interface, not per address.  This means I<ifa_addr> and other "
"fields can actually be NULL if the interface has no address, and no link-"
"level address is returned if the interface has an IP address assigned.  "
"Also, the way of choosing either I<ifa_broadaddr> or I<ifa_dstaddr> differs "
"on various systems."
msgstr "Нет в POSIX.1. Данная функция впервые появилась в BSDi и существует в системах BSD, но со слегка другой семантикой — возвращается одна запись на интерфейс, а не на адрес. Это означает, что I<ifa_addr> и другие поля могут быть равны NULL, если интерфейс не имеет адресов, и адрес канального уровня не возвращается, если интерфейсу назначен IP-адрес. Также в разных системах различается способ выбора между I<ifa_broadaddr> и I<ifa_dstaddr>."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:221
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"rtnl_link_stats>, defined in I<E<lt>linux/if_link.hE<gt>> (in Linux 2.4 and "
"earlier, I<struct net_device_stats>, defined in "
"I<E<lt>linux/netdevice.hE<gt>>), which contains various interface attributes"
" and statistics."
msgstr "Адреса, возвращаемые в Linux, обычно, являются адресами IPv4 и IPv6, назначенными интерфейсу, но также есть один адрес B<AF_PACKET> на интерфейс, содержащий канальные настройки интерфейса и его физический уровень. В этом случае поле I<ifa_data> может содержать указатель на I<struct rtnl_link_stats>, определённую в I<E<lt>linux/if_link.hE<gt>> (в Linux 2.4 и ранее — I<struct net_device_stats>, определена в I<E<lt>linux/netdevice.hE<gt>>), которая содержит различные атрибуты интерфейса и статистику."

#. type: Plain text
#: man-pages/man3/getifaddrs.3:228
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(),"
" and B<getnameinfo>(3).  Here is what we see when running this program on "
"one system:"
msgstr "В программе, показанной далее, демонстрируется использование B<getifaddrs>(), B<freeifaddrs>(), и B<getnameinfo>(3). Вот результат запуска этой программы:"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:249
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo       AF_PACKET (17)\n"
"                tx_packets =        524; rx_packets =        524\n"
"                tx_bytes   =      38788; rx_bytes   =      38788\n"
"wlp3s0   AF_PACKET (17)\n"
"                tx_packets =     108391; rx_packets =     130245\n"
"                tx_bytes   =   30420659; rx_bytes   =   94230014\n"
"em1      AF_PACKET (17)\n"
"                tx_packets =          0; rx_packets =          0\n"
"                tx_bytes   =          0; rx_bytes   =          0\n"
"lo       AF_INET (2)\n"
"                address: E<lt>127.0.0.1E<gt>\n"
"wlp3s0   AF_INET (2)\n"
"                address: E<lt>192.168.235.137E<gt>\n"
"lo       AF_INET6 (10)\n"
"                address: E<lt>::1E<gt>\n"
"wlp3s0   AF_INET6 (10)\n"
"                address: E<lt>fe80::7ee9:d3ff:fef5:1a91%wlp3s0E<gt>\n"
msgstr "$ B<./a.out>\nlo       AF_PACKET (17)\n                tx_packets =        524; rx_packets =        524\n                tx_bytes   =      38788; rx_bytes   =      38788\nwlp3s0   AF_PACKET (17)\n                tx_packets =     108391; rx_packets =     130245\n                tx_bytes   =   30420659; rx_bytes   =   94230014\nem1      AF_PACKET (17)\n                tx_packets =          0; rx_packets =          0\n                tx_bytes   =          0; rx_bytes   =          0\nlo       AF_INET (2)\n                адрес: E<lt>127.0.0.1E<gt>\nwlp3s0   AF_INET (2)\n                адрес: E<lt>192.168.235.137E<gt>\nlo       AF_INET6 (10)\n                адрес: E<lt>::1E<gt>\nwlp3s0   AF_INET6 (10)\n                адрес: E<lt>fe80::7ee9:d3ff:fef5:1a91%wlp3s0E<gt>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:263
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get defns of NI_MAXSERV and NI_MAXHOST */\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/if_link.hE<gt>\n"
msgstr "#define _GNU_SOURCE     /* чтобы получить NI_MAXSERV и NI_MAXHOST */\n#include E<lt>arpa/inet.hE<gt>\n#include E<lt>sys/socket.hE<gt>\n#include E<lt>netdb.hE<gt>\n#include E<lt>ifaddrs.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>linux/if_link.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:269
#, no-wrap
msgid ""
"int main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr, *ifa;\n"
"    int family, s, n;\n"
"    char host[NI_MAXHOST];\n"
msgstr "int main(int argc, char *argv[])\n{\n    struct ifaddrs *ifaddr, *ifa;\n    int family, s, n;\n    char host[NI_MAXHOST];\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:274
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (getifaddrs(&ifaddr) == -1) {\n        perror(\"getifaddrs\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:277
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr "    /* обходим связный список, сохраняя начальный указатель, чтобы\n       освободить список позже */\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:281
#, no-wrap
msgid ""
"    for (ifa = ifaddr, n = 0; ifa != NULL; ifa = ifa-E<gt>ifa_next, n++) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr "    for (ifa = ifaddr, n = 0; ifa != NULL; ifa = ifa-E<gt>ifa_next, n++) {\n        if (ifa-E<gt>ifa_addr == NULL)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:283
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:286
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr "        /* вывод имени интерфейса и семейства (включая символический\n           вид для общих семейств) */\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:293
#, no-wrap
msgid ""
"        printf(\"%-8s %s (%d)\\en\",\n"
"               ifa-E<gt>ifa_name,\n"
"               (family == AF_PACKET) ? \"AF_PACKET\" :\n"
"               (family == AF_INET) ? \"AF_INET\" :\n"
"               (family == AF_INET6) ? \"AF_INET6\" : \"???\",\n"
"               family);\n"
msgstr "        printf(\"%-8s %s (%d)\\en\",\n               ifa-E<gt>ifa_name,\n               (family == AF_PACKET) ? \"AF_PACKET\" :\n               (family == AF_INET) ? \"AF_INET\" :\n               (family == AF_INET6) ? \"AF_INET6\" : \"???\",\n               family);\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:295
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr "        /* для адресов интерфейса AF_INET* показываем адрес */\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:306
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST,\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr "        if (family == AF_INET || family == AF_INET6) {\n            s = getnameinfo(ifa-E<gt>ifa_addr,\n                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n                                          sizeof(struct sockaddr_in6),\n                    host, NI_MAXHOST,\n                    NULL, 0, NI_NUMERICHOST);\n            if (s != 0) {\n                printf(\"ошибка getnameinfo(): %s\\en\", gai_strerror(s));\n                exit(EXIT_FAILURE);\n            }\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:308
#, no-wrap
msgid "            printf(\"\\et\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
msgstr "            printf(\"\\et\\etадрес: E<lt>%sE<gt>\\en\", host);\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:311
#, no-wrap
msgid ""
"        } else if (family == AF_PACKET && ifa-E<gt>ifa_data != NULL) {\n"
"            struct rtnl_link_stats *stats = ifa-E<gt>ifa_data;\n"
msgstr "        } else if (family == AF_PACKET && ifa-E<gt>ifa_data != NULL) {\n            struct rtnl_link_stats *stats = ifa-E<gt>ifa_data;\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:318
#, no-wrap
msgid ""
"            printf(\"\\et\\ettx_packets = %10u; rx_packets = %10u\\en\"\n"
"                   \"\\et\\ettx_bytes   = %10u; rx_bytes   = %10u\\en\",\n"
"                   stats-E<gt>tx_packets, stats-E<gt>rx_packets,\n"
"                   stats-E<gt>tx_bytes, stats-E<gt>rx_bytes);\n"
"        }\n"
"    }\n"
msgstr "            printf(\"\\et\\ettx_packets = %10u; rx_packets = %10u\\en\"\n                   \"\\et\\ettx_bytes   = %10u; rx_bytes   = %10u\\en\",\n                   stats-E<gt>tx_packets, stats-E<gt>rx_packets,\n                   stats-E<gt>tx_bytes, stats-E<gt>rx_bytes);\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:322
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    freeifaddrs(ifaddr);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:328
msgid ""
"B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr "B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"

#. type: TH
#: man-pages/man3/getline.3:26
#, no-wrap
msgid "GETLINE"
msgstr "GETLINE"

#. type: Plain text
#: man-pages/man3/getline.3:29
msgid "getline, getdelim - delimited string input"
msgstr "getline, getdelim - разделяет входные данные на строки"

#. type: Plain text
#: man-pages/man3/getline.3:34
#, no-wrap
msgid ""
"B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE "
"*>I<stream>B<);>\n"
msgstr "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getline.3:37
#, no-wrap
msgid ""
"B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, "
"FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getline.3:47
msgid "B<getline>(), B<getdelim>():"
msgstr "B<getline>(), B<getdelim>():"

#. type: TP
#: man-pages/man3/getline.3:49
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man3/getline.3:52
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man3/getline.3:52
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man3/getline.3:65
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is null-"
"terminated and includes the newline character, if one was found."
msgstr "Функция B<getline>() считывает целую строку из I<stream>, сохраняет адрес буфера с текстом в I<*lineptr>. Буфер завершается null и включает символ новой строки, если был найден разделитель для новой строки."

#. type: Plain text
#: man-pages/man3/getline.3:77
msgid ""
"If I<*lineptr> is set to NULL and I<*n> is set 0 before the call, then "
"B<getline>()  will allocate a buffer for storing the line.  This buffer "
"should be freed by the user program even if B<getline>()  failed."
msgstr "Если I<*lineptr> равно NULL и I<*n> равно 0 перед вызовом, то B<getline>() выделит буфер для хранения строки. Этот буфер должен быть высвобожден программой пользователя, даже если B<getline>() завершилась с ошибкой."

#. type: Plain text
#: man-pages/man3/getline.3:95
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr "Как альтернатива, перед вызовом B<getline>(), I<*lineptr> может содержать указатель на буфер, выделенный с помощью B<malloc>(3) размером I<*n> байтов. Если буфер недостаточно велик для размещения строки, то B<getline>() изменяет размер буфера с помощью B<realloc>(3), обновляя I<*lineptr> и I<*n> при необходимости."

#. type: Plain text
#: man-pages/man3/getline.3:101
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr "В любом случае при успешном выполнении вызова I<*lineptr> и I<*n> будут содержать правильный адрес буфера и его размер, соответственно."

#. type: Plain text
#: man-pages/man3/getline.3:112
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr "Функция B<getdelim>() работает аналогично B<getline>(), за исключением того, что в аргументе I<delimiter> можно задать разделитель строки, отличный от символа новой строки. Как и с B<getline>(), символ-разделитель не добавляется, если его было в входных данных до конца файла."

#. type: Plain text
#: man-pages/man3/getline.3:121
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters"
" read, including the delimiter character, but not including the terminating "
"null byte (\\(aq\\e0\\(aq).  This value can be used to handle embedded null "
"bytes in the line read."
msgstr "При успешном выполнении B<getline>() и B<getdelim>() возвращают количество считанных символов, включая символ разделителя, но не включая завершающий байт null (\\(aq\\e0\\(aq). Это значение может использоваться для обработки встроенных байтов null при чтении строки."

#. type: Plain text
#: man-pages/man3/getline.3:127
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition).  In the event of an error, I<errno> is set to indicate the "
"cause."
msgstr "Обе функции возвращают -1 при ошибках чтения строки (включая условие достижения конца файла). При возникновении ошибки в I<errno> сохраняется её значение."

#. type: Plain text
#: man-pages/man3/getline.3:137
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr "Некорректные параметры (I<n> или I<lineptr> равно NULL или неправильное значение I<stream>)."

#. type: Plain text
#: man-pages/man3/getline.3:140
msgid "Allocation or reallocation of the line buffer failed."
msgstr "Не удалось выделить или переместить строчный буфер."

#. type: tbl table
#: man-pages/man3/getline.3:151
#, no-wrap
msgid ""
"B<getline>(),\n"
"B<getdelim>()"
msgstr "B<getline>(),\nB<getdelim>()"

#. type: Plain text
#: man-pages/man3/getline.3:161
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr "Изначально, функции B<getline>() и B<getdelim>() были расширениями GNU. Позднее они были стандартизированы в POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/getline.3:166
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getline.3:174
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *stream;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t nread;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    FILE *stream;\n    char *line = NULL;\n    size_t len = 0;\n    ssize_t nread;\n"

#. type: Plain text
#: man-pages/man3/getline.3:179
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s E<lt>файлE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getline.3:185
#, no-wrap
msgid ""
"    stream = fopen(argv[1], \"r\");\n"
"    if (stream == NULL) {\n"
"        perror(\"fopen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    stream = fopen(argv[1], \"r\");\n    if (stream == NULL) {\n        perror(\"fopen\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getline.3:190
#, no-wrap
msgid ""
"    while ((nread = getline(&line, &len, stream)) != -1) {\n"
"        printf(\"Retrieved line of length %zu:\\en\", nread);\n"
"        fwrite(line, nread, 1, stdout);\n"
"    }\n"
msgstr "    while ((nread = getline(&line, &len, stream)) != -1) {\n        printf(\"Retrieved line of length %zu:\\en\", nread);\n        fwrite(line, nread, 1, stdout);\n    }\n"

#. type: Plain text
#: man-pages/man3/getline.3:195
#, no-wrap
msgid ""
"    free(line);\n"
"    fclose(stream);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    free(line);\n    fclose(stream);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getline.3:201
msgid "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<scanf>(3)"
msgstr "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<scanf>(3)"

#. type: Plain text
#: man-pages/man3/glob.3:37
msgid ""
"glob, globfree - find pathnames matching a pattern, free memory from glob()"
msgstr "glob, globfree - ищет имена путей по шаблону, освобождает память после glob()"

#. type: Plain text
#: man-pages/man3/glob.3:40
#, no-wrap
msgid "B<#include E<lt>glob.hE<gt>>\n"
msgstr "B<#include E<lt>glob.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/glob.3:45
#, no-wrap
msgid ""
"B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"
"B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int >I<eerrno>B<),>\n"
"B<         glob_t *>I<pglob>B<);>\n"
"B<void globfree(glob_t *>I<pglob>B<);>\n"
msgstr "B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\nB<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int >I<eerrno>B<),>\nB<         glob_t *>I<pglob>B<);>\nB<void globfree(glob_t *>I<pglob>B<);>\n"

#. type: Plain text
#: man-pages/man3/glob.3:56
msgid ""
"The B<glob>()  function searches for all the pathnames matching I<pattern> "
"according to the rules used by the shell (see B<glob>(7)).  No tilde "
"expansion or parameter substitution is done; if you want these, use "
"B<wordexp>(3)."
msgstr "Функция B<glob>() ищет все совпадения имён путей с заданным шаблоном I<pattern>, согласно правилам, используемым оболочкой (смотрите B<glob>(7)). Расширения тильды или подстановка параметров не выполняется; если это нужно, то используйте B<wordexp>(3)."

#. type: Plain text
#: man-pages/man3/glob.3:62
msgid ""
"The B<globfree>()  function frees the dynamically allocated storage from an "
"earlier call to B<glob>()."
msgstr "Функция B<globfree>() освобождает динамически выделенное хранилище, полученное в последнем вызове B<glob>()."

#. type: Plain text
#: man-pages/man3/glob.3:73
msgid ""
"The results of a B<glob>()  call are stored in the structure pointed to by "
"I<pglob>.  This structure is of type I<glob_t> (declared in "
"I<E<lt>glob.hE<gt>>)  and includes the following elements defined by POSIX.2"
" (more may be present as an extension):"
msgstr "Результаты вызова B<glob>() сохраняются в структуре, на которую указывает I<pglob>. Эта структура имеет тип I<glob_t> (объявлен в I<E<lt>glob.hE<gt>>) и содержит следующие элементы, определённые в POSIX.2 (их может быть и больше, в виде расширений):"

#. type: Plain text
#: man-pages/man3/glob.3:81
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t   gl_pathc;    /* Count of paths matched so far  */\n"
"    char   **gl_pathv;    /* List of matched pathnames.  */\n"
"    size_t   gl_offs;     /* Slots to reserve in I<gl_pathv>.  */\n"
"} glob_t;\n"
msgstr "typedef struct {\n    size_t   gl_pathc;    /* количество совпавших путей  */\n    char   **gl_pathv;    /* список совпавших имён путей.  */\n    size_t   gl_offs;     /* зарезервированные в I<gl_pathv> слоты.  */\n} glob_t;\n"

#. type: Plain text
#: man-pages/man3/glob.3:85
msgid "Results are stored in dynamically allocated storage."
msgstr "Результаты размещаются в динамически выделяемом хранилище."

#. type: Plain text
#: man-pages/man3/glob.3:91
msgid ""
"The argument I<flags> is made up of the bitwise OR of zero or more the "
"following symbolic constants, which modify the behavior of B<glob>():"
msgstr "Значение параметра I<flags> формируется побитовым сложением нуля или более следующих символических констант, которые меняют ход работы B<glob>():"

#. type: TP
#: man-pages/man3/glob.3:91
#, no-wrap
msgid "B<GLOB_ERR>"
msgstr "B<GLOB_ERR>"

#. type: Plain text
#: man-pages/man3/glob.3:99
msgid ""
"Return upon a read error (because a directory does not have read permission,"
" for example).  By default, B<glob>()  attempts carry on despite errors, "
"reading all of the directories that it can."
msgstr "Выполнять возврат при ошибке чтения (например, нет прав для чтения каталога). По умолчанию B<glob>() пытается продолжить работу не смотря на ошибки, читая все каталоги, которые может."

#. type: TP
#: man-pages/man3/glob.3:99
#, no-wrap
msgid "B<GLOB_MARK>"
msgstr "B<GLOB_MARK>"

#. type: Plain text
#: man-pages/man3/glob.3:102
msgid "Append a slash to each path which corresponds to a directory."
msgstr "Добавлять косую черту к каждому пути, который соответствует каталогу."

#. type: TP
#: man-pages/man3/glob.3:102
#, no-wrap
msgid "B<GLOB_NOSORT>"
msgstr "B<GLOB_NOSORT>"

#. type: Plain text
#: man-pages/man3/glob.3:107
msgid ""
"Don't sort the returned pathnames.  The only reason to do this is to save "
"processing time.  By default, the returned pathnames are sorted."
msgstr "Не сортировать возвращаемые имена. Это экономит процессорное время. По умолчанию имена сортируются."

#. type: TP
#: man-pages/man3/glob.3:107
#, no-wrap
msgid "B<GLOB_DOOFFS>"
msgstr "B<GLOB_DOOFFS>"

#. type: Plain text
#: man-pages/man3/glob.3:114
msgid ""
"Reserve I<pglob-E<gt>gl_offs> slots at the beginning of the list of strings "
"in I<pglob-E<gt>pathv>.  The reserved slots contain null pointers."
msgstr "Резервировать слоты I<pglob-E<gt>gl_offs> у начала списка строк в I<pglob-E<gt>pathv>. Зарезервированные слоты содержат указатели null."

#. type: TP
#: man-pages/man3/glob.3:114
#, no-wrap
msgid "B<GLOB_NOCHECK>"
msgstr "B<GLOB_NOCHECK>"

#. type: Plain text
#: man-pages/man3/glob.3:122
msgid ""
"If no pattern matches, return the original pattern.  By default, B<glob>()  "
"returns B<GLOB_NOMATCH> if there are no matches."
msgstr "Если не найдено совпадений по шаблону, возвращать в качестве результата заданный шаблон. По умолчанию при отсутствии совпадений B<glob>() возвращает B<GLOB_NOMATCH>."

#. type: TP
#: man-pages/man3/glob.3:122
#, no-wrap
msgid "B<GLOB_APPEND>"
msgstr "B<GLOB_APPEND>"

#. type: Plain text
#: man-pages/man3/glob.3:129
msgid ""
"Append the results of this call to the vector of results returned by a "
"previous call to B<glob>().  Do not set this flag on the first invocation of"
" B<glob>()."
msgstr "Добавлять результаты вызова к вектору результатов, полученному от предыдущего вызова B<glob>(). Не следует включать этот флаг при первом вызове B<glob>()."

#. type: TP
#: man-pages/man3/glob.3:129
#, no-wrap
msgid "B<GLOB_NOESCAPE>"
msgstr "B<GLOB_NOESCAPE>"

#. type: Plain text
#: man-pages/man3/glob.3:136
msgid ""
"Don't allow backslash (\\(aq\\e\\(aq) to be used as an escape character.  "
"Normally, a backslash can be used to quote the following character, "
"providing a mechanism to turn off the special meaning metacharacters."
msgstr "Не использовать символы обратной косой черты (\\(aq\\e\\(aq) в качестве экранирующего символа. Обычно, обратная косая черта может использоваться для экранирования следующего символа, таким образом предоставляя механизм для выключения специального значения метасимволов."

#. type: Plain text
#: man-pages/man3/glob.3:140
msgid ""
"I<flags> may also include any of the following, which are GNU extensions and"
" not defined by POSIX.2:"
msgstr "В I<flags> также могу быть включены следующие флаги, которые являются расширениями GNU и отсутствуют в POSIX.2:"

#. type: TP
#: man-pages/man3/glob.3:140
#, no-wrap
msgid "B<GLOB_PERIOD>"
msgstr "B<GLOB_PERIOD>"

#. type: Plain text
#: man-pages/man3/glob.3:144
msgid ""
"Allow a leading period to be matched by metacharacters.  By default, "
"metacharacters can't match a leading period."
msgstr "Разрешить начальной точке соответствовать метасимволам. По умолчанию метасимволы не считаются совпадающими с начальной точкой."

#. type: TP
#: man-pages/man3/glob.3:144
#, no-wrap
msgid "B<GLOB_ALTDIRFUNC>"
msgstr "B<GLOB_ALTDIRFUNC>"

#. type: Plain text
#: man-pages/man3/glob.3:154
msgid ""
"Use alternative functions I<pglob-E<gt>gl_closedir>, "
"I<pglob-E<gt>gl_readdir>, I<pglob-E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat>, "
"and I<pglob-E<gt>gl_stat> for filesystem access instead of the normal "
"library functions."
msgstr "Для доступа к файловой системе использовать функции I<pglob-E<gt>gl_closedir>, I<pglob-E<gt>gl_readdir>, I<pglob-E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat> и I<pglob-E<gt>gl_stat> вместо стандартных библиотечных функций."

#. type: TP
#: man-pages/man3/glob.3:154
#, no-wrap
msgid "B<GLOB_BRACE>"
msgstr "B<GLOB_BRACE>"

#. type: Plain text
#: man-pages/man3/glob.3:170
msgid ""
"Expand B<csh>(1)  style brace expressions of the form B<{a,b}>.  Brace "
"expressions can be nested.  Thus, for example, specifying the pattern "
"\"{foo/{,cat,dog},bar}\" would return the same results as four separate "
"B<glob>()  calls using the strings: \"foo/\", \"foo/cat\", \"foo/dog\", and "
"\"bar\"."
msgstr "Раскрывать выражения в фигурных скобках B<{a,b}> аналогичны используемым в B<csh>(1). Выражения могут быть вложенными. То есть, например, по шаблону \"{foo/{,cat,dog},bar}\" возвращаются те же результаты что и при четырёх отдельных вызовах B<glob>() со строками: \"foo/\", \"foo/cat\", \"foo/dog\" и \"bar\"."

#. type: TP
#: man-pages/man3/glob.3:170
#, no-wrap
msgid "B<GLOB_NOMAGIC>"
msgstr "B<GLOB_NOMAGIC>"

#. type: Plain text
#: man-pages/man3/glob.3:175
msgid ""
"If the pattern contains no metacharacters, then it should be returned as the"
" sole matching word, even if there is no file with that name."
msgstr "Возвращать сам шаблон, если в нём не содержатся метасимволы, даже при отсутствии файла с таким именем."

#. type: TP
#: man-pages/man3/glob.3:175
#, no-wrap
msgid "B<GLOB_TILDE>"
msgstr "B<GLOB_TILDE>"

#. type: Plain text
#: man-pages/man3/glob.3:187
msgid ""
"Carry out tilde expansion.  If a tilde (\\(aq~\\(aq) is the only character "
"in the pattern, or an initial tilde is followed immediately by a slash "
"(\\(aq/\\(aq), then the home directory of the caller is substituted for the "
"tilde.  If an initial tilde is followed by a username (e.g., "
"\"~andrea/bin\"), then the tilde and username are substituted by the home "
"directory of that user.  If the username is invalid, or the home directory "
"cannot be determined, then no substitution is performed."
msgstr "Выполнять расширения тильды. Если тильда (\\(aq~\\(aq) — единственный символ в шаблоне или после начальной тильды сразу указана косая черта (\\(aq/\\(aq), то вместо тильды подставляется домашний каталог вызывающего Если после начальной тильды указано имя пользователя (например, \"~andrea/bin\"), то вместо тильды и имени пользователя подставляется домашний каталог этого пользователя. Если имя пользователя некорректно или домашний каталог невозможно определить, то подстановка не выполняется."

#. type: TP
#: man-pages/man3/glob.3:187
#, no-wrap
msgid "B<GLOB_TILDE_CHECK>"
msgstr "B<GLOB_TILDE_CHECK>"

#. type: Plain text
#: man-pages/man3/glob.3:198
msgid ""
"This provides behavior similar to that of B<GLOB_TILDE>.  The difference is "
"that if the username is invalid, or the home directory cannot be determined,"
" then instead of using the pattern itself as the name, B<glob>()  returns "
"B<GLOB_NOMATCH> to indicate an error."
msgstr "Поведение подобно B<GLOB_TILDE>. Отличие в том, что если имя пользователя некорректно или домашний каталог невозможно определить, то вместо использования самого шаблона как имени, B<glob>() возвращает B<GLOB_NOMATCH> для указания на ошибку."

#. type: TP
#: man-pages/man3/glob.3:198
#, no-wrap
msgid "B<GLOB_ONLYDIR>"
msgstr "B<GLOB_ONLYDIR>"

#. type: Plain text
#: man-pages/man3/glob.3:211
msgid ""
"This is a I<hint> to B<glob>()  that the caller is interested only in "
"directories that match the pattern.  If the implementation can easily "
"determine file-type information, then nondirectory files are not returned to"
" the caller.  However, the caller must still check that returned files are "
"directories.  (The purpose of this flag is merely to optimize performance "
"when the caller is interested only in directories.)"
msgstr "Это только I<указание> B<glob>() на то, что вызывающего интересуют только каталоги, соответствующие шаблону. Если реализация может легко определить информацию о типе файла, то файлы не каталоги не возвращаются вызывающему. Однако, вызывающий всё равно должен проверять, что полученные файлы — каталоги (назначение этого флага — все лишь оптимизация производительности в случае, когда вызывающему нужны только каталоги)."

#. type: Plain text
#: man-pages/man3/glob.3:234
msgid ""
"If I<errfunc> is not NULL, it will be called in case of an error with the "
"arguments I<epath>, a pointer to the path which failed, and I<eerrno>, the "
"value of I<errno> as returned from one of the calls to B<opendir>(3), "
"B<readdir>(3), or B<stat>(2).  If I<errfunc> returns nonzero, or if "
"B<GLOB_ERR> is set, B<glob>()  will terminate after the call to I<errfunc>."
msgstr "Если I<errfunc> не равно NULL, то в случае ошибки она будет вызвана с параметрами I<epath> (указатель на путь, в котором произошла ошибка) и I<eerrno> (полученное значение I<errno> после вызова одной из функций B<opendir>(3), B<readdir>(3) или B<stat>(2)).Если I<errfunc> вернёт ненулевое значение или если флаг B<GLOB_ERR> установлен, то B<glob>() закончит работу после вызова I<errfunc>."

#. type: Plain text
#: man-pages/man3/glob.3:241
msgid ""
"Upon successful return, I<pglob-E<gt>gl_pathc> contains the number of "
"matched pathnames and I<pglob-E<gt>gl_pathv> contains a pointer to the list "
"of pointers to matched pathnames.  The list of pointers is terminated by a "
"null pointer."
msgstr "При успешном выполнении в I<pglob-E<gt>gl_pathc> содержится количество совпадающих имён, а I<pglob-E<gt>gl_pathv> содержит указатель на список указателей на найденные имена. Список указателей завершается указателем null."

#. type: Plain text
#: man-pages/man3/glob.3:250
msgid ""
"It is possible to call B<glob>()  several times.  In that case, the "
"B<GLOB_APPEND> flag has to be set in I<flags> on the second and later "
"invocations."
msgstr "Вызов B<glob>() может выполняться несколько раз. В этом случае флаг B<GLOB_APPEND> должен быть включён в I<flags> при втором и последующих вызовах."

#. type: Plain text
#: man-pages/man3/glob.3:258
msgid ""
"As a GNU extension, I<pglob-E<gt>gl_flags> is set to the flags specified, "
"B<or>ed with B<GLOB_MAGCHAR> if any metacharacters were found."
msgstr "Как расширение GNU, при обнаружении метасимволов I<pglob-E<gt>gl_flags> — набор задаваемых флагов, сложенный с B<GLOB_MAGCHAR> (с помощью операции ИЛИ)."

#. type: Plain text
#: man-pages/man3/glob.3:263
msgid ""
"On successful completion, B<glob>()  returns zero.  Other possible returns "
"are:"
msgstr "При успешном выполнении B<glob>() возвращает ноль. Другие возможные возвращаемые значения:"

#. type: TP
#: man-pages/man3/glob.3:263
#, no-wrap
msgid "B<GLOB_NOSPACE>"
msgstr "B<GLOB_NOSPACE>"

#. type: Plain text
#: man-pages/man3/glob.3:266
msgid "for running out of memory,"
msgstr "занята вся свободная память"

#. type: TP
#: man-pages/man3/glob.3:266
#, no-wrap
msgid "B<GLOB_ABORTED>"
msgstr "B<GLOB_ABORTED>"

#. type: Plain text
#: man-pages/man3/glob.3:269
msgid "for a read error, and"
msgstr "ошибка чтения"

#. type: TP
#: man-pages/man3/glob.3:269
#, no-wrap
msgid "B<GLOB_NOMATCH>"
msgstr "B<GLOB_NOMATCH>"

#. type: Plain text
#: man-pages/man3/glob.3:272
msgid "for no found matches."
msgstr "не найдено совпадений с шаблоном"

#. type: tbl table
#: man-pages/man3/glob.3:282
#, no-wrap
msgid "B<glob>()"
msgstr "B<glob>()"

#. type: tbl table
#: man-pages/man3/glob.3:284
#, no-wrap
msgid "MT-Unsafe race:utent env\n"
msgstr "MT-Unsafe race:utent env\n"

#. type: tbl table
#: man-pages/man3/glob.3:289
#, no-wrap
msgid "B<globfree>()"
msgstr "B<globfree>()"

#. type: Plain text
#: man-pages/man3/glob.3:306
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<glob>()  calls those functions, so we use race:utent to remind users."
msgstr "В приведённой выше таблице I<utent> в I<race:utent> означает, что если любая из функций B<setutent>(3), B<getutent>(3) или B<endutent>(3) используется одновременно в нескольких нитях программы, то может возникнуть состязательность по данным. Эти функции вызываются из B<glob>(), поэтому мы используем race:utent для напоминания."

#. type: Plain text
#: man-pages/man3/glob.3:308
msgid "POSIX.1-2001, POSIX.1-2008, POSIX.2."
msgstr "POSIX.1-2001, POSIX.1-2008, POSIX.2."

#. type: Plain text
#: man-pages/man3/glob.3:319
msgid ""
"The structure elements I<gl_pathc> and I<gl_offs> are declared as I<size_t> "
"in glibc 2.1, as they should be according to POSIX.2, but are declared as "
"I<int> in glibc 2.0."
msgstr "Элементы структуры I<gl_pathc> и I<gl_offs> объявлены с типом I<size_t> в glibc 2.1 (как и должны указываться, согласно POSIX.2), но указаны как I<int> в glibc 2.0."

#. type: Plain text
#: man-pages/man3/glob.3:328
msgid ""
"The B<glob>()  function may fail due to failure of underlying function "
"calls, such as B<malloc>(3)  or B<opendir>(3).  These will store their error"
" code in I<errno>."
msgstr "Функция B<glob>() может завершиться с ошибкой из-за ошибок в используемых её функций: B<malloc>(3) или B<opendir>(3). Эти функции записывают коды своих ошибок в переменную I<errno>."

#. type: Plain text
#: man-pages/man3/glob.3:330
msgid "One example of use is the following code, which simulates typing"
msgstr "Пример использования приводится ниже, в нём имитируется набор строки"

#. type: Plain text
#: man-pages/man3/glob.3:334
#, no-wrap
msgid "ls -l *.c ../*.c\n"
msgstr "ls -l *.c ../*.c\n"

#. type: Plain text
#: man-pages/man3/glob.3:338
msgid "in the shell:"
msgstr "в оболочке:"

#. type: Plain text
#: man-pages/man3/glob.3:342
#, no-wrap
msgid "glob_t globbuf;\n"
msgstr "glob_t globbuf;\n"

#. type: Plain text
#: man-pages/man3/glob.3:349
#, no-wrap
msgid ""
"globbuf.gl_offs = 2;\n"
"glob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\n"
"glob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\n"
"globbuf.gl_pathv[0] = \"ls\";\n"
"globbuf.gl_pathv[1] = \"-l\";\n"
"execvp(\"ls\", &globbuf.gl_pathv[0]);\n"
msgstr "globbuf.gl_offs = 2;\nglob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\nglob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\nglobbuf.gl_pathv[0] = \"ls\";\nglobbuf.gl_pathv[1] = \"-l\";\nexecvp(\"ls\", &globbuf.gl_pathv[0]);\n"

#. type: Plain text
#: man-pages/man3/glob.3:361
msgid ""
"B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"
msgstr "B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"

#. type: TH
#: man-pages/man3/getaddrinfo_a.3:30
#, no-wrap
msgid "GETADDRINFO_A"
msgstr "GETADDRINFO_A"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:34
msgid ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - asynchronous network "
"address and service translation"
msgstr "getaddrinfo_a, gai_suspend, gai_error, gai_cancel - асинхронная трансляция сетевого адреса и службы"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:38
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* См. feature_test_macros(7) */\nB<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:41
#, no-wrap
msgid ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr "B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\nB<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:44
#, no-wrap
msgid ""
"B<int gai_suspend(const struct gaicb * const >I<list[]>B<, int >I<nitems>B<,>\n"
"B<                const struct timespec *>I<timeout>B<);>\n"
msgstr "B<int gai_suspend(const struct gaicb * const >I<list[]>B<, int >I<nitems>B<,>\nB<                const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:46
#, no-wrap
msgid "B<int gai_error(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_error(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:48
#, no-wrap
msgid "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:50
#, no-wrap
msgid "Link with I<-lanl>.\n"
msgstr "Компонуется при указании параметра I<-lanl>.\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:58
msgid ""
"The B<getaddrinfo_a>()  function performs the same task as "
"B<getaddrinfo>(3), but allows multiple name look-ups to be performed "
"asynchronously, with optional notification on completion of look-up "
"operations."
msgstr "Функция B<getaddrinfo_a>() выполняет ту же задачу что и B<getaddrinfo>(3), но позволяет выполнять поиск нескольких имён асинхронно, с дополнительным уведомлением о завершении операций поиска."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:62
msgid "The I<mode> argument has one of the following values:"
msgstr "В аргументе I<mode> указывается одно из следующих значений:"

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:62
#, no-wrap
msgid "B<GAI_WAIT>"
msgstr "B<GAI_WAIT>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:66
msgid ""
"Perform the look-ups synchronously.  The call blocks until the look-ups have"
" completed."
msgstr "Выполнять поиск синхронно. Вызов блокирует выполнение пока поиск не завершится."

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:66
#, no-wrap
msgid "B<GAI_NOWAIT>"
msgstr "B<GAI_NOWAIT>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:74
msgid ""
"Perform the look-ups asynchronously.  The call returns immediately, and the "
"requests are resolved in the background.  See the discussion of the I<sevp> "
"argument below."
msgstr "Выполнять поиск асинхронно. Вызов сразу завершается и запросы обрабатываются в фоновом режиме. Смотрите далее описание параметра I<sevp>."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:89
msgid ""
"The array I<list> specifies the look-up requests to process.  The I<nitems> "
"argument specifies the number of elements in I<list>.  The requested look-up"
" operations are started in parallel.  NULL elements in I<list> are ignored."
"  Each request is described by a I<gaicb> structure, defined as follows:"
msgstr "В массиве I<list> задаются запросы на обработку. В аргументе I<nitems> задаётся количество элементов в I<list>. Запрашиваемые операции поиска начинаются параллельно. Элементы NULL в списке I<list> игнорируются. Каждый запрос описывается структурой I<gaicb>, которая определена следующим образом:"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:98
#, no-wrap
msgid ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"
msgstr "struct gaicb {\n    const char            *ar_name;\n    const char            *ar_service;\n    const struct addrinfo *ar_request;\n    struct addrinfo       *ar_result;\n};\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:129
msgid ""
"The elements of this structure correspond to the arguments of "
"B<getaddrinfo>(3).  Thus, I<ar_name> corresponds to the I<node> argument and"
" I<ar_service> to the I<service> argument, identifying an Internet host and "
"a service.  The I<ar_request> element corresponds to the I<hints> argument, "
"specifying the criteria for selecting the returned socket address "
"structures.  Finally, I<ar_result> corresponds to the I<res> argument; you "
"do not need to initialize this element, it will be automatically set when "
"the request is resolved.  The I<addrinfo> structure referenced by the last "
"two elements is described in B<getaddrinfo>(3)."
msgstr "Элементы данной структуры совпадают с аргументами B<getaddrinfo>(3). То есть I<ar_name> соответствует аргументу I<node>, а I<ar_service> аргументу I<service> (определяют узел Интернета и службу). Элемент I<ar_request> соответствует аргументу I<hints>; им задаётся критерий выбора структуры возвращаемого адреса сокета. И, наконец, I<ar_result> соответствует аргументу I<res>; вам не нужно инициализировать этот элемент, он будет заполнен автоматически в результате запроса. Структура I<addrinfo>, на которую ссылаются последние два элемента, описана в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:145
msgid ""
"When I<mode> is specified as B<GAI_NOWAIT>, notifications about resolved "
"requests can be obtained by employing the I<sigevent> structure pointed to "
"by the I<sevp> argument.  For the definition and general details of this "
"structure, see B<sigevent>(7).  The I<sevp-E<gt>sigev_notify> field can have"
" the following values:"
msgstr "Если значение I<mode> равно B<GAI_NOWAIT>, то уведомления о обработанных запросах можно получить из структуры I<sigevent>, на которую указывает  аргумент I<sevp>. Определение и описание данной структуры приведено в B<sigevent>(7). Поле I<sevp-E<gt>sigev_notify> может иметь следующие значения:"

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:145
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:148
msgid "Don't provide any notification."
msgstr "Отключить уведомление."

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:148
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#.  si_pid and si_uid are also set, to the values of the calling process,
#.  which doesn't provide useful information, so we'll skip mentioning it.
#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:164
msgid ""
"When a look-up completes, generate the signal I<sigev_signo> for the "
"process.  See B<sigevent>(7)  for general details.  The I<si_code> field of "
"the I<siginfo_t> structure will be set to B<SI_ASYNCNL>."
msgstr "При завершении поиска послать процессу сигнал I<sigev_signo>. Подробности смотрите в B<sigevent>(7). Полю I<si_code> структуры I<siginfo_t> присваивается значение B<SI_ASYNCNL>."

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:164
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:172
msgid ""
"When a look-up completes, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr "При завершении поиска вызвать I<sigev_notify_function>, как если бы с этой функции начиналась бы новая нить. Подробности смотрите в B<sigevent>(7)."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:181
msgid ""
"For B<SIGEV_SIGNAL> and B<SIGEV_THREAD>, it may be useful to point "
"I<sevp-E<gt>sigev_value.sival_ptr> to I<list>."
msgstr "При B<SIGEV_SIGNAL> и B<SIGEV_THREAD>, может быть полезно, чтобы I<sevp-E<gt>sigev_value.sival_ptr> указывала на I<list>."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:192
msgid ""
"The B<gai_suspend>()  function suspends execution of the calling thread, "
"waiting for the completion of one or more requests in the array I<list>.  "
"The I<nitems> argument specifies the size of the array I<list>.  The call "
"blocks until one of the following occurs:"
msgstr "Функция B<gai_suspend>() приостанавливает выполнение вызывающей нити, ожидая завершения поиска одного или более запросов из массива I<list>. В аргументе I<nitems> задаётся размер массива I<list>. Вызов блокирует выполнение пока не произойдёт одно из следующего:"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:196
msgid "One or more of the operations in I<list> completes."
msgstr "Завершится операция для одного или более запросов из I<list>."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:198
msgid "The call is interrupted by a signal that is caught."
msgstr "Вызов прервётся пойманным сигналом."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:211
msgid ""
"The time interval specified in I<timeout> elapses.  This argument specifies "
"a timeout in seconds plus nanoseconds (see B<nanosleep>(2)  for details of "
"the I<timespec> structure).  If I<timeout> is NULL, then the call blocks "
"indefinitely (until one of the events above occurs)."
msgstr "Временной интервал ожидания задаётся в I<timeout>. В данном аргумента указывается промежуток в секундах плюс наносекундах (о структуре I<timespec>  смотрите B<nanosleep>(2)). Если I<timeout> равно NULL, то вызов блокирует выполнение навсегда (пока не произойдёт одно из событий выше)."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:216
msgid ""
"No explicit indication of which request was completed is given; you must "
"determine which request(s) have completed by iterating with B<gai_error>()  "
"over the list of requests."
msgstr "При выполнении явно не указывается какие запросы завершены; для определения вам нужно обойти весь список запросов с помощью B<gai_error>()."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:226
msgid ""
"The B<gai_error>()  function returns the status of the request I<req>: "
"either B<EAI_INPROGRESS> if the request was not completed yet, 0 if it was "
"handled successfully, or an error code if the request could not be resolved."
msgstr "Функция B<gai_error>() возвращает состояние запроса I<req>: B<EAI_INPROGRESS> — запрос пока не выполнен, 0 — обработан успешно, код ошибки — запрос невозможно обработать."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:243
msgid ""
"The B<gai_cancel>()  function cancels the request I<req>.  If the request "
"has been canceled successfully, the error status of the request will be set "
"to B<EAI_CANCELED> and normal asynchronous notification will be performed.  "
"The request cannot be canceled if it is currently being processed; in that "
"case, it will be handled as if B<gai_cancel>()  has never been called.  If "
"I<req> is NULL, an attempt is made to cancel all outstanding requests that "
"the process has made."
msgstr "Функция B<gai_cancel>()  отменяет запрос I<req>. При успешной отмене состояние ошибки устанавливается в B<EAI_CANCELED> и выполняется обычное асинхронное уведомление. Запрос не может быть отменён, если он начал обрабатываться; в этом случае действие будет доведено до конца, как если бы вызова B<gai_cancel>() не происходило. Если I<req> равно NULL, то будет предпринята попытка отменить все имеющиеся запросы."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:248
msgid ""
"The B<getaddrinfo_a>()  function returns 0 if all of the requests have been "
"enqueued successfully, or one of the following nonzero error codes:"
msgstr "Функция B<getaddrinfo_a>() возвращает 0, если все запросы были успешно обработаны или один из следующих ненулевых кодов ошибки:"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:253
msgid ""
"The resources necessary to enqueue the look-up requests were not available."
"  The application may check the error status of each request to determine "
"which ones failed."
msgstr "Недоступны ресурсы, необходимые, чтобы постановки запросов поиска в очередь. Для нахождения проблемного приложение может проверить состояние ошибки каждого запроса."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:260
msgid "I<mode> is invalid."
msgstr "Неверное значение I<mode>."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:265
msgid ""
"The B<gai_suspend>()  function returns 0 if at least one of the listed "
"requests has been completed.  Otherwise, it returns one of the following "
"nonzero error codes:"
msgstr "Функция B<gai_suspend>() возвращает 0, если завершён хотя бы один из запросов. В противном случае возвращается один из следующих ненулевых кодов ошибки:"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:268
msgid ""
"The given timeout expired before any of the requests could be completed."
msgstr "Указанный интервал истёк до завершения хотят бы одного из запросов."

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:268 man-pages/man3/getaddrinfo_a.3:298
#, no-wrap
msgid "B<EAI_ALLDONE>"
msgstr "B<EAI_ALLDONE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:271
msgid "There were no actual requests given to the function."
msgstr "В функцию не было передано никаких фактических запросов."

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:271
#, no-wrap
msgid "B<EAI_INTR>"
msgstr "B<EAI_INTR>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:276
msgid ""
"A signal has interrupted the function.  Note that this interruption might "
"have been caused by signal notification of some completed look-up request."
msgstr "Функция прервана сигналом. Заметим, что такое прерывание может быть вызвано сигналом уведомления о каком-то выполненном запросе."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:288
msgid ""
"The B<gai_error>()  function can return B<EAI_INPROGRESS> for an unfinished "
"look-up request, 0 for a successfully completed look-up (as described "
"above), one of the error codes that could be returned by B<getaddrinfo>(3), "
"or the error code B<EAI_CANCELED> if the request has been canceled "
"explicitly before it could be finished."
msgstr "Функция B<gai_error>() может вернуть B<EAI_INPROGRESS> для незаконченных запросов поиска, 0 при успешном поиске (как описано выше), один из кодов ошибок, которые может вернуть B<getaddrinfo>(3) или код ошибки B<EAI_CANCELED>, если запрос был отменён явно до завершения."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:292
msgid "The B<gai_cancel>()  function can return one of these values:"
msgstr "Функция B<gai_cancel>() может вернуть одно из следующих значений:"

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:292
#, no-wrap
msgid "B<EAI_CANCELED>"
msgstr "B<EAI_CANCELED>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:295
msgid "The request has been canceled successfully."
msgstr "Запрос успешно отменён."

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:295
#, no-wrap
msgid "B<EAI_NOTCANCELED>"
msgstr "B<EAI_NOTCANCELED>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:298
msgid "The request has not been canceled."
msgstr "Запрос не был отменён."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:301
msgid "The request has already completed."
msgstr "Запрос уже выполнен."

#. type: tbl table
#: man-pages/man3/getaddrinfo_a.3:319
#, no-wrap
msgid ""
"B<getaddrinfo_a>(),\n"
"B<gai_suspend>(),\n"
"B<gai_error>(),\n"
"B<gai_cancel>()"
msgstr "B<getaddrinfo_a>(),\nB<gai_suspend>(),\nB<gai_error>(),\nB<gai_cancel>()"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:325
msgid ""
"These functions are GNU extensions; they first appeared in glibc in version "
"2.2.3."
msgstr "Эти функции являются расширениями GNU, доступными в glibc начиная с версии 2.2.3."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:331
msgid ""
"The interface of B<getaddrinfo_a>()  was modeled after the B<lio_listio>(3)"
"  interface."
msgstr "Интерфейс B<getaddrinfo_a>() был создан после интерфейса B<lio_listio>(3)."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:335
msgid ""
"Two examples are provided: a simple example that resolves several requests "
"in parallel synchronously, and a complex example showing some of the "
"asynchronous capabilities."
msgstr "Вот два примера: простой пример выполнения нескольких запросов синхронно одновременно, и сложный пример, показывающий асинхронные возможности."

#. type: SS
#: man-pages/man3/getaddrinfo_a.3:335
#, no-wrap
msgid "Synchronous example"
msgstr "Синхронный пример"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:340
msgid ""
"The program below simply resolves several hostnames in parallel, giving a "
"speed-up compared to resolving the hostnames sequentially using "
"B<getaddrinfo>(3).  The program might be used like this:"
msgstr "Эта программа определяет несколько имён узлов параллельно, что быстрее по сравнению с определением имён последовательно с помощью B<getaddrinfo>(3). Результат работы программы:"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:347
#, no-wrap
msgid ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"
msgstr "$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\nftp.us.kernel.org: 128.30.2.36\nenoent.linuxfoundation.org: Name or service not known\ngnu.cz: 87.236.197.13\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:351
msgid "Here is the program source code"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:358 man-pages/man3/getaddrinfo_a.3:447
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>netdb.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:366
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int i, ret;\n    struct gaicb *reqs[argc - 1];\n    char host[NI_MAXHOST];\n    struct addrinfo *res;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:371
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 2) {\n        fprintf(stderr, \"Использование: %s УЗЕЛ...\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:381
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"
msgstr "    for (i = 0; i E<lt> argc - 1; i++) {\n        reqs[i] = malloc(sizeof(*reqs[0]));\n        if (reqs[i] == NULL) {\n            perror(\"malloc\");\n            exit(EXIT_FAILURE);\n        }\n        memset(reqs[i], 0, sizeof(*reqs[0]));\n        reqs[i]-E<gt>ar_name = argv[i + 1];\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:388
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n    if (ret != 0) {\n        fprintf(stderr, \"ошибка getaddrinfo_a(): %s\\en\",\n                gai_strerror(ret));\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:394
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr "    for (i = 0; i E<lt> argc - 1; i++) {\n        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n        ret = gai_error(reqs[i]);\n        if (ret == 0) {\n            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:404
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
msgstr "            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n                    host, sizeof(host),\n                    NULL, 0, NI_NUMERICHOST);\n            if (ret != 0) {\n                fprintf(stderr, \"ошибка getnameinfo(): %s\\en\",\n                        gai_strerror(ret));\n                exit(EXIT_FAILURE);\n            }\n            puts(host);\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:411
#, no-wrap
msgid ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "        } else {\n            puts(gai_strerror(ret));\n        }\n    }\n    exit(EXIT_SUCCESS);\n}\n"

#. type: SS
#: man-pages/man3/getaddrinfo_a.3:412
#, no-wrap
msgid "Asynchronous example"
msgstr "Асинхронный пример"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:417
msgid ""
"This example shows a simple interactive B<getaddrinfo_a>()  front-end.  The "
"notification facility is not demonstrated."
msgstr "Данный пример — простая интерактивная оболочка к B<getaddrinfo_a>(). Возможности уведомления не используются."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:419
msgid "An example session might look like this:"
msgstr "Результат работы программы:"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:436
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"
msgstr "$ B<./a.out>\nE<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\nE<gt> c 2\n[2] gnu.cz: Request not canceled\nE<gt> w 0 1\n[00] ftp.us.kernel.org: Выполнено\nE<gt> l\n[00] ftp.us.kernel.org: 216.165.129.139\n[01] enoent.linuxfoundation.org: Processing request in progress\n[02] gnu.cz: 87.236.197.13\nE<gt> l\n[00] ftp.us.kernel.org: 216.165.129.139\n[01] enoent.linuxfoundation.org: Name or service not known\n[02] gnu.cz: 87.236.197.13\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:440
msgid "The program source is as follows:"
msgstr "Исходный код программы:"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:450
#, no-wrap
msgid ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"
msgstr "static struct gaicb **reqs = NULL;\nstatic int nreqs = 0;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:455
#, no-wrap
msgid ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"
msgstr "static char *\ngetcmd(void)\n{\n    static char buf[256];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:459
#, no-wrap
msgid ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"
msgstr "    fputs(\"E<gt> \", stdout); fflush(stdout);\n    if (fgets(buf, sizeof(buf), stdin) == NULL)\n        return NULL;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:462
#, no-wrap
msgid ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"
msgstr "    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n        buf[strlen(buf) - 1] = 0;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:465
#, no-wrap
msgid ""
"    return buf;\n"
"}\n"
msgstr "    return buf;\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:473
#, no-wrap
msgid ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"
msgstr "/* добавление запросов задаваемых имён */\nstatic void\nadd_requests(void)\n{\n    int nreqs_base = nreqs;\n    char *host;\n    int ret;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:477
#, no-wrap
msgid ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"
msgstr "    while ((host = strtok(NULL, \" \"))) {\n        nreqs++;\n        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:481
#, no-wrap
msgid ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"
msgstr "        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:483
#, no-wrap
msgid "    /* Queue nreqs_base..nreqs requests. */\n"
msgstr "    /* очередь запросов nreqs_base..nreqs. */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:492
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr "    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n                        nreqs - nreqs_base, NULL);\n    if (ret) {\n        fprintf(stderr, \"ошибка getaddrinfo_a(): %s\\en\",\n                gai_strerror(ret));\n        exit(EXIT_FAILURE);\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:501
#, no-wrap
msgid ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int i, ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"
msgstr "/* ждём, пока один из запросов не выполнится */\nstatic void\nwait_requests(void)\n{\n    char *id;\n    int i, ret, n;\n    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n                /* элементы NULL игнорируются gai_suspend(). */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:504 man-pages/man3/getaddrinfo_a.3:541
#, no-wrap
msgid ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"
msgstr "    while ((id = strtok(NULL, \" \")) != NULL) {\n        n = atoi(id);\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:509 man-pages/man3/getaddrinfo_a.3:546
#, no-wrap
msgid ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"
msgstr "        if (n E<gt>= nreqs) {\n            printf(\"Неправильный номер запроса: %s\\en\", id);\n            return;\n        }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:512
#, no-wrap
msgid ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"
msgstr "        wait_reqs[n] = reqs[n];\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:518
#, no-wrap
msgid ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"
msgstr "    ret = gai_suspend(wait_reqs, nreqs, NULL);\n    if (ret) {\n        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n        return;\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:522
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"
msgstr "    for (i = 0; i E<lt> nreqs; i++) {\n        if (wait_reqs[i] == NULL)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:526
#, no-wrap
msgid ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"
msgstr "        ret = gai_error(reqs[i]);\n        if (ret == EAI_INPROGRESS)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:531
#, no-wrap
msgid ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr "        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n               ret == 0 ? \"Выполнено\" : gai_strerror(ret));\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:538
#, no-wrap
msgid ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
msgstr "/* отменяет заданные запросы */\nstatic void\ncancel_requests(void)\n{\n    char *id;\n    int ret, n;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:552
#, no-wrap
msgid ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr "        ret = gai_cancel(reqs[n]);\n        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n               gai_strerror(ret));\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:560
#, no-wrap
msgid ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int i, ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr "/* перечислим все запросы */\nstatic void\nlist_requests(void)\n{\n    int i, ret;\n    char host[NI_MAXHOST];\n    struct addrinfo *res;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:564
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
msgstr "    for (i = 0; i E<lt> nreqs; i++) {\n        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n        ret = gai_error(reqs[i]);\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:567
#, no-wrap
msgid ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr "        if (!ret) {\n            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:582
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"
msgstr "            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n                              host, sizeof(host),\n                              NULL, 0, NI_NUMERICHOST);\n            if (ret) {\n                fprintf(stderr, \"ошибка getnameinfo(): %s\\en\",\n                        gai_strerror(ret));\n                exit(EXIT_FAILURE);\n            }\n            puts(host);\n        } else {\n            puts(gai_strerror(ret));\n        }\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:588
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char *cmdline;\n    char *cmd;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:591
#, no-wrap
msgid ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"
msgstr "    while ((cmdline = getcmd()) != NULL) {\n        cmd = strtok(cmdline, \" \");\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:616
#, no-wrap
msgid ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "        if (cmd == NULL) {\n            list_requests();\n        } else {\n            switch (cmd[0]) {\n            case \\(aqa\\(aq:\n                add_requests();\n                break;\n            case \\(aqw\\(aq:\n                wait_requests();\n                break;\n            case \\(aqc\\(aq:\n                cancel_requests();\n                break;\n            case \\(aql\\(aq:\n                list_requests();\n                break;\n            default:\n                fprintf(stderr, \"Неверная команда: %c\\en\", cmd[0]);\n                break;\n            }\n        }\n    }\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:623
msgid ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"
msgstr "B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), B<sigevent>(7)"

#. type: TH
#: man-pages/man3/getnetent.3:30
#, no-wrap
msgid "GETNETENT"
msgstr "GETNETENT"

#. type: Plain text
#: man-pages/man3/getnetent.3:34
msgid ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - get network "
"entry"
msgstr "getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - получить запись сети"

#. type: Plain text
#: man-pages/man3/getnetent.3:39
#, no-wrap
msgid "B<struct netent *getnetent(void);>\n"
msgstr "B<struct netent *getnetent(void);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:41
#, no-wrap
msgid "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"
msgstr "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:43
#, no-wrap
msgid "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"
msgstr "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:45
#, no-wrap
msgid "B<void setnetent(int >I<stayopen>B<);>\n"
msgstr "B<void setnetent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:47
#, no-wrap
msgid "B<void endnetent(void);>\n"
msgstr "B<void endnetent(void);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:57
msgid ""
"The B<getnetent>()  function reads the next entry from the networks database"
" and returns a I<netent> structure containing the broken-out fields from the"
" entry.  A connection is opened to the database if necessary."
msgstr "Функция B<getnetent>() считывает следующую запись из файла, содержащего базу сетей, и возвращает структуру I<netent>, содержащую поля из этой записи. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getnetent.3:66
msgid ""
"The B<getnetbyname>()  function returns a I<netent> structure for the entry "
"from the database that matches the network I<name>."
msgstr "Функция B<getnetbyname>() возвращает структуру I<netent> для записи из базы, соответствующей сети I<name>."

#. type: Plain text
#: man-pages/man3/getnetent.3:80
msgid ""
"The B<getnetbyaddr>()  function returns a I<netent> structure for the entry "
"from the database that matches the network number I<net> of type I<type>.  "
"The I<net> argument must be in host byte order."
msgstr "Функция B<getnetbyaddr>() возвращает структуру I<netent> для записи из базы, которая соответствует номеру сети  I<net> типа  I<type>. Аргумент I<net> должен использовать порядок байтов, использующийся на машине."

#. type: Plain text
#: man-pages/man3/getnetent.3:92
msgid ""
"The B<setnetent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getnet*>()  functions."
msgstr "Функция B<setnetent>() открывает соединение к базе и устанавливает следующую запись к первой записи. Если I<stayopen> не равен нулю, то подключение к базе между вызовами нескольких функций B<getnet*>() не будет закрыто."

#. type: Plain text
#: man-pages/man3/getnetent.3:96
msgid "The B<endnetent>()  function closes the connection to the database."
msgstr "Функция B<endnetent>() закрывает подключение к базе."

#. type: Plain text
#: man-pages/man3/getnetent.3:102
msgid "The I<netent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "Структура I<netent> определена в I<E<lt>netdb.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/getnetent.3:111
#, no-wrap
msgid ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"
msgstr "struct netent {\n    char      *n_name;     /* официальное имя сети */\n    char     **n_aliases;  /* список псевдонимов */\n    int        n_addrtype; /* тип сетевого адреса */\n    uint32_t   n_net;      /* номер сети */\n}\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:117
msgid "The members of the I<netent> structure are:"
msgstr "Члены структуры I<netent>:"

#. type: TP
#: man-pages/man3/getnetent.3:117
#, no-wrap
msgid "I<n_name>"
msgstr "I<n_name>"

#. type: Plain text
#: man-pages/man3/getnetent.3:120
msgid "The official name of the network."
msgstr "Официальное название сети."

#. type: TP
#: man-pages/man3/getnetent.3:120
#, no-wrap
msgid "I<n_aliases>"
msgstr "I<n_aliases>"

#. type: Plain text
#: man-pages/man3/getnetent.3:123
msgid "A NULL-terminated list of alternative names for the network."
msgstr "Список альтернативных имён сети, завершающийся NULL."

#. type: TP
#: man-pages/man3/getnetent.3:123
#, no-wrap
msgid "I<n_addrtype>"
msgstr "I<n_addrtype>"

#. type: Plain text
#: man-pages/man3/getnetent.3:127
msgid "The type of the network number; always B<AF_INET>."
msgstr "Тип номера сети, всегда равно B<AF_INET>."

#. type: TP
#: man-pages/man3/getnetent.3:127
#, no-wrap
msgid "I<n_net>"
msgstr "I<n_net>"

#. type: Plain text
#: man-pages/man3/getnetent.3:130
msgid "The network number in host byte order."
msgstr "Номер сети в порядке байтов, использующемся на машине."

#. type: Plain text
#: man-pages/man3/getnetent.3:141
msgid ""
"The B<getnetent>(), B<getnetbyname>()  and B<getnetbyaddr>()  functions "
"return a pointer to a statically allocated I<netent> structure, or a null "
"pointer if an error occurs or the end of the file is reached."
msgstr "Функции B<getnetent>(), B<getnetbyname>() и B<getnetbyaddr>() возвращают указатель на статически выделенную структуру I<netent> или указатель null при ошибке или достижении конца файла."

#. type: TP
#: man-pages/man3/getnetent.3:142
#, no-wrap
msgid "I</etc/networks>"
msgstr "I</etc/networks>"

#. type: Plain text
#: man-pages/man3/getnetent.3:145
msgid "networks database file"
msgstr "файл, содержащий базу сетей"

#. type: tbl table
#: man-pages/man3/getnetent.3:155
#, no-wrap
msgid "B<getnetent>()"
msgstr "B<getnetent>()"

#. type: tbl table
#: man-pages/man3/getnetent.3:157
#, no-wrap
msgid "MT-Unsafe race:netent\n"
msgstr "MT-Unsafe race:netent\n"

#. type: tbl table
#: man-pages/man3/getnetent.3:159
#, no-wrap
msgid "race:netentbuf env locale"
msgstr "race:netentbuf env locale"

#. type: tbl table
#: man-pages/man3/getnetent.3:162
#, no-wrap
msgid "B<getnetbyname>()"
msgstr "B<getnetbyname>()"

#. type: tbl table
#: man-pages/man3/getnetent.3:164
#, no-wrap
msgid "MT-Unsafe race:netbyname\n"
msgstr "MT-Unsafe race:netbyname\n"

#. type: tbl table
#: man-pages/man3/getnetent.3:169
#, no-wrap
msgid "B<getnetbyaddr>()"
msgstr "B<getnetbyaddr>()"

#. type: tbl table
#: man-pages/man3/getnetent.3:171
#, no-wrap
msgid "MT-Unsafe race:netbyaddr\n"
msgstr "MT-Unsafe race:netbyaddr\n"

#. type: tbl table
#: man-pages/man3/getnetent.3:176
#, no-wrap
msgid "B<setnetent>(),\n"
msgstr "B<setnetent>(),\n"

#. type: tbl table
#: man-pages/man3/getnetent.3:178
#, no-wrap
msgid "B<endnetent>()"
msgstr "B<endnetent>()"

#. type: tbl table
#: man-pages/man3/getnetent.3:180
#, no-wrap
msgid "MT-Unsafe race:netent env\n"
msgstr "MT-Unsafe race:netent env\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:196
msgid ""
"In the above table, I<netent> in I<race:netent> signifies that if any of the"
" functions B<setnetent>(), B<getnetent>(), or B<endnetent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr "В приведённой выше таблице I<netent> в I<race:netent> означает, что если в нескольких нитях программы одновременно используются функции B<setnetent>(), B<getnetent>() или B<endnetent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getnetent.3:205
msgid ""
"In glibc versions before 2.2, the I<net> argument of B<getnetbyaddr>()  was "
"of type I<long>."
msgstr "В версия glibc ниже 2.2 аргумент I<net> из B<getnetbyaddr>() имел тип I<long>."

#.  .BR networks (5)
#. type: Plain text
#: man-pages/man3/getnetent.3:210
msgid "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"
msgstr "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"

#. type: Plain text
#: man-pages/man3/getnetent.3:211
msgid "RFC\\ 1101"
msgstr "RFC\\ 1101"

#. type: TH
#: man-pages/man3/getgrent_r.3:24
#, no-wrap
msgid "GETGRENT_R"
msgstr "GETGRENT_R"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:27
msgid "getgrent_r, fgetgrent_r - get group file entry reentrantly"
msgstr "getgrent_r, fgetgrent_r - возвращает запись из файла групп (реентерабельные версии)"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:30
#, no-wrap
msgid "B<#include E<lt>grp.hE<gt>>\n"
msgstr "B<#include E<lt>grp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:33
#, no-wrap
msgid ""
"B<int getgrent_r(struct group *>I<gbuf>B<, char *>I<buf>B<,>\n"
"B<               size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"
msgstr "B<int getgrent_r(struct group *>I<gbuf>B<, char *>I<buf>B<,>\nB<               size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:36
#, no-wrap
msgid ""
"B<int fgetgrent_r(FILE *>I<stream>B<, struct group *>I<gbuf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"
msgstr "B<int fgetgrent_r(FILE *>I<stream>B<, struct group *>I<gbuf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"

#.  FIXME . The FTM requirements seem inconsistent here.  File a glibc bug?
#. type: Plain text
#: man-pages/man3/getgrent_r.3:46
msgid "B<getgrent_r>(): _GNU_SOURCE"
msgstr "B<getgrent_r>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:52
#, no-wrap
msgid ""
"B<fgetgrent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr "B<fgetgrent_r>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:65
msgid ""
"The functions B<getgrent_r>()  and B<fgetgrent_r>()  are the reentrant "
"versions of B<getgrent>(3)  and B<fgetgrent>(3).  The former reads the next "
"group entry from the stream initialized by B<setgrent>(3).  The latter reads"
" the next group entry from I<stream>."
msgstr "Функции B<getgrent_r>() и B<fgetgrent_r>() являются реентерабельными версиями B<getgrent>(3) и B<fgetgrent>(3). Первая читает следующую запись группы из потока, инициализированного B<setgrent>(3). Последняя читает следующую запись группы из I<stream>."

#. type: Plain text
#: man-pages/man3/getgrent_r.3:103
msgid ""
"The nonreentrant functions return a pointer to static storage, where this "
"static storage contains further pointers to group name, password and "
"members.  The reentrant functions described here return all of that in "
"caller-provided buffers.  First of all there is the buffer I<gbuf> that can "
"hold a I<struct group>.  And next the buffer I<buf> of size I<buflen> that "
"can hold additional strings.  The result of these functions, the I<struct "
"group> read from the stream, is stored in the provided buffer I<*gbuf>, and "
"a pointer to this I<struct group> is returned in I<*gbufp>."
msgstr "Нереентерабельные версии возвращают указатель на статическое хранилище, в котором хранятся другие указатели на имя группы, пароль и список членов. Реентерабельные функции, описанные здесь, возвращают всю информацию в буферах, предоставленных вызывающим. Основным буфером является I<gbuf>, в котором может храниться I<struct group>. В дополнительном буфере I<buf> размера I<buflen> могут храниться дополнительные строки. Результат этих функций, прочитанная из потока I<struct group>, сохраняется в предоставляемый буфер I<*gbuf>, и указатель на эту I<struct group> возвращается в I<*gbufp>."

#. type: Plain text
#: man-pages/man3/getgrent_r.3:110
msgid ""
"On success, these functions return 0 and I<*gbufp> is a pointer to the "
"I<struct group>.  On error, these functions return an error value and "
"I<*gbufp> is NULL."
msgstr "При успешном выполнении эти функции возвращают 0 и I<*gbufp> указывает на I<struct group>. При ошибке возвращается значение ошибки и I<*gbufp> равен NULL."

#. type: tbl table
#: man-pages/man3/getgrent_r.3:128
#, no-wrap
msgid "B<getgrent_r>()"
msgstr "B<getgrent_r>()"

#. type: tbl table
#: man-pages/man3/getgrent_r.3:131
#, no-wrap
msgid "B<fgetgrent_r>()"
msgstr "B<fgetgrent_r>()"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:146
msgid ""
"In the above table, I<grent> in I<race:grent> signifies that if any of the "
"functions B<setgrent>(), B<getgrent>(), B<endgrent>(), or B<getgrent_r>()  "
"are used in parallel in different threads of a program, then data races "
"could occur."
msgstr "В приведённой выше таблице I<grent> в I<race:grent> означает, что если в нескольких нитях программы одновременно используются функции B<setgrent>(), B<getgrent>(), B<endgrent>() или B<getgrent_r>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getgrent_r.3:156
#, no-wrap
msgid ""
"struct group *getgrent_r(struct group *grp, char *buf,\n"
"                         int buflen);\n"
msgstr "struct group *getgrent_r(struct group *grp, char *buf,\n                         int buflen);\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:165
#, no-wrap
msgid ""
"int getgrent_r(struct group *grp, char *buf, int buflen,\n"
"               FILE **gr_fp);\n"
msgstr "int getgrent_r(struct group *grp, char *buf, int buflen,\n               FILE **gr_fp);\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:172
msgid ""
"The function B<getgrent_r>()  is not really reentrant since it shares the "
"reading position in the stream with all other threads."
msgstr "Функция B<getgrent_r>() не совсем реентерабельна, так как она использует общую позицию чтения в потоке с другими нитями."

#. type: Plain text
#: man-pages/man3/getgrent_r.3:179
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>grp.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#define BUFLEN 4096\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>grp.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#define BUFLEN 4096\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:186
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct group grp, *grpp;\n"
"    char buf[BUFLEN];\n"
"    int i;\n"
msgstr "int\nmain(void)\n{\n    struct group grp, *grpp;\n    char buf[BUFLEN];\n    int i;\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:203
#, no-wrap
msgid ""
"    setgrent();\n"
"    while (1) {\n"
"        i = getgrent_r(&grp, buf, BUFLEN, &grpp);\n"
"        if (i)\n"
"            break;\n"
"        printf(\"%s (%d):\", grpp-E<gt>gr_name, grpp-E<gt>gr_gid);\n"
"        for (i = 0; ; i++) {\n"
"            if (grpp-E<gt>gr_mem[i] == NULL)\n"
"                break;\n"
"            printf(\" %s\", grpp-E<gt>gr_mem[i]);\n"
"        }\n"
"        printf(\"\\en\");\n"
"    }\n"
"    endgrent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    setgrent();\n    while (1) {\n        i = getgrent_r(&grp, buf, BUFLEN, &grpp);\n        if (i)\n            break;\n        printf(\"%s (%d):\", grpp-E<gt>gr_name, grpp-E<gt>gr_gid);\n        for (i = 0; ; i++) {\n            if (grpp-E<gt>gr_mem[i] == NULL)\n                break;\n            printf(\" %s\", grpp-E<gt>gr_mem[i]);\n        }\n        printf(\"\\en\");\n    }\n    endgrent();\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:219
msgid ""
"B<fgetgrent>(3), B<getgrent>(3), B<getgrgid>(3), B<getgrnam>(3), "
"B<putgrent>(3), B<group>(5)"
msgstr "B<fgetgrent>(3), B<getgrent>(3), B<getgrgid>(3), B<getgrnam>(3), B<putgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/getspnam.3:8
#, no-wrap
msgid "GETSPNAM"
msgstr "GETSPNAM"

#. type: Plain text
#: man-pages/man3/getspnam.3:13
msgid ""
"getspnam, getspnam_r, getspent, getspent_r, setspent, endspent, fgetspent, "
"fgetspent_r, sgetspent, sgetspent_r, putspent, lckpwdf, ulckpwdf - get "
"shadow password file entry"
msgstr "getspnam, getspnam_r, getspent, getspent_r, setspent, endspent, fgetspent, fgetspent_r, sgetspent, sgetspent_r, putspent, lckpwdf, ulckpwdf - получение записи из теневого файла паролей"

#. type: Plain text
#: man-pages/man3/getspnam.3:17
#, no-wrap
msgid ""
"/* General shadow password file API */\n"
"B<#include E<lt>shadow.hE<gt>>\n"
msgstr "/* Основной API теневого файла паролей */\nB<#include E<lt>shadow.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:19
#, no-wrap
msgid "B<struct spwd *getspnam(const char *>I<name>B<);>\n"
msgstr "B<struct spwd *getspnam(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:21
#, no-wrap
msgid "B<struct spwd *getspent(void);>\n"
msgstr "B<struct spwd *getspent(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:23
#, no-wrap
msgid "B<void setspent(void);>\n"
msgstr "B<void setspent(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:25
#, no-wrap
msgid "B<void endspent(void);>\n"
msgstr "B<void endspent(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:27
#, no-wrap
msgid "B<struct spwd *fgetspent(FILE *>I<stream>B<);>\n"
msgstr "B<struct spwd *fgetspent(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:29
#, no-wrap
msgid "B<struct spwd *sgetspent(const char *>I<s>B<);>\n"
msgstr "B<struct spwd *sgetspent(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:31
#, no-wrap
msgid "B<int putspent(const struct spwd *>I<p>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putspent(const struct spwd *>I<p>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:33
#, no-wrap
msgid "B<int lckpwdf(void);>\n"
msgstr "B<int lckpwdf(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:35
#, no-wrap
msgid "B<int ulckpwdf(void);>\n"
msgstr "B<int ulckpwdf(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:38
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>shadow.hE<gt>>\n"
msgstr "/* Расширение GNU */\nB<#include E<lt>shadow.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:41
#, no-wrap
msgid ""
"B<int getspent_r(struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr "B<int getspent_r(struct spwd *>I<spbuf>B<,>\nB<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:44
#, no-wrap
msgid ""
"B<int getspnam_r(const char *>I<name>B<, struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr "B<int getspnam_r(const char *>I<name>B<, struct spwd *>I<spbuf>B<,>\nB<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:47
#, no-wrap
msgid ""
"B<int fgetspent_r(FILE *>I<stream>B<, struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr "B<int fgetspent_r(FILE *>I<stream>B<, struct spwd *>I<spbuf>B<,>\nB<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:50
#, no-wrap
msgid ""
"B<int sgetspent_r(const char *>I<s>B<, struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr "B<int sgetspent_r(const char *>I<s>B<, struct spwd *>I<spbuf>B<,>\nB<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:66
#, no-wrap
msgid ""
"B<getspent_r>(),\n"
"B<getspnam_r>(),\n"
"B<fgetspent_r>(),\n"
"B<sgetspent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getspent_r>(),\nB<getspnam_r>(),\nB<fgetspent_r>(),\nB<sgetspent_r>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:79
msgid ""
"Long ago it was considered safe to have encrypted passwords openly visible "
"in the password file.  When computers got faster and people got more "
"security-conscious, this was no longer acceptable.  Julianne Frances Haugh "
"implemented the shadow password suite that keeps the encrypted passwords in "
"the shadow password database (e.g., the local shadow password file "
"I</etc/shadow>, NIS, and LDAP), readable only by root."
msgstr "В давние времена считалось, что хранить зашифрованные пароли в открытом доступе достаточно безопасно. Со временем компьютеры стали быстрее, а люди - более обеспокоенными проблемами безопасности, и данный подход стал неприемлемым. Джулиан Франс Хог (Julianne Frances Haugh) реализовал набор программ для теневых паролей, который хранит зашифрованные пароли в базе данных теневых паролей (например в локальном файле теневых паролей I</etc/shadow>, NIS или LDAP), доступной для чтения только root."

#.  FIXME . I've commented out the following for the
#.  moment.  The relationship between PAM and nsswitch.conf needs
#.  to be clearly documented in one place, which is pointed to by
#.  the pages for the user, group, and shadow password functions.
#.  (Jul 2005, mtk)
#.  This shadow password setup has been superseded by PAM
#.  (pluggable authentication modules), and the file
#.  .I /etc/nsswitch.conf
#.  now describes the sources to be used.
#. type: Plain text
#: man-pages/man3/getspnam.3:96
msgid ""
"The functions described below resemble those for the traditional password "
"database (e.g., see B<getpwnam>(3)  and B<getpwent>(3))."
msgstr "Описанные ниже функции соответствуют аналогами для традиционной базы паролей (см. B<getpwnam>(3) and B<getpwent>(3))."

#. type: Plain text
#: man-pages/man3/getspnam.3:103
msgid ""
"The B<getspnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the shadow password database that matches"
" the username I<name>."
msgstr "Функция B<getspnam>() возвращает указатель на структуру, содержащую разделённую на поля запись из базы данных теневых паролей, которая соответствует имени пользователя I<name>."

#.  some systems require a call of setspent() before the first getspent()
#.  glibc does not
#. type: Plain text
#: man-pages/man3/getspnam.3:115
msgid ""
"The B<getspent>()  function returns a pointer to the next entry in the "
"shadow password database.  The position in the input stream is initialized "
"by B<setspent>().  When done reading, the program may call B<endspent>()  so"
" that resources can be deallocated."
msgstr "Функция B<getspent>() возвращает указатель на следующую запись в базе данных теневых паролей. Положение во входном потоке инициализируется с помощью B<setspent>(). После выполнения чтения программа может вызвать B<endspent>() для освобождения ресурсов."

#. type: Plain text
#: man-pages/man3/getspnam.3:122
msgid ""
"The B<fgetspent>()  function is similar to B<getspent>()  but uses the "
"supplied stream instead of the one implicitly opened by B<setspent>()."
msgstr "Функция B<fgetspent>() подобна B<getspent>() но использует заданный поток вместо неявного открытия с помощью B<setspent>()."

#. type: Plain text
#: man-pages/man3/getspnam.3:129
msgid ""
"The B<sgetspent>()  function parses the supplied string I<s> into a struct "
"I<spwd>."
msgstr "Функция B<sgetspent>() разбирает передаваемую строку I<s> в структуру I<spwd>."

#. type: Plain text
#: man-pages/man3/getspnam.3:139
msgid ""
"The B<putspent>()  function writes the contents of the supplied struct "
"I<spwd> I<*p> as a text line in the shadow password file format to "
"I<stream>.  String entries with value NULL and numerical entries with value "
"-1 are written as an empty string."
msgstr "Функция B<putspent>() записывает в I<stream> содержимое передаваемой структуры I<spwd> I<*p> в виде текстовой строки в формате файла теневых паролей. Строковые записи со значением NULL и числовые записи со значением -1 записываются как пустые строки."

#. type: Plain text
#: man-pages/man3/getspnam.3:154
msgid ""
"The B<lckpwdf>()  function is intended to protect against multiple "
"simultaneous accesses of the shadow password database.  It tries to acquire "
"a lock, and returns 0 on success, or -1 on failure (lock not obtained within"
" 15 seconds).  The B<ulckpwdf>()  function releases the lock again.  Note "
"that there is no protection against direct access of the shadow password "
"file.  Only programs that use B<lckpwdf>()  will notice the lock."
msgstr "Функция B<lckpwdf>() предназначена для защиты базы данных теневых паролей при одновременном многочисленном доступе. Она пытается захватить блокировку и возвращает 0 при успешном выполнении и -1 при ошибке (блокировка не получена в течении 15 секунд). Функция B<ulckpwdf>() освобождает блокировку. Заметим, что это не защищает при прямом доступе к файлу теневых паролей. О блокировке будут уведомлены только программы, использующие B<lckpwdf>()."

#.  Also in libc5
#.  SUN doesn't have sgetspent()
#. type: Plain text
#: man-pages/man3/getspnam.3:159
msgid ""
"These were the functions that formed the original shadow API.  They are "
"widely available."
msgstr "Эти функции возникли в исходном программном интерфейсе. Они широко используются."

#. type: SS
#: man-pages/man3/getspnam.3:159
#, no-wrap
msgid "Reentrant versions"
msgstr "Реентерабельные версии"

#. type: Plain text
#: man-pages/man3/getspnam.3:176
msgid ""
"Analogous to the reentrant functions for the password database, glibc also "
"has reentrant functions for the shadow password database.  The "
"B<getspnam_r>()  function is like B<getspnam>()  but stores the retrieved "
"shadow password structure in the space pointed to by I<spbuf>.  This shadow "
"password structure contains pointers to strings, and these strings are "
"stored in the buffer I<buf> of size I<buflen>.  A pointer to the result (in "
"case of success) or NULL (in case no entry was found or an error occurred) "
"is stored in I<*spbufp>."
msgstr "По аналогии с реентерабельными функциями для базы данных паролей, в glibc также есть реентерабельные функции для базы данных теневых паролей. Функция B<getspnam_r>() подобна B<getspnam>(), но хранит выбранную структуру теневого пароля в пространстве, на которое указывает I<spbuf>. Данная структура теневого пароля содержит указатели на строки и эти строки хранятся в буфере I<buf> размером I<buflen>. Указатель на результат (при успешном выполнении) или NULL (в случае отсутствия записи или ошибки) сохраняется в I<*spbufp>."

#. type: Plain text
#: man-pages/man3/getspnam.3:183
msgid ""
"The functions B<getspent_r>(), B<fgetspent_r>(), and B<sgetspent_r>()  are "
"similarly analogous to their nonreentrant counterparts."
msgstr "Функции B<getspent_r>(), B<fgetspent_r>() и B<sgetspent_r>() подобны их нереентерабельным аналогам."

#.  SUN doesn't have sgetspent_r()
#. type: Plain text
#: man-pages/man3/getspnam.3:187
msgid ""
"Some non-glibc systems also have functions with these names, often with "
"different prototypes."
msgstr "Некоторые не-glibc системы также содержат функции с такими именами, но, чаще всего, с другими прототипами."

#. type: SS
#: man-pages/man3/getspnam.3:187
#, no-wrap
msgid "Structure"
msgstr "Структура"

#. type: Plain text
#: man-pages/man3/getspnam.3:189
msgid ""
"The shadow password structure is defined in I<E<lt>shadow.hE<gt>> as "
"follows:"
msgstr "Структура теневого пароля определена в I<E<lt>shadow.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/getspnam.3:209
#, no-wrap
msgid ""
"struct spwd {\n"
"    char *sp_namp;     /* Login name */\n"
"    char *sp_pwdp;     /* Encrypted password */\n"
"    long  sp_lstchg;   /* Date of last change\n"
"                          (measured in days since\n"
"                          1970-01-01 00:00:00 +0000 (UTC)) */\n"
"    long  sp_min;      /* Min # of days between changes */\n"
"    long  sp_max;      /* Max # of days between changes */\n"
"    long  sp_warn;     /* # of days before password expires\n"
"                          to warn user to change it */\n"
"    long  sp_inact;    /* # of days after password expires\n"
"                          until account is disabled */\n"
"    long  sp_expire;   /* Date when account expires\n"
"                          (measured in days since\n"
"                          1970-01-01 00:00:00 +0000 (UTC)) */\n"
"    unsigned long sp_flag;  /* Reserved */\n"
"};\n"
msgstr "struct spwd {\n    char *sp_namp;     /* имя пользователя */\n    char *sp_pwdp;     /* зашифрованный пароль */\n    long  sp_lstchg;   /* дата последнего изменения\n                      в днях начиная с 1970-01-01 00:00:00 +0000 (UTC)) */\n    long  sp_min;      /* мин. кол-во дней между сменой */\n    long  sp_max;      /* макс. кол-во дней между сменой */\n    long  sp_warn;     /* кол-во дней до истечения срока действия пароля\n                          для предупреждения пользователя */\n    long  sp_inact;    /* кол-во дней до истечения срока действия пароля,\n                          после запись блокируется */\n    long  sp_expire;   /* дата устаревания учётной записи\n                      в днях начиная с 1970-01-01 00:00:00 +0000 (UTC)) */\n    unsigned long sp_flag;  /* зарезервировано */\n};\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:218
msgid ""
"The functions that return a pointer return NULL if no more entries are "
"available or if an error occurs during processing.  The functions which have"
" I<int> as the return value return 0 for success and -1 for failure, with "
"I<errno> set to indicate the cause of the error."
msgstr "Функции, которые возвращают указатель, возвращают NULL, если элементы закончились или произошла ошибка во время обработки. Функции, которые возвращают значение с типом I<int>, возвращают 0 при успешном выполнении и -1 при ошибке, записывая в I<errno> причину ошибки."

#. type: Plain text
#: man-pages/man3/getspnam.3:221
msgid ""
"For the nonreentrant functions, the return value may point to static area, "
"and may be overwritten by subsequent calls to these functions."
msgstr "У нереентерабельных функций возвращаемое значение может указывать на статическую область и может быть перезаписано последующими вызовами этих функций."

#. type: Plain text
#: man-pages/man3/getspnam.3:224
msgid ""
"The reentrant functions return zero on success.  In case of error, an error "
"number is returned."
msgstr "При успешном выполнении реентерабельные функции возвращают 0. В случае ошибки возвращается номер ошибки."

#. type: Plain text
#: man-pages/man3/getspnam.3:228
msgid ""
"The caller does not have permission to access the shadow password file."
msgstr "Вызывающий не имеет прав доступа к файлу теневых паролей."

#. type: Plain text
#: man-pages/man3/getspnam.3:231
msgid "Supplied buffer is too small."
msgstr "Указанный буфер слишком мал."

#. type: TP
#: man-pages/man3/getspnam.3:232
#, no-wrap
msgid "I</etc/shadow>"
msgstr "I</etc/shadow>"

#. type: Plain text
#: man-pages/man3/getspnam.3:235
msgid "local shadow password database file"
msgstr "файл, содержащий базу локальных теневых паролей"

#. type: TP
#: man-pages/man3/getspnam.3:235
#, no-wrap
msgid "I</etc/.pwd.lock>"
msgstr "I</etc/.pwd.lock>"

#. type: Plain text
#: man-pages/man3/getspnam.3:238
msgid "lock file"
msgstr "файл блокировки"

#. type: Plain text
#: man-pages/man3/getspnam.3:244
msgid ""
"The include file I<E<lt>paths.hE<gt>> defines the constant B<_PATH_SHADOW> "
"to the pathname of the shadow password file."
msgstr "При включении файла I<E<lt>paths.hE<gt>> определяется константа B<_PATH_SHADOW>, в которой хранится путь к файлу теневых паролей."

#. type: tbl table
#: man-pages/man3/getspnam.3:254
#, no-wrap
msgid "B<getspnam>()"
msgstr "B<getspnam>()"

#. type: tbl table
#: man-pages/man3/getspnam.3:256
#, no-wrap
msgid "MT-Unsafe race:getspnam locale"
msgstr "MT-Unsafe race:getspnam locale"

#. type: tbl table
#: man-pages/man3/getspnam.3:259
#, no-wrap
msgid "B<getspent>()"
msgstr "B<getspent>()"

#. type: tbl table
#: man-pages/man3/getspnam.3:261
#, no-wrap
msgid "MT-Unsafe race:getspent\n"
msgstr "MT-Unsafe race:getspent\n"

#. type: tbl table
#: man-pages/man3/getspnam.3:263
#, no-wrap
msgid "race:spentbuf locale"
msgstr "race:spentbuf locale"

#. type: tbl table
#: man-pages/man3/getspnam.3:266
#, no-wrap
msgid "B<setspent>(),\n"
msgstr "B<setspent>(),\n"

#. type: tbl table
#: man-pages/man3/getspnam.3:268
#, no-wrap
msgid "B<endspent>(),\n"
msgstr "B<endspent>(),\n"

#. type: tbl table
#: man-pages/man3/getspnam.3:270
#, no-wrap
msgid "B<getspent_r>()"
msgstr "B<getspent_r>()"

#. type: tbl table
#: man-pages/man3/getspnam.3:272
#, no-wrap
msgid "MT-Unsafe race:getspent locale"
msgstr "MT-Unsafe race:getspent locale"

#. type: tbl table
#: man-pages/man3/getspnam.3:275
#, no-wrap
msgid "B<fgetspent>()"
msgstr "B<fgetspent>()"

#. type: tbl table
#: man-pages/man3/getspnam.3:275
#, no-wrap
msgid "MT-Unsafe race:fgetspent"
msgstr "MT-Unsafe race:fgetspent"

#. type: tbl table
#: man-pages/man3/getspnam.3:278
#, no-wrap
msgid "B<sgetspent>()"
msgstr "B<sgetspent>()"

#. type: tbl table
#: man-pages/man3/getspnam.3:278
#, no-wrap
msgid "MT-Unsafe race:sgetspent"
msgstr "MT-Unsafe race:sgetspent"

#. type: tbl table
#: man-pages/man3/getspnam.3:281
#, no-wrap
msgid "B<putspent>(),\n"
msgstr "B<putspent>(),\n"

#. type: tbl table
#: man-pages/man3/getspnam.3:283
#, no-wrap
msgid "B<getspnam_r>(),\n"
msgstr "B<getspnam_r>(),\n"

#. type: tbl table
#: man-pages/man3/getspnam.3:285
#, no-wrap
msgid "B<sgetspent_r>()"
msgstr "B<sgetspent_r>()"

#. type: tbl table
#: man-pages/man3/getspnam.3:288
#, no-wrap
msgid "B<lckpwdf>(),\n"
msgstr "B<lckpwdf>(),\n"

#. type: tbl table
#: man-pages/man3/getspnam.3:290
#, no-wrap
msgid "B<ulckpwdf>(),\n"
msgstr "B<ulckpwdf>(),\n"

#. type: tbl table
#: man-pages/man3/getspnam.3:292
#, no-wrap
msgid "B<fgetspent_r>()"
msgstr "B<fgetspent_r>()"

#. type: Plain text
#: man-pages/man3/getspnam.3:307
msgid ""
"In the above table, I<getspent> in I<race:getspent> signifies that if any of"
" the functions B<setspent>(), B<getspent>(), B<getspent_r>(), or "
"B<endspent>()  are used in parallel in different threads of a program, then "
"data races could occur."
msgstr "В приведённой выше таблице I<getspent> в I<race:getspent> означает, что если в нескольких нитях программы одновременно используются функции B<setspent>(), B<getspent>(), B<getspent_r>() или B<endspent>(), то может возникнуть состязательность по данным."

#. type: Plain text
#: man-pages/man3/getspnam.3:311
msgid ""
"The shadow password database and its associated API are not specified in "
"POSIX.1.  However, many other systems provide a similar API."
msgstr "База данных теневых паролей и её программный интерфейс не описаны в POSIX.1. Однако, во многих системах есть похожий программный интерфейс."

#. type: Plain text
#: man-pages/man3/getspnam.3:315
msgid "B<getgrnam>(3), B<getpwnam>(3), B<getpwnam_r>(3), B<shadow>(5)"
msgstr "B<getgrnam>(3), B<getpwnam>(3), B<getpwnam_r>(3), B<shadow>(5)"

#. type: TH
#: man-pages/man3/getaddrinfo.3:44
#, no-wrap
msgid "GETADDRINFO"
msgstr "GETADDRINFO"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:48
msgid ""
"getaddrinfo, freeaddrinfo, gai_strerror - network address and service "
"translation"
msgstr "getaddrinfo, freeaddrinfo, gai_strerror - трансляция сетевого адреса и службы"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:53
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/socket.hE<gt>>\nB<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:57
#, no-wrap
msgid ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"
msgstr "B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\nB<                const struct addrinfo *>I<hints>B<,>\nB<                struct addrinfo **>I<res>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:59
#, no-wrap
msgid "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"
msgstr "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:61
#, no-wrap
msgid "B<const char *gai_strerror(int >I<errcode>B<);>\n"
msgstr "B<const char *gai_strerror(int >I<errcode>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:74
#, no-wrap
msgid ""
"B<getaddrinfo>(),\n"
"B<freeaddrinfo>(),\n"
"B<gai_strerror>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 200112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr "B<getaddrinfo>(),\nB<freeaddrinfo>(),\nB<gai_strerror>():\n    начиная c glibc 2.22: _POSIX_C_SOURCE E<gt>= 200112L\n    в glibc 2.21 и старее: _POSIX_C_SOURCE\n"

#.  .BR getipnodebyname (3),
#.  .BR getipnodebyaddr (3),
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:100
msgid ""
"Given I<node> and I<service>, which identify an Internet host and a service,"
" B<getaddrinfo>()  returns one or more I<addrinfo> structures, each of which"
" contains an Internet address that can be specified in a call to B<bind>(2)"
"  or B<connect>(2).  The B<getaddrinfo>()  function combines the "
"functionality provided by the B<gethostbyname>(3)  and B<getservbyname>(3)  "
"functions into a single interface, but unlike the latter functions, "
"B<getaddrinfo>()  is reentrant and allows programs to eliminate IPv4-versus-"
"IPv6 dependencies."
msgstr "По заданным I<node> и I<service>, определяющим узел и службу Интернета, B<getaddrinfo>() возвращает одну или несколько структур I<addrinfo>, каждая из которых содержит Интернет-адрес, который можно передавать в вызов B<bind>(2) или B<connect>(2). Функция B<getaddrinfo>() объединяет возможности, предоставляемые функциями B<gethostbyname>(3) и B<getservbyname>(3) в одном интерфейсе, но в отличие от этих функций, B<getaddrinfo>() реентерабельна и позволяет программам не зависеть от IPv4 или IPv6."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:106
msgid ""
"The I<addrinfo> structure used by B<getaddrinfo>()  contains the following "
"fields:"
msgstr "Структура I<addrinfo>, используемая в B<getaddrinfo>(), содержит следующие поля:"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:119
#, no-wrap
msgid ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"
msgstr "struct addrinfo {\n    int              ai_flags;\n    int              ai_family;\n    int              ai_socktype;\n    int              ai_protocol;\n    socklen_t        ai_addrlen;\n    struct sockaddr *ai_addr;\n    char            *ai_canonname;\n    struct addrinfo *ai_next;\n};\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:141
msgid ""
"The I<hints> argument points to an I<addrinfo> structure that specifies "
"criteria for selecting the socket address structures returned in the list "
"pointed to by I<res>.  If I<hints> is not NULL it points to an I<addrinfo> "
"structure whose I<ai_family>, I<ai_socktype>, and I<ai_protocol> specify "
"criteria that limit the set of socket addresses returned by "
"B<getaddrinfo>(), as follows:"
msgstr "Аргумент I<hints> указывает на структуру I<addrinfo>, которая определяет критерии выбора структур адреса сокета, возвращаемых в списке, указанном в I<res>. Если I<hints> не является NULL, то он указывает на структуру I<addrinfo>. В ней с помощью I<ai_family>, I<ai_socktype> и I<ai_protocol> определяются критерии, ограничивающие набор адресов сокета, возвращаемых B<getaddrinfo>():"

#. type: TP
#: man-pages/man3/getaddrinfo.3:141
#, no-wrap
msgid "I<ai_family>"
msgstr "I<ai_family>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:157
msgid ""
"This field specifies the desired address family for the returned addresses."
"  Valid values for this field include B<AF_INET> and B<AF_INET6>.  The value"
" B<AF_UNSPEC> indicates that B<getaddrinfo>()  should return socket "
"addresses for any address family (either IPv4 or IPv6, for example) that can"
" be used with I<node> and I<service>."
msgstr "Это поле определяет предпочитаемое семейство адресов для возвращаемых адресов. Правильными значениями для данного поля могут быть B<AF_INET> и B<AF_INET6>. Значение B<AF_UNSPEC> отображает, что B<getaddrinfo>() должна возвращать адреса сокета для любого семейства адресов (например, либо IPv4, либо IPv6), которые в дальнейшем могут быть использованы вместе с I<node> и I<service>."

#. type: TP
#: man-pages/man3/getaddrinfo.3:157
#, no-wrap
msgid "I<ai_socktype>"
msgstr "I<ai_socktype>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:166
msgid ""
"This field specifies the preferred socket type, for example B<SOCK_STREAM> "
"or B<SOCK_DGRAM>.  Specifying 0 in this field indicates that socket "
"addresses of any type can be returned by B<getaddrinfo>()."
msgstr "Это поле определяет предпочитаемы тип сокета, например, B<SOCK_STREAM> или B<SOCK_DGRAM>. Если в этом поле указан 0, то это означает, что B<getaddrinfo>() может вернуть адреса сокета любого типа."

#. type: TP
#: man-pages/man3/getaddrinfo.3:166
#, no-wrap
msgid "I<ai_protocol>"
msgstr "I<ai_protocol>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:172
msgid ""
"This field specifies the protocol for the returned socket addresses.  "
"Specifying 0 in this field indicates that socket addresses with any protocol"
" can be returned by B<getaddrinfo>()."
msgstr "Это поле определяет протокол для возвращаемых адресов сокета. Если в этом поле указан 0, то это означает, что B<getaddrinfo>() может вернуть адрес сокета с любым протоколом."

#. type: TP
#: man-pages/man3/getaddrinfo.3:172
#, no-wrap
msgid "I<ai_flags>"
msgstr "I<ai_flags>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:176
msgid ""
"This field specifies additional options, described below.  Multiple flags "
"are specified by bitwise OR-ing them together."
msgstr "В этом поле задаются дополнительные параметры, описываемые ниже. Несколько флагов указываются с логическим ИЛИ."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:180
msgid ""
"All the other fields in the structure pointed to by I<hints> must contain "
"either 0 or a null pointer, as appropriate."
msgstr "Все остальные поля структуры, указываемой I<hints>, должны содержать 0 или указатель null, соответственно."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:215
msgid ""
"Specifying I<hints> as NULL is equivalent to setting I<ai_socktype> and "
"I<ai_protocol> to 0; I<ai_family> to B<AF_UNSPEC>; and I<ai_flags> to "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>.  (POSIX specifies different defaults "
"for I<ai_flags>; see NOTES.)  I<node> specifies either a numerical network "
"address (for IPv4, numbers-and-dots notation as supported by "
"B<inet_aton>(3); for IPv6, hexadecimal string format as supported by "
"B<inet_pton>(3)), or a network hostname, whose network addresses are looked "
"up and resolved.  If I<hints.ai_flags> contains the B<AI_NUMERICHOST> flag, "
"then I<node> must be a numerical network address.  The B<AI_NUMERICHOST> "
"flag suppresses any potentially lengthy network host address lookups."
msgstr "Указание в I<hints> значения NULL эквивалентно установке I<ai_socktype> и I<ai_protocol> равными 0; I<ai_family> присваивается B<AF_UNSPEC>; I<ai_flags> присваивается B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> (в POSIX указаны другие значения по умолчанию для I<ai_flags>; смотрите ЗАМЕЧАНИЯ). В I<node> задаётся либо числовой сетевой адрес (для IPv4 это цифро-точечная нотация, которую поддерживает B<inet_aton>(3); для IPv6 это строка в шестнадцатеричном формате, который поддерживает B<inet_pton>(3)), либо сетевое имя узла, для которого в дальнейшем определяется адрес. Если в I<hints.ai_flags> содержится флаг B<AI_NUMERICHOST>, тогда I<node> должен иметь цифровой формат сетевого адреса. При B<AI_NUMERICHOST> любые возможные преобразования сетевого адреса узла подавляются."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:240
msgid ""
"If the B<AI_PASSIVE> flag is specified in I<hints.ai_flags>, and I<node> is "
"NULL, then the returned socket addresses will be suitable for B<bind>(2)ing "
"a socket that will B<accept>(2)  connections.  The returned socket address "
"will contain the \"wildcard address\" (B<INADDR_ANY> for IPv4 addresses, "
"B<IN6ADDR_ANY_INIT> for IPv6 address).  The wildcard address is used by "
"applications (typically servers)  that intend to accept connections on any "
"of the host's network addresses.  If I<node> is not NULL, then the "
"B<AI_PASSIVE> flag is ignored."
msgstr "Если в I<hints.ai_flags> указан флаг B<AI_PASSIVE> и I<node> равно NULL, то возвращаемые адреса сокета будут пригодны для B<bind>(2) сокета, который принимает соединение с помощью B<accept>(2). Возвращаемый адрес сокета будет содержать «шаблонный адрес» (B<INADDR_ANY> для адресов IPv4, B<IN6ADDR_ANY_INIT> для адреса IPv6). Шаблонный адрес используется в приложениях (обычно, серверах), которым нужно принимать подключения с любых сетевых адресов узлов. Если I<node> не равно NULL, то флаг B<AI_PASSIVE> игнорируется."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:260
msgid ""
"If the B<AI_PASSIVE> flag is not set in I<hints.ai_flags>, then the returned"
" socket addresses will be suitable for use with B<connect>(2), B<sendto>(2),"
" or B<sendmsg>(2).  If I<node> is NULL, then the network address will be set"
" to the loopback interface address (B<INADDR_LOOPBACK> for IPv4 addresses, "
"B<IN6ADDR_LOOPBACK_INIT> for IPv6 address); this is used by applications "
"that intend to communicate with peers running on the same host."
msgstr "Если флаг B<AI_PASSIVE> отсутствует в I<hints.ai_flags>, то возвращаемые адреса сокета будут пригодны для использоваться в B<connect>(2), B<sendto>(2), или B<sendmsg>(2). Если I<node> равно NULL, то сетевому адресу будет назначен адрес кольцевого интерфейса (loopback) (B<INADDR_LOOPBACK> для адресов IPv4, B<IN6ADDR_LOOPBACK_INIT> для адреса IPv6); это используется в приложениях, которым нужно связываться с партнёрами, запущенными на том же узле."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:283
msgid ""
"I<service> sets the port in each returned address structure.  If this "
"argument is a service name (see B<services>(5)), it is translated to the "
"corresponding port number.  This argument can also be specified as a decimal"
" number, which is simply converted to binary.  If I<service> is NULL, then "
"the port number of the returned socket addresses will be left uninitialized."
"  If B<AI_NUMERICSERV> is specified in I<hints.ai_flags> and I<service> is "
"not NULL, then I<service> must point to a string containing a numeric port "
"number.  This flag is used to inhibit the invocation of a name resolution "
"service in cases where it is known not to be required."
msgstr "В I<service> задаётся порт для каждой возвращаемой адресной структуры. Если этот аргумент — имя службы (смотрите B<services>(5)), то он транслируется в соответствующий номер порта. Также, данный параметр может быть указан в виде десятичного числа, которое просто преобразуется в двоичную форму. Если I<service> равно NULL, то номер порта возвращаемых сокетных адресов остаётся неинициализированным. Если в I<hints.ai_flags> указан флаг B<AI_NUMERICSERV> и I<service> не равно NULL, то значение I<service> должно указывать на строку с числовым номером порта. Данный флаг используется для запрета вызова службы определения имён, если известно, что она не требуется."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:289
msgid "Either I<node> or I<service>, but not both, may be NULL."
msgstr "Либо I<node>, либо I<service> (но не оба одновременно) могут быть равны NULL."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:305
msgid ""
"The B<getaddrinfo>()  function allocates and initializes a linked list of "
"I<addrinfo> structures, one for each network address that matches I<node> "
"and I<service>, subject to any restrictions imposed by I<hints>, and returns"
" a pointer to the start of the list in I<res>.  The items in the linked list"
" are linked by the I<ai_next> field."
msgstr "Функция B<getaddrinfo>() выделяет место и инициализирует связный список структур I<addrinfo>, по одной на каждый сетевой адрес, который совпадает с I<node> и I<service>, в соответствии с любыми ограничениями, наложенными I<hints>, и возвращает указатель на начало списка в I<res>. Элементы в связном списке связаны через поле I<ai_next>."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:327
msgid ""
"There are several reasons why the linked list may have more than one "
"I<addrinfo> structure, including: the network host is multihomed, accessible"
" over multiple protocols (e.g., both B<AF_INET> and B<AF_INET6>); or the "
"same service is available from multiple socket types (one B<SOCK_STREAM> "
"address and another B<SOCK_DGRAM> address, for example).  Normally, the "
"application should try using the addresses in the order in which they are "
"returned.  The sorting function used within B<getaddrinfo>()  is defined in "
"RFC\\ 3484; the order can be tweaked for a particular system by editing "
"I</etc/gai.conf> (available since glibc 2.5)."
msgstr "Существует несколько причин того, почему связный список может содержать более одной структуры I<addrinfo>: сетевой узел имеет несколько адресов, доступен по нескольким протоколам (например, B<AF_INET> и B<AF_INET6>); служба доступна через несколько типов сокетов (например, один её адрес — B<SOCK_STREAM>, а второй — B<SOCK_DGRAM>). Обычно, приложение должно стараться использовать адреса в том порядке, в котором они получены. Функция сортировки, используемая в B<getaddrinfo>(), определена в RFC\\ 3484; в системе порядок может быть изменён через файл I</etc/gai.conf> (доступен, начиная с glibc 2.5)."

#.  In glibc prior to 2.3.4, the ai_canonname of each addrinfo
#.  structure was set pointing to the canonical name; that was
#.  more than POSIX.1-2001 specified, or other implementations provided.
#.  MTK, Aug 05
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:342
msgid ""
"If I<hints.ai_flags> includes the B<AI_CANONNAME> flag, then the "
"I<ai_canonname> field of the first of the I<addrinfo> structures in the "
"returned list is set to point to the official name of the host."
msgstr "Если в I<hints.ai_flags> выставлен флаг B<AI_CANONNAME>, то в поле I<ai_canonname> первой из структур I<addrinfo> возвращаемого списка задаётся указатель официального имени узла."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:346
msgid ""
"The remaining fields of each returned I<addrinfo> structure are initialized "
"as follows:"
msgstr "Остальные поля каждой возвращаемой структуры I<addrinfo> инициализируются следующим образом:"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:369
msgid ""
"The I<ai_family>, I<ai_socktype>, and I<ai_protocol> fields return the "
"socket creation parameters (i.e., these fields have the same meaning as the "
"corresponding arguments of B<socket>(2)).  For example, I<ai_family> might "
"return B<AF_INET> or B<AF_INET6>; I<ai_socktype> might return B<SOCK_DGRAM> "
"or B<SOCK_STREAM>; and I<ai_protocol> returns the protocol for the socket."
msgstr "В полях I<ai_family>, I<ai_socktype> и I<ai_protocol> возвращаются параметры создания сокета (т. е., эти поля имеют те же значения, что и соответствующие аргументы в B<socket>(2)). Например, в I<ai_family> может вернуться B<AF_INET> или B<AF_INET6>; в I<ai_socktype> может вернуться B<SOCK_DGRAM> или B<SOCK_STREAM>; в I<ai_protocol> возвращается протокол сокета."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:376
msgid ""
"A pointer to the socket address is placed in the I<ai_addr> field, and the "
"length of the socket address, in bytes, is placed in the I<ai_addrlen> "
"field."
msgstr "Указатель на адрес сокета помещается в поле I<ai_addr>, а длина адреса сокета (в байтах) помещается в поле I<ai_addrlen>."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:395
msgid ""
"If I<hints.ai_flags> includes the B<AI_ADDRCONFIG> flag, then IPv4 addresses"
" are returned in the list pointed to by I<res> only if the local system has "
"at least one IPv4 address configured, and IPv6 addresses are returned only "
"if the local system has at least one IPv6 address configured.  The loopback "
"address is not considered for this case as valid as a configured address.  "
"This flag is useful on, for example, IPv4-only systems, to ensure that "
"B<getaddrinfo>()  does not return IPv6 socket addresses that would always "
"fail in B<connect>(2)  or B<bind>(2)."
msgstr "Если в I<hints.ai_flags> содержится флаг B<AI_ADDRCONFIG>, то адреса IPv4, возвращаются в списке, на который указывает I<res>, только, если в локальной системе настроен, как минимум, один адрес IPv4, и адреса IPv6 возвращаются только, если в локальной системе настроен, как минимум, один адрес IPv6. Кольцевой (loopback) адрес в этом случае не учитывается как настроенный. Этот флаг полезен, например в только IPv4-системах, чтобы B<getaddrinfo>() не возвращал сокетные адреса IPv6, с которыми невозможно выполнить B<connect>(2) или B<bind>(2)."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:420
msgid ""
"If I<hints.ai_flags> specifies the B<AI_V4MAPPED> flag, and "
"I<hints.ai_family> was specified as B<AF_INET6>, and no matching IPv6 "
"addresses could be found, then return IPv4-mapped IPv6 addresses in the list"
" pointed to by I<res>.  If both B<AI_V4MAPPED> and B<AI_ALL> are specified "
"in I<hints.ai_flags>, then return both IPv6 and IPv4-mapped IPv6 addresses "
"in the list pointed to by I<res>.  B<AI_ALL> is ignored if B<AI_V4MAPPED> is"
" not also specified."
msgstr "Если в I<hints.ai_flags> содержится флаг B<AI_V4MAPPED> и в I<hints.ai_family> задан B<AF_INET6>, и не найдено подходящих адресов IPv6, то в списке, на который указывает I<res>, возвращаются IPv6 адреса отображённых адресов IPv4. Если в I<hints.ai_flags> указаны и B<AI_V4MAPPED>, и B<AI_ALL>, то в списке, на который указывает I<res>, возвращаются и адреса IPv6 и IPv6 адреса отображённых адресов IPv4. Флаг B<AI_ALL> игнорируется, если с ним не задан B<AI_V4MAPPED>."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:426
msgid ""
"The B<freeaddrinfo>()  function frees the memory that was allocated for the "
"dynamically allocated linked list I<res>."
msgstr "Функция B<freeaddrinfo>() освобождает память, которая была выделена для динамического связного списка I<res>."

#. type: SS
#: man-pages/man3/getaddrinfo.3:426
#, no-wrap
msgid "Extensions to getaddrinfo() for Internationalized Domain Names"
msgstr "Расширения getaddrinfo() для интернациональных доменных имён"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:435
msgid ""
"Starting with glibc 2.3.4, B<getaddrinfo>()  has been extended to "
"selectively allow the incoming and outgoing hostnames to be transparently "
"converted to and from the Internationalized Domain Name (IDN) format (see "
"RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>).  Four "
"new flags are defined:"
msgstr "Начиная с glibc 2.3.4, B<getaddrinfo>() был расширен для выборочного прозрачного разрешения исходящих и входящих адресов в формате интернациональных доменных имен (IDN, см. RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>). Было определено четыре новых флага:"

#. type: TP
#: man-pages/man3/getaddrinfo.3:435
#, no-wrap
msgid "B<AI_IDN>"
msgstr "B<AI_IDN>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:441
msgid ""
"If this flag is specified, then the node name given in I<node> is converted "
"to IDN format if necessary.  The source encoding is that of the current "
"locale."
msgstr "Если указан этот флаг, то, в случае необходимости, имя узла, указанного в I<node>, будет преобразовано в IDN-формат. Исходной кодировкой будет текущая локаль."

#.  Implementation Detail:
#.  To minimize effects on system performance the implementation might
#.  want to check whether the input string contains any non-ASCII
#.  characters.  If there are none the IDN step can be skipped completely.
#.  On systems which allow not-ASCII safe encodings for a locale this
#.  might be a problem.
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:453
msgid ""
"If the input name contains non-ASCII characters, then the IDN encoding is "
"used.  Those parts of the node name (delimited by dots) that contain non-"
"ASCII characters are encoded using ASCII Compatible Encoding (ACE)  before "
"being passed to the name resolution functions."
msgstr "Если имя на входе содержит символы не-ASCII, то будет задействовано кодирование IDN. Части имени узла (разделенные точками), которые содержат символы не-ASCII, будут закодированы с помощью ASCII Compatible Encoding (ACE) прежде, чем будут переданы функциям преобразования имен"

#. type: TP
#: man-pages/man3/getaddrinfo.3:453
#, no-wrap
msgid "B<AI_CANONIDN>"
msgstr "B<AI_CANONIDN>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:465
msgid ""
"After a successful name lookup, and if the B<AI_CANONNAME> flag was "
"specified, B<getaddrinfo>()  will return the canonical name of the node "
"corresponding to the I<addrinfo> structure value passed back.  The return "
"value is an exact copy of the value returned by the name resolution "
"function."
msgstr "При указанном флаге B<AI_CANONNAME> после успешного преобразования имени B<getaddrinfo>() вернет каноничное имя узла согласно значению структуры I<addrinfo>. Возвращаемое значение будет точной копией значения, возвращенного функцией разрешения имени."

#. Implementation Detail:
#. If no component of the returned name starts with xn\-\- the IDN
#. step can be skipped, therefore avoiding unnecessary slowdowns.
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:478
msgid ""
"If the name is encoded using ACE, then it will contain the I<xn--> prefix "
"for one or more components of the name.  To convert these components into a "
"readable form the B<AI_CANONIDN> flag can be passed in addition to "
"B<AI_CANONNAME>.  The resulting string is encoded using the current locale's"
" encoding."
msgstr "Если имя закодировано с помощью ACE, то оно будет содержать префикс I<xn--> для каждого из закодированных компонентов имени. Чтобы преобразовать эти компоненты в читаемый вид, вместе с флагом B<AI_CANONNAME> следует передать B<AI_CANONIDN>. Итоговая строка будет кодирована при помощи текущей локали."

#. type: TP
#: man-pages/man3/getaddrinfo.3:478
#, no-wrap
msgid "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"
msgstr "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getaddrinfo(); they need to
#.  be documented.
#.     #ifdef __USE_GNU
#.     #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.     #define EAI_CANCELED    -101  /* Request canceled.  */
#.     #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.     #define EAI_ALLDONE     -103  /* All requests done.  */
#.     #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.     #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.     #endif
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:499
msgid ""
"B<getaddrinfo>()  returns 0 if it succeeds, or one of the following nonzero "
"error codes:"
msgstr "В случае успеха B<getaddrinfo>() возвращает 0, либо один из следующие ненулевых кодов ошибки:"

#. type: TP
#: man-pages/man3/getaddrinfo.3:499
#, no-wrap
msgid "B<EAI_ADDRFAMILY>"
msgstr "B<EAI_ADDRFAMILY>"

#.  Not in SUSv3
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:504
msgid ""
"The specified network host does not have any network addresses in the "
"requested address family."
msgstr "У указанного сетевого узла нет сетевых адресов в запрашиваемом семействе адресов."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:508
msgid ""
"The name server returned a temporary failure indication.  Try again later."
msgstr "Сервер имен вернул временную ошибку. Попробуйте позднее."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:518
msgid ""
"I<hints.ai_flags> contains invalid flags; or, I<hints.ai_flags> included "
"B<AI_CANONNAME> and I<name> was NULL."
msgstr "В I<hints.ai_flags> содержатся неправильные флаги, либо I<hints.ai_flags> содержит B<AI_CANONNAME>, а I<name> - NULL."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:521
msgid "The name server returned a permanent failure indication."
msgstr "Сервер имен вернул постоянную ошибку."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:524
msgid "The requested address family is not supported."
msgstr "Запрашиваемое семейство адресов не поддерживается."

#. type: TP
#: man-pages/man3/getaddrinfo.3:527
#, no-wrap
msgid "B<EAI_NODATA>"
msgstr "B<EAI_NODATA>"

#.  Not in SUSv3
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:532
msgid ""
"The specified network host exists, but does not have any network addresses "
"defined."
msgstr "Указанный сетевой узел существует, однако не имеет ни одного определенного сетевого адреса."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:549
msgid ""
"The I<node> or I<service> is not known; or both I<node> and I<service> are "
"NULL; or B<AI_NUMERICSERV> was specified in I<hints.ai_flags> and I<service>"
" was not a numeric port-number string."
msgstr "I<node> или I<service> неизвестно; либо и I<node>, и I<service> равны NULL; либо в I<hints.ai_flags> указан флаг B<AI_NUMERICSERV>, а I<service> не является числовой строкой порта."

#. type: TP
#: man-pages/man3/getaddrinfo.3:549
#, no-wrap
msgid "B<EAI_SERVICE>"
msgstr "B<EAI_SERVICE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:570
msgid ""
"The requested service is not available for the requested socket type.  It "
"may be available through another socket type.  For example, this error could"
" occur if I<service> was \"shell\" (a service available only on stream "
"sockets), and either I<hints.ai_protocol> was B<IPPROTO_UDP>, or "
"I<hints.ai_socktype> was B<SOCK_DGRAM>; or the error could occur if "
"I<service> was not NULL, and I<hints.ai_socktype> was B<SOCK_RAW> (a socket "
"type that does not support the concept of services)."
msgstr "Запрошенная служба не доступна для запрошенного типа сокета. Она может быть доступна через другой тип сокета. Например, эта ошибка может возникнуть, если в I<service> указан «shell» (служба, доступная только для потоковых сокетов) при указанном в I<hints.ai_protocol> B<IPPROTO_UDP>, либо указанном в I<hints.ai_socktype> B<SOCK_DGRAM>. Также ошибка может возникнуть, если I<service> не равно NULL, а в I<hints.ai_socktype> указано значение B<SOCK_RAW> (тип сокета, для которого концепция служб неприменима)."

#. type: TP
#: man-pages/man3/getaddrinfo.3:570
#, no-wrap
msgid "B<EAI_SOCKTYPE>"
msgstr "B<EAI_SOCKTYPE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:582
msgid ""
"The requested socket type is not supported.  This could occur, for example, "
"if I<hints.ai_socktype> and I<hints.ai_protocol> are inconsistent (e.g., "
"B<SOCK_DGRAM> and B<IPPROTO_TCP>, respectively)."
msgstr "Запрашиваемый тип сокетов не поддерживается. Такая ошибка может возникнуть, если I<hints.ai_socktype> и I<hints.ai_protocol> противоречат друг другу (например, B<SOCK_DGRAM> и B<IPPROTO_TCP> соответственно)."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:587
msgid "Other system error, check I<errno> for details."
msgstr "Для других системных ошибок следует проверять I<errno>."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:592
msgid ""
"The B<gai_strerror>()  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr "Функция B<gai_strerror>() транслирует эти коды ошибок в читаемый формат, подходящий для сообщений об ошибке."

#. type: tbl table
#: man-pages/man3/getaddrinfo.3:604
#, no-wrap
msgid "B<getaddrinfo>()"
msgstr "B<getaddrinfo>()"

#. type: tbl table
#: man-pages/man3/getaddrinfo.3:608
#, no-wrap
msgid ""
"B<freeaddrinfo>(),\n"
"B<gai_strerror>()"
msgstr "B<freeaddrinfo>(),\nB<gai_strerror>()"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:616
msgid ""
"POSIX.1-2001, POSIX.1-2008.  The B<getaddrinfo>()  function is documented in"
" RFC\\ 2553."
msgstr "POSIX.1-2001, POSIX.1-2008. Функция B<getaddrinfo>() описана в RFC\\ 2553."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:621
msgid ""
"B<getaddrinfo>()  supports the I<address>B<%>I<scope-id> notation for "
"specifying the IPv6 scope-ID."
msgstr "B<getaddrinfo>() поддерживает нотацию I<address>B<%>I<scope-id> для указания IPv6 scope-ID."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:629
msgid ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, and B<AI_V4MAPPED> are available since glibc "
"2.3.3.  B<AI_NUMERICSERV> is available since glibc 2.3.4."
msgstr "B<AI_ADDRCONFIG>, B<AI_ALL> и B<AI_V4MAPPED> доступны, начиная с glibc 2.3.3.  B<AI_NUMERICSERV> доступен, начиная с glibc 2.3.4."

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:640
msgid ""
"According to POSIX.1, specifying I<hints> as NULL should cause I<ai_flags> "
"to be assumed as 0.  The GNU C library instead assumes a value of "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> for this case, since this value is "
"considered an improvement on the specification."
msgstr "Согласно POSIX.1, при указании I<hints> в NULL I<ai_flags> должен предполагаться как равный 0. Вместо этого библиотека GNU C в данном случае предполагает значение B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>, так как данное значение было принято в качестве улучшения спецификации."

#.  getnameinfo.3 refers to this example
#.  socket.2 refers to this example
#.  bind.2 refers to this example
#.  connect.2 refers to this example
#.  recvfrom.2 refers to this example
#.  sendto.2 refers to this example
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:654
msgid ""
"The following programs demonstrate the use of B<getaddrinfo>(), "
"B<gai_strerror>(), B<freeaddrinfo>(), and B<getnameinfo>(3).  The programs "
"are an echo server and client for UDP datagrams."
msgstr "Следующие программы демонстрируют использование B<getaddrinfo>(), B<gai_strerror>(), B<freeaddrinfo>() и B<getnameinfo>(3). Это программы эхо-сервера и клиента UDP-дейтаграмм."

#. type: SS
#: man-pages/man3/getaddrinfo.3:654
#, no-wrap
msgid "Server program"
msgstr "Серверная программа"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:664
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr "#include E<lt>sys/types.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>sys/socket.hE<gt>\n#include E<lt>netdb.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:666 man-pages/man3/getaddrinfo.3:761
#, no-wrap
msgid "#define BUF_SIZE 500\n"
msgstr "#define BUF_SIZE 500\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:677
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct addrinfo hints;\n    struct addrinfo *result, *rp;\n    int sfd, s;\n    struct sockaddr_storage peer_addr;\n    socklen_t peer_addr_len;\n    ssize_t nread;\n    char buf[BUF_SIZE];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:682
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:691
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"
msgstr "    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    /* Разрешены IPv4 и IPv6 */\n    hints.ai_socktype = SOCK_DGRAM; /* Сокет для дейтаграмм */\n    hints.ai_flags = AI_PASSIVE;    /* Для wildcard IP-адреса */\n    hints.ai_protocol = 0;          /* Любой протокол */\n    hints.ai_canonname = NULL;\n    hints.ai_addr = NULL;\n    hints.ai_next = NULL;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:697
#, no-wrap
msgid ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    s = getaddrinfo(NULL, argv[1], &hints, &result);\n    if (s != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:702
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr "    /* getaddrinfo() возвращает список структур адресов.\n       Идет проверка каждого адреса до успешного bind(2).\n       Если socket(2) (или bind(2)) терпит неудачу, мы (закрываем\n       сокет и) пробуем следующий. */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:708
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr "    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n                rp-E<gt>ai_protocol);\n        if (sfd == -1)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:711
#, no-wrap
msgid ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"
msgstr "        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n            break;                  /* Успех */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:714 man-pages/man3/getaddrinfo.3:807
#, no-wrap
msgid ""
"        close(sfd);\n"
"    }\n"
msgstr "        close(sfd);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:719
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (rp == NULL) {               /* Нет успешных адресов */\n        fprintf(stderr, \"Could not bind\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:721 man-pages/man3/getaddrinfo.3:814
#, no-wrap
msgid "    freeaddrinfo(result);           /* No longer needed */\n"
msgstr "    freeaddrinfo(result);           /* Больше не нужен */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:723
#, no-wrap
msgid "    /* Read datagrams and echo them back to sender */\n"
msgstr "    /* Читаем дейтаграмму и пересылаем ее назад отправителю */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:730
#, no-wrap
msgid ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(struct sockaddr_storage);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"
msgstr "    for (;;) {\n        peer_addr_len = sizeof(struct sockaddr_storage);\n        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n                (struct sockaddr *) &peer_addr, &peer_addr_len);\n        if (nread == -1)\n            continue;               /* Игнорируем запрос с ошибкой */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:732
#, no-wrap
msgid "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"
msgstr "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:741
#, no-wrap
msgid ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"        if (s == 0)\n"
"            printf(\"Received %zd bytes from %s:%s\\en\",\n"
"                    nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"
msgstr "        s = getnameinfo((struct sockaddr *) &peer_addr,\n                        peer_addr_len, host, NI_MAXHOST,\n                        service, NI_MAXSERV, NI_NUMERICSERV);\n       if (s == 0)\n            printf(\"Получено %zd байт из %s:%s\\en\",\n                    nread, host, service);\n        else\n            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:748
#, no-wrap
msgid ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"
msgstr "        if (sendto(sfd, buf, nread, 0,\n                    (struct sockaddr *) &peer_addr,\n                    peer_addr_len) != nread)\n            fprintf(stderr, \"Ошибка отправки ответа\\en\");\n    }\n}\n"

#. type: SS
#: man-pages/man3/getaddrinfo.3:749
#, no-wrap
msgid "Client program"
msgstr "Клиентская программа"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:759
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#include E<lt>sys/types.hE<gt>\n#include E<lt>sys/socket.hE<gt>\n#include E<lt>netdb.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:771
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s, j;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct addrinfo hints;\n    struct addrinfo *result, *rp;\n    int sfd, s, j;\n    size_t len;\n    ssize_t nread;\n    char buf[BUF_SIZE];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:776
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 3) {\n        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:778
#, no-wrap
msgid "    /* Obtain address(es) matching host/port */\n"
msgstr "    /* Получаем адрес(а), соответствующие узлу/порту */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:784
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
msgstr "    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    /* Разрешены IPv4 и IPv6 */\n    hints.ai_socktype = SOCK_DGRAM; /* Сокет дейтаграмм */\n    hints.ai_flags = 0;\n    hints.ai_protocol = 0;          /* Любой протокол */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:790
#, no-wrap
msgid ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n    if (s != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:795
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr "    /* getaddrinfo() возвращает список структур адресов.\n       Идет проверка каждого адреса до успешного connect(2).\n       Если socket(2) (или connect(2)) терпит неудачу, мы (закрываем\n       сокет и) пробуем следующий. */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:801
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr "    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n                     rp-E<gt>ai_protocol);\n        if (sfd == -1)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:804
#, no-wrap
msgid ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"
msgstr "        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n            break;                  /* Успех */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:812
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (rp == NULL) {               /* Нет успешных адресов */\n        fprintf(stderr, \"Could not connect\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:817
#, no-wrap
msgid ""
"    /* Send remaining command-line arguments as separate\n"
"       datagrams, and read responses from server */\n"
msgstr "    /* Отправляем оставшиеся аргументы командной строки\n       в виде отдельных дейтаграмм и ждем ответа от сервера */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:821
#, no-wrap
msgid ""
"    for (j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"
msgstr "    for (j = 3; j E<lt> argc; j++) {\n        len = strlen(argv[j]) + 1;\n                /* +1 для завершающего null-байта */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:827
#, no-wrap
msgid ""
"        if (len E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"
msgstr "        if (len E<gt> BUF_SIZE) {\n            fprintf(stderr,\n                    \"Игнорируем длинное сообщение в аргументе %d\\en\", j);\n            continue;\n        }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:832
#, no-wrap
msgid ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr "        if (write(sfd, argv[j], len) != len) {\n            fprintf(stderr, \"partial/failed write\\en\");\n            exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:838
#, no-wrap
msgid ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr "        nread = read(sfd, buf, BUF_SIZE);\n        if (nread == -1) {\n            perror(\"read\");\n            exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:841
#, no-wrap
msgid ""
"        printf(\"Received %zd bytes: %s\\en\", nread, buf);\n"
"    }\n"
msgstr "        printf(\"Получено %zd байт: %s\\en\", nread, buf);\n    }\n"

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:854
msgid ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"
msgstr "B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), B<gai.conf>(5), B<hostname>(7), B<ip>(7)"

#. type: TH
#: man-pages/man3/getsubopt.3:25
#, no-wrap
msgid "GETSUBOPT"
msgstr "GETSUBOPT"

#. type: Plain text
#: man-pages/man3/getsubopt.3:28
msgid "getsubopt - parse suboption arguments from a string"
msgstr "getsubopt - анализирует подпараметры аргументов строки"

#. type: Plain text
#: man-pages/man3/getsubopt.3:33
msgid ""
"B<int getsubopt(char **>I<optionp>B<, char * const *>I<tokens>B<, char "
"**>I<valuep>B<);>"
msgstr "B<int getsubopt(char **>I<optionp>B<, char * const *>I<tokens>B<, char **>I<valuep>B<);>"

#. type: Plain text
#: man-pages/man3/getsubopt.3:40
msgid "B<getsubopt>():"
msgstr "B<getsubopt>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getsubopt.3:45
msgid "_XOPEN_SOURCE\\ E<gt>= 500"
msgstr "_XOPEN_SOURCE\\ E<gt>= 500"

#. type: Plain text
#: man-pages/man3/getsubopt.3:64
msgid ""
"B<getsubopt>()  parses the list of comma-separated suboptions provided in "
"I<optionp>.  (Such a suboption list is typically produced when B<getopt>(3)"
"  is used to parse a command line; see for example the I<-o> option of "
"B<mount>(8).)  Each suboption may include an associated value, which is "
"separated from the suboption name by an equal sign.  The following is an "
"example of the kind of string that might be passed in I<optionp>:"
msgstr "Функция B<getsubopt>() анализирует список подпараметров, указываемых через запятую, заданный в I<optionp> (такой список подпараметров, обычно, создаётся при использовании B<getopt>(3) для разбора командной строки; например, смотрите параметр  I<-o> в B<mount>(8)). Каждый подпараметр может содержать связанное с ним значение, которое отделяется от имени подпараметра знаком равно. Вот пример строки, которую можно передать в I<optionp>:"

#. type: Plain text
#: man-pages/man3/getsubopt.3:68
#, no-wrap
msgid "B<ro,name=xyz>\n"
msgstr "B<ro,name=xyz>\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:79
msgid ""
"The I<tokens> argument is a pointer to a NULL-terminated array of pointers "
"to the tokens that B<getsubopt>()  will look for in I<optionp>.  The tokens "
"should be distinct, null-terminated strings containing at least one "
"character, with no embedded equal signs or commas."
msgstr "Аргумент I<tokens> — указатель на массив (завершается NULL) указателей на токены, которые B<getsubopt>() будет просматривать при поиске в I<optionp>. Токены должны быть различающимися строками (завершающимися null), содержащими, как минимум, один символ и не содержащих знаков равно или запятых."

#. type: Plain text
#: man-pages/man3/getsubopt.3:100
msgid ""
"Each call to B<getsubopt>()  returns information about the next unprocessed "
"suboption in I<optionp>.  The first equal sign in a suboption (if any) is "
"interpreted as a separator between the name and the value of that suboption."
"  The value extends to the next comma, or (for the last suboption) to the "
"end of the string.  If the name of the suboption matches a known name from "
"I<tokens>, and a value string was found, B<getsubopt>()  sets I<*valuep> to "
"the address of that string.  The first comma in I<optionp> is overwritten "
"with a null byte, so I<*valuep> is precisely the \"value string\" for that "
"suboption."
msgstr "При каждом вызове B<getsubopt>() возвращается информация о следующем необработанном подпараметре в I<optionp>. Первый знак равно в подпараметре (если есть) считается разделителем имени и значения в этом подпараметре. Значение длится до последующей запятой или (для последнего подпараметра) до конца строки. Если имя подпараметра совпадает с известным именем из I<tokens>, и найдено строка-значение, то B<getsubopt>() записывает в I<*valuep> адрес этой строки. Первая запятая в I<optionp> перезаписывается байтом null, поэтому I<*valuep> — точное «строка-значение» этого подпараметра."

#. type: Plain text
#: man-pages/man3/getsubopt.3:104
msgid ""
"If the suboption is recognized, but no value string was found, I<*valuep> is"
" set to NULL."
msgstr "Если подпараметр распознан, но значение строки не найдено, то I<*valuep> присваивается NULL."

#. type: Plain text
#: man-pages/man3/getsubopt.3:112
msgid ""
"When B<getsubopt>()  returns, I<optionp> points to the next suboption, or to"
" the null byte (\\(aq\\e0\\(aq) at the end of the string if the last "
"suboption was just processed."
msgstr "При завершении работы B<getsubopt>() значение I<optionp> указывает на следующий подпараметр или на байт null (\\(aq\\e0\\(aq) в конце строки (в случае, если последний подпараметр был только что обработан)."

#. type: Plain text
#: man-pages/man3/getsubopt.3:124
msgid ""
"If the first suboption in I<optionp> is recognized, B<getsubopt>()  returns "
"the index of the matching suboption element in I<tokens>.  Otherwise, -1 is "
"returned and I<*valuep> is the entire I<name>B<[=>I<value>B<]> string."
msgstr "Если в I<optionp> распознан первый подпараметр, то B<getsubopt>() возвращает индекс элемента в I<tokens> найденного подпараметра. В противном случае возвращается -1 и значение I<*valuep> указывает на целую строку I<name>B<[=>I<value>B<]>."

#. type: Plain text
#: man-pages/man3/getsubopt.3:131
msgid ""
"Since I<*optionp> is changed, the first suboption before the call to "
"B<getsubopt>()  is not (necessarily) the same as the first suboption after "
"B<getsubopt>()."
msgstr "Так как I<*optionp> изменяется, первый подпараметр перед вызовом B<getsubopt>() не (не всегда) тот же самый, что и первый подпараметр после B<getsubopt>()."

#. type: tbl table
#: man-pages/man3/getsubopt.3:141
#, no-wrap
msgid "B<getsubopt>()"
msgstr "B<getsubopt>()"

#. type: Plain text
#: man-pages/man3/getsubopt.3:152
msgid ""
"Since B<getsubopt>()  overwrites any commas it finds in the string "
"I<*optionp>, that string must be writable; it cannot be a string constant."
msgstr "Так как B<getsubopt>() заменяет запятые, найденные в строке I<*optionp>, то строка должна быть доступна на запись; она не может быть строковой константой."

#. type: Plain text
#: man-pages/man3/getsubopt.3:154
msgid "The following program expects suboptions following a \"-o\" option."
msgstr "Следующая программа ожидает подпараметры после параметра «-o»."

#. type: Plain text
#: man-pages/man3/getsubopt.3:160
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#define _XOPEN_SOURCE 500\n#include E<lt>stdlib.hE<gt>\n#include E<lt>assert.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:178
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    enum {\n"
"        RO_OPT = 0,\n"
"        RW_OPT,\n"
"        NAME_OPT\n"
"    };\n"
"    char *const token[] = {\n"
"        [RO_OPT]   = \"ro\",\n"
"        [RW_OPT]   = \"rw\",\n"
"        [NAME_OPT] = \"name\",\n"
"        NULL\n"
"    };\n"
"    char *subopts;\n"
"    char *value;\n"
"    int opt;\n"
msgstr "int\nmain(int argc, char **argv)\n{\n    enum {\n        RO_OPT = 0,\n        RW_OPT,\n        NAME_OPT\n    };\n    char *const token[] = {\n        [RO_OPT]   = \"ro\",\n        [RW_OPT]   = \"rw\",\n        [NAME_OPT] = \"name\",\n        NULL\n    };\n    char *subopts;\n    char *value;\n    int opt;\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:183
#, no-wrap
msgid ""
"    int readonly = 0;\n"
"    int readwrite = 0;\n"
"    char *name = NULL;\n"
"    int errfnd = 0;\n"
msgstr "    int readonly = 0;\n    int readwrite = 0;\n    char *name = NULL;\n    int errfnd = 0;\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:189
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"o:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqo\\(aq:\n"
"            subopts = optarg;\n"
"            while (*subopts != \\(aq\\e0\\(aq && !errfnd) {\n"
msgstr "    while ((opt = getopt(argc, argv, \"o:\")) != -1) {\n        switch (opt) {\n        case \\(aqo\\(aq:\n            subopts = optarg;\n            while (*subopts != \\(aq\\e0\\(aq && !errfnd) {\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:194
#, no-wrap
msgid ""
"            switch (getsubopt(&subopts, token, &value)) {\n"
"            case RO_OPT:\n"
"                readonly = 1;\n"
"                break;\n"
msgstr "            switch (getsubopt(&subopts, token, &value)) {\n            case RO_OPT:\n                readonly = 1;\n                break;\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:198
#, no-wrap
msgid ""
"            case RW_OPT:\n"
"                readwrite = 1;\n"
"                break;\n"
msgstr "            case RW_OPT:\n                readwrite = 1;\n                break;\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:206
#, no-wrap
msgid ""
"            case NAME_OPT:\n"
"                if (value == NULL) {\n"
"                    fprintf(stderr, \"Missing value for \"\n"
"                            \"suboption \\(aq%s\\(aq\\en\", token[NAME_OPT]);\n"
"                    errfnd = 1;\n"
"                    continue;\n"
"                }\n"
msgstr "            case NAME_OPT:\n                if (value == NULL) {\n                    fprintf(stderr, \"Отсутствует значение для \"\n                            \"подпараметра \\(aq%s\\(aq\\en\", token[NAME_OPT]);\n                    errfnd = 1;\n                    continue;\n                }\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:209
#, no-wrap
msgid ""
"                name = value;\n"
"                break;\n"
msgstr "                name = value;\n                break;\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:223
#, no-wrap
msgid ""
"            default:\n"
"                fprintf(stderr, \"No match found \"\n"
"                        \"for token: /%s/\\en\", value);\n"
"                errfnd = 1;\n"
"                break;\n"
"            }\n"
"        }\n"
"        if (readwrite && readonly) {\n"
"            fprintf(stderr, \"Only one of \\(aq%s\\(aq and \\(aq%s\\(aq can be \"\n"
"                    \"specified\\en\", token[RO_OPT], token[RW_OPT]);\n"
"            errfnd = 1;\n"
"        }\n"
"        break;\n"
msgstr "            default:\n                fprintf(stderr, \"Совпадения не найдены \"\n                        \"для токена: /%s/\\en\", value);\n                errfnd = 1;\n                break;\n            }\n        }\n        if (readwrite && readonly) {\n            fprintf(stderr, \"Может указываться только одно из \\(aq%s\\(aq \"\n                    \"и \\(aq%s\\(aq\\en\", token[RO_OPT], token[RW_OPT]);\n            errfnd = 1;\n        }\n        break;\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:228
#, no-wrap
msgid ""
"        default:\n"
"            errfnd = 1;\n"
"        }\n"
"    }\n"
msgstr "        default:\n            errfnd = 1;\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:235
#, no-wrap
msgid ""
"    if (errfnd || argc == 1) {\n"
"        fprintf(stderr, \"\\enUsage: %s -o E<lt>suboptstringE<gt>\\en\", argv[0]);\n"
"        fprintf(stderr, \"suboptions are \\(aqro\\(aq, \\(aqrw\\(aq, \"\n"
"                \"and \\(aqname=E<lt>valueE<gt>\\(aq\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (errfnd || argc == 1) {\n        fprintf(stderr, \"\\enИспользование: %s -o E<lt>подпараметрE<gt>\\en\", argv[0]);\n        fprintf(stderr, \"возможны подпараметры: \\(aqro\\(aq, \\(aqrw\\(aq, \"\n                \"и \\(aqname=E<lt>значениеE<gt>\\(aq\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:237
#, no-wrap
msgid "    /* Remainder of program... */\n"
msgstr "    /* Остальная часть программы… */\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:242
msgid "B<getopt>(3)"
msgstr "B<getopt>(3)"

#. type: TH
#: man-pages/man3/getrpcent_r.3:26
#, no-wrap
msgid "GETRPCENT_R"
msgstr "GETRPCENT_R"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:30
msgid ""
"getrpcent_r, getrpcbyname_r, getrpcbynumber_r - get RPC entry (reentrant)"
msgstr "getrpcent_r, getrpcbyname_r, getrpcbynumber_r - возвращают запись RPC (реентерабельные версии)"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:36
#, no-wrap
msgid ""
"B<int getrpcent_r(struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr "B<int getrpcent_r(struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:40
#, no-wrap
msgid ""
"B<int getrpcbyname_r(const char *>I<name>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr "B<int getrpcbyname_r(const char *>I<name>B<,>\nB<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:44
#, no-wrap
msgid ""
"B<int getrpcbynumber_r(int >I<number>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr "B<int getrpcbynumber_r(int >I<number>B<,>\nB<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:59
#, no-wrap
msgid ""
"B<getrpcent_r>(),\n"
"B<getrpcbyname_r>(),\n"
"B<getrpcbynumber_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getrpcent_r>(),\nB<getrpcbyname_r>(),\nB<getrpcbynumber_r>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:77
msgid ""
"The B<getrpcent_r>(), B<getrpcbyname_r>(), and B<getrpcbynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getrpcent>(3), "
"B<getrpcbyname>(3), and B<getrpcbynumber>(3).  They differ in the way that "
"the I<rpcent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr "Функции B<getrpcent_r>(), B<getrpcbyname_r>() и B<getrpcbynumber_r>() являются реентерабельными эквивалентами B<getrpcent>(3), B<getrpcbyname>(3) и B<getrpcbynumber>(3), соответственно. Они отличаются способом возврата структуры I<rpcent>, списком параметров и типом возвращаемого значения. В этой справочной странице описаны только различия с нереентерабельными функциями."

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<rpcent> structure"
" as the function result, these functions copy the structure into the "
"location pointed to by I<result_buf>."
msgstr "Вместо возврата указателя на статически выделенную структуру I<rpcent> в качестве результата эти функции копируют структуру в расположение, указанное I<result_buf>."

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getrpcent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<rpcent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr "Массив I<buf> используется для хранения строковых полей из возвращаемой структуры I<rpcent> (нереентерабельные функции выделяют эти строки из статического хранилища). Размер данного массива задаётся в I<buflen>. Если I<buf> слишком мал, то вызов завершается с ошибкой B<ERANGE>, вызывающий должен его повторить с большим буфером (для большинства приложений должно быть достаточно буфера длиной 1024 байт)."

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:108
msgid ""
"If the function call successfully obtains an RPC record, then I<*result> is "
"set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr "Если вызов получил запись RPC, то  I<*result> указывает на I<result_buf>; в противном случае I<*result> устанавливается в NULL."

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:119
msgid ""
"On error, record not found (B<getrpcbyname_r>(), B<getrpcbynumber_r>()), or "
"end of input (B<getrpcent_r>())  I<result> is set to NULL."
msgstr "При ошибке, отсутствии записи (B<getrpcbyname_r>(), B<getrpcbynumber_r>()) или конце данных (B<getrpcent_r>()) значение I<result> равно NULL."

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:124
msgid "(B<getrpcent_r>())  No more records in database."
msgstr "(B<getrpcent_r>()) Больше нет записей в базе данных."

#. type: tbl table
#: man-pages/man3/getrpcent_r.3:144
#, no-wrap
msgid ""
"B<getrpcent_r>(),\n"
"B<getrpcbyname_r>(),\n"
"B<getrpcbynumber_r>()"
msgstr "B<getrpcent_r>(),\nB<getrpcbyname_r>(),\nB<getrpcbynumber_r>()"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:153
msgid "B<getrpcent>(3), B<rpc>(5)"
msgstr "B<getrpcent>(3), B<rpc>(5)"

#. type: TH
#: man-pages/man3/getdtablesize.3:27
#, no-wrap
msgid "GETDTABLESIZE"
msgstr "GETDTABLESIZE"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:30
msgid "getdtablesize - get file descriptor table size"
msgstr "getdtablesize - возвращает размер таблицы файловых дескрипторов"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:34
msgid "B<int getdtablesize(void);>"
msgstr "B<int getdtablesize(void);>"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:41
msgid "B<getdtablesize>():"
msgstr "B<getdtablesize>():"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:50
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr "/* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:62
msgid ""
"B<getdtablesize>()  returns the maximum number of files a process can have "
"open, one more than the largest possible value for a file descriptor."
msgstr "B<getdtablesize>() возвращает максимальное количество файлов, которое может быть открыто в процессе, на единицу больше, чем наибольшее возможное значение для дескриптора файла."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:64
msgid "The current limit on the number of open files per process."
msgstr "Текущее ограничение на количество открытых файлов для процесса."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:70
msgid ""
"On Linux, B<getdtablesize>()  can return any of the errors described for "
"B<getrlimit>(2); see NOTES below."
msgstr "В Linux, B<getdtablesize>() может вернуть любую ошибку из описанных в B<getrlimit>(2); см. ЗАМЕЧАНИЯ далее."

#. type: tbl table
#: man-pages/man3/getdtablesize.3:80
#, no-wrap
msgid "B<getdtablesize>()"
msgstr "B<getdtablesize>()"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:90
msgid ""
"SVr4, 4.4BSD (the B<getdtablesize>()  function first appeared in 4.2BSD).  "
"It is not specified in POSIX.1; portable applications should employ "
"I<sysconf(_SC_OPEN_MAX)> instead of this call."
msgstr "SVr4, 4.4BSD (функция B<getdtablesize>() впервые появилась в 4.2BSD). Она отсутствует в POSIX.1; переносимые приложения вместо неё должны применять I<sysconf(_SC_OPEN_MAX)>."

#.  The libc4 and libc5 versions return
#.  .B OPEN_MAX
#.  (set to 256 since Linux 0.98.4).
#. type: Plain text
#: man-pages/man3/getdtablesize.3:103
msgid ""
"B<getdtablesize>()  is implemented as a libc library function.  The glibc "
"version calls B<getrlimit>(2)  and returns the current B<RLIMIT_NOFILE> "
"limit, or B<OPEN_MAX> when that fails."
msgstr "Функция B<getdtablesize>() реализована в виде библиотечной функции libc. Версия glibc вызывает B<getrlimit>(2) и возвращает текущее ограничение B<RLIMIT_NOFILE>; при ошибке возвращается B<OPEN_MAX>."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:107
msgid "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"
msgstr "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"

#. type: TH
#: man-pages/man3/getcwd.3:32
#, no-wrap
msgid "GETCWD"
msgstr "GETCWD"

#. type: Plain text
#: man-pages/man3/getcwd.3:35
msgid "getcwd, getwd, get_current_dir_name - get current working directory"
msgstr "getcwd, getwd, get_current_dir_name - возвращают текущий рабочий каталог"

#. type: Plain text
#: man-pages/man3/getcwd.3:40
#, no-wrap
msgid "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:42
#, no-wrap
msgid "B<char *getwd(char *>I<buf>B<);>\n"
msgstr "B<char *getwd(char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:44
#, no-wrap
msgid "B<char *get_current_dir_name(void);>\n"
msgstr "B<char *get_current_dir_name(void);>\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:52
msgid "B<get_current_dir_name>():"
msgstr "B<get_current_dir_name>():"

#. type: Plain text
#: man-pages/man3/getcwd.3:57
msgid "B<getwd>():"
msgstr "B<getwd>():"

#. type: Plain text
#: man-pages/man3/getcwd.3:66
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr "(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:81
msgid ""
"These functions return a null-terminated string containing an absolute "
"pathname that is the current working directory of the calling process.  The "
"pathname is returned as the function result and via the argument I<buf>, if "
"present."
msgstr "Данные функции возвращают строку (с null в конце), содержащую абсолютный путь текущего рабочего каталога вызывающего процесса. Путь возвращается как результат функции или в аргументе I<buf>, если он есть."

#. type: Plain text
#: man-pages/man3/getcwd.3:89
msgid ""
"The B<getcwd>()  function copies an absolute pathname of the current working"
" directory to the array pointed to by I<buf>, which is of length I<size>."
msgstr "Функция B<getcwd>() копирует абсолютный путь текущего рабочего каталога в массив, на который указывает I<buf>, имеющий длину I<size>."

#. type: Plain text
#: man-pages/man3/getcwd.3:99
msgid ""
"If the length of the absolute pathname of the current working directory, "
"including the terminating null byte, exceeds I<size> bytes, NULL is "
"returned, and I<errno> is set to B<ERANGE>; an application should check for "
"this error, and allocate a larger buffer if necessary."
msgstr "Если длина абсолютного пути, включая конечный байт null, превышает I<size> байт, то возвращается NULL, а I<errno> принимает значение B<ERANGE>; приложение должно проверить, возникла эта ошибка или нет и, если необходимо, выделить буфер большего размера."

#. type: Plain text
#: man-pages/man3/getcwd.3:117
msgid ""
"As an extension to the POSIX.1-2001 standard, glibc's B<getcwd>()  allocates"
" the buffer dynamically using B<malloc>(3)  if I<buf> is NULL.  In this "
"case, the allocated buffer has the length I<size> unless I<size> is zero, "
"when I<buf> is allocated as big as necessary.  The caller should B<free>(3)"
"  the returned buffer."
msgstr "Согласно расширению стандарта POSIX.1-2001 в glibc предусмотрено следующее: если I<buf> равно NULL, то при вызове B<getcwd>() буфер выделяется динамически с помощью функции B<malloc>(3). В этом случае выделенный буфер имеет размер I<size>; если I<size> равно нулю, то выделяется I<buf> необходимого размера. Вызывающий после использования должен освободить выделенный буфер с помощью B<free>(3)."

#. type: Plain text
#: man-pages/man3/getcwd.3:130
msgid ""
"B<get_current_dir_name>()  will B<malloc>(3)  an array big enough to hold "
"the absolute pathname of the current working directory.  If the environment "
"variable B<PWD> is set, and its value is correct, then that value will be "
"returned.  The caller should B<free>(3)  the returned buffer."
msgstr "Функция B<get_current_dir_name>() выделит с помощью B<malloc>(3) массив, достаточно большой для помещения в него абсолютного пути имени текущего каталога. Если существует и имеет правильное значение переменная окружения B<PWD>, то будет возвращено её значение. Вызывающий после использования должен освободить выделенный буфер с помощью B<free>(3)."

#. type: Plain text
#: man-pages/man3/getcwd.3:155
msgid ""
"B<getwd>()  does not B<malloc>(3)  any memory.  The I<buf> argument should "
"be a pointer to an array at least B<PATH_MAX> bytes long.  If the length of "
"the absolute pathname of the current working directory, including the "
"terminating null byte, exceeds B<PATH_MAX> bytes, NULL is returned, and "
"I<errno> is set to B<ENAMETOOLONG>.  (Note that on some systems, B<PATH_MAX>"
" may not be a compile-time constant; furthermore, its value may depend on "
"the filesystem, see B<pathconf>(3).)  For portability and security reasons, "
"use of B<getwd>()  is deprecated."
msgstr "Функция B<getwd>() не выделяет память с помощью B<malloc>(3). Аргумент I<buf> должен быть указателем на массив длиной не менее B<PATH_MAX> байтов. Если длина абсолютного пути текущего рабочего каталога, включая конечный байт null, превышает B<PATH_MAX> байт, то возвращается NULL и I<errno> присваивается значение B<ENAMETOOLONG> (заметим, что в некоторых системах B<PATH_MAX> может не являться константой времени компиляции; более того, её значение может зависеть от файловой системы, смотрите B<pathconf>(3)). Для переносимости и безопасности использование B<getwd>() не рекомендуется."

#. type: Plain text
#: man-pages/man3/getcwd.3:164
msgid ""
"On success, these functions return a pointer to a string containing the "
"pathname of the current working directory.  In the case B<getcwd>()  and "
"B<getwd>()  this is the same value as I<buf>."
msgstr "При успешном выполнении эти функции возвращают указатель на строку, содержащую пути текущего рабочего каталога. У B<getcwd>() и B<getwd>() это значение совпадает с I<buf>."

#. type: Plain text
#: man-pages/man3/getcwd.3:171
msgid ""
"On failure, these functions return NULL, and I<errno> is set to indicate the"
" error.  The contents of the array pointed to by I<buf> are undefined on "
"error."
msgstr "При ошибках эти функции возвращают NULL и в I<errno> помещают причину ошибки. Содержимое массива I<buf> в этом случае не определено."

#. type: Plain text
#: man-pages/man3/getcwd.3:175
msgid "Permission to read or search a component of the filename was denied."
msgstr "Нет прав на чтение или поиск одного из компонентов пути файла."

#. type: Plain text
#: man-pages/man3/getcwd.3:179
msgid "I<buf> points to a bad address."
msgstr "Значение I<buf> указывает на неправильный адрес."

#. type: Plain text
#: man-pages/man3/getcwd.3:186
msgid "The I<size> argument is zero and I<buf> is not a null pointer."
msgstr "Аргумент I<size> равен нулю, а I<buf> не является указателем null."

#. type: Plain text
#: man-pages/man3/getcwd.3:191
msgid "B<getwd>(): I<buf> is NULL."
msgstr "B<getwd>(): I<buf> равно NULL."

#. type: Plain text
#: man-pages/man3/getcwd.3:197
msgid ""
"B<getwd>(): The size of the null-terminated absolute pathname string exceeds"
" B<PATH_MAX> bytes."
msgstr "B<getwd>(): Размер строки абсолютного пути, включая конечный null, превышает B<PATH_MAX> байт."

#. type: Plain text
#: man-pages/man3/getcwd.3:200
msgid "The current working directory has been unlinked."
msgstr "Текущий рабочий каталог был удалён."

#. type: Plain text
#: man-pages/man3/getcwd.3:210
msgid ""
"The I<size> argument is less than the length of the absolute pathname of the"
" working directory, including the terminating null byte.  You need to "
"allocate a bigger array and try again."
msgstr "Аргумент I<size> меньше длины абсолютного пути рабочего каталога, включая конечный байт null. Вам нужно выделить массив большего размера попробовать ещё раз."

#. type: tbl table
#: man-pages/man3/getcwd.3:221
#, no-wrap
msgid ""
"B<getcwd>(),\n"
"B<getwd>()"
msgstr "B<getcwd>(),\nB<getwd>()"

#. type: tbl table
#: man-pages/man3/getcwd.3:224
#, no-wrap
msgid "B<get_current_dir_name>()"
msgstr "B<get_current_dir_name>()"

#. type: tbl table
#: man-pages/man3/getcwd.3:224
#, no-wrap
msgid "MT-Safe env"
msgstr "MT-Safe env"

#. type: Plain text
#: man-pages/man3/getcwd.3:234
msgid ""
"B<getcwd>()  conforms to POSIX.1-2001.  Note however that POSIX.1-2001 "
"leaves the behavior of B<getcwd>()  unspecified if I<buf> is NULL."
msgstr "Функция B<getcwd>() соответствует POSIX.1-2001. Однако заметим, что в POSIX.1-2001 не описано поведение B<getcwd>(), если I<buf> равно NULL."

#. type: Plain text
#: man-pages/man3/getcwd.3:245
msgid ""
"B<getwd>()  is present in POSIX.1-2001, but marked LEGACY.  POSIX.1-2008 "
"removes the specification of B<getwd>().  Use B<getcwd>()  instead.  "
"POSIX.1-2001 does not define any errors for B<getwd>()."
msgstr "Функция B<getwd>() описана в POSIX.1-2001, но помечена как УСТАРЕВШАЯ. В POSIX.1-2008 B<getwd>() удалена. Вместо неё используйте B<getcwd>(). В POSIX.1-2001 не определены ошибки, возвращаемые B<getwd>()."

#. type: Plain text
#: man-pages/man3/getcwd.3:248
msgid "B<get_current_dir_name>()  is a GNU extension."
msgstr "Функция B<get_current_dir_name>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/getcwd.3:259
msgid ""
"Under Linux, these functions make use of the B<getcwd>()  system call "
"(available since Linux 2.1.92).  On older systems they would query "
"I</proc/self/cwd>.  If both system call and proc filesystem are missing, a "
"generic implementation is called.  Only in that case can these calls fail "
"under Linux with B<EACCES>."
msgstr "В Linux, эти функции используют системный вызов B<getcwd>() (доступен в Linux, начиная с версии 2.1.92). В старых системах они опрашивают I</proc/self/cwd>. Если в системе отсутствует системный вызов и файловая система proc, то задействуется обобщённая реализация. Только в этом случает данные вызовы в Linux могут завершиться с ошибкой B<EACCES>."

#. type: Plain text
#: man-pages/man3/getcwd.3:268
msgid ""
"These functions are often used to save the location of the current working "
"directory for the purpose of returning to it later.  Opening the current "
"directory (\".\") and calling B<fchdir>(2)  to return is usually a faster "
"and more reliable alternative when sufficiently many file descriptors are "
"available, especially on platforms other than Linux."
msgstr "Данные функции часто используются для сохранения расположения текущего рабочего каталога с целью возврата в него позднее. Открытие текущего каталога («.») и вызов B<fchdir>(2) для возврата, обычно, более быстрая и надёжная альтернатива при наличии достаточного количества файловых дескрипторов, особенно на платформах, отличных от Linux."

#.  commit 3272c544da48f8915a0e34189182aed029bd0f2b
#. type: Plain text
#: man-pages/man3/getcwd.3:288
msgid ""
"On Linux, the kernel provides a B<getcwd>()  system call, which the "
"functions described in this page will use if possible.  The system call "
"takes the same arguments as the library function of the same name, but is "
"limited to returning at most B<PATH_MAX> bytes.  (Before Linux 3.12, the "
"limit on the size of the returned pathname was the system page size.  On "
"many architectures, B<PATH_MAX> and the system page size are both 4096 "
"bytes, but a few architectures have a larger page size.)  If the length of "
"the pathname of the current working directory exceeds this limit, then the "
"system call fails with the error B<ENAMETOOLONG>.  In this case, the library"
" functions fall back to a (slower) alternative implementation that returns "
"the full pathname."
msgstr "Ядро Linux предоставляет системный вызов B<getcwd>(), который, если возможно, будут использовать описываемые на этой страницы функции. Системный вызов имеет такие же параметры как и библиотечная функция с тем же именем, но возвращает не более B<PATH_MAX> байт (до Linux 3.12 размер возвращаемого пути ограничивался размером системной страницы. На многих архитектурах B<PATH_MAX> и размер системной страницы равны 4096 байтам, но у некоторых архитектур размер страницы больше этого значения). Если длина пути текущего рабочего каталога превышает это ограничение, то системный вызов возвращает ошибку B<ENAMETOOLONG>. В этом случае библиотечные функции переходят к использованию альтернативной (медленной) реализации, которая возвращает полный путь."

#.  commit 8df9d1a4142311c084ffeeacb67cd34d190eff74
#. type: Plain text
#: man-pages/man3/getcwd.3:305
msgid ""
"Following a change in Linux 2.6.36, the pathname returned by the B<getcwd>()"
"  system call will be prefixed with the string \"(unreachable)\" if the "
"current directory is not below the root directory of the current process "
"(e.g., because the process set a new filesystem root using B<chroot>(2)  "
"without changing its current directory into the new root).  Such behavior "
"can also be caused by an unprivileged user by changing the current directory"
" into another mount namespace.  When dealing with pathname from untrusted "
"sources, callers of the functions described in this page should consider "
"checking whether the returned pathname starts with '/' or '(' to avoid "
"misinterpreting an unreachable path as a relative pathname."
msgstr "После внесения изменения в Linux 2.6.36, путь, возвращаемый системным вызовом B<getcwd>(), будет начинаться со строки «(unreachable)», если текущий каталог не ниже корневого каталога текущего процесса (например, из-за того, что процесс установил новую корневую файловую систему с помощью B<chroot>(2) без изменения своего текущего каталога в новый корень). Такое поведение также проявляется у непривилегированного пользователя текущий каталог переводится в другое пространство имён монтирования. При работе с путём из недоверенных источников вызывающие описанные на этой странице функции должны учитывать, что возвращаемый путь может начинаться с «/» или «(», и не принимать недоступный путь за относительный."

#. type: Plain text
#: man-pages/man3/getcwd.3:316
msgid ""
"Since the Linux 2.6.36 change that added \"(unreachable)\" in the "
"circumstances described above, the glibc implementation of B<getcwd>()  has "
"failed to conform to POSIX and returned a relative pathname when the API "
"contract requires an absolute pathname.  With glibc 2.27 onwards this is "
"corrected; calling B<getcwd>()  from such a pathname will now result in "
"failure with B<ENOENT>."
msgstr "Так как изменения в Linux 2.6.36 добавляет при описанных выше определённых обстоятельствах «(unreachable)», реализация B<getcwd>() в glibc нарушает POSIX и возвращает относительный путь, в то время как по соглашению API требуется абсолютный путь. В glibc 2.27 и новее это исправлено; вызов B<getcwd>() из такого пути приводит к ошибке B<ENOENT>."

#. type: Plain text
#: man-pages/man3/getcwd.3:323
msgid ""
"B<pwd>(1), B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), "
"B<malloc>(3)"
msgstr "B<pwd>(1), B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), B<malloc>(3)"

#. type: TH
#: man-pages/man3/get_phys_pages.3:25
#, no-wrap
msgid "GET_PHYS_PAGES"
msgstr "GET_PHYS_PAGES"

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:29
msgid ""
"get_phys_pages, get_avphys_pages - get total and available physical page "
"counts"
msgstr "get_phys_pages, get_avphys_pages - возвращает количество физических страниц, а также количество доступных страниц"

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:32
#, no-wrap
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>\n"
msgstr "B<#include E<lt>sys/sysinfo.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:35
#, no-wrap
msgid ""
"B<long int get_phys_pages(void);>\n"
"B<long int get_avphys_pages(void);>\n"
msgstr "B<long int get_phys_pages(void);>\nB<long int get_avphys_pages(void);>\n"

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:40
msgid ""
"The function B<get_phys_pages>()  returns the total number of physical pages"
" of memory available on the system."
msgstr "Функция B<get_phys_pages>() возвращает общее количество физических страниц памяти, доступных в системе."

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:45
msgid ""
"The function B<get_avphys_pages>()  returns the number of currently "
"available physical pages of memory on the system."
msgstr "Функция B<get_avphys_pages>() возвращает количество доступных в данный момент физических страниц памяти в системе."

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:51
msgid ""
"On success, these functions return a nonnegative value as given in "
"DESCRIPTION.  On failure, they return -1 and set I<errno> to indicate the "
"cause of the error."
msgstr "При успешном выполнении эти функции возвращают значение согласно ОПИСАНИЮ. При ошибке возвращается -1 и в I<errno> записывается номер ошибки."

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:58
msgid ""
"The system could not provide the required information (possibly because the "
"I</proc> filesystem was not mounted)."
msgstr "Система не может предоставить требуемую информацию (возможно, из-за того, что не смонтирована файловая система I</proc>)."

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:67
msgid ""
"These functions obtain the required information by scanning the I<MemTotal> "
"and I<MemFree> fields of I</proc/meminfo>."
msgstr "Эти функции получают требуемую информацию из полей I<MemTotal> и I<MemFree> файла I</proc/meminfo>."

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:72
msgid ""
"The following B<sysconf>(3)  calls provide a portable means of obtaining the"
" same information as the functions described on this page."
msgstr "Следующие вызовы B<sysconf>(3) предоставляют переносимый способ получения информации, возвращаемой этими функциями."

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:77
#, no-wrap
msgid ""
"total_pages = sysconf(_SC_PHYS_PAGES);    /* total pages */\n"
"avl_pages = sysconf(_SC_AVPHYS_PAGES);    /* available pages */\n"
msgstr "total_pages = sysconf(_SC_PHYS_PAGES); /* общее количество страниц */\n    avl_pages = sysconf(_SC_AVPHYS_PAGES); /* количество доступных страниц */\n"

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:85
msgid ""
"The following example shows how B<get_phys_pages>()  and "
"B<get_avphys_pages>()  can be used."
msgstr "В следующем примере показано использование B<get_phys_pages>() и B<get_avphys_pages>()."

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:90
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>sys/sysinfo.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:99
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %ld pages of physical memory and \"\n"
"            \"%ld pages of physical memory available.\\en\",\n"
"            get_phys_pages(), get_avphys_pages());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    printf(\"В этой системе %ld страниц физической памяти и \"\n            \"доступно %ld страниц физической памяти.\\en\",\n            get_phys_pages(), get_avphys_pages());\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:101
msgid "B<sysconf>(3)"
msgstr "B<sysconf>(3)"

#. type: TH
#: man-pages/man3/getpt.3:7
#, no-wrap
msgid "GETPT"
msgstr "GETPT"

#. type: Plain text
#: man-pages/man3/getpt.3:10
msgid "getpt - open the pseudoterminal master (PTM)"
msgstr "getpt - открывает основной псевдотерминал (PTM)"

#. type: Plain text
#: man-pages/man3/getpt.3:14
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>             /* смотрите feature_test_macros(7) */\nB<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getpt.3:16
#, no-wrap
msgid "B<int getpt(void);>\n"
msgstr "B<int getpt(void);>\n"

#. type: Plain text
#: man-pages/man3/getpt.3:21
msgid ""
"B<getpt>()  opens a pseudoterminal master and returns its file descriptor.  "
"It is equivalent to"
msgstr "Функция B<getpt>() открывает основной псевдотерминал и возвращает его файловый дескриптор. Она эквивалентна "

#. type: Plain text
#: man-pages/man3/getpt.3:25
#, no-wrap
msgid "open(/dev/ptmx, O_RDWR | O_NOCTTY);\n"
msgstr "open(/dev/ptmx, O_RDWR | O_NOCTTY);\n"

#. type: Plain text
#: man-pages/man3/getpt.3:30
msgid ""
"on Linux systems, though the pseudoterminal master is located elsewhere on "
"some systems that use GNU Libc."
msgstr "в системах Linux, хотя основной псевдотерминал в других системах, использующих библиотеку GNU Libc, может быть расположен в другом месте."

#. type: Plain text
#: man-pages/man3/getpt.3:37
msgid ""
"B<getpt>()  returns an open file descriptor upon successful completion.  "
"Otherwise, it returns -1 and sets I<errno> to indicate the error."
msgstr "При успешном выполнении функция B<getp>t() возвращает открытый файловых дескриптор. В противном случае возвращается -1 и переменной I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/getpt.3:41
msgid "B<getpt>()  can fail with various errors described in B<open>(2)."
msgstr "Функция B<getpt>() может завершаться с ошибками, описанными в B<open>(2)."

#. type: Plain text
#: man-pages/man3/getpt.3:44
msgid "B<getpt>()  is provided in glibc since version 2.1."
msgstr "Функция B<getpt>() появилась в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/getpt.3:54
#, no-wrap
msgid "B<getpt>()"
msgstr "B<getpt>()"

#. type: Plain text
#: man-pages/man3/getpt.3:62
msgid "B<getpt>()  is glibc-specific; use B<posix_openpt>(3)  instead."
msgstr "Функция B<getpt>() есть только в glibc; вместо неё используйте B<posix_openpt>(3)."

#. type: Plain text
#: man-pages/man3/getpt.3:68
msgid ""
"B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), "
"B<ptmx>(4), B<pty>(7)"
msgstr "B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), B<ptmx>(4), B<pty>(7)"

#. type: TH
#: man-pages/man3/getloadavg.3:34
#, no-wrap
msgid "GETLOADAVG"
msgstr "GETLOADAVG"

#. type: Plain text
#: man-pages/man3/getloadavg.3:37
msgid "getloadavg - get system load averages"
msgstr "getloadavg - возвращает среднее значение загруженности системы"

#. type: Plain text
#: man-pages/man3/getloadavg.3:42
#, no-wrap
msgid "B<int getloadavg(double >I<loadavg[]>B<, int >I<nelem>B<);>\n"
msgstr "B<int getloadavg(double >I<loadavg[]>B<, int >I<nelem>B<);>\n"

#. type: Plain text
#: man-pages/man3/getloadavg.3:50
msgid "B<getloadavg>():"
msgstr "B<getloadavg>():"

#. type: Plain text
#: man-pages/man3/getloadavg.3:55
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr "    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc до версии 2.19 включительно:\n        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getloadavg.3:67
msgid ""
"The B<getloadavg>()  function returns the number of processes in the system "
"run queue averaged over various periods of time.  Up to I<nelem> samples are"
" retrieved and assigned to successive elements of I<loadavg>[].  The system "
"imposes a maximum of 3 samples, representing averages over the last 1, 5, "
"and 15 minutes, respectively."
msgstr "Функция B<getloadavg>() возвращает количество процессов в системной очереди выполнения, усреднённое в разных периодах времени. Воспринимается до I<nelem> образцов и они последовательно назначаются в элементы I<loadavg>[]. Система максимально выводит 3 образца, представляющие средние данные за последние 1, 5 и 15 минут, соответственно."

#.  .SH HISTORY
#.  The
#.  BR getloadavg ()
#.  function appeared in
#.  4.3BSD Reno .
#. type: Plain text
#: man-pages/man3/getloadavg.3:75
msgid ""
"If the load average was unobtainable, -1 is returned; otherwise, the number "
"of samples actually retrieved is returned."
msgstr "Если невозможно получить данные о средней загруженности системы, то возвращается -1; иначе возвращается количество полученных образов."

#. type: Plain text
#: man-pages/man3/getloadavg.3:77
msgid "This function is available in glibc since version 2.2."
msgstr "Эта функция доступна в glibc начиная с версии 2.2."

#. type: tbl table
#: man-pages/man3/getloadavg.3:87
#, no-wrap
msgid "B<getloadavg>()"
msgstr "B<getloadavg>()"

#.  mdoc seems to have a bug - there must be no newline here
#. type: Plain text
#: man-pages/man3/getloadavg.3:93
msgid "Not in POSIX.1.  Present on the BSDs and Solaris."
msgstr "Не является частью POSIX.1. Имеется в BSD и Solaris."

#. type: Plain text
#: man-pages/man3/getloadavg.3:95
msgid "B<uptime>(1), B<proc>(5)"
msgstr "B<uptime>(1), B<proc>(5)"

#. type: TH
#: man-pages/man3/getprotoent_r.3:26
#, no-wrap
msgid "GETPROTOENT_R"
msgstr "GETPROTOENT_R"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:30
msgid ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - get protocol entry "
"(reentrant)"
msgstr "getprotoent_r, getprotobyname_r, getprotobynumber_r - возвращают запись о протоколе (реентерабельные версии)"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:36
#, no-wrap
msgid ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr "B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:40
#, no-wrap
msgid ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr "B<int getprotobyname_r(const char *>I<name>B<,>\nB<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:44
#, no-wrap
msgid ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr "B<int getprotobynumber_r(int >I<proto>B<,>\nB<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:59
#, no-wrap
msgid ""
"B<getprotoent_r>(),\n"
"B<getprotobyname_r>(),\n"
"B<getprotobynumber_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getprotoent_r>(),\nB<getprotobyname_r>(),\nB<getprotobynumber_r>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:77
msgid ""
"The B<getprotoent_r>(), B<getprotobyname_r>(), and B<getprotobynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getprotoent>(3),"
" B<getprotobyname>(3), and B<getprotobynumber>(3).  They differ in the way "
"that the I<protoent> structure is returned, and in the function calling "
"signature and return value.  This manual page describes just the differences"
" from the nonreentrant functions."
msgstr "Функции B<getprotoent_r>(), B<getprotobyname_r>() и B<getprotobynumber_r>() являются реентерабельными эквивалентами  B<getprotoent>(3), B<getprotobyname>(3) и B<getprotobynumber>(3), соответственно. Они отличаются способом возврата структуры I<protoent>, списком параметров и типом возвращаемого значения. В этой справочной странице описаны только различия с нереентерабельными функциями."

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<protoent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr "Вместо возврата указателя на статически выделенную структуру I<protoent> в качестве результата эти функции копируют структуру в расположение, указанное I<result_buf>."

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer.
#.  The 1024 byte value is also what the Solaris man page suggests. -- mtk
#. type: Plain text
#: man-pages/man3/getprotoent_r.3:101
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<protoent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr "Массив I<buf> используется для хранения строковых полей из возвращаемой структуры I<protoent> (нереентерабельные функции выделяют эти строки из статического хранилища). Размер данного массива задаётся в I<buflen>. Если I<buf> слишком мал, то вызов завершается с ошибкой B<ERANGE>, вызывающий должен его повторить с большим буфером (для большинства приложений должно быть достаточно буфера длиной 1024 байт)."

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:109
msgid ""
"If the function call successfully obtains a protocol record, then I<*result>"
" is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr "Если вызов получил запись о протоколе, то  I<*result> указывает на I<result_buf>; в противном случае I<*result> устанавливается в NULL."

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:120
msgid ""
"On error, record not found (B<getprotobyname_r>(), B<getprotobynumber_r>()),"
" or end of input (B<getprotoent_r>())  I<result> is set to NULL."
msgstr "При ошибке, отсутствии записи (B<getprotobyname_r>(), B<getprotobynumber_r>()) или конце данных (B<getprotoent_r>()) значение I<result> равно NULL."

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:125
msgid "(B<getprotoent_r>())  No more records in database."
msgstr "(B<getprotoent_r>()) Больше нет записей в базе данных."

#. type: tbl table
#: man-pages/man3/getprotoent_r.3:142
#, no-wrap
msgid "B<getprotoent_r>(),\n"
msgstr "B<getprotoent_r>(),\n"

#. type: tbl table
#: man-pages/man3/getprotoent_r.3:144
#, no-wrap
msgid "B<getprotobyname_r>(),\n"
msgstr "B<getprotobyname_r>(),\n"

#. type: tbl table
#: man-pages/man3/getprotoent_r.3:146
#, no-wrap
msgid "B<getprotobynumber_r>()"
msgstr "B<getprotobynumber_r>()"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:167
msgid ""
"The program below uses B<getprotobyname_r>()  to retrieve the protocol "
"record for the protocol named in its first command-line argument.  If a "
"second (integer) command-line argument is supplied, it is used as the "
"initial value for I<buflen>; if B<getprotobyname_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr "Программа, представленная ниже, использует B<getprotobyname_r>() для получения записи о протоколе с именем, указанным в командной строке. Если задан второй параметр (целое), то он используется как начальное значение I<buflen>; если B<getprotobyname_r>() завершается с ошибкой B<ERANGE>, то программа повторяет попытки с большими значениями буфера. Пара примеров работы в сеансовой оболочке:"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:178
#, no-wrap
msgid ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"
msgstr "$B< ./a.out tcp 1>\nERANGE! Повтор с большим буфером\nрезультат getprotobyname_r(): 0 (успешно)  (buflen=78)\np_name=tcp; p_proto=6; aliases=TCP\n$B< ./a.out xxx 1>\nERANGE! Повтор с большим буфером\nрезультат getprotobyname_r(): 0 (успешно)  (buflen=100)\nОшибка вызова/запись не найдена\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:201
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
"    char **p;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int buflen, erange_cnt, s;\n    struct protoent result_buf;\n    struct protoent *result;\n    char buf[MAX_BUF];\n    char **p;\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:206
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 2) {\n        printf(\"Использование: %s имя-протокола [длина-буф]\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:210
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"
msgstr "    buflen = 1024;\n    if (argc E<gt> 2)\n        buflen = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:224
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr "    erange_cnt = 0;\n    do {\n        s = getprotobyname_r(argv[1], &result_buf,\n                     buf, buflen, &result);\n        if (s == ERANGE) {\n            if (erange_cnt == 0)\n                printf(\"ERANGE! Повтор с большим буфером\\en\");\n            erange_cnt++;\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:240
#, no-wrap
msgid ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr "    printf(\"результат getprotobyname_r(): %s  (buflen=%d)\\en\",\n            (s == 0) ? \"0 (успешно)\" : (s == ENOENT) ? \"ENOENT\" :\n            strerror(s), buflen);\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:251
#, no-wrap
msgid ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr "    printf(\"p_name=%s; p_proto=%d; aliases=\",\n                result_buf.p_name, result_buf.p_proto);\n    for (p = result_buf.p_aliases; *p != NULL; p++)\n        printf(\"%s \", *p);\n    printf(\"\\en\");\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:257
msgid "B<getprotoent>(3), B<protocols>(5)"
msgstr "B<getprotoent>(3), B<protocols>(5)"

#. type: TH
#: man-pages/man3/getenv.3:33
#, no-wrap
msgid "GETENV"
msgstr "GETENV"

#. type: Plain text
#: man-pages/man3/getenv.3:36
msgid "getenv, secure_getenv - get an environment variable"
msgstr "getenv, secure_getenv - возвращают значения переменной окружения"

#. type: Plain text
#: man-pages/man3/getenv.3:41
#, no-wrap
msgid "B<char *getenv(const char *>I<name>B<);>\n"
msgstr "B<char *getenv(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getenv.3:43
#, no-wrap
msgid "B<char *secure_getenv(const char *>I<name>B<);>\n"
msgstr "B<char *secure_getenv(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getenv.3:52
msgid "B<secure_getenv>(): _GNU_SOURCE"
msgstr "B<secure_getenv>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getenv.3:61
msgid ""
"The B<getenv>()  function searches the environment list to find the "
"environment variable I<name>, and returns a pointer to the corresponding "
"I<value> string."
msgstr "Функция B<getenv>() ищет в списке окружения переменную окружения I<name> и возвращает указатель на соответствующую строку I<value>."

#. type: Plain text
#: man-pages/man3/getenv.3:69
msgid ""
"The GNU-specific B<secure_getenv>()  function is just like B<getenv>()  "
"except that it returns NULL in cases where \"secure execution\" is required."
"  Secure execution is required if one of the following conditions was true "
"when the program run by the calling process was loaded:"
msgstr "Специальная функция GNU B<secure_getenv>() работает также как B<getenv>(), но возвращает NULL, если требуется «безопасное выполнение». Безопасное выполнение требуется, если верно одно из следующих условий на момент загрузки программы вызывающего процесса:"

#. type: Plain text
#: man-pages/man3/getenv.3:74
msgid ""
"the process's effective user ID did not match its real user ID or the "
"process's effective group ID did not match its real group ID (typically this"
" is the result of executing a set-user-ID or set-group-ID program);"
msgstr "эффективный пользовательский ID процесса не совпадает с реальным пользовательским ID или эффективный групповой ID процесса не совпадает с реальным групповым ID (обычно в результате выполнения программы с установленным битом set-user-ID или set-group-ID);"

#. type: Plain text
#: man-pages/man3/getenv.3:76
msgid "the effective capability bit was set on the executable file; or"
msgstr "у исполняемого файла установлен эффективный мандатный бит; или"

#. type: Plain text
#: man-pages/man3/getenv.3:78
msgid "the process has a nonempty permitted capability set."
msgstr "у процесса имеется непустой ограничивающий набор мандатов."

#. type: Plain text
#: man-pages/man3/getenv.3:81
msgid ""
"Secure execution may also be required if triggered by some Linux security "
"modules."
msgstr "Безопасное выполнение также может требоваться некоторыми модулями безопасности Linux."

#. type: Plain text
#: man-pages/man3/getenv.3:88
msgid ""
"The B<secure_getenv>()  function is intended for use in general-purpose "
"libraries to avoid vulnerabilities that could occur if set-user-ID or set-"
"group-ID programs accidentally trusted the environment."
msgstr "Функция B<secure_getenv>() предназначена для библиотек общего назначения с целью недопущения уязвимостей, которые могли бы возникнуть, если программы с битом set-user-ID или set-group-ID ненамеренно доверяли бы окружению."

#. type: Plain text
#: man-pages/man3/getenv.3:93
msgid ""
"The B<getenv>()  function returns a pointer to the value in the environment,"
" or NULL if there is no match."
msgstr "Функция B<getenv>() возвращает указатель на значение в окружении или NULL, если ничего не найдено."

#. type: Plain text
#: man-pages/man3/getenv.3:96
msgid "B<secure_getenv>()  first appeared in glibc 2.17."
msgstr "Функция B<secure_getenv>() впервые появилась в glibc версии 2.17."

#. type: tbl table
#: man-pages/man3/getenv.3:107
#, no-wrap
msgid ""
"B<getenv>(),\n"
"B<secure_getenv>()"
msgstr "B<getenv>(),\nB<secure_getenv>()"

#. type: Plain text
#: man-pages/man3/getenv.3:112
msgid "B<getenv>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "B<getenv>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/getenv.3:115
msgid "B<secure_getenv>()  is a GNU extension."
msgstr "Функция B<secure_getenv>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/getenv.3:117
msgid "The strings in the environment list are of the form I<name=value>."
msgstr "Строки в списке окружения имеют вид I<имя=значение>."

#. type: Plain text
#: man-pages/man3/getenv.3:123
msgid ""
"As typically implemented, B<getenv>()  returns a pointer to a string within "
"the environment list.  The caller must take care not to modify this string, "
"since that would change the environment of the process."
msgstr "В типичной реализации B<getenv>() возвращает указатель на строку в списке окружения. Вызывающий не должен изменять эту строку, так как это изменить окружение процесса."

#. type: Plain text
#: man-pages/man3/getenv.3:136
msgid ""
"The implementation of B<getenv>()  is not required to be reentrant.  The "
"string pointed to by the return value of B<getenv>()  may be statically "
"allocated, and can be modified by a subsequent call to B<getenv>(), "
"B<putenv>(3), B<setenv>(3), or B<unsetenv>(3)."
msgstr "Реализации B<getenv>() не требуется быть реентерабельной. Строка, указанная в возвращаемом значение B<getenv>(), может быть выделена статически и может изменяться после вызова B<getenv>() с помощью B<putenv>(3), B<setenv>(3) или B<unsetenv>(3)."

#. type: Plain text
#: man-pages/man3/getenv.3:142
msgid ""
"The \"secure execution\" mode of B<secure_getenv>()  is controlled by the "
"B<AT_SECURE> flag contained in the auxiliary vector passed from the kernel "
"to user space."
msgstr "Режим «безопасного выполнения» в B<secure_getenv>() управляется флагом B<AT_SECURE> вспомогательного вектора, передаваемого из ядра в пользовательское пространство."

#. type: Plain text
#: man-pages/man3/getenv.3:149
msgid ""
"B<clearenv>(3), B<getauxval>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3),"
" B<capabilities>(7), B<environ>(7)"
msgstr "B<clearenv>(3), B<getauxval>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<capabilities>(7), B<environ>(7)"

#. type: TH
#: man-pages/man3/getpw.3:32
#, no-wrap
msgid "GETPW"
msgstr "GETPW"

#. type: Plain text
#: man-pages/man3/getpw.3:35
msgid "getpw - reconstruct password line entry"
msgstr "getpw - восстанавливает строку пароля"

#. type: Plain text
#: man-pages/man3/getpw.3:40
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>             /* смотрите feature_test_macros(7) */\nB<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getpw.3:42
#, no-wrap
msgid "B<int getpw(uid_t >I<uid>B<, char *>I<buf>B<);>\n"
msgstr "B<int getpw(uid_t >I<uid>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpw.3:49
msgid ""
"The B<getpw>()  function reconstructs the password line entry for the given "
"user ID I<uid> in the buffer I<buf>.  The returned buffer contains a line of"
" format"
msgstr "Функция B<getpw>() заново создаёт в буфере строку пароля для пользователя с ID I<uid> в буфере I<buf>. Возвращаемый буфер содержит строку в формате"

#. type: Plain text
#: man-pages/man3/getpw.3:53
#, no-wrap
msgid "B<name:passwd:uid:gid:gecos:dir:shell>\n"
msgstr "B<name:passwd:uid:gid:gecos:dir:shell>\n"

#. type: Plain text
#: man-pages/man3/getpw.3:80
msgid ""
"The B<getpw>()  function returns 0 on success; on error, it returns -1, and "
"I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<getpw>() возвращается 0; при ошибке возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/getpw.3:90
msgid ""
"If I<uid> is not found in the password database, B<getpw>()  returns -1, "
"sets I<errno> to 0, and leaves I<buf> unchanged."
msgstr "Если I<uid> не найден в базе данных паролей, то B<getpw>() возвращает -1, присваивает I<errno> значение 0 и I<buf> не изменяется."

#. type: TP
#: man-pages/man3/getpw.3:91
#, no-wrap
msgid "B<0> or B<ENOENT>"
msgstr "B<0> или B<ENOENT>"

#. type: Plain text
#: man-pages/man3/getpw.3:95
msgid "No user corresponding to I<uid>."
msgstr "Отсутствует пользователь с соответствующим I<uid>."

#. type: Plain text
#: man-pages/man3/getpw.3:99
msgid "I<buf> is NULL."
msgstr "Значение I<buf> равно NULL."

#. type: tbl table
#: man-pages/man3/getpw.3:118
#, no-wrap
msgid "B<getpw>()"
msgstr "B<getpw>()"

#. type: Plain text
#: man-pages/man3/getpw.3:123
msgid "SVr2."
msgstr "SVr2."

#. type: Plain text
#: man-pages/man3/getpw.3:130
msgid ""
"The B<getpw>()  function is dangerous as it may overflow the provided buffer"
" I<buf>.  It is obsoleted by B<getpwuid>(3)."
msgstr "Функция B<getpw>() является в каком-то смысле опасной, так как может переполнить предоставляемый ей буфер I<buf>. Она заменена на B<getpwuid>(3)."

#. type: Plain text
#: man-pages/man3/getpw.3:138
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getpwent>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"
msgstr "B<endpwent>(3), B<fgetpwent>(3), B<getpwent>(3), B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getipnodebyname.3:26
#, no-wrap
msgid "GETIPNODEBYNAME"
msgstr "GETIPNODEBYNAME"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:30
msgid ""
"getipnodebyname, getipnodebyaddr, freehostent - get network hostnames and "
"addresses"
msgstr "getipnodebyname, getipnodebyaddr, freehostent - возвращают сетевые имена и адреса машины"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:38
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"
msgstr "B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\nB<                                int >I<flags>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:41
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"
msgstr "B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\nB<                                int >I<af>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:43
#, no-wrap
msgid "B<void freehostent(struct hostent *>I<ip>B<);>\n"
msgstr "B<void freehostent(struct hostent *>I<ip>B<);>\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:51
msgid ""
"These functions are deprecated (and unavailable in glibc).  Use "
"B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr "Эти функции устарели (и недоступны в glibc). Используйте вместо них функции B<getaddrinfo>(3) и B<getnameinfo>(3)."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:59
msgid ""
"The B<getipnodebyname>()  and B<getipnodebyaddr>()  functions return the "
"names and addresses of a network host.  These functions return a pointer to "
"the following structure:"
msgstr "Функции B<getipnodebyname>() и B<getipnodebyaddr>() возвращают имена и адреса машины в сети. Эти функции возвращают указатель на следующую структуру:"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:69
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"
msgstr "struct hostent {\n    char  *h_name;\n    char **h_aliases;\n    int    h_addrtype;\n    int    h_length;\n    char **h_addr_list;\n};\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:82
msgid ""
"These functions replace the B<gethostbyname>(3)  and B<gethostbyaddr>(3)  "
"functions, which could access only the IPv4 network address family.  The "
"B<getipnodebyname>()  and B<getipnodebyaddr>()  functions can access "
"multiple network address families."
msgstr "Эти функции заменяют функции B<gethostbyname>(3) и B<gethostbyaddr>(3), которые могут возвращать только сетевые адреса семейства IPv4. Функции B<getipnodebyname>() и B<getipnodebyaddr>() могут осуществлять доступ к нескольким семействам сетевых адресов."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:93
msgid ""
"Unlike the B<gethostby> functions, these functions return pointers to "
"dynamically allocated memory.  The B<freehostent>()  function is used to "
"release the dynamically allocated memory after the caller no longer needs "
"the I<hostent> structure."
msgstr "В отличие от функций B<gethostby> эти функции возвращают указатели на динамически выделяемую память. Функция B<freehostent>() используется для освобождения динамически выделенной памяти после того, как надобность в структуре I<hostent> отпадёт."

#. type: SS
#: man-pages/man3/getipnodebyname.3:93
#, no-wrap
msgid "getipnodebyname() arguments"
msgstr "Параметры getipnodebyname()"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:104
msgid ""
"The B<getipnodebyname>()  function looks up network addresses for the host "
"specified by the I<name> argument.  The I<af> argument specifies one of the "
"following values:"
msgstr "Функция B<getipnodebyname>() ищет сетевой адрес узла, указанного в параметре I<name>. В параметре I<af> указывается одно из следующих значений:"

#. type: TP
#: man-pages/man3/getipnodebyname.3:104 man-pages/man3/getipnodebyname.3:166
#, no-wrap
msgid "B<AF_INET>"
msgstr "B<AF_INET>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:110
msgid ""
"The I<name> argument points to a dotted-quad IPv4 address or a name of an "
"IPv4 network host."
msgstr "Параметр I<name> указывает на адрес IPv4 в точечной нотации или на имя сетевого узла IPv4."

#. type: TP
#: man-pages/man3/getipnodebyname.3:110 man-pages/man3/getipnodebyname.3:176
#, no-wrap
msgid "B<AF_INET6>"
msgstr "B<AF_INET6>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:116
msgid ""
"The I<name> argument points to a hexadecimal IPv6 address or a name of an "
"IPv6 network host."
msgstr "Параметр I<name> указывает на шестнадцатеричный адрес IPv6 или на имя сетевого узла IPv6."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:125
msgid ""
"The I<flags> argument specifies additional options.  More than one option "
"can be specified by bitwise OR-ing them together.  I<flags> should be set to"
" 0 if no options are desired."
msgstr "В аргументе I<flags> указываются дополнительные параметры. Возможно указать более одного параметра с помощью логического сложения (OR). Если параметры не требуются, то значение I<flags> должно быть равно нулю."

#. type: TP
#: man-pages/man3/getipnodebyname.3:125
#, no-wrap
msgid "B<AI_V4MAPPED>"
msgstr "B<AI_V4MAPPED>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:132
msgid ""
"This flag is used with B<AF_INET6> to request a query for IPv4 addresses "
"instead of IPv6 addresses; the IPv4 addresses will be mapped to IPv6 "
"addresses."
msgstr "Этот флаг используется с B<AF_INET6> для запроса адресов IPv4 вместо адресов IPv6; адрес IPv4 будет отображён в адрес IPv6."

#. type: TP
#: man-pages/man3/getipnodebyname.3:132
#, no-wrap
msgid "B<AI_ALL>"
msgstr "B<AI_ALL>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:138
msgid ""
"This flag is used with B<AI_V4MAPPED> to request a query for both IPv4 and "
"IPv6 addresses.  Any IPv4 address found will be mapped to an IPv6 address."
msgstr "Это флаг используется с B<AI_V4MAPPED> для запроса одновременно адресов IPv4 и IPv6. Любой найденный адрес IPv4 будет отображён в адрес IPv6."

#. type: TP
#: man-pages/man3/getipnodebyname.3:138
#, no-wrap
msgid "B<AI_ADDRCONFIG>"
msgstr "B<AI_ADDRCONFIG>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:150
msgid ""
"This flag is used with B<AF_INET6> to further request that queries for IPv6 "
"addresses should not be made unless the system has at least one IPv6 address"
" assigned to a network interface, and that queries for IPv4 addresses should"
" not be made unless the system has at least one IPv4 address assigned to a "
"network interface.  This flag may be used by itself or with the "
"B<AI_V4MAPPED> flag."
msgstr "Этот флаг используется с B<AF_INET6> и указывает, что запросы адресов IPv6 не должны производиться, если система не имеет хотя бы одного адреса IPv6, присвоенного сетевому интерфейсу, а также, что запросы адресов IPv4 не должны производиться, если система не имеет хотя бы одного адреса IPv4, присвоенного сетевому интерфейсу. Флаг может быть использован сам по себе или вместе с флагом B<AI_V4MAPPED>."

#. type: TP
#: man-pages/man3/getipnodebyname.3:150
#, no-wrap
msgid "B<AI_DEFAULT>"
msgstr "B<AI_DEFAULT>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:154
msgid "This flag is equivalent to B<(AI_ADDRCONFIG | AI_V4MAPPED)>."
msgstr "Этот флаг эквивалентен B<(AI_ADDRCONFIG | AI_V4MAPPED)>."

#. type: SS
#: man-pages/man3/getipnodebyname.3:154
#, no-wrap
msgid "getipnodebyaddr() arguments"
msgstr "Параметры getipnodebyaddr()"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:166
msgid ""
"The B<getipnodebyaddr>()  function looks up the name of the host whose "
"network address is specified by the I<addr> argument.  The I<af> argument "
"specifies one of the following values:"
msgstr "Функция B<getipnodebyaddr>() ищет имя узла, чей сетевой адрес указан в параметре I<addr>. В параметре I<af> указывается одно из следующих значений:"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:176
msgid ""
"The I<addr> argument points to a I<struct in_addr> and I<len> must be set to"
" I<sizeof(struct in_addr)>."
msgstr "Параметр I<addr> указывает на структуру I<struct in_addr> и значение I<len> должно быть равно I<sizeof(struct in_addr)>."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:186
msgid ""
"The I<addr> argument points to a I<struct in6_addr> and I<len> must be set "
"to I<sizeof(struct in6_addr)>."
msgstr "Параметр I<addr> указывает на структуру I<struct in6_addr> и значение I<len> должно быть равно I<sizeof(struct in6_addr)>."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:190
msgid ""
"NULL is returned if an error occurred, and I<error_num> will contain an "
"error code from the following list:"
msgstr "При ошибке возвращается NULL, а в I<error_num> будет содержаться код ошибки из следующего списка:"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:193
msgid "The hostname or network address was not found."
msgstr "Имя узла или сетевой адрес не найдены."

#. type: TP
#: man-pages/man3/getipnodebyname.3:193
#, no-wrap
msgid "B<NO_ADDRESS>"
msgstr "B<NO_ADDRESS>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:199
msgid ""
"The domain name server recognized the network address or name, but no answer"
" was returned.  This can happen if the network host has only IPv4 addresses "
"and a request has been made for IPv6 information only, or vice versa."
msgstr "Сервер доменных имён распознал сетевой адрес или имя, но не ответил. Это может произойти, если сетевой узел имеет только адреса IPv4, а запрашивалась информация об IPv6, или наоборот."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:202
msgid "The domain name server returned a permanent failure response."
msgstr "Сервер доменных имён возвратил сообщение о постоянной ошибке."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:206
msgid ""
"The domain name server returned a temporary failure response.  You might "
"have better luck next time."
msgstr "Сервер доменных имён возвратил сообщение о временной ошибке. Возможно, ответ может быть получен при повторной попытке."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:210
msgid ""
"A successful query returns a pointer to a I<hostent> structure that contains"
" the following fields:"
msgstr "При выполненном запросе возвращается указатель на структуру I<hostent>, содержащую следующие поля:"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:213
msgid "This is the official name of this network host."
msgstr "Официальное имя данного сетевого узла."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:217
msgid ""
"This is an array of pointers to unofficial aliases for the same host.  The "
"array is terminated by a null pointer."
msgstr "Массив указателей на неофициальные псевдонимы этого же узла. Массив оканчивается указателем null."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:239
msgid ""
"This is a copy of the I<af> argument to B<getipnodebyname>()  or "
"B<getipnodebyaddr>().  I<h_addrtype> will always be B<AF_INET> if the I<af> "
"argument was B<AF_INET>.  I<h_addrtype> will always be B<AF_INET6> if the "
"I<af> argument was B<AF_INET6>."
msgstr "Копия параметра I<af> вызова B<getipnodebyname>() или B<getipnodebyaddr>(). Значение I<h_addrtype> всегда равно B<AF_INET>, если значение I<af> равно B<AF_INET>. Значение I<h_addrtype> всегда равно B<AF_INET6>, если значение I<af> равно B<AF_INET6>."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:253
msgid ""
"This field will be set to I<sizeof(struct in_addr)> if I<h_addrtype> is "
"B<AF_INET>, and to I<sizeof(struct in6_addr)> if I<h_addrtype> is "
"B<AF_INET6>."
msgstr "Это поле равно I<sizeof(struct in_addr)>, если I<h_addrtype> равно B<AF_INET>, и I<sizeof(struct in6_addr)>, если I<h_addrtype> равно B<AF_INET6>."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:258
msgid ""
"This is an array of one or more pointers to network address structures for "
"the network host.  The array is terminated by a null pointer."
msgstr "Массив из одного или нескольких указателей на структуры сетевого адреса для сетевого узла. Массив оканчивается указателем null."

#.  Not in POSIX.1-2001.
#. type: Plain text
#: man-pages/man3/getipnodebyname.3:261
msgid "RFC\\ 2553."
msgstr "RFC\\ 2553."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:266
msgid ""
"These functions were present in glibc 2.1.91-95, but were removed again.  "
"Several UNIX-like systems support them, but all call them deprecated."
msgstr "Эти функции существовали в glibc 2.1.91-95, но были удалены. Некоторые UNIX-подобные системы поддерживают их, но все эти вызовы устарели."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:270
msgid "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"
msgstr "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"

#. type: TH
#: man-pages/man3/getgrnam.3:33
#, no-wrap
msgid "GETGRNAM"
msgstr "GETGRNAM"

#. type: Plain text
#: man-pages/man3/getgrnam.3:36
msgid "getgrnam, getgrnam_r, getgrgid, getgrgid_r - get group file entry"
msgstr "getgrnam, getgrnam_r, getgrgid, getgrgid_r - возвращают запись файла групп"

#. type: Plain text
#: man-pages/man3/getgrnam.3:42
#, no-wrap
msgid "B<struct group *getgrnam(const char *>I<name>B<);>\n"
msgstr "B<struct group *getgrnam(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:44
#, no-wrap
msgid "B<struct group *getgrgid(gid_t >I<gid>B<);>\n"
msgstr "B<struct group *getgrgid(gid_t >I<gid>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:47
#, no-wrap
msgid ""
"B<int getgrnam_r(const char *>I<name>B<, struct group *>I<grp>B<,>\n"
"B<          char *>I<buf>B<, size_t >I<buflen>B<, struct group **>I<result>B<);>\n"
msgstr "B<int getgrnam_r(const char *>I<name>B<, struct group *>I<grp>B<,>\nB<          char *>I<buf>B<, size_t >I<buflen>B<, struct group **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:50
#, no-wrap
msgid ""
"B<int getgrgid_r(gid_t >I<gid>B<, struct group *>I<grp>B<,>\n"
"B<          char *>I<buf>B<, size_t >I<buflen>B<, struct group **>I<result>B<);>\n"
msgstr "B<int getgrgid_r(gid_t >I<gid>B<, struct group *>I<grp>B<,>\nB<          char *>I<buf>B<, size_t >I<buflen>B<, struct group **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:60
msgid "B<getgrnam_r>(), B<getgrgid_r>():"
msgstr "B<getgrnam_r>(), B<getgrgid_r>():"

#. type: Plain text
#: man-pages/man3/getgrnam.3:75
msgid ""
"The B<getgrnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the group database (e.g., the local group"
" file I</etc/group>, NIS, and LDAP)  that matches the group name I<name>."
msgstr "Функция B<getgrnam>() возвращает указатель на структуру, содержащую разделённую на поля запись из базы данных групп (например, из локального файла групп I</etc/group>, NIS и LDAP), которая соответствует имени группы I<name>."

#. type: Plain text
#: man-pages/man3/getgrnam.3:82
msgid ""
"The B<getgrgid>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the group database that matches the group"
" ID I<gid>."
msgstr "Функция B<getgrgid>() возвращает указатель на структуру, содержащую разделённую на поля запись из базы данных групп, которая соответствует идентификатору группы I<gid>."

#. type: Plain text
#: man-pages/man3/getgrnam.3:122
msgid ""
"The B<getgrnam_r>()  and B<getgrgid_r>()  functions obtain the same "
"information as B<getgrnam>()  and B<getgrgid>(), but store the retrieved "
"I<group> structure in the space pointed to by I<grp>.  The string fields "
"pointed to by the members of the I<group> structure are stored in the buffer"
" I<buf> of size I<buflen>.  A pointer to the result (in case of success) or "
"NULL (in case no entry was found or an error occurred) is stored in "
"I<*result>."
msgstr "Функции B<getgrnam_r>() и B<getgrgid_r>() принимают ту же информацию что и B<getgrnam>() и B<getgrgid>(), но сохраняют полученную структуру I<group> в пространство, указанное I<grp>. Строковые поля членов структуры I<group> сохраняются в буфере I<buf> размера I<buflen>. Указатель на результат (при успешном выполнении) или NULL (если записи отсутствуют или произошла ошибка) сохраняется в I<*result>."

#. type: Plain text
#: man-pages/man3/getgrnam.3:126
#, no-wrap
msgid "    sysconf(_SC_GETGR_R_SIZE_MAX)\n"
msgstr "    sysconf(_SC_GETGR_R_SIZE_MAX)\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:150
msgid ""
"The B<getgrnam>()  and B<getgrgid>()  functions return a pointer to a "
"I<group> structure, or NULL if the matching entry is not found or an error "
"occurs.  If an error occurs, I<errno> is set appropriately.  If one wants to"
" check I<errno> after the call, it should be set to zero before the call."
msgstr "Функции B<getgrnam>() и B<getgrgid>() возвращают указатель на структуру I<group> или NULL, если подходящих записей не найдено или возникла ошибка. При ошибке I<errno> устанавливается в соответствующее значение. Если нужно проверять переменную I<errno> после вызова, то перед этим нужно присвоить ей нулевое значение."

#. type: Plain text
#: man-pages/man3/getgrnam.3:159
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getgrent>(3), B<getgrgid>(), or B<getgrnam>().  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr "Возвращаемое значение может указывать на статическую область и может быть перезаписано при последующих вызовах B<getgrent>(3), B<getgrnam>() или B<getgrgid>() (не передавайте полученный указатель B<free>(3))."

#. type: Plain text
#: man-pages/man3/getgrnam.3:173
msgid ""
"On success, B<getgrnam_r>()  and B<getgrgid_r>()  return zero, and set "
"I<*result> to I<grp>.  If no matching group record was found, these "
"functions return 0 and store NULL in I<*result>.  In case of error, an error"
" number is returned, and NULL is stored in I<*result>."
msgstr "При успешном выполнении B<getgrnam_r>() и B<getgrgid_r>() возвращают ноль, и устанавливают I<*result> в I<pwd>. Если совпадений не найдено, то эти функции возвращают 0 и сохраняют NULL в I<*result>. При ошибке возвращается её номер и в I<*result> сохраняется NULL."

#. type: Plain text
#: man-pages/man3/getgrnam.3:181
msgid "The given I<name> or I<gid> was not found."
msgstr "Указанное значение I<name> или I<gid> не найдено."

#. type: tbl table
#: man-pages/man3/getgrnam.3:218
#, no-wrap
msgid "B<getgrnam>()"
msgstr "B<getgrnam>()"

#. type: tbl table
#: man-pages/man3/getgrnam.3:218
#, no-wrap
msgid "MT-Unsafe race:grnam locale"
msgstr "MT-Unsafe race:grnam locale"

#. type: tbl table
#: man-pages/man3/getgrnam.3:221
#, no-wrap
msgid "B<getgrgid>()"
msgstr "B<getgrgid>()"

#. type: tbl table
#: man-pages/man3/getgrnam.3:221
#, no-wrap
msgid "MT-Unsafe race:grgid locale"
msgstr "MT-Unsafe race:grgid locale"

#. type: tbl table
#: man-pages/man3/getgrnam.3:224
#, no-wrap
msgid "B<getgrnam_r>(),\n"
msgstr "B<getgrnam_r>(),\n"

#. type: tbl table
#: man-pages/man3/getgrnam.3:226
#, no-wrap
msgid "B<getgrgid_r>()"
msgstr "B<getgrgid_r>()"

#.  POSIX.1-2001, POSIX.1-2008
#.  more precisely:
#.  AIX 5.1 - gives ESRCH
#.  OSF1 4.0g - gives EWOULDBLOCK
#.  libc, glibc up to version 2.6, Irix 6.5 - give ENOENT
#.  glibc since version 2.7 - give 0
#.  FreeBSD 4.8, OpenBSD 3.2, NetBSD 1.6 - give EPERM
#.  SunOS 5.8 - gives EBADF
#.  Tru64 5.1b, HP-UX-11i, SunOS 5.7 - give 0
#. type: Plain text
#: man-pages/man3/getgrnam.3:252
msgid ""
"The formulation given above under \"RETURN VALUE\" is from POSIX.1.  It does"
" not call \"not found\" an error, hence does not specify what value I<errno>"
" might have in this situation.  But that makes it impossible to recognize "
"errors.  One might argue that according to POSIX I<errno> should be left "
"unchanged if an entry is not found.  Experiments on various UNIX-like "
"systems show that lots of different values occur in this situation: 0, "
"ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM, and probably others."
msgstr "Описание «ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ», приведённое выше, взято из POSIX.1. В нём «не найдено» не считается ошибкой и поэтому не указано, каким может быть значение I<errno> в этом случае. Но это делает невозможным определить тип ошибки. Из описание POSIX можно посчитать, что I<errno> не должно измениться, если запись не найдена. Эксперименты в различных UNIX-подобных системах показывают, что в этой ситуации возвращается много разных значений: 0, ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM и, возможно, другие."

#. type: Plain text
#: man-pages/man3/getgrnam.3:258
msgid ""
"B<endgrent>(3), B<fgetgrent>(3), B<getgrent>(3), B<getpwnam>(3), "
"B<setgrent>(3), B<group>(5)"
msgstr "B<endgrent>(3), B<fgetgrent>(3), B<getgrent>(3), B<getpwnam>(3), B<setgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/gamma.3:9
#, no-wrap
msgid "GAMMA"
msgstr "GAMMA"

#. type: Plain text
#: man-pages/man3/gamma.3:12
msgid "gamma, gammaf, gammal - (logarithm of the) gamma function"
msgstr "gamma, gammaf, gammal - логарифм гамма-функции"

#. type: Plain text
#: man-pages/man3/gamma.3:14
msgid "B<#include E<lt>math.hE<gt>>"
msgstr "B<#include E<lt>math.hE<gt>>"

#. type: Plain text
#: man-pages/man3/gamma.3:16
msgid "B<double gamma(double >I<x>B<);>"
msgstr "B<double gamma(double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/gamma.3:18
msgid "B<float gammaf(float >I<x>B<);>"
msgstr "B<float gammaf(float >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/gamma.3:20
msgid "B<long double gammal(long double >I<x>B<);>"
msgstr "B<long double gammal(long double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/gamma.3:22
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/gamma.3:30
msgid "B<gamma>():"
msgstr "B<gamma>():"

#. type: Plain text
#: man-pages/man3/gamma.3:34
#, no-wrap
msgid ""
"_XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "_XOPEN_SOURCE\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/gamma.3:37
msgid "B<gammaf>(), B<gammal>():"
msgstr "B<gammaf>(), B<gammal>():"

#. type: Plain text
#: man-pages/man3/gamma.3:41
#, no-wrap
msgid ""
"_XOPEN_SOURCE E<gt>= 600 || (_XOPEN_SOURCE && _ISOC99_SOURCE)\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "_XOPEN_SOURCE E<gt>= 600 || (_XOPEN_SOURCE && _ISOC99_SOURCE)\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/gamma.3:49
msgid ""
"These functions are deprecated: instead, use either the B<tgamma>(3)  or the"
" B<lgamma>(3)  functions, as appropriate."
msgstr "Данные функции устарели. Используйте вместо них, по возможности, B<tgamma>(3) либо B<lgamma>(3)."

#. type: Plain text
#: man-pages/man3/gamma.3:52
msgid "For the definition of the Gamma function, see B<tgamma>(3)."
msgstr "Определение гамма-функции смотрите в B<tgamma>(3)."

#. type: SS
#: man-pages/man3/gamma.3:52
#, no-wrap
msgid "*BSD version"
msgstr "Версия *BSD"

#. type: Plain text
#: man-pages/man3/gamma.3:56
msgid ""
"The libm in 4.4BSD and some versions of FreeBSD had a B<gamma>()  function "
"that computes the Gamma function, as one would expect."
msgstr "В libm из 4.4BSD и некоторых версиях FreeBSD имеется функция B<gamma>(), которая вычисляет гамма-функцию, как и ожидается."

#. type: SS
#: man-pages/man3/gamma.3:56
#, no-wrap
msgid "glibc version"
msgstr "Версия glibc"

#. type: Plain text
#: man-pages/man3/gamma.3:62
msgid ""
"Glibc has a B<gamma>()  function that is equivalent to B<lgamma>(3)  and "
"computes the natural logarithm of the Gamma function."
msgstr "В glibc есть функция B<gamma>(), которая эквивалентна B<lgamma>(3) и вычисляет натуральный логарифм гамма-функции."

#. type: Plain text
#: man-pages/man3/gamma.3:65 man-pages/man3/gamma.3:68
msgid "See B<lgamma>(3)."
msgstr "Смотрите B<lgamma>(3)."

#. type: tbl table
#: man-pages/man3/gamma.3:80
#, no-wrap
msgid ""
"B<gamma>(),\n"
"B<gammaf>(),\n"
"B<gammal>()"
msgstr "B<gamma>(),\nB<gammaf>(),\nB<gammal>()"

#. type: tbl table
#: man-pages/man3/gamma.3:80
#, no-wrap
msgid "MT-Unsafe race:signgam"
msgstr "MT-Unsafe race:signgam"

#. type: Plain text
#: man-pages/man3/gamma.3:86
msgid ""
"Because of historical variations in behavior across systems, this function "
"is not specified in any recent standard.  It was documented in SVID 2."
msgstr "Из-за различий в поведении в различных системах эта функция не попала ни в один современный стандарт. Она описана в SVID 2."

#. type: Plain text
#: man-pages/man3/gamma.3:99
msgid ""
"4.2BSD had a B<gamma>()  that computed ln(|Gamma(|I<x>|)|), leaving the sign"
" of Gamma(|I<x>|)  in the external integer I<signgam>.  In 4.3BSD the name "
"was changed to B<lgamma>(3), and the man page promises"
msgstr "В 4.2BSD функция B<gamma>() вычисляет ln(|Gamma(|I<x>|)|), записывая знак Gamma(|I<x>|) во внешнее целое I<signgam>. В 4.3BSD было изменено имя на B<lgamma>(3), и в справочной странице указано"

#. type: Plain text
#: man-pages/man3/gamma.3:103
msgid ""
"At some time in the future the name gamma will be rehabilitated and used for"
" the Gamma function"
msgstr "Через некоторое время имя gamma было восстановлено и использовано для гаммы-функции"

#.  The FreeBSD man page says about gamma() that it is like lgamma()
#.  except that is does not set signgam.
#.  Also, that 4.4BSD has a gamma() that computes the true gamma function.
#. type: Plain text
#: man-pages/man3/gamma.3:115
msgid ""
"This did indeed happen in 4.4BSD, where B<gamma>()  computes the Gamma "
"function (with no effect on I<signgam>).  However, this came too late, and "
"we now have B<tgamma>(3), the \"true gamma\" function."
msgstr "В действительности это произошло в 4.4BSD, где B<gamma>() вычисляла гамма-функцию (без влияния на I<signgam>). Однако, это случилось слишком поздно и теперь мы имеем B<tgamma>(3), «настоящую» гамма-функцию."

#. type: Plain text
#: man-pages/man3/gamma.3:118
msgid "B<lgamma>(3), B<signgam>(3), B<tgamma>(3)"
msgstr "B<lgamma>(3), B<signgam>(3), B<tgamma>(3)"

#. type: TH
#: man-pages/man3/getwchar.3:17
#, no-wrap
msgid "GETWCHAR"
msgstr "GETWCHAR"

#. type: Plain text
#: man-pages/man3/getwchar.3:20
msgid "getwchar - read a wide character from standard input"
msgstr "getwchar - считывает широкий символ из стандартного ввода"

#. type: Plain text
#: man-pages/man3/getwchar.3:23
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getwchar.3:25
#, no-wrap
msgid "B<wint_t getwchar(void);>\n"
msgstr "B<wint_t getwchar(void);>\n"

#. type: Plain text
#: man-pages/man3/getwchar.3:46
msgid ""
"The B<getwchar>()  function is the wide-character equivalent of the "
"B<getchar>(3)  function.  It reads a wide character from I<stdin> and "
"returns it.  If the end of stream is reached, or if I<ferror(stdin)> becomes"
" true, it returns B<WEOF>.  If a wide-character conversion error occurs, it "
"sets I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr "Функция B<getwchar>() — это эквивалент функции B<getchar>(3), но для широких символов. Она читает широкий символ из I<stdin> и возвращает его. Если достигнут конец потока или значение I<ferror(stdin)> истинно, то функция возвращает B<WEOF>. Если при преобразовании в широкий символ возникает ошибка, то значение переменной I<errno> устанавливается равным B<EILSEQ> и возвращается B<WEOF>."

#. type: Plain text
#: man-pages/man3/getwchar.3:49
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr "Неблокирующий аналог смотрите в B<unlocked_stdio>(3)."

#. type: Plain text
#: man-pages/man3/getwchar.3:55
msgid ""
"The B<getwchar>()  function returns the next wide-character from standard "
"input, or B<WEOF>."
msgstr "Функция B<getwchar>() возвращает следующий широкий символ из стандартного ввода или B<WEOF>."

#. type: tbl table
#: man-pages/man3/getwchar.3:65
#, no-wrap
msgid "B<getwchar>()"
msgstr "B<getwchar>()"

#. type: Plain text
#: man-pages/man3/getwchar.3:70
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/getwchar.3:77
msgid ""
"The behavior of B<getwchar>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<getwchar>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/getwchar.3:83
msgid ""
"It is reasonable to expect that B<getwchar>()  will actually read a "
"multibyte sequence from standard input and then convert it to a wide "
"character."
msgstr "Закономерно ожидать, что B<getwchar>() на самом деле читает мультибайтовую последовательность из стандартного потока, а затем преобразует её в широкий символ."

#. type: Plain text
#: man-pages/man3/getwchar.3:85
msgid "B<fgetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/getentropy.3:25
#, no-wrap
msgid "GETENTROPY"
msgstr "GETENTROPY"

#. type: Plain text
#: man-pages/man3/getentropy.3:28
msgid "getentropy - fill a buffer with random bytes"
msgstr "getentropy - заполнение буфера случайными байтами"

#. type: Plain text
#: man-pages/man3/getentropy.3:32
msgid "B<int getentropy(void *>I<buffer>B<, size_t >I<length>B<);>"
msgstr "B<int getentropy(void *>I<buffer>B<, size_t >I<length>B<);>"

#. type: Plain text
#: man-pages/man3/getentropy.3:39
msgid "B<getentropy>():"
msgstr "B<getentropy>():"

#. type: Plain text
#: man-pages/man3/getentropy.3:56
msgid ""
"The B<getentropy>()  function writes I<length> bytes of high-quality random "
"data to the buffer starting at the location pointed to by I<buffer>.  The "
"maximum permitted value for the I<length> argument is 256."
msgstr "Функция B<getentropy>() записывает I<length> байт высококачественных случайных данных в буфер, начинающийся в области, указанной в I<buffer>. Максимально разрешенное значение аргумента I<length> равно 256."

#. type: Plain text
#: man-pages/man3/getentropy.3:60
msgid ""
"A successful call to B<getentropy>()  always provides the requested number "
"of bytes of entropy."
msgstr "Успешный вызов B<getentropy>() всегда предоставляет затребованное число байт энтропии."

#. type: Plain text
#: man-pages/man3/getentropy.3:65
msgid ""
"On success, this function returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "В случае успеха функция возвращает 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/getentropy.3:73
msgid ""
"Part or all of the buffer specified by I<buffer> and I<length> is not in "
"valid addressable memory."
msgstr "Часть или весь буфер, указанный в I<buffer> и I<length>, не является валидной адресуемой памятью."

#. type: Plain text
#: man-pages/man3/getentropy.3:77
msgid "I<length> is greater than 256."
msgstr "Значение I<length> больше 256."

#. type: Plain text
#: man-pages/man3/getentropy.3:82
msgid ""
"An unspecified error occurred while trying to overwrite I<buffer> with "
"random data."
msgstr "При попытке перезаписать I<buffer> случайными данными произошла ошибка."

#. type: Plain text
#: man-pages/man3/getentropy.3:87
msgid ""
"This kernel version does not implement the B<getrandom>(2)  system call "
"required to implement this function."
msgstr "Данная версия ядра не имеет реализации системного вызова B<getrandom>(2), необходимого для реализации данной функции."

#. type: Plain text
#: man-pages/man3/getentropy.3:91
msgid "The B<getentropy>()  function first appeared in glibc 2.25."
msgstr "Функция B<getentropy>() впервые появилась в glibc 2.25."

#. type: Plain text
#: man-pages/man3/getentropy.3:94
msgid "This function is nonstandard.  It is also present on OpenBSD."
msgstr "Эта функция является нестандартной. Она также присутствует в OpenBSD."

#. type: Plain text
#: man-pages/man3/getentropy.3:99
msgid "The B<getentropy>()  function is implemented using B<getrandom>(2)."
msgstr "Функция B<getentropy>() реализована через вызов B<getrandom>(2)."

#. type: Plain text
#: man-pages/man3/getentropy.3:105
msgid ""
"Whereas the glibc wrapper makes B<getrandom>(2)  a cancellation point, "
"B<getentropy>()  is not a cancellation point."
msgstr "Следует учитывать, что в glibc обертка делает B<getrandom>(2) точкой отмены, а точкой отмены B<getentropy>() не является."

#. type: Plain text
#: man-pages/man3/getentropy.3:111
msgid ""
"B<getentropy>()  is also declared in B<E<lt>sys/random.hE<gt>>.  (No feature"
" test macro need be defined to obtain the declaration from that header "
"file.)"
msgstr "Функция B<getentropy>() также объявлена в B<E<lt>sys/random.hE<gt>> (для получения этого объявления из заголовочного файла макроса тестирования свойств не требуется)."

#. type: Plain text
#: man-pages/man3/getentropy.3:120
msgid ""
"A call to B<getentropy>()  may block if the system has just booted and the "
"kernel has not yet collected enough randomness to initialize the entropy "
"pool.  In this case, B<getentropy>()  will keep blocking even if a signal is"
" handled, and will return only once the entropy pool has been initialized."
msgstr "Вызов B<getentropy>() может блокировать работу, если система только что загрузилась и ядро ещё не успело набрать достаточно случайных событий для инициализации пула энтропии. В этом случае B<getentropy>() продолжает блокировать работу даже при обработке сигнала и вернёт управление только после завершения инициализации пула энтропии."

#. type: Plain text
#: man-pages/man3/getentropy.3:123
msgid "B<getrandom>(2), B<urandom>(4), B<random>(7)"
msgstr "B<getrandom>(2), B<urandom>(4), B<random>(7)"

#. type: TH
#: man-pages/man3/getdirentries.3:27
#, no-wrap
msgid "GETDIRENTRIES"
msgstr "GETDIRENTRIES"

#. type: Plain text
#: man-pages/man3/getdirentries.3:30
msgid ""
"getdirentries - get directory entries in a filesystem-independent format"
msgstr "getdirentries - возвращает элементы каталога в формате, не зависящем от файловой системы"

#. type: Plain text
#: man-pages/man3/getdirentries.3:32
msgid "B<#include E<lt>dirent.hE<gt>>"
msgstr "B<#include E<lt>dirent.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getdirentries.3:35
msgid ""
"B<ssize_t getdirentries(int >I<fd>B<, char *>I<buf>B<, size_t >I<nbytes> B<,"
" off_t *>I<basep>B<);>"
msgstr "B<ssize_t getdirentries(int >I<fd>B<, char *>I<buf>B<, size_t >I<nbytes> B<, off_t *>I<basep>B<);>"

#. type: Plain text
#: man-pages/man3/getdirentries.3:46
#, no-wrap
msgid ""
"B<getdirentries>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<getdirentries>(),\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/getdirentries.3:59
msgid ""
"Read directory entries from the directory specified by I<fd> into I<buf>.  "
"At most I<nbytes> are read.  Reading starts at offset I<*basep>, and "
"I<*basep> is updated with the new position after reading."
msgstr "Данная функция считывает (не более I<nbytes> байтов) элементы каталога, указанного в I<fd>, в I<buf>. Чтение начинается со смещения I<*basep> и после чтения I<*basep> обновляется в соответствии с новой позицией."

#. type: Plain text
#: man-pages/man3/getdirentries.3:65
msgid ""
"B<getdirentries>()  returns the number of bytes read or zero when at the end"
" of the directory.  If an error occurs, -1 is returned, and I<errno> is set "
"appropriately."
msgstr "Функция B<getdirentries>() возвращает количество считанных байтов или ноль, если достигнут конец каталога. Если произошла ошибка, возвращается -1, и устанавливается, соответствующим образом, переменная I<errno>."

#. type: Plain text
#: man-pages/man3/getdirentries.3:67
msgid "See the Linux library source code for details."
msgstr "Дополнительную информацию смотрите в исходном коде библиотеки Linux."

#. type: tbl table
#: man-pages/man3/getdirentries.3:77
#, no-wrap
msgid "B<getdirentries>()"
msgstr "B<getdirentries>()"

#. type: Plain text
#: man-pages/man3/getdirentries.3:87
msgid ""
"Not in POSIX.1.  Present on the BSDs, and a few other systems.  Use "
"B<opendir>(3)  and B<readdir>(3)  instead."
msgstr "Нет в POSIX.1. Присутствует в BSD и многих других системах. Используйте вместо нее B<opendir>(3) и B<readdir>(3)."

#. type: Plain text
#: man-pages/man3/getdirentries.3:89
msgid "B<lseek>(2), B<open>(2)"
msgstr "B<lseek>(2), B<open>(2)"

#. type: TH
#: man-pages/man3/gets.3:29
#, no-wrap
msgid "GETS"
msgstr "GETS"

#. type: Plain text
#: man-pages/man3/gets.3:32
msgid "gets - get a string from standard input (DEPRECATED)"
msgstr "gets - получает строку из стандартного потока ввода (УСТАРЕЛА)"

#. type: Plain text
#: man-pages/man3/gets.3:37
#, no-wrap
msgid "B<char *gets(char *>I<s>B<);>\n"
msgstr "B<char *gets(char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/gets.3:40
msgid "I<Never use this function>."
msgstr "I<Никогда не используйте эту функцию>."

#. type: Plain text
#: man-pages/man3/gets.3:50
msgid ""
"B<gets>()  reads a line from I<stdin> into the buffer pointed to by I<s> "
"until either a terminating newline or B<EOF>, which it replaces with a null "
"byte (\\(aq\\e0\\(aq).  No check for buffer overrun is performed (see BUGS "
"below)."
msgstr "Функция B<gets>() считывает строку из I<stdin> и записывает её в буфер, на который указывает I<s>, пока не встретится символ новой строки или B<EOF>, которые заменяются байтом null (\\(aq\\e0\\(aq). Проверка на переполнение буфера не производится (смотрите ДЕФЕКТЫ далее)."

#. type: Plain text
#: man-pages/man3/gets.3:58
msgid ""
"B<gets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read.  However, given the lack of "
"buffer overrun checking, there can be no guarantees that the function will "
"even return."
msgstr "При успешном выполнении функция B<gets>() возвращает I<s> и NULL при ошибке или если достигнут конец файла, а символы остались несчитанными. Тем не менее, из-за невозможности проверить переполнение буфера, нет гарантии, что функция вообще что-нибудь сможет вернуть."

#. type: tbl table
#: man-pages/man3/gets.3:68
#, no-wrap
msgid "B<gets>()"
msgstr "B<gets>()"

#. type: Plain text
#: man-pages/man3/gets.3:73
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/gets.3:85
msgid ""
"LSB deprecates B<gets>().  POSIX.1-2008 marks B<gets>()  obsolescent.  ISO "
"C11 removes the specification of B<gets>()  from the C language, and since "
"version 2.16, glibc header files don't expose the function declaration if "
"the B<_ISOC11_SOURCE> feature test macro is defined."
msgstr "В LSB функция B<gets>() указана как устаревшая. В POSIX.1-2008 функция B<gets>() как вышедшая из употребления. В ISO C11 описание B<gets>() удалено из языка Си, и начиная с версии 2.16, заголовочные файлы glibc не объявляют эту функцию, если не определён макрос тестирования свойств B<_ISOC11_SOURCE>."

#. type: Plain text
#: man-pages/man3/gets.3:99
msgid ""
"Never use B<gets>().  Because it is impossible to tell without knowing the "
"data in advance how many characters B<gets>()  will read, and because "
"B<gets>()  will continue to store characters past the end of the buffer, it "
"is extremely dangerous to use.  It has been used to break computer security."
"  Use B<fgets>()  instead."
msgstr "Никогда не используйте B<gets>(), потому что без предварительного знакомства с данными невозможно узнать, какое количество символов считает B<gets>(), а также потому, что B<gets>() будет продолжать заносить символы в буфер даже по достижении его конца, что представляет собой большую опасность. Эта функция использовалась для взлома систем безопасности компьютера. Вместо этой функции используйте B<fgets>()."

#. type: Plain text
#: man-pages/man3/gets.3:103
msgid ""
"For more information, see CWE-242 (aka \"Use of Inherently Dangerous "
"Function\") at http://cwe.mitre.org/data/definitions/242.html"
msgstr "Подробное описание смотрите в CWE-242 (или «Use of Inherently Dangerous Function») на http://cwe.mitre.org/data/definitions/242.html"

#. type: Plain text
#: man-pages/man3/gets.3:120
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), "
"B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), "
"B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr "B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), B<unlocked_stdio>(3), B<feature_test_macros>(7)"
