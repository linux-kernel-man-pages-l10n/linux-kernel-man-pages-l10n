# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2013-2014
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2014
# Yuri Kozlov <yuray@komyakino.ru>, 2014
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2013-03-23 18:36+0400\n"
"PO-Revision-Date: 2014-08-17 04:30+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian (http://www.transifex.com/projects/p/man-pages/language/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#. type: TH
#: man-pages/man1/getent.1:24
#, no-wrap
msgid "GETENT"
msgstr "GETENT"

#. type: TH
#: man-pages/man1/getent.1:24
#, no-wrap
msgid "2013-03-15"
msgstr "2013-03-15"

#. type: TH
#: man-pages/man1/getent.1:24
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man1/getent.1:24
#, no-wrap
msgid "User Commands"
msgstr "Пользовательские команды"

#. type: SH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man1/getent.1:27
msgid "getent - get entries from Name Service Switch libraries"
msgstr "getent - возвращает записи из библиотек диспетчера службы имён"

#. type: SH
#: man-pages/man1/getent.1:27
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man1/getent.1:30
msgid "B<getent> I<database> [I<key> ...]"
msgstr "B<getent> I<база данных> [I<ключ> …]"

#. type: SH
#: man-pages/man1/getent.1:30
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man1/getent.1:45
msgid ""
"The B<getent> command displays entries from databases supported by the Name "
"Service Switch libraries, which are configured in I</etc/nsswitch.conf>.  If"
" one or more I<key> arguments are provided, then only the entries that match"
" the supplied keys will be displayed.  Otherwise, if no I<key> is provided, "
"all entries will be displayed (unless the database does not support "
"enumeration)."
msgstr "Команда B<getent> отображает записи из баз данных, поддерживаемых библиотеками диспетчера службы имён (Name Service Switch), которые настраиваются в I</etc/nsswitch.conf>. Если указан один или более аргументов I<ключ>, то отображаются только записи, совпадающие с заданными ключами. В противном случае, если I<ключ> не указан, то будут показаны все записи (если база данных поддерживает перечисление)."

#. type: Plain text
#: man-pages/man1/getent.1:49
msgid ""
"The I<database> may be any of those supported by the GNU C Library, listed "
"below:"
msgstr "Значение I<базы данных> может быть любым из поддерживаемых библиотекой GNU C:"

#. type: TP
#: man-pages/man1/getent.1:50
#, no-wrap
msgid "B<ahosts>"
msgstr "B<ahosts>"

#. type: Plain text
#: man-pages/man1/getent.1:71
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  This is identical to "
"using B<hosts>.  When one or more I<key> arguments are provided, pass each "
"I<key> in succession to B<getaddrinfo>(3)  with the address family "
"B<AF_UNSPEC>, enumerating each socket address structure returned."
msgstr "Если I<ключ> не указан, то используются B<sethostent>(3), B<gethostent>(3) и B<endhostent>(3) для перечисления базы данных hosts. Идентично использованию B<hosts>. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getaddrinfo>(3) с адресным семейством B<AF_UNSPEC>, которая возвращает каждую перечисляемую адресную структуру сокета."

#. type: TP
#: man-pages/man1/getent.1:71
#, no-wrap
msgid "B<ahostsv4>"
msgstr "B<ahostsv4>"

#. type: Plain text
#: man-pages/man1/getent.1:77
msgid "Same as B<ahosts>, but use the address family B<AF_INET>."
msgstr "То же, что и B<ahosts>, но используется адресное семейство B<AF_INET>."

#. type: TP
#: man-pages/man1/getent.1:77
#, no-wrap
msgid "B<ahostsv6>"
msgstr "B<ahostsv6>"

#. type: Plain text
#: man-pages/man1/getent.1:88
msgid ""
"Same as B<ahosts>, but use the address family B<AF_INET6>.  The call to "
"B<getaddrinfo>(3)  in this case includes the B<AI_V4MAPPED> flag."
msgstr "То же, что и B<ahosts>, но используется адресное семейство B<AF_INET6>. В этом случае при вызове B<getaddrinfo>(3) включается флаг B<AI_V4MAPPED>."

#. type: TP
#: man-pages/man1/getent.1:88
#, no-wrap
msgid "B<aliases>"
msgstr "B<aliases>"

#. type: Plain text
#: man-pages/man1/getent.1:105
msgid ""
"When no I<key> is provided, use B<setaliasent>(3), B<getaliasent>(3), and "
"B<endaliasent>(3)  to enumerate the aliases database.  When one or more "
"I<key> arguments are provided, pass each I<key> in succession to "
"B<getaliasbyname>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setaliasent>(3), B<getaliasent>(3) и B<endaliasent>(3) для перечисления базы данных aliases. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getaliasbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:105
#, no-wrap
msgid "B<ethers>"
msgstr "B<ethers>"

#. type: Plain text
#: man-pages/man1/getent.1:121
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<ether_aton>(3)  and B<ether_hostton>(3)  until a result is "
"obtained, and display the result.  Enumeration is not supported on "
"B<ethers>, so a I<key> must be provided."
msgstr "Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<ether_aton>(3) и B<ether_hostton>(3), пока не будет возвращён результат, и показывается результат. Перечисление B<ethers> не поддерживается, поэтому I<ключ> обязателен."

#. type: TP
#: man-pages/man1/getent.1:121
#, no-wrap
msgid "B<group>"
msgstr "B<group>"

#. type: Plain text
#: man-pages/man1/getent.1:142
msgid ""
"When no I<key> is provided, use B<setgrent>(3), B<getgrent>(3), and "
"B<endgrent>(3)  to enumerate the group database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getgrgid>(3)  and each"
" nonnumeric I<key> to B<getgrnam>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setgrent>(3), B<getgrent>(3) и B<endgrent>(3) для перечисления базы данных group. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getgrgid>(3) и каждый не числовой I<ключ> в B<getgrnam>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:142
#, no-wrap
msgid "B<gshadow>"
msgstr "B<gshadow>"

#. type: Plain text
#: man-pages/man1/getent.1:159
msgid ""
"When no I<key> is provided, use B<setsgent>(3), B<getsgent>(3), and "
"B<endsgent>(3)  to enumerate the gshadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getsgnam>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setsgent>(3), B<getsgent>(3) и B<endsgent>(3) для перечисления базы данных gshadow. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getsgnam>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:159
#, no-wrap
msgid "B<hosts>"
msgstr "B<hosts>"

#. type: Plain text
#: man-pages/man1/getent.1:182
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  When one or more I<key> "
"arguments are provided, pass each I<key> to B<gethostbyaddr>(3)  or "
"B<gethostbyname2>(3), depending on whether a call to B<inet_pton>(3)  "
"indicates that the I<key> is an IPv6 or IPv4 address or not, and display the"
" result."
msgstr "Если I<ключ> не указан, используется B<sethostent>(3), B<gethostent>(3) и B<endhostent>(3) для перечисления базы данных hosts. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<gethostbyaddr>(3) или B<gethostbyname2>(3), в зависимости от результата вызова B<inet_pton>(3), определяющего, является ли I<ключ> адресом IPv6 или IPv4, и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:182
#, no-wrap
msgid "B<initgroups>"
msgstr "B<initgroups>"

#. type: Plain text
#: man-pages/man1/getent.1:196
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<getgrouplist>(3)  and display the result.  Enumeration is "
"not supported on B<initgroups>, so a I<key> must be provided."
msgstr "Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getgrouplist>(3) и показывается результат. Перечисление B<initgroups> не поддерживается, поэтому I<ключ> обязателен."

#. type: TP
#: man-pages/man1/getent.1:196
#, no-wrap
msgid "B<netgroup>"
msgstr "B<netgroup>"

#. type: Plain text
#: man-pages/man1/getent.1:222
msgid ""
"When one I<key> is provided, pass the I<key> to B<setnetgrent>(3)  and, "
"using B<getnetgrent>(3)  display the resulting string triple (I<hostname>, "
"I<username>, I<domainname>).  Alternatively, three I<keys> may be provided, "
"which are interpreted as the I<hostname>, I<username> and I<domainname> to "
"match to a netgroup name via B<innetgr>(3).  Enumeration is not supported on"
" B<netgroup>, so either one or three I<keys> must be provided."
msgstr "Если указан один I<ключ>, то он передаётся в B<setnetgrent>(3) и, с помощью B<getnetgrent>(3), отображается полученная строковая тройка (I<hostname>, I<username>, I<domainname>). В противном случае могут быть указаны три I<ключа>, которые рассматриваются как I<hostname>, I<username> и I<domainname> для поиска имени netgroup посредством B<innetgr>(3). Перечисление B<netgroup> не поддерживается, поэтому должен быть указан либо один, либо три I<ключа>."

#. type: TP
#: man-pages/man1/getent.1:222
#, no-wrap
msgid "B<networks>"
msgstr "B<networks>"

#. type: Plain text
#: man-pages/man1/getent.1:243
msgid ""
"When no I<key> is provided, use B<setnetent>(3), B<getnetent>(3), and "
"B<endnetent>(3)  to enumerate the networks database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getnetbyaddr>(3)  and each nonnumeric I<key> to B<getnetbyname>(3)  and "
"display the result."
msgstr "Если I<ключ> не указан, используется B<setnetent>(3), B<getnetent>(3) и B<endnetent>(3) для перечисления базы данных networks. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getnetbyaddr>(3) и каждый не числовой I<ключ> в B<getnetbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:243
#, no-wrap
msgid "B<passwd>"
msgstr "B<passwd>"

#. type: Plain text
#: man-pages/man1/getent.1:264
msgid ""
"When no I<key> is provided, use B<setpwent>(3), B<getpwent>(3), and "
"B<endpwent>(3)  to enumerate the passwd database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getpwuid>(3)  and each"
" nonnumeric I<key> to B<getpwnam>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setpwent>(3), B<getpwent>(3) и B<endpwent>(3) для перечисления базы данных passwd. Если указан один или более I<ключ>, то  каждый числовой I<ключ> передаётся в B<getpwuid>(3) и каждый не числовой I<ключ> в B<getpwnam>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:264
#, no-wrap
msgid "B<protocols>"
msgstr "B<protocols>"

#. type: Plain text
#: man-pages/man1/getent.1:285
msgid ""
"When no I<key> is provided, use B<setprotoent>(3), B<getprotoent>(3), and "
"B<endprotoent>(3)  to enumerate the protocols database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getprotobynumber>(3)  and each nonnumeric I<key> to B<getprotobyname>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setprotoent>(3), B<getprotoent>(3) и B<endprotoent>(3) для перечисления базы данных protocols. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getprotobynumber>(3) и каждый не числовой I<ключ> в B<getprotobyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:285
#, no-wrap
msgid "B<rpc>"
msgstr "B<rpc>"

#. type: Plain text
#: man-pages/man1/getent.1:306
msgid ""
"When no I<key> is provided, use B<setrpcent>(3), B<getrpcent>(3), and "
"B<endrpcent>(3)  to enumerate the rpc database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getrpcbynumber>(3)  "
"and each nonnumeric I<key> to B<getrpcbyname>(3)  and display the result."
msgstr "Если I<ключ> не указан, используется B<setrpcent>(3), B<getrpcent>(3) и B<endrpcent>(3) для перечисления базы данных rpc. Если указан один или более I<ключ>, то каждый числовой I<ключ> передаётся в B<getrpcbynumber>(3) и каждый не числовой I<ключ> в B<getrpcbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:306
#, no-wrap
msgid "B<services>"
msgstr "B<services>"

#. type: Plain text
#: man-pages/man1/getent.1:327
msgid ""
"When no I<key> is provided, use B<setservent>(3), B<getservent>(3), and "
"B<endservent>(3)  to enumerate the services database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getservbynumber>(3)  and each nonnumeric I<key> to B<getservbyname>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setservent>(3), B<getservent>(3) и B<endservent>(3) для перечисления базы данных services. Если указан один или более I<ключ>, то  каждый числовой I<ключ> передаётся в B<getservbynumber>(3) и каждый не числовой I<ключ> в B<getservbyname>(3) и показывается результат."

#. type: TP
#: man-pages/man1/getent.1:327
#, no-wrap
msgid "B<shadow>"
msgstr "B<shadow>"

#. type: Plain text
#: man-pages/man1/getent.1:344
msgid ""
"When no I<key> is provided, use B<setspent>(3), B<getspent>(3), and "
"B<endspent>(3)  to enumerate the shadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getspnam>(3)  "
"and display the result."
msgstr "Если I<ключ> не указан, используется B<setspent>(3), B<getspent>(3) и B<endspent>(3) для перечисления базы данных shadow. Если указан один или более I<ключ>, то каждый I<ключ> последовательно передаётся в B<getspnam>(3) и показывается результат."

#. type: SH
#: man-pages/man1/getent.1:345
#, no-wrap
msgid "EXIT STATUS"
msgstr "КОД РЕЗУЛЬТАТА"

#. type: Plain text
#: man-pages/man1/getent.1:348
msgid "One of the following exit values can be returned by B<getent>:"
msgstr "Программа B<getent> может возвращать один из следующих кодов завершения:"

#. type: TP
#: man-pages/man1/getent.1:349
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: man-pages/man1/getent.1:352
msgid "Command completed successfully."
msgstr "Команда успешно выполнена."

#. type: TP
#: man-pages/man1/getent.1:352
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: man-pages/man1/getent.1:357
msgid "Missing arguments, or I<database> unknown."
msgstr "Отсутствуют аргументы или неизвестная I<база данных>."

#. type: TP
#: man-pages/man1/getent.1:357
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: man-pages/man1/getent.1:363
msgid "One or more supplied I<key> could not be found in the I<database>."
msgstr "Один или более указанных I<ключей> невозможно найти в I<базе данных>."

#. type: TP
#: man-pages/man1/getent.1:363
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: man-pages/man1/getent.1:367
msgid "Enumeration not supported on this I<database>."
msgstr "Перечисление не поддерживается в этой I<базе данных>."

#. type: SH
#: man-pages/man1/getent.1:368
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man1/getent.1:369
msgid "B<nsswitch.conf>(5)"
msgstr "B<nsswitch.conf>(5)"

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "GLOB"
msgstr "GLOB"

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "2012-07-28"
msgstr "2012-07-28"

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: Plain text
#: man-pages/man7/glob.7:29
msgid "glob - globbing pathnames"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:34
msgid ""
"Long ago, in UNIX\\ V6, there was a program I</etc/glob> that would expand "
"wildcard patterns.  Soon afterward this became a shell built-in."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:38
msgid ""
"These days there is also a library routine B<glob>(3)  that will perform "
"this function for a user program."
msgstr "В наши дни существует библиотечная функция B<glob>(3), которая выполняет эту задачу для пользовательских программ."

#. type: Plain text
#: man-pages/man7/glob.7:40
msgid "The rules are as follows (POSIX.2, 3.13)."
msgstr "Следующие правила приведены в соответствии со стандартом POSIX.2, 3.13."

#. type: SS
#: man-pages/man7/glob.7:40
#, no-wrap
msgid "Wildcard matching"
msgstr "Тип шаблона"

#. type: Plain text
#: man-pages/man7/glob.7:47
msgid ""
"A string is a wildcard pattern if it contains one of the characters "
"\\(aq?\\(aq, \\(aq*\\(aq or \\(aq[\\(aq.  Globbing is the operation that "
"expands a wildcard pattern into the list of pathnames matching the pattern."
"  Matching is defined by:"
msgstr "Строка считается шаблоном подстановки, если содержит в себе один из символов \\(aq?\\(aq, \\(aq*\\(aq or \\(aq[\\(aq. Globbing - это операция, которая раскрывает шаблон подстановки в список имен путей, соответствующих данному шаблону. Соответствие определяется следующими правилами:"

#. type: Plain text
#: man-pages/man7/glob.7:49
msgid "A \\(aq?\\(aq (not between brackets) matches any single character."
msgstr "\\(aq?\\(aq (без учета кавычек) соответствует любому одному символу."

#. type: Plain text
#: man-pages/man7/glob.7:52
msgid ""
"A \\(aq*\\(aq (not between brackets) matches any string, including the empty"
" string."
msgstr "\\(aq*\\(aq (без учета кавычек) соответствует любой строке, включая пустую строку."

#. type: Plain text
#: man-pages/man7/glob.7:54
msgid "B<Character classes>"
msgstr "B<Классы символов>"

#. type: Plain text
#: man-pages/man7/glob.7:63
msgid ""
"An expression \"I<[...]>\" where the first character after the leading "
"\\(aq[\\(aq is not an \\(aq!\\(aq matches a single character, namely any of "
"the characters enclosed by the brackets.  The string enclosed by the "
"brackets cannot be empty; therefore \\(aq]\\(aq can be allowed between the "
"brackets, provided that it is the first character.  (Thus, \"I<[][!]>\" "
"matches the three characters \\(aq[\\(aq, \\(aq]\\(aq and \\(aq!\\(aq.)"
msgstr "Выражение \"I<[...]>\", где первый символ после открывающей \\(aq[\\(aq - не \\(aq!\\(aq, соответствует одному символу, который может быть любым символом из набора, находящегося внутри скобок. Строка внутри скобок не может быть пустой, таким образом, \\(aq]\\(aq также может находится внутри скобок и выступать в качестве первого символа (то есть \"I<[][!]>\" будет соответствовать трем символам \\(aq[\\(aq, \\(aq]\\(aq and \\(aq!\\(aq)."

#. type: Plain text
#: man-pages/man7/glob.7:65
msgid "B<Ranges>"
msgstr "B<Диапазоны>"

#. type: Plain text
#: man-pages/man7/glob.7:76
msgid ""
"There is one special convention: two characters separated by \\(aq-\\(aq "
"denote a range.  (Thus, \"I<[A-Fa-f0-9]>\" is equivalent to "
"\"I<[ABCDEFabcdef0123456789]>\".)  One may include \\(aq-\\(aq in its "
"literal meaning by making it the first or last character between the "
"brackets.  (Thus, \"I<[]-]>\" matches just the two characters \\(aq]\\(aq "
"and \\(aq-\\(aq, and \"I<[--0]>\" matches the three characters \\(aq-\\(aq, "
"\\(aq.\\(aq, \\(aq0\\(aq, since \\(aq/\\(aq cannot be matched.)"
msgstr "Два символа, разделенных \\(aq-\\(aq, образуют особое выражение - диапазон (то есть \"I<[A-Fa-f0-9]>\" будет эквивалентен записи \"I<[ABCDEFabcdef0123456789]>\"). Сюда также может входить и сам \\(aq-\\(aq в качестве начального или конечного символа (то есть \"I<[]-]>\" будет соответствовать только двум символам - \\(aq]\\(aq и \\(aq-\\(aq, а \"I<[--0]>\" - трем символам, (aq-\\(aq, \\(aq.\\(aq, \\(aq0\\(aq, \\(aq/\\(aq не может быть использован)."

#. type: Plain text
#: man-pages/man7/glob.7:78
msgid "B<Complementation>"
msgstr "B<Разность множеств>"

#. type: Plain text
#: man-pages/man7/glob.7:84
msgid ""
"An expression \"I<[!...]>\" matches a single character, namely any character"
" that is not matched by the expression obtained by removing the first "
"\\(aq!\\(aq from it.  (Thus, \"I<[!]a-]>\" matches any single character "
"except \\(aq]\\(aq, \\(aqa\\(aq and \\(aq-\\(aq.)"
msgstr "Выражение \"I<[!...]>\" соответствует одному символу, который является любым символом, который не входит в множество, получаемое путем удаления первого  \\(aq!\\(aq (то есть \"I<[!]a-]>\" будет соответствовать любому одному символу за исключением \\(aq]\\(aq, \\(aqa\\(aq и \\(aq-\\(aq)."

#. type: Plain text
#: man-pages/man7/glob.7:91
msgid ""
"One can remove the special meaning of \\(aq?\\(aq, \\(aq*\\(aq and "
"\\(aq[\\(aq by preceding them by a backslash, or, in case this is part of a "
"shell command line, enclosing them in quotes.  Between brackets these "
"characters stand for themselves.  Thus, \"I<[[?*\\e]>\" matches the four "
"characters \\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq and \\(aq\\e\\(aq."
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:91
#, no-wrap
msgid "Pathnames"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:98
msgid ""
"Globbing is applied on each of the components of a pathname separately.  A "
"\\(aq/\\(aq in a pathname cannot be matched by a \\(aq?\\(aq or \\(aq*\\(aq "
"wildcard, or by a range like \"I<[.-0]>\".  A range cannot contain an "
"explicit \\(aq/\\(aq character; this would lead to a syntax error."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:103
msgid ""
"If a filename starts with a \\(aq.\\(aq, this character must be matched "
"explicitly.  (Thus, I<rm\\ *> will not remove .profile, and I<tar\\ c\\ *> "
"will not archive all your files; I<tar\\ c\\ .> is better.)"
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:103
#, no-wrap
msgid "Empty lists"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:109
msgid ""
"The nice and simple rule given above: \"expand a wildcard pattern into the "
"list of matching pathnames\" was the original UNIX definition.  It allowed "
"one to have patterns that expand into an empty list, as in"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:112
#, no-wrap
msgid "    xv -wait 0 *.gif *.jpg\n"
msgstr "    xv -wait 0 *.gif *.jpg\n"

#. type: Plain text
#: man-pages/man7/glob.7:122
msgid ""
"where perhaps no *.gif files are present (and this is not an error).  "
"However, POSIX requires that a wildcard pattern is left unchanged when it is"
" syntactically incorrect, or the list of matching pathnames is empty.  With "
"I<bash> one can force the classical behavior using this command:"
msgstr ""

#.  In Bash v1, by setting allow_null_glob_expansion=true
#. type: Plain text
#: man-pages/man7/glob.7:125
#, no-wrap
msgid "    shopt -s nullglob\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:128
msgid ""
"(Similar problems occur elsewhere.  For example, where old scripts have"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:131
#, no-wrap
msgid "    rm \\`find . -name \"*~\"\\`\n"
msgstr "    rm \\`find . -name \"*~\"\\`\n"

#. type: Plain text
#: man-pages/man7/glob.7:134
msgid "new scripts require"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:137
#, no-wrap
msgid "    rm -f nosuchfile \\`find . -name \"*~\"\\`\n"
msgstr "    rm -f nosuchfile \\`find . -name \"*~\"\\`\n"

#. type: Plain text
#: man-pages/man7/glob.7:142
msgid ""
"to avoid error messages from I<rm> called with an empty argument list.)"
msgstr ""

#. type: SH
#: man-pages/man7/glob.7:142
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: SS
#: man-pages/man7/glob.7:143
#, no-wrap
msgid "Regular expressions"
msgstr "Регулярные выражения"

#. type: Plain text
#: man-pages/man7/glob.7:150
msgid ""
"Note that wildcard patterns are not regular expressions, although they are a"
" bit similar.  First of all, they match filenames, rather than text, and "
"secondly, the conventions are not the same: for example, in a regular "
"expression \\(aq*\\(aq means zero or more copies of the preceding thing."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:154
msgid ""
"Now that regular expressions have bracket expressions where the negation is "
"indicated by a \\(aq^\\(aq, POSIX has declared the effect of a wildcard "
"pattern \"I<[^...]>\" to be undefined."
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:154
#, no-wrap
msgid "Character classes and internationalization"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:172
msgid ""
"Of course ranges were originally meant to be ASCII ranges, so that \"I<[\\ "
"-%]>\" stands for \"I<[\\ !\"#$%]>\" and \"I<[a-z]>\" stands for \"any "
"lowercase letter\".  Some UNIX implementations generalized this so that a "
"range X-Y stands for the set of characters with code between the codes for X"
" and for Y.  However, this requires the user to know the character coding in"
" use on the local system, and moreover, is not convenient if the collating "
"sequence for the local alphabet differs from the ordering of the character "
"codes.  Therefore, POSIX extended the bracket notation greatly, both for "
"wildcard patterns and for regular expressions.  In the above we saw three "
"types of items that can occur in a bracket expression: namely (i) the "
"negation, (ii) explicit single characters, and (iii) ranges.  POSIX "
"specifies ranges in an internationally more useful way and adds three more "
"types:"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:178
msgid ""
"(iii) Ranges X-Y comprise all characters that fall between X and Y "
"(inclusive) in the current collating sequence as defined by the "
"B<LC_COLLATE> category in the current locale."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:180
msgid "(iv) Named character classes, like"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:185
#, no-wrap
msgid ""
"[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n"
"[:digit:]  [:graph:]  [:lower:]  [:print:]\n"
"[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"
msgstr "[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n[:digit:]  [:graph:]  [:lower:]  [:print:]\n[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"

#. type: Plain text
#: man-pages/man7/glob.7:194
msgid ""
"so that one can say \"I<[[:lower:]]>\" instead of \"I<[a-z]>\", and have "
"things work in Denmark, too, where there are three letters past \\(aqz\\(aq "
"in the alphabet.  These character classes are defined by the B<LC_CTYPE> "
"category in the current locale."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:200
msgid ""
"(v) Collating symbols, like \"I<[.ch.]>\" or \"I<[.a-acute.]>\", where the "
"string between \"I<[.>\" and \"I<.]>\" is a collating element defined for "
"the current locale.  Note that this may be a multicharacter element."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:208
msgid ""
"(vi) Equivalence class expressions, like \"I<[=a=]>\", where the string "
"between \"I<[=>\" and \"I<=]>\" is any collating element from its "
"equivalence class, as defined for the current locale.  For example, "
"\"I<[[=a=]]>\" might be equivalent to \"I<[a\\('a\\(`a\\(:a\\(^a]>\", that "
"is, to \"I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:213
msgid "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"
msgstr "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"

#. type: TH
#: man-pages/man2/getsid.2:26
#, no-wrap
msgid "GETSID"
msgstr "GETSID"

#. type: TH
#: man-pages/man2/getsid.2:26
#, no-wrap
msgid "2010-09-26"
msgstr "2010-09-26"

#. type: Plain text
#: man-pages/man2/getsid.2:29
msgid "getsid - get session ID"
msgstr "getsid - получить ID сеанса"

#. type: Plain text
#: man-pages/man2/getsid.2:31
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getsid.2:33
msgid "B<pid_t getsid(pid_t>I< pid>B<);>"
msgstr "B<pid_t getsid(pid_t>I< pid>B<);>"

#. type: Plain text
#: man-pages/man2/getsid.2:37
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/getsid.2:42
msgid "B<getsid>():"
msgstr "B<getsid>():"

#. type: Plain text
#: man-pages/man2/getsid.2:45
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man2/getsid.2:47
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: man-pages/man2/getsid.2:58
msgid ""
"I<getsid(0)> returns the session ID of the calling process.  I<getsid(p)> "
"returns the session ID of the process with process ID I<p>.  (The session ID"
" of a process is the process group ID of the session leader.)"
msgstr "I<getsid(0)> возвращает идентификатор (ID) сеанса вызвавшего процесса. I<getsid(p)> возвращает идентификатор сеанса процесса с ID равным I<p>. (Идентификатор сеанса процесса \\(em это идентификатор группы процесса, который является лидером сеанса.)"

#. type: SH
#: man-pages/man2/getsid.2:58
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/getsid.2:63
msgid ""
"On success, a session ID is returned.  On error, I<(pid_t)\\ -1> will be "
"returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении возвращается идентификатор сеанса. В случае ошибки возвращается I<(pid_t)\\ -1>, а I<errno> устанавливается в соответствующее значение."

#. type: SH
#: man-pages/man2/getsid.2:63
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man2/getsid.2:64
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/getsid.2:70
msgid ""
"A process with process ID I<p> exists, but it is not in the same session as "
"the calling process, and the implementation considers this an error."
msgstr "Процесс с идентификатором I<p> существует, но не находится в том же сеансе что и вызвавший процесс; в данной реализации это считается ошибкой."

#. type: TP
#: man-pages/man2/getsid.2:70
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/getsid.2:75
msgid "No process with process ID I<p> was found."
msgstr "Процесс с идентификатором I<p> не найден."

#. type: SH
#: man-pages/man2/getsid.2:75
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#.  Linux has this system call since Linux 1.3.44.
#.  There is libc support since libc 5.2.19.
#. type: Plain text
#: man-pages/man2/getsid.2:79
msgid "This system call is available on Linux since version 2.0."
msgstr "Данный системный вызов доступен в Linux начиная с версии 2.0."

#. type: SH
#: man-pages/man2/getsid.2:79
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man2/getsid.2:81
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/getsid.2:84
msgid "Linux does not return B<EPERM>."
msgstr "Linux не возвращает B<EPERM>."

#. type: Plain text
#: man-pages/man2/getsid.2:87
msgid "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/getpid.2:25
#, no-wrap
msgid "GETPID"
msgstr "GETPID"

#. type: TH
#: man-pages/man2/getpid.2:25
#, no-wrap
msgid "2008-09-23"
msgstr "2008-09-23"

#. type: Plain text
#: man-pages/man2/getpid.2:28
msgid "getpid, getppid - get process identification"
msgstr "getpid, getppid - получение идентификатора процесса"

#. type: Plain text
#: man-pages/man2/getpid.2:30
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getpid.2:34
msgid "B<pid_t getpid(void);>"
msgstr "B<pid_t getpid(void);>"

#. type: Plain text
#: man-pages/man2/getpid.2:36
msgid "B<pid_t getppid(void);>"
msgstr "B<pid_t getppid(void);>"

#. type: Plain text
#: man-pages/man2/getpid.2:41
msgid ""
"B<getpid>()  returns the process ID of the calling process.  (This is often "
"used by routines that generate unique temporary filenames.)"
msgstr "B<getpid>() возвращает идентификатор вызвавшего процесса. (Часто используется функциями, которые генерируют уникальные имена временных файлов.)"

#. type: Plain text
#: man-pages/man2/getpid.2:44
msgid ""
"B<getppid>()  returns the process ID of the parent of the calling process."
msgstr "B<getppid>() возвращает идентификатор процесса, являющегося родительским по отношению к вызвавшему процессу."

#. type: Plain text
#: man-pages/man2/getpid.2:46
msgid "These functions are always successful."
msgstr "Функции всегда завершаются успешно."

#. type: Plain text
#: man-pages/man2/getpid.2:48
msgid "POSIX.1-2001, 4.3BSD, SVr4."
msgstr "POSIX.1-2001, 4.3BSD, SVr4."

#.  The following program demonstrates this "feature":
#.  #define _GNU_SOURCE
#.  #include <sys/syscall.h>
#.  #include <sys/wait.h>
#.  #include <stdio.h>
#.  #include <stdlib.h>
#.  #include <unistd.h>
#.  int
#.  main(int argc, char *argv[])
#.  {
#.     /* The following statement fills the getpid() cache */
#.     printf("parent PID = %ld
#. ", (long) getpid());
#.     if (syscall(SYS_fork) == 0) {
#.         if (getpid() != syscall(SYS_getpid))
#.             printf("child getpid() mismatch: getpid()=%ld; "
#.                     "syscall(SYS_getpid)=%ld
#. ",
#.                     (long) getpid(), (long) syscall(SYS_getpid));
#.         exit(EXIT_SUCCESS);
#.     }
#.     wait(NULL);
#. }
#. type: Plain text
#: man-pages/man2/getpid.2:100
msgid ""
"Since glibc version 2.3.4, the glibc wrapper function for B<getpid>()  "
"caches PIDs, so as to avoid additional system calls when a process calls "
"B<getpid>()  repeatedly.  Normally this caching is invisible, but its "
"correct operation relies on support in the wrapper functions for B<fork>(2),"
" B<vfork>(2), and B<clone>(2): if an application bypasses the glibc wrappers"
" for these system calls by using B<syscall>(2), then a call to B<getpid>()  "
"in the child will return the wrong value (to be precise: it will return the "
"PID of the parent process).  See also B<clone>(2)  for discussion of a case "
"where B<getpid>()  may return the wrong value even when invoking B<clone>(2)"
"  via the glibc wrapper function."
msgstr "Начиная с glibc версии 2.3.4, обёрточная функция glibc для B<getpid>() кэширует PID, чтобы избежать дополнительных системных вызовов, если процесс постоянно вызывает B<getpid>(). Обычно это кэширование проходит незаметно, но его правильная работа полагается на поддержку обёрточных функций для B<fork>(2), B<vfork>(2) и B<clone>(2): если приложение не использует обёрточные функции glibc для этих системных вызовов и использует вместо них B<syscall>(2), то вызов B<getpid>() в потомке вернёт неправильное значение (точнее, вернёт PID родительского процесса). Смотрите также в B<clone>(2) обсуждение случая, когда B<getpid>() может вернуть неправильное значение даже когда B<clone>(2) вызывается через обёрточную функцию glibc."

#. type: Plain text
#: man-pages/man2/getpid.2:109
msgid ""
"B<clone>(2), B<fork>(2), B<kill>(2), B<exec>(3), B<mkstemp>(3), "
"B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), B<credentials>(7)"
msgstr "B<clone>(2), B<fork>(2), B<kill>(2), B<exec>(3), B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), B<credentials>(7)"

#. type: TH
#: man-pages/man2/getpriority.2:48
#, no-wrap
msgid "GETPRIORITY"
msgstr "GETPRIORITY"

#. type: TH
#: man-pages/man2/getpriority.2:48
#, no-wrap
msgid "2014-05-10"
msgstr "2014-05-10"

#. type: Plain text
#: man-pages/man2/getpriority.2:51
msgid "getpriority, setpriority - get/set program scheduling priority"
msgstr "getpriority, setpriority - получить/установить приоритет планирования программы"

#. type: Plain text
#: man-pages/man2/getpriority.2:53
msgid "B<#include E<lt>sys/time.hE<gt>>"
msgstr "B<#include E<lt>sys/time.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getpriority.2:55
msgid "B<#include E<lt>sys/resource.hE<gt>>"
msgstr "B<#include E<lt>sys/resource.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getpriority.2:57
msgid "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"
msgstr "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"

#. type: Plain text
#: man-pages/man2/getpriority.2:59
msgid "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"
msgstr "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"

#. type: Plain text
#: man-pages/man2/getpriority.2:70
msgid ""
"The scheduling priority of the process, process group, or user, as indicated"
" by I<which> and I<who> is obtained with the B<getpriority>()  call and set "
"with the B<setpriority>()  call."
msgstr "С помощью вызова B<getpriority>() можно получить приоритет планирования (scheduling priority) процесса, группы процессов или пользователя, которые заданы в аргументах I<which> и I<who>, а с помощью вызова B<setpriority>() назначить его."

#. type: Plain text
#: man-pages/man2/getpriority.2:97
msgid ""
"The value I<which> is one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>,"
" and I<who> is interpreted relative to I<which> (a process identifier for "
"B<PRIO_PROCESS>, process group identifier for B<PRIO_PGRP>, and a user ID "
"for B<PRIO_USER>).  A zero value for I<who> denotes (respectively) the "
"calling process, the process group of the calling process, or the real user "
"ID of the calling process.  I<Prio> is a value in the range -20 to 19 (but "
"see the Notes below).  The default priority is 0; lower priorities cause "
"more favorable scheduling."
msgstr "Значением I<which> может быть одно из: B<PRIO_PROCESS>, B<PRIO_PGRP> или B<PRIO_USER>, а значение I<who> рассматривается относительно I<which> (идентификатор процесса, если B<PRIO_PROCESS>; группы процесса, если B<PRIO_PGRP>; идентификатор пользователя, если B<PRIO_USER>). Нулевое значение I<who> означает (соответственно) вызывающий процесс, группу вызывающего процесса или реальный идентификатор пользователя вызывающего процесса. I<Prio> \\(em это значение в диапазоне от -20 до 19 (см. Замечания ниже). По умолчанию приоритет равен 0; более низкие значения соответствуют большему приоритету, который выделяет задаче планировщик."

#. type: Plain text
#: man-pages/man2/getpriority.2:107
msgid ""
"The B<getpriority>()  call returns the highest priority (lowest numerical "
"value)  enjoyed by any of the specified processes.  The B<setpriority>()  "
"call sets the priorities of all of the specified processes to the specified "
"value.  Only the superuser may lower priorities."
msgstr "Вызов B<getpriority>() возвращает наивысший приоритет (наименьшее числовое значение) из приоритетов всех указанных процессов. Вызов B<setpriority>() устанавливает приоритеты всех указанных процессов в заданное значение. Только суперпользователь может устанавливать более низкие значения приоритета."

#. type: Plain text
#: man-pages/man2/getpriority.2:120
msgid ""
"Since B<getpriority>()  can legitimately return the value -1, it is "
"necessary to clear the external variable I<errno> prior to the call, then "
"check it afterward to determine if -1 is an error or a legitimate value.  "
"The B<setpriority>()  call returns 0 if there is no error, or -1 if there "
"is."
msgstr "Так как B<getpriority>() в качестве результата может возвращать -1, то перед вызовом необходимо очищать значение внешней переменной I<errno>, а затем проверять его снова после вызова, чтобы определить, является ли -1 ошибкой или результатом вызова. Вызов B<setpriority>() возвращает 0, если не было ошибок или -1, если произошла ошибка."

#. type: TP
#: man-pages/man2/getpriority.2:121
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man2/getpriority.2:129
msgid ""
"I<which> was not one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>."
msgstr "Значение I<which> не равно B<PRIO_PROCESS>, B<PRIO_PGRP> или B<PRIO_USER>."

#. type: Plain text
#: man-pages/man2/getpriority.2:136
msgid "No process was located using the I<which> and I<who> values specified."
msgstr "Не найдено процессов, которые заданы значениями I<which> и I<who>."

#. type: Plain text
#: man-pages/man2/getpriority.2:140
msgid ""
"In addition to the errors indicated above, B<setpriority>()  may fail if:"
msgstr "В дополнение к вышеуказанным ошибкам, B<setpriority>() может завершиться неудачно:"

#. type: TP
#: man-pages/man2/getpriority.2:140
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/getpriority.2:152
msgid ""
"The caller attempted to lower a process priority, but did not have the "
"required privilege (on Linux: did not have the B<CAP_SYS_NICE> capability)."
"  Since Linux 2.6.12, this error occurs only if the caller attempts to set a"
" process priority outside the range of the B<RLIMIT_NICE> soft resource "
"limit of the target process; see B<getrlimit>(2)  for details."
msgstr "Вызывающий пытается понизить приоритет процесса, но он не имеет на это прав (в Linux: не имеет мандата B<CAP_SYS_NICE>). Начиная с Linux 2.6.12, эта ошибка возникает только, если вызывающий пытается задать приоритет процесса вне границ диапазона мягкого ограничения ресурса процесса назначения B<RLIMIT_NICE>; подробности смотрите в B<getrlimit>(2)."

#. type: Plain text
#: man-pages/man2/getpriority.2:160
msgid ""
"A process was located, but its effective user ID did not match either the "
"effective or the real user ID of the caller, and was not privileged (on "
"Linux: did not have the B<CAP_SYS_NICE> capability).  But see NOTES below."
msgstr "Процесс был найден, но эффективному идентификатору пользователя этого процесса не соответствует заданный в вызове эффективный (или реальный) идентификатор вызывающего и  у вызывающего нет прав (в Linux: не имеет мандата B<CAP_SYS_NICE>). Смотрите ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man2/getpriority.2:163
msgid ""
"SVr4, 4.4BSD (these function calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr "SVr4, 4.4BSD (эти вызовы впервые появились в 4.2BSD), POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/getpriority.2:169
msgid ""
"A child created by B<fork>(2)  inherits its parent's nice value.  The nice "
"value is preserved across B<execve>(2)."
msgstr "Потомок, созданный с помощью B<fork>(2), наследует значение nice родителя. При вызове B<execve>(2)  значение nice сохраняется."

#. type: Plain text
#: man-pages/man2/getpriority.2:180
msgid ""
"The degree to which their relative nice value affects the scheduling of "
"processes varies across UNIX systems, and, on Linux, across kernel versions."
"  Starting with kernel 2.6.23, Linux adopted an algorithm that causes "
"relative differences in nice values to have a much stronger effect.  This "
"causes very low nice values (+19) to truly provide little CPU to a process "
"whenever there is any other higher priority load on the system, and makes "
"high nice values (-20) deliver most of the CPU to applications that require "
"it (e.g., some audio applications)."
msgstr "Величина, с которой относительное значение nice влияет на планирование процессов, в различных системах UNIX и версиях ядер Linux различна. Начиная с ядра 2.6.23, в Linux принят алгоритм, который учитывает относительную разницу между значениями nice, что оказывает большее влияние при изменении. Его работа приводит к тому, что при очень низких значениях nice (+19) процессу действительно выделяется совсем мало времени ЦП, в то время как при любом другом большем значении приоритета система загружается сильнее и при самом высоком значении nice (-20) приложениям отдаётся большая часть времени ЦП (например, некоторым программам работы со звуком)."

#. type: Plain text
#: man-pages/man2/getpriority.2:195
msgid ""
"The details on the condition for B<EPERM> depend on the system.  The above "
"description is what POSIX.1-2001 says, and seems to be followed on all "
"System\\ V-like systems.  Linux kernels before 2.6.12 required the real or "
"effective user ID of the caller to match the real user of the process I<who>"
" (instead of its effective user ID).  Linux 2.6.12 and later require the "
"effective user ID of the caller to match the real or effective user ID of "
"the process I<who>.  All BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, "
"FreeBSD 4.3, OpenBSD-2.5, ...) behave in the same manner as Linux 2.6.12 and"
" later."
msgstr "Детали условия возникновения ошибки B<EPERM> зависят от системы. Описание, приведённое выше, соответствует POSIX.1-2001, и, кажется, ему удовлетворяют все System\\ V-подобные системы. Ядра Linux до версии 2.6.12 требуют, чтобы эффективный идентификатор пользователя вызывающего совпадал с реальным идентификатором пользователя процесса I<who> (вместо его эффективного идентификатора пользователя). В Linux 2.6.12 и новее требуется, чтобы эффективный идентификатор пользователя вызывающего совпадал с реальным или эффективным идентификатором пользователя процесса I<who>. Все системы BSD (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, FreeBSD 4.3, OpenBSD-2.5, …) действуют также как Linux 2.6.12 и новее."

#. type: Plain text
#: man-pages/man2/getpriority.2:211
msgid ""
"The actual priority range varies between kernel versions.  Linux before "
"1.3.36 had -infinity..15.  Since kernel 1.3.43, Linux has the range -20..19."
"  Within the kernel, nice values are actually represented using the "
"corresponding range 40..1 (since negative numbers are error codes) and these"
" are the values employed by the B<setpriority>()  and B<getpriority>()  "
"system calls.  The glibc wrapper functions for these system calls handle the"
" translations between the user-land and kernel representations of the nice "
"value according to the formula I<unice\\ =\\ 20\\ -\\ knice>."
msgstr "Фактический диапазон значений приоритета варьируется в зависимости от версий ядра. Linux до 1.3.36 имел диапазон значений -infinity..15. Linux, начиная с 1.3.43, имеет диапазон значений -20..19. Внутри ядра значения nice на самом деле представлены как диапазон 40..1 (так как отрицательными числами задаются коды ошибок) и эти значения возвращаются системными вызовами B<setpriority>() и B<getpriority>(). Обёрточные функции glibc для этих системных вызовов преобразуют значение между пользовательским и ядерным диапазонами по формуле I<unice\\ =\\ 20\\ -\\ knice>."

#. type: Plain text
#: man-pages/man2/getpriority.2:213
msgid "On some systems, the range of nice values is -20..20."
msgstr "В некоторых системах используется диапазон значений nice от -20 до 20."

#. type: Plain text
#: man-pages/man2/getpriority.2:225
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr "Включать I<E<lt>sys/time.hE<gt>> в настоящее время не требуется, но это увеличивает переносимость. (Безусловно, в I<E<lt>sys/resource.hE<gt>> определена структура I<rusage> с полями типа I<struct timeval>, которая определена в I<E<lt>sys/time.hE<gt>>.)"

#. type: SH
#: man-pages/man2/getpriority.2:225
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man2/getpriority.2:232
msgid ""
"According to POSIX, the nice value is a per-process setting.  However, under"
" the current Linux/NPTL implementation of POSIX threads, the nice value is a"
" per-thread attribute: different threads in the same process can have "
"different nice values.  Portable applications should avoid relying on the "
"Linux behavior, which may be made standards conformant in the future."
msgstr "Согласно POSIX, значение nice — свойство процесса. Однако в текущей реализации Linux/NPTL нитей POSIX значение nice — атрибут нити: различные нити в одном процессе могут иметь разные значения nice. Переносимые приложения не должны полагаться на поведение Linux, которое может стать стандартом в будущем."

#. type: Plain text
#: man-pages/man2/getpriority.2:238
msgid "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"
msgstr "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"

#. type: Plain text
#: man-pages/man2/getpriority.2:240
msgid ""
"I<Documentation/scheduler/sched-nice-design.txt> in the Linux kernel source "
"tree (since Linux 2.6.23)"
msgstr "Файл I<Documentation/scheduler/sched-nice-design.txt> из дерева исходного кода ядра Linux (начиная с Linux 2.6.23)"

#. type: TH
#: man-pages/man2/getpeername.2:42
#, no-wrap
msgid "GETPEERNAME"
msgstr "GETPEERNAME"

#. type: TH
#: man-pages/man2/getpeername.2:42
#, no-wrap
msgid "2013-02-12"
msgstr "2013-02-12"

#. type: Plain text
#: man-pages/man2/getpeername.2:45
msgid "getpeername - get name of connected peer socket"
msgstr "getpeername - получает имя подключившегося сокета"

#. type: Plain text
#: man-pages/man2/getpeername.2:47
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getpeername.2:50
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr "B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>"

#. type: Plain text
#: man-pages/man2/getpeername.2:63
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by I<addr>."
"  On return it contains the actual size of the name returned (in bytes).  "
"The name is truncated if the buffer provided is too small."
msgstr "B<getpeername>() возвращает адрес машины, подключившейся к сокету I<sockfd>, в буфер, указанный I<addr>. В параметре I<addrlen> должно быть указано, сколько места выделено, на которое указывает I<addr>. По возвращении он содержит реальный размер памяти, занимаемый возвращаемым именем (в байтах). Имя обрезается, если буфер окажется слишком мал."

#. type: Plain text
#: man-pages/man2/getpeername.2:68
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr "Возвращаемый адрес урежется, если предоставленный буфер окажется слишком маленьким; в этом случае в I<addrlen> будет возвращено значение большее чем было в вызове."

#. type: Plain text
#: man-pages/man2/getpeername.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/getpeername.2:74
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/getpeername.2:79
msgid "The argument I<sockfd> is not a valid descriptor."
msgstr "Аргумент I<sockfd> не является допустимым дескриптором."

#. type: TP
#: man-pages/man2/getpeername.2:79
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/getpeername.2:85
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr "Аргумент I<addr> указывает на память в недопустимой части адресуемого пространства процесса."

#. type: Plain text
#: man-pages/man2/getpeername.2:89
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr "Неправильное значение аргумента I<addrlen> (например, отрицательное)."

#. type: TP
#: man-pages/man2/getpeername.2:89
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: man-pages/man2/getpeername.2:93
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr "Недостаточно ресурсов в системе для выполнения операции."

#. type: TP
#: man-pages/man2/getpeername.2:93
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man2/getpeername.2:96
msgid "The socket is not connected."
msgstr "Сокет не подключён."

#. type: TP
#: man-pages/man2/getpeername.2:96
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man2/getpeername.2:101
msgid "The argument I<sockfd> is a file, not a socket."
msgstr "Аргумент I<sockfd> является файлом, а не сокетом."

#. type: Plain text
#: man-pages/man2/getpeername.2:105
msgid ""
"SVr4, 4.4BSD (the B<getpeername>()  function call first appeared in 4.2BSD),"
" POSIX.1-2001."
msgstr "SVr4, 4.4BSD (функциональный вызов B<getpeername>() впервые появился в 4.2BSD), POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/getpeername.2:116
msgid ""
"The third argument of B<getpeername>()  is in reality an I<int\\ *> (and "
"this is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion "
"resulted in the present I<socklen_t>, also used by glibc.  See also "
"B<accept>(2)."
msgstr "Третий аргумент функции B<getpeername>() в действительности имеет тип I<int\\ *> (это именно так в 4.x BSD, libc4 и libc5). Определённое недопонимание привело к тому, что в стандарте POSIX появился тип I<socklen_t> также используемый в glibc. Смотрите также B<accept>(2)."

#. type: Plain text
#: man-pages/man2/getpeername.2:143
msgid ""
"For stream sockets, once a B<connect>(2)  has been performed, either socket "
"can call B<getpeername>()  to obtain the address of the peer socket.  On the"
" other hand, datagram sockets are connectionless.  Calling B<connect>(2)  on"
" a datagram socket merely sets the peer address for outgoing datagrams sent "
"with B<write>(2)  or B<recv>(2).  The caller of B<connect>(2)  can use "
"B<getpeername>()  to obtain the peer address that it earlier set for the "
"socket.  However, the peer socket is unaware of this information, and "
"calling B<getpeername>()  on the peer socket will return no useful "
"information (unless a B<connect>(2)  call was also executed on the peer).  "
"Note also that the receiver of a datagram can obtain the address of the "
"sender when using B<recvfrom>(2)."
msgstr "Для потоковых сокетов после выполнения B<connect>(2) любой сокет может вызвать B<getpeername>() для получения адреса соседа (peer). С другой стороны, дейтаграмные сокеты не устанавливают соединения. Вызов B<connect>(2) для дейтаграмного сокета просто задаст адрес соседа в исходящих дейтаграммах, посылаемых с помощью B<write>(2) или B<recv>(2). Вызывающий B<connect>(2) может использовать B<getpeername>() для получения адреса соседа., который был установлен у сокета ранее. Однако, сокет соседа не знает про это и  вызов B<getpeername>() для сокета соседа не вернёт полезной информации (если сосед также не вызвал B<connect>(2)). Заметим, что получатель дейтаграммы может получить адрес отправителя, если использует B<recvfrom>(2)."

#. type: Plain text
#: man-pages/man2/getpeername.2:149
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr "B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/getgid.2:25
#, no-wrap
msgid "GETGID"
msgstr "GETGID"

#. type: TH
#: man-pages/man2/getgid.2:25
#, no-wrap
msgid "2010-11-22"
msgstr "2010-11-22"

#. type: Plain text
#: man-pages/man2/getgid.2:28
msgid "getgid, getegid - get group identity"
msgstr "getgid, getegid - получить идентификатор группы процесса"

#. type: Plain text
#: man-pages/man2/getgid.2:34
msgid "B<gid_t getgid(void);>"
msgstr "B<gid_t getgid(void);>"

#. type: Plain text
#: man-pages/man2/getgid.2:36
msgid "B<gid_t getegid(void);>"
msgstr "B<gid_t getegid(void);>"

#. type: Plain text
#: man-pages/man2/getgid.2:39
msgid "B<getgid>()  returns the real group ID of the calling process."
msgstr "B<getgid>() возвращает действительный идентификатор группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getgid.2:42
msgid "B<getegid>()  returns the effective group ID of the calling process."
msgstr "B<getegid>() возвращает эффективный идентификатор группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getgid.2:46
msgid "POSIX.1-2001, 4.3BSD."
msgstr "POSIX.1-2001, 4.3BSD."

#. type: Plain text
#: man-pages/man2/getgid.2:62
msgid ""
"The original Linux B<getgid>()  and B<getegid>()  system calls supported "
"only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
"B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and "
"B<getegid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr "Первоначальные версии системных вызовов B<getgid>() и B<getegid>() в Linux поддерживали только 16-битные идентификаторы групп. Позднее в Linux 2.4 были добавлены вызовы B<getgid32>() и B<getegid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<getgid>() и B<getegid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getgid.2:66
msgid "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"
msgstr "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/getdents.2:30
#, no-wrap
msgid "GETDENTS"
msgstr "GETDENTS"

#. type: TH
#: man-pages/man2/getdents.2:30
#, no-wrap
msgid "2012-08-03"
msgstr "2012-08-03"

#. type: Plain text
#: man-pages/man2/getdents.2:33
msgid "getdents - get directory entries"
msgstr "getdents - получить записи каталога"

#. type: Plain text
#: man-pages/man2/getdents.2:37
#, no-wrap
msgid ""
"B<int getdents(unsigned int >I<fd>B<, struct linux_dirent *>I<dirp>B<,>\n"
"B<             unsigned int >I<count>B<);>\n"
msgstr "B<int getdents(unsigned int >I<fd>B<, struct linux_dirent *>I<dirp>B<,>\nB<             unsigned int >I<count>B<);>\n"

#. type: Plain text
#: man-pages/man2/getdents.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr "I<Замечание>:В glibc нет обёрточной функции для данного системного вызова; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/getdents.2:47
msgid ""
"This is not the function you are interested in.  Look at B<readdir>(3)  for "
"the POSIX conforming C library interface.  This page documents the bare "
"kernel system call interface."
msgstr "Эта не та функция, которая должна представлять для вас интерес. Смотрите описание функции B<readdir>(3), которая является интерфейсом библиотеки языка C, соответствующим стандарту POSIX. В этой странице описан минимальный интерфейс системного вызова ядра."

#. type: Plain text
#: man-pages/man2/getdents.2:60
msgid ""
"The system call B<getdents>()  reads several I<linux_dirent> structures from"
" the directory referred to by the open file descriptor I<fd> into the buffer"
" pointed to by I<dirp>.  The argument I<count> specifies the size of that "
"buffer."
msgstr "Системный вызов B<getdents>() читает несколько структур I<linux_dirent> из каталога, на который указывает открытый файловый дескриптор I<fd>, в буфер, указанный в I<dirp>. В аргументе I<count> задаётся размер этого буфера."

#. type: Plain text
#: man-pages/man2/getdents.2:64
msgid "The I<linux_dirent> structure is declared as follows:"
msgstr "Структура I<linux_dirent> определена следующим образом:"

#. type: Plain text
#: man-pages/man2/getdents.2:79
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    unsigned long  d_ino;     /* Inode number */\n"
"    unsigned long  d_off;     /* Offset to next I<linux_dirent> */\n"
"    unsigned short d_reclen;  /* Length of this I<linux_dirent> */\n"
"    char           d_name[];  /* Filename (null-terminated) */\n"
"                      /* length is actually (d_reclen - 2 -\n"
"                         offsetof(struct linux_dirent, d_name)) */\n"
"    /*\n"
"    char           pad;       // Zero padding byte\n"
"    char           d_type;    // File type (only since Linux\n"
"                              // 2.6.4); offset is (d_reclen - 1)\n"
"    */\n"
msgstr "struct linux_dirent {\n    unsigned long  d_ino;     /* номер inode */\n    unsigned long  d_off;     /* смещение до следующей I<linux_dirent> */\n    unsigned short d_reclen;  /* длина данной I<linux_dirent> */\n    char           d_name[];  /* имя файла (завершается null) */\n                              /* реальная длина (d_reclen - 2 -\n                                 offsetof(struct linux_dirent, d_name) */\n    /*\n    char           pad;       // нулевой байт заполнения\n    char           d_type;    // тип файла (начиная с Linux\n                              // 2.6.4; смещение (d_reclen - 1)\n    */\n"

#. type: Plain text
#: man-pages/man2/getdents.2:81
#, no-wrap
msgid "}\n"
msgstr "}\n"

#. type: Plain text
#: man-pages/man2/getdents.2:94
msgid ""
"I<d_ino> is an inode number.  I<d_off> is the distance from the start of the"
" directory to the start of the next I<linux_dirent>.  I<d_reclen> is the "
"size of this entire I<linux_dirent>.  I<d_name> is a null-terminated "
"filename."
msgstr "В I<d_ino> указан номер inode. В I<d_off> задаётся расстояние от начала каталога до начала следующей I<linux_dirent>. В I<d_reclen> указывается размер данного I<linux_dirent> целиком. В I<d_name> задаётся имя файла, завершающееся null."

#. type: Plain text
#: man-pages/man2/getdents.2:99
msgid ""
"I<d_type> is a byte at the end of the structure that indicates the file "
"type.  It contains one of the following values (defined in "
"I<E<lt>dirent.hE<gt>>):"
msgstr "I<d_type> \\(em байт в конце структуры, которым определяется тип файла. В нём содержится одно из следующих значений (определённых в I<E<lt>dirent.hE<gt>>):"

#. type: TP
#: man-pages/man2/getdents.2:99
#, no-wrap
msgid "B<DT_BLK>"
msgstr "B<DT_BLK>"

#. type: Plain text
#: man-pages/man2/getdents.2:102
msgid "This is a block device."
msgstr "Блочное устройство."

#. type: TP
#: man-pages/man2/getdents.2:102
#, no-wrap
msgid "B<DT_CHR>"
msgstr "B<DT_CHR>"

#. type: Plain text
#: man-pages/man2/getdents.2:105
msgid "This is a character device."
msgstr "Символьное устройство."

#. type: TP
#: man-pages/man2/getdents.2:105
#, no-wrap
msgid "B<DT_DIR>"
msgstr "B<DT_DIR>"

#. type: Plain text
#: man-pages/man2/getdents.2:108
msgid "This is a directory."
msgstr "Каталог."

#. type: TP
#: man-pages/man2/getdents.2:108
#, no-wrap
msgid "B<DT_FIFO>"
msgstr "B<DT_FIFO>"

#. type: Plain text
#: man-pages/man2/getdents.2:111
msgid "This is a named pipe (FIFO)."
msgstr "Именованный канал (FIFO)."

#. type: TP
#: man-pages/man2/getdents.2:111
#, no-wrap
msgid "B<DT_LNK>"
msgstr "B<DT_LNK>"

#. type: Plain text
#: man-pages/man2/getdents.2:114
msgid "This is a symbolic link."
msgstr "Символическая ссылка."

#. type: TP
#: man-pages/man2/getdents.2:114
#, no-wrap
msgid "B<DT_REG>"
msgstr "B<DT_REG>"

#. type: Plain text
#: man-pages/man2/getdents.2:117
msgid "This is a regular file."
msgstr "Обычный файл."

#. type: TP
#: man-pages/man2/getdents.2:117
#, no-wrap
msgid "B<DT_SOCK>"
msgstr "B<DT_SOCK>"

#. type: Plain text
#: man-pages/man2/getdents.2:120
msgid "This is a UNIX domain socket."
msgstr "Доменный сокет UNIX."

#. type: TP
#: man-pages/man2/getdents.2:120
#, no-wrap
msgid "B<DT_UNKNOWN>"
msgstr "B<DT_UNKNOWN>"

#. type: Plain text
#: man-pages/man2/getdents.2:123
msgid "The file type is unknown."
msgstr "Неизвестный тип."

#. type: Plain text
#: man-pages/man2/getdents.2:133
msgid ""
"The I<d_type> field is implemented since Linux 2.6.4.  It occupies a space "
"that was previously a zero-filled padding byte in the I<linux_dirent> "
"structure.  Thus, on kernels before 2.6.3, attempting to access this field "
"always provides the value 0 (B<DT_UNKNOWN>)."
msgstr "Поле I<d_type> появилось начиная с Linux 2.6.4. Оно занимает пространство, которое раньше в структуре I<linux_dirent> было отведено для заполняющего байта с нулевым значением. Поэтому при работе с ядрами до версии 2.6.3, при чтении значения этого поля всегда возвращается 0 (B<DT_UNKNOWN>)."

#.  kernel 2.6.27
#.  The same sentence is in readdir.2
#. type: Plain text
#: man-pages/man2/getdents.2:142
msgid ""
"Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4)  "
"have full support for returning the file type in I<d_type>.  All "
"applications must properly handle a return of B<DT_UNKNOWN>."
msgstr "В настоящее время, только файловые системы (среди которых: Btrfs, ext2, ext3 и ext4) поддерживают возврат типа файла в I<d_type>. Все приложения должны правильно обрабатывать возвращаемое значение B<DT_UNKNOWN>."

#. type: Plain text
#: man-pages/man2/getdents.2:148
msgid ""
"On success, the number of bytes read is returned.  On end of directory, 0 is"
" returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При нормальном завершении работы возвращается количество прочитанных байт. При достижении конца каталога возвращается 0. В случае ошибки возвращается -1 и значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/getdents.2:153
msgid "Invalid file descriptor I<fd>."
msgstr "Неверный файловый дескриптор I<fd>."

#. type: Plain text
#: man-pages/man2/getdents.2:156
msgid "Argument points outside the calling process's address space."
msgstr "Аргумент указывает за пределы адресного пространства вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getdents.2:159
msgid "Result buffer is too small."
msgstr "Буфер результата слишком мал."

#. type: TP
#: man-pages/man2/getdents.2:159
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/getdents.2:162
msgid "No such directory."
msgstr "Заданный каталог не существует."

#. type: TP
#: man-pages/man2/getdents.2:162
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/getdents.2:165
msgid "File descriptor does not refer to a directory."
msgstr "Файловый дескриптор указывает не на каталог."

#.  SVr4 documents additional ENOLINK, EIO error conditions.
#. type: Plain text
#: man-pages/man2/getdents.2:168
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man2/getdents.2:177
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  You will need to define the I<linux_dirent> structure "
"yourself.  However, you probably want to use B<readdir>(3)  instead."
msgstr "В glibc нет обёртки для данного системного вызова; запускайте его с помощью B<syscall>(2). Структуру I<linux_dirent> нужно определить самостоятельно. Однако лучше использовать B<readdir>(3)."

#. type: Plain text
#: man-pages/man2/getdents.2:180
msgid "This call supersedes B<readdir>(2)."
msgstr "Этот вызов заменяет B<readdir>(2)."

#. type: Plain text
#: man-pages/man2/getdents.2:193
msgid ""
"The original Linux B<getdents>()  system call did not handle large "
"filesystems and large file offsets.  Consequently, Linux 2.4 added "
"B<getdents64>(), with wider types for the I<d_ino> and I<d_off> fields "
"employed in the I<linux_dirent> structure."
msgstr "Первоначальный системный вызов B<getdents>() в Linux не умел работать с большими файловыми системами и файловыми смещениями. Позднее, в Linux 2.4 был добавлен вызов B<getdents64>() с расширенными типами для полей I<d_ino> и I<d_off> структуры I<linux_dirent>."

#. type: SH
#: man-pages/man2/getdents.2:193
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#.  FIXME: This program uses the older getdents() system call
#.  and the structure with smaller field widths.
#. type: Plain text
#: man-pages/man2/getdents.2:200
msgid ""
"The program below demonstrates the use of B<getdents>().  The following "
"output shows an example of what we see when running this program on an ext2 "
"directory:"
msgstr "В программе, показанной далее, демонстрируется использование B<getdents>(). В следующем выводе показан пример запуска этой программы с каталогом с ext2:"

#. type: Plain text
#: man-pages/man2/getdents.2:213
#, no-wrap
msgid ""
"$B< ./a.out /testfs/>\n"
"--------------- nread=120 ---------------\n"
"i-node#  file type  d_reclen  d_off   d_name\n"
"       2  directory    16         12  .\n"
"       2  directory    16         24  ..\n"
"      11  directory    24         44  lost+found\n"
"      12  regular      16         56  a\n"
"  228929  directory    16         68  sub\n"
"   16353  directory    16         80  sub2\n"
"  130817  directory    16       4096  sub3\n"
msgstr "$B< ./a.out /testfs/>\n--------------- nread=120 ---------------\ni-node#  file type  d_reclen  d_off   d_name\n       2  directory    16         12  .\n       2  directory    16         24  ..\n      11  directory    24         44  lost+found\n      12  regular      16         56  a\n  228929  directory    16         68  sub\n   16353  directory    16         80  sub2\n  130817  directory    16       4096  sub3\n"

#. type: SS
#: man-pages/man2/getdents.2:215
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/getdents.2:226
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>dirent.hE<gt>     /* Defines DT_* constants */\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>dirent.hE<gt>     /* Определяет константы DT_* */\n#include E<lt>fcntl.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>sys/stat.hE<gt>\n#include E<lt>sys/syscall.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/getdents.2:229
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr "#define handle_error(msg) \\e\n        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man2/getdents.2:236
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    long           d_ino;\n"
"    off_t          d_off;\n"
"    unsigned short d_reclen;\n"
"    char           d_name[];\n"
"};\n"
msgstr "struct linux_dirent {\n    long           d_ino;\n    off_t          d_off;\n    unsigned short d_reclen;\n    char           d_name[];\n};\n"

#. type: Plain text
#: man-pages/man2/getdents.2:238
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: man-pages/man2/getdents.2:247
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd, nread;\n"
"    char buf[BUF_SIZE];\n"
"    struct linux_dirent *d;\n"
"    int bpos;\n"
"    char d_type;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int fd, nread;\n    char buf[BUF_SIZE];\n    struct linux_dirent *d;\n    int bpos;\n    char d_type;\n"

#. type: Plain text
#: man-pages/man2/getdents.2:251
#, no-wrap
msgid ""
"    fd = open(argc E<gt> 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr "    fd = open(argc E<gt> 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);\n    if (fd == -1)\n        handle_error(\"open\");\n"

#. type: Plain text
#: man-pages/man2/getdents.2:256
#, no-wrap
msgid ""
"    for ( ; ; ) {\n"
"        nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);\n"
"        if (nread == -1)\n"
"            handle_error(\"getdents\");\n"
msgstr "    for ( ; ; ) {\n        nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);\n        if (nread == -1)\n            handle_error(\"getdents\");\n"

#. type: Plain text
#: man-pages/man2/getdents.2:259
#, no-wrap
msgid ""
"        if (nread == 0)\n"
"            break;\n"
msgstr "        if (nread == 0)\n            break;\n"

#. type: Plain text
#: man-pages/man2/getdents.2:278
#, no-wrap
msgid ""
"        printf(\"--------------- nread=%d ---------------\\en\", nread);\n"
"        printf(\"i-node#  file type  d_reclen  d_off   d_name\\en\");\n"
"        for (bpos = 0; bpos E<lt> nread;) {\n"
"            d = (struct linux_dirent *) (buf + bpos);\n"
"            printf(\"%8ld  \", d-E<gt>d_ino);\n"
"            d_type = *(buf + bpos + d-E<gt>d_reclen - 1);\n"
"            printf(\"%-10s \", (d_type == DT_REG) ?  \"regular\" :\n"
"                             (d_type == DT_DIR) ?  \"directory\" :\n"
"                             (d_type == DT_FIFO) ? \"FIFO\" :\n"
"                             (d_type == DT_SOCK) ? \"socket\" :\n"
"                             (d_type == DT_LNK) ?  \"symlink\" :\n"
"                             (d_type == DT_BLK) ?  \"block dev\" :\n"
"                             (d_type == DT_CHR) ?  \"char dev\" : \"???\");\n"
"            printf(\"%4d %10lld  %s\\en\", d-E<gt>d_reclen,\n"
"                    (long long) d-E<gt>d_off, d-E<gt>d_name);\n"
"            bpos += d-E<gt>d_reclen;\n"
"        }\n"
"    }\n"
msgstr "        printf(\"--------------- nread=%d ---------------\\en\", nread);\n        printf(\"i-node#  file type  d_reclen  d_off   d_name\\en\");\n        for (bpos = 0; bpos E<lt> nread;) {\n            d = (struct linux_dirent *) (buf + bpos);\n            printf(\"%8ld  \", d-E<gt>d_ino);\n            d_type = *(buf + bpos + d-E<gt>d_reclen - 1);\n            printf(\"%-10s \", (d_type == DT_REG) ?  \"regular\" :\n                             (d_type == DT_DIR) ?  \"directory\" :\n                             (d_type == DT_FIFO) ? \"FIFO\" :\n                             (d_type == DT_SOCK) ? \"socket\" :\n                             (d_type == DT_LNK) ?  \"symlink\" :\n                             (d_type == DT_BLK) ?  \"block dev\" :\n                             (d_type == DT_CHR) ?  \"char dev\" : \"???\");\n            printf(\"%4d %10lld  %s\\en\", d-E<gt>d_reclen,\n                    (long long) d-E<gt>d_off, d-E<gt>d_name);\n            bpos += d-E<gt>d_reclen;\n        }\n    }\n"

#. type: Plain text
#: man-pages/man2/getdents.2:281
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/getdents.2:284
msgid "B<readdir>(2), B<readdir>(3)"
msgstr "B<readdir>(2), B<readdir>(3)"

#. type: TH
#: man-pages/man2/getsockopt.2:44
#, no-wrap
msgid "GETSOCKOPT"
msgstr "GETSOCKOPT"

#. type: TH
#: man-pages/man2/getsockopt.2:44
#, no-wrap
msgid "2014-04-28"
msgstr "2014-04-28"

#. type: Plain text
#: man-pages/man2/getsockopt.2:47
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr "getsockopt, setsockopt - получить или установить флаги сокета"

#. type: Plain text
#: man-pages/man2/getsockopt.2:50
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>          /* Смотрите ЗАМЕЧАНИЯ */\n"

#. type: Plain text
#: man-pages/man2/getsockopt.2:52
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getsockopt.2:57
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr "B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\nB<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\nB<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\nB<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/getsockopt.2:67
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple"
" protocol levels; they are always present at the uppermost socket level."
msgstr "B<getsockopt>() и B<setsockopt>() управляют параметрами сокета, на который указывает файловый дескриптор I<sockfd>. Параметры могут быть из различных уровней протоколов; они всегда присутствуют на самом верхнем уровне сокета."

#. type: Plain text
#: man-pages/man2/getsockopt.2:86
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option"
" is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr "При работе с параметрами сокета должен быть указан уровень, на котором находится этот параметр и его имя. Для работы с параметрами на уровне API сокета в I<level> указывается значение B<SOL_SOCKET>. Для работы с параметрами на любом другом уровне, этим вызовам передаётся номер соответствующего протокола, который они контролируют. Например, для указания, что параметр должен интерпретироваться протоколом B<TCP>, в I<level> нужно указать номер протокола B<TCP>; смотрите B<getprotoent>(3)."

#. type: Plain text
#: man-pages/man2/getsockopt.2:108
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr "Аргументы I<optval> и I<optlen> используются в B<setsockopt>() для доступа к значениям параметров. Для B<getsockopt>() они задают буфер, в который нужно поместить запрошенное значение параметра при возврате. У B<getsockopt>() в аргументе I<optlen> изначально содержится размер буфера, на который указывает I<optval>, а при завершении в нём содержится реальный размер возвращаемого значения. Если значение параметра не указывается или возвращается, то I<optval> может быть NULL."

#. type: Plain text
#: man-pages/man2/getsockopt.2:118
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file "
"I<E<lt>sys/socket.hE<gt>> contains definitions for socket level options, "
"described below.  Options at other protocol levels vary in format and name; "
"consult the appropriate entries in section 4 of the manual."
msgstr "Аргумент I<optname> и все указанные параметры без изменений передаются для интерпретации соответствующему модулю протоколов. Файл I<E<lt>sys/socket.hE<gt>> содержит определения параметров уровня сокета; их описание дано ниже. Параметры на других уровнях протоколов различаются по формату и по имени. Обращайтесь к соответствующим файлам раздела 4 справочных страниц."

#. type: Plain text
#: man-pages/man2/getsockopt.2:127
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr "Большинство параметров уровня сокета используют тип I<int> для аргумента I<optval>. Чтобы установить параметр логического типа аргумент B<setsockopt>() должен быть ненулевым, и ноль, если нужно отключить этот параметр."

#. type: Plain text
#: man-pages/man2/getsockopt.2:131
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr "Описание доступных параметров сокетов находится в B<socket>(7) и соответствующих протоколам справочных страницах."

#. type: Plain text
#: man-pages/man2/getsockopt.2:152
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr "Адрес, на который указывает I<optval>, не находится в разрешённой части адресного пространства процесса. Для B<getsockopt>() эта ошибка может также появиться, если I<optlen> выходит за пределы адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/getsockopt.2:163
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr "Неправильное значение I<optlen> в B<setsockopt>(). В некоторых случаях эта ошибка может возникать из-за неправильного значения в I<optval> (например, для параметра B<IP_ADD_MEMBERSHIP>, описанного в B<ip>(7))."

#. type: TP
#: man-pages/man2/getsockopt.2:163
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr "B<ENOPROTOOPT>"

#. type: Plain text
#: man-pages/man2/getsockopt.2:166
msgid "The option is unknown at the level indicated."
msgstr "Неизвестный параметр для указанного уровня."

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: man-pages/man2/getsockopt.2:178
msgid ""
"SVr4, 4.4BSD (these system calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr "SVr4, 4.4BSD (данные системные вызовы впервые появились в 4.2BSD), POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/getsockopt.2:184
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and"
" this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr "В POSIX.1-2001 не требуется включение I<E<lt>sys/types.hE<gt>>, и этот заголовочный файл не требуется в Linux. Однако, некоторые старые (BSD) реализации требуют данный файл, и в переносимых приложениях для предосторожности, вероятно, он будет включён."

#. type: Plain text
#: man-pages/man2/getsockopt.2:199
msgid ""
"The I<optlen> argument of B<getsockopt>()  and B<setsockopt>()  is in "
"reality an I<int [*]> (and this is what 4.x BSD and libc4 and libc5 have).  "
"Some POSIX confusion resulted in the present I<socklen_t>, also used by "
"glibc.  See also B<accept>(2)."
msgstr "Аргумент I<optlen> в B<getsockopt>() и B<setsockopt>() в действительности имеет тип I<int [*]> (это именно так в 4.x BSD, libc4 и libc5). При разработке стандарта POSIX случилось некоторое недопонимание и появился тип I<socklen_t>, также используемый в glibc. Смотрите также B<accept>(2)."

#. type: Plain text
#: man-pages/man2/getsockopt.2:202
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr "Некоторые параметры сокетов должны обрабатываться на более низких уровнях системы."

#. type: Plain text
#: man-pages/man2/getsockopt.2:212
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), "
"B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr "B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr "GETCPU"

#. type: TH
#: man-pages/man2/getcpu.2:12
#, no-wrap
msgid "2013-04-03"
msgstr "2013-04-03"

#. type: Plain text
#: man-pages/man2/getcpu.2:15
msgid ""
"getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr "getcpu - определяет ЦП и узел NUMA, на котором выполняется вызывающая нить"

#. type: Plain text
#: man-pages/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr "B<#include E<lt>linux/getcpu.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getcpu.2:21
#, no-wrap
msgid ""
"B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache "
"*>I<tcache>B<);>\n"
msgstr "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"

#. type: Plain text
#: man-pages/man2/getcpu.2:42
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a"
" unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr "Системный вызов B<getcpu>() определяет процессор и узел, на котором вызывающая нить или процесс выполняются в данный момент и записывает их в виде целых чисел в память, на которую указывают аргументы I<cpu> и I<node>. Процессор представляется в виде уникального малого целого числа, закреплённого за определённым ЦП. Узел представляется в виде уникального идентификатора, закреплённого за определённым узлом NUMA. Если значение I<cpu> или I<node> равно NULL, то по соответствующему указателю ничего не записывается."

#. type: Plain text
#: man-pages/man2/getcpu.2:46
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr "Третий аргумент этого системного вызова в настоящее время не используется и указываться как NULL, не требуется переносимость на Linux 2.6.23 или более младшие версии (смотрите ЗАМЕЧАНИЯ)."

#. type: Plain text
#: man-pages/man2/getcpu.2:61
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr "Информация, помещаемая в I<cpu>, будет находиться там только на время вызова: unless the CPU affinity has been fixed using B<sched_setaffinity>(2), the kernel might change the CPU at any time.  (Normally this does not happen because the scheduler tries to minimize movements between CPUs to keep caches hot, but it is possible.) Достоверность информации, помещаемой в I<cpu>, гарантируется только на момент  вызова: если привязка ЦП не была изменена с помощью B<sched_setaffinity>(2), то ядро может сменить ЦП в любой момент (обычно этого не происходит, так как планировщик пытается минимизировать перемещения задач между процессорами для поддержания актуальности кэша,но всё же это возможно). Вызывающий должен быть готов к ситуации, что информация, возвращённая в I<cpu> и I<node>, может потерять актуальность уже после возврата из вызова."

#. type: Plain text
#: man-pages/man2/getcpu.2:66
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getcpu.2:70
msgid "Arguments point outside the calling process's address space."
msgstr "Аргументы указывают за пределы адресного пространства вызывающего процесса."

#. type: Plain text
#: man-pages/man2/getcpu.2:73
msgid "B<getcpu>()  was added in kernel 2.6.19 for x86_64 and i386."
msgstr "Вызов B<getcpu>() был добавлен в ядро 2.6.19 для x86_64 и i386."

#. type: Plain text
#: man-pages/man2/getcpu.2:76
msgid "B<getcpu>()  is Linux-specific."
msgstr "Вызов B<getcpu>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/getcpu.2:82
msgid ""
"Linux makes a best effort to make this call as fast possible.  The intention"
" of B<getcpu>()  is to allow programs to make optimizations with per-CPU "
"data or for NUMA optimization."
msgstr "Linux старается выполнить данный вызов как можно быстрее. Предназначение B<getcpu>() \\(em позволить программам оптимизировать обработку данных на разных ЦП или выполнить оптимизации NUMA."

#. type: Plain text
#: man-pages/man2/getcpu.2:88
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2); or use B<sched_getcpu>(3)  instead."
msgstr "В glibc нет обёртки для данного системного вызова; выполняйте его с помощью B<syscall>(2); или используйте вместо него B<sched_getcpu>(3)."

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: man-pages/man2/getcpu.2:139
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if"
" this argument was non-NULL, then it specified a pointer to a caller-"
"allocated buffer in thread-local storage that was used to provide a caching "
"mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  calls,"
" at the cost that there was a very small chance that the returned "
"information would be out of date.  The caching mechanism was considered to "
"cause problems when migrating threads between CPUs, and so the argument is "
"now ignored."
msgstr "Аргумент I<tcache> не используется начиная с Linux 2.6.24. В более старых ядрах, если этот аргумент не равнялся NULL, то в нём задавался указатель на буфер, выделяемый вызывающим в локальном хранилище нити, который использовался для работы механизма кэширования B<getcpu>(). Использование кэша могло бы увеличить скорость работы B<getcpu>(), и расплатой за это было бы возникновение очень маленькой вероятности, что возвращаемая информация устарела. Кэширующий механизм стал рассматриваться как вызывающий проблемы при перемещения нитей между ЦП, и поэтому теперь этот аргумент игнорируется."

#. type: Plain text
#: man-pages/man2/getcpu.2:144
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7)"
msgstr "B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), B<sched_getcpu>(3), B<cpuset>(7)"

#. type: TH
#: man-pages/man2/gettid.2:26
#, no-wrap
msgid "GETTID"
msgstr "GETTID"

#. type: TH
#: man-pages/man2/gettid.2:26
#, no-wrap
msgid "2014-02-11"
msgstr "2014-02-11"

#. type: Plain text
#: man-pages/man2/gettid.2:29
msgid "gettid - get thread identification"
msgstr "gettid - получить идентификатор нити"

#. type: Plain text
#: man-pages/man2/gettid.2:32
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/gettid.2:34
#, no-wrap
msgid "B<pid_t gettid(void);>\n"
msgstr "B<pid_t gettid(void);>\n"

#. type: Plain text
#: man-pages/man2/gettid.2:50
msgid ""
"B<gettid>()  returns the caller's thread ID (TID).  In a single-threaded "
"process, the thread ID is equal to the process ID (PID, as returned by "
"B<getpid>(2)).  In a multithreaded process, all threads have the same PID, "
"but each one has a unique TID.  For further details, see the discussion of "
"B<CLONE_THREAD> in B<clone>(2)."
msgstr "B<gettid>() возвращает идентификатор нити вызвавшего процесса (TID). В случае процесса с одной нитью он эквивалентен идентификатору процесса (PID, возвращаемому B<getpid>(2)). В случае процесса с множеством нитей все нити имеют одинаковый идентификатор процесса PID, но каждый из них имеет уникальный идентификатор нити TID. Для получения подробной информации см. обсуждение B<CLONE_THREAD> B<clone>(2)."

#. type: Plain text
#: man-pages/man2/gettid.2:52
msgid "On success, returns the thread ID of the calling process."
msgstr "В случае успеха возвращает идентификатор нити вызывающего процесса."

#. type: Plain text
#: man-pages/man2/gettid.2:54
msgid "This call is always successful."
msgstr "Этот системный вызов всегда выполняется успешно."

#. type: Plain text
#: man-pages/man2/gettid.2:58
msgid "The B<gettid>()  system call first appeared on Linux in kernel 2.4.11."
msgstr "Вызов B<gettid>() впервые появился в Linux в ядре версии 2.4.11."

#. type: Plain text
#: man-pages/man2/gettid.2:62
msgid ""
"B<gettid>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr "Вызов B<gettid>() является специфичным для Linux и не должен использоваться в переносимых программах."

#.  FIXME See http://sourceware.org/bugzilla/show_bug.cgi?id=6399
#.  "gettid() should have a wrapper"
#. type: Plain text
#: man-pages/man2/gettid.2:67
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr "В glibc нет обёртки для данного системного вызова; запускайте его с помощью B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/gettid.2:71
msgid ""
"The thread ID returned by this call is not the same thing as a POSIX thread "
"ID (i.e., the opaque value returned by B<pthread_self>(3))."
msgstr "Идентификатор нити, возвращаемый этим вызовом, не является идентификатором нити POSIX (т.е., неясным значением, возвращаемым B<pthread_self>(3))."

#.  .BR kcmp (2),
#.  .BR move_pages (2),
#.  .BR migrate_pages (2),
#.  .BR process_vm_readv (2),
#.  .BR ptrace (2),
#. type: Plain text
#: man-pages/man2/gettid.2:89
msgid ""
"B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<get_robust_list>(2), "
"B<getpid>(2), B<ioprio_set>(2), B<perf_event_open>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<tgkill>(2), B<timer_create>(2)"
msgstr "B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<get_robust_list>(2), B<getpid>(2), B<ioprio_set>(2), B<perf_event_open>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), B<tgkill>(2), B<timer_create>(2)"

#. type: TH
#: man-pages/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr "GETXATTR"

#. type: TH
#: man-pages/man2/getxattr.2:25
#, no-wrap
msgid "2014-04-06"
msgstr "2014-04-06"

#. type: Plain text
#: man-pages/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr "getxattr, lgetxattr, fgetxattr - получить расширенное значение атрибута"

#. type: Plain text
#: man-pages/man2/getxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/xattr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr "B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\nB<                 void\\ *>I<value>B<, size_t >I<size>B<);>\nB<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\nB<                 void\\ *>I<value>B<, size_t >I<size>B<);>\nB<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\nB<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man2/getxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<attr>(5)."
msgstr "Расширенные атрибуты представляют собой пару I<имя>:I<значение> и связываются с записями inode (файлы, каталоги, символьные ссылки и т.п.). Они являются расширениями к обычным атрибутам, связанным со всеми записями inode в системе (например, данные B<stat>(2)). Полное описание модели расширенных атрибутов можно найти в B<attr>(5)."

#. type: Plain text
#: man-pages/man2/getxattr.2:65
msgid ""
"B<getxattr>()  retrieves the I<value> of the extended attribute identified "
"by I<name> and associated with the given I<path> in the filesystem.  The "
"length of the attribute I<value> is returned."
msgstr "B<getxattr>() возвращает значение I<value> расширенного атрибута с именем I<name> и связанного с указанным путем I<path> в файловой системе. Возвращается длина атрибута I<value>."

#. type: Plain text
#: man-pages/man2/getxattr.2:71
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr "B<lgetxattr>() идентичен B<getxattr>(), за исключением указания символьной ссылки, когда рассматривается именно ссылка, а не файл, на который она указывает."

#. type: Plain text
#: man-pages/man2/getxattr.2:81
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr "B<fgetxattr>() идентичен B<getxattr>(), только вместо I<path> берётся открытый файл, на который указывает I<fd> (возвращаемый B<open>(2))."

#. type: Plain text
#: man-pages/man2/getxattr.2:89
msgid ""
"An extended attribute I<name> is a simple null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data of specified length."
msgstr "Расширенный атрибут I<name> является простой строкой, заканчивающейся NULL. Имя включает префикс пространства имён; их может быть несколько, разрозненные пространства связаны с разными записями inode. Значением расширенного атрибута является произвольный кусок текстовых или двоичных данных заданной длины."

#. type: Plain text
#: man-pages/man2/getxattr.2:96
msgid ""
"An empty buffer of I<size> zero can be passed into these calls to return the"
" current size of the named extended attribute, which can be used to estimate"
" the size of a buffer which is sufficiently large to hold the value "
"associated with the extended attribute."
msgstr "Для возврата текущего размера указанного расширенного атрибута, этим вызовам может быть передан пустой буфер с I<size> равным нулю; это можно использовать для определения размера буфера, который вместил бы всё значение, связанное с расширенным атрибутом."

#. type: Plain text
#: man-pages/man2/getxattr.2:100
msgid ""
"The interface is designed to allow guessing of initial buffer sizes, and to "
"enlarge buffers when the return value indicates that the buffer provided was"
" too small."
msgstr "Интерфейс разработан так, чтобы можно было узнать размеры начального буфера и увеличить буферы, если возвращаемое значение показывает, что переданный буфер был слишком мал."

#. type: Plain text
#: man-pages/man2/getxattr.2:106
msgid ""
"On success, a nonnegative number is returned indicating the size of the "
"extended attribute value.  On failure, -1 is returned and I<errno> is set "
"appropriately."
msgstr "При успешном выполнении возвращается неотрицательное число, обозначающее размер значения расширенного атрибута. При ошибках возвращается -1 и I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/getxattr.2:107
#, no-wrap
msgid "B<ENOATTR>"
msgstr "B<ENOATTR>"

#. type: Plain text
#: man-pages/man2/getxattr.2:116
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute.  (B<ENOATTR> is defined to be a synonym for B<ENODATA> in "
"I<E<lt>attr/xattr.hE<gt>>.)"
msgstr "Атрибут с таким именем не существует, или процесс не имеет доступа к этому атрибуту (B<ENOATTR> определена как синонимB<ENODATA> в I<E<lt>attr/xattr.hE<gt>>)."

#. type: TP
#: man-pages/man2/getxattr.2:116
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man2/getxattr.2:119
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled."
msgstr "Расширенные атрибуты не поддерживаются файловой системой или отключены."

#. type: TP
#: man-pages/man2/getxattr.2:119
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man2/getxattr.2:126
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr "Размер I<size> буфера I<value> слишком мал для хранения результата."

#. type: Plain text
#: man-pages/man2/getxattr.2:130
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "Также могут возникать ошибки, описанные в B<stat>(2)."

#. type: Plain text
#: man-pages/man2/getxattr.2:133
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr "Данные системные вызовы доступны в Linux начиная с ядра версии 2.4; поддержка в glibc появилась в версии 2.3."

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@computer.org >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#.  Please send any bug reports or comments to these addresses.
#. type: Plain text
#: man-pages/man2/getxattr.2:141
msgid "These system calls are Linux-specific."
msgstr "Данные системные вызовы есть только в Linux."

#. type: Plain text
#: man-pages/man2/getxattr.2:150
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr "B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"

#. type: TH
#: man-pages/man2/getunwind.2:27
#, no-wrap
msgid "GETUNWIND"
msgstr "GETUNWIND"

#. type: TH
#: man-pages/man2/getunwind.2:27
#, no-wrap
msgid "2013-02-13"
msgstr "2013-02-13"

#. type: Plain text
#: man-pages/man2/getunwind.2:30
msgid "getunwind - copy the unwind data to caller's buffer"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:36
#, no-wrap
msgid "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"
msgstr "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"

#. type: Plain text
#: man-pages/man2/getunwind.2:42
msgid "I<Note: this function is obsolete.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:52
msgid ""
"The IA-64-specific B<getunwind>()  system call copies the kernel's call "
"frame unwind data into the buffer pointed to by I<buf> and returns the size "
"of the unwind data; this data describes the gate page (kernel code that is "
"mapped into user space)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:64
msgid ""
"The size of the buffer I<buf> is specified in I<buf_size>.  The data is "
"copied only if I<buf_size> is greater than or equal to the size of the "
"unwind data and I<buf> is not NULL; otherwise, no data is copied, and the "
"call succeeds, returning the size that would be needed to store the unwind "
"data."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:68
msgid ""
"The first part of the unwind data contains an unwind table.  The rest "
"contains the associated unwind information, in no particular order.  The "
"unwind table contains entries of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:73
#, no-wrap
msgid ""
"    u64 start;      (64-bit address of start of function)\n"
"    u64 end;        (64-bit address of end of function)\n"
"    u64 info;       (BUF-relative offset to unwind info)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:81
msgid ""
"An entry whose I<start> value is zero indicates the end of the table.  For "
"more information about the format, see the I<IA-64 Software Conventions and "
"Runtime Architecture> manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:88
msgid ""
"On success, B<getunwind>()  returns the size of unwind table.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:94
msgid ""
"B<getunwind>()  fails with the error B<EFAULT> if the unwind info can't be "
"stored in the space specified by I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:96
msgid "This system call is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:99
msgid ""
"This system call is Linux-specific, and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:107
msgid ""
"This system call has been deprecated.  The modern way to obtain the kernel's"
" unwind data is via the gate DSO.  The address of the ELF header for this "
"DSO is passed to user level via B<AT_SYSINFO_EHDR> (see B<getauxval>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:111
msgid ""
"Glibc does not provide a wrapper for this system call; in the unlikely event"
" that you want to call it, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:112
msgid "B<getauxval>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/get_thread_area.2:8
#, no-wrap
msgid "GET_THREAD_AREA"
msgstr "GET_THREAD_AREA"

#. type: TH
#: man-pages/man2/get_thread_area.2:8
#, no-wrap
msgid "2012-07-13"
msgstr "2012-07-13"

#. type: Plain text
#: man-pages/man2/get_thread_area.2:11
msgid "get_thread_area - get a thread-local storage (TLS) area"
msgstr "get_thread_area - получение области локального хранилища нити (TLS, Thread Local Storage)"

#. type: Plain text
#: man-pages/man2/get_thread_area.2:13
msgid "B<#include E<lt>linux/unistd.hE<gt>>"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/get_thread_area.2:15
msgid "B<#include E<lt>asm/ldt.hE<gt>>"
msgstr "B<#include E<lt>asm/ldt.hE<gt>>"

#. type: Plain text
#: man-pages/man2/get_thread_area.2:17
msgid "B<int get_thread_area(struct user_desc *>I<u_info>B<);>"
msgstr "B<int get_thread_area(struct user_desc *>I<u_info>B<);>"

#. type: Plain text
#: man-pages/man2/get_thread_area.2:29
msgid ""
"B<get_thread_area>()  returns an entry in the current thread's thread-local "
"storage (TLS) array.  The index of the entry corresponds to the value of "
"I<u_info-E<gt>entry_number>, passed in by the user.  If the value is in "
"bounds, B<get_thread_area>()  copies the corresponding TLS entry into the "
"area pointed to by I<u_info>."
msgstr "B<get_thread_area>() возвращает элемент в текущем массиве локального хранилища нити. Индекс записи соответствует значению I<u_info-E<gt>entry_number>, переданного от пользователя. Если это значение находится в допустимых пределах, то B<get_thread_area>() копирует соответствующую запись TLS в область, на которую указывает I<u_info>."

#. type: Plain text
#: man-pages/man2/get_thread_area.2:35
msgid ""
"B<get_thread_area>()  returns 0 on success.  Otherwise, it returns -1 and "
"sets I<errno> appropriately."
msgstr "B<get_thread_area>() возвращает 0 при нормальном завершении работы. Иначе возвращается -1, а I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/get_thread_area.2:39
msgid "I<u_info> is an invalid pointer."
msgstr "I<u_info> является некорректным указателем."

#. type: Plain text
#: man-pages/man2/get_thread_area.2:42
msgid "I<u_info-E<gt>entry_number> is out of bounds."
msgstr "I<u_info-E<gt>entry_number> вне допустимых границ."

#. type: Plain text
#: man-pages/man2/get_thread_area.2:46
msgid "A version of B<get_thread_area>()  first appeared in Linux 2.5.32."
msgstr "Впервые, B<get_thread_area>() появилась в Linux 2.5.32."

#. type: Plain text
#: man-pages/man2/get_thread_area.2:50
msgid ""
"B<get_thread_area>()  is Linux-specific and should not be used in programs "
"that are intended to be portable."
msgstr "Вызов B<get_thread_area>() есть только в Linux, и он не должен использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/get_thread_area.2:55
msgid ""
"Glibc does not provide a wrapper for this system call, since it is generally"
" intended for use only by threading libraries.  In the unlikely event that "
"you want to call it directly, use B<syscall>(2)."
msgstr "В glibc нет обёрточной функции для этого системного вызова, так как он предназначен только для использования в библиотеках нитей. Если вам всё-таки нужно его вызвать, используйте B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/get_thread_area.2:57
msgid "B<modify_ldt>(2), B<set_thread_area>(2)"
msgstr "B<modify_ldt>(2), B<set_thread_area>(2)"

#. type: TH
#: man-pages/man2/getsockname.2:40
#, no-wrap
msgid "GETSOCKNAME"
msgstr "GETSOCKNAME"

#. type: TH
#: man-pages/man2/getsockname.2:40
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: man-pages/man2/getsockname.2:43
msgid "getsockname - get socket name"
msgstr "getsockname - получить имя сокета"

#. type: Plain text
#: man-pages/man2/getsockname.2:49
#, no-wrap
msgid ""
"B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr "B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/getsockname.2:62
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr "B<getsockname>() возвращает текущий адрес, к которому привязан сокет I<sockfd>, в буфере, указываемом I<addr>. В параметре I<addrlen> должно быть указано, сколько места выделено (в байтах), на которое указывает I<addr>. При возврате в этом параметре передается реальный размер адреса сокета."

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: man-pages/man2/getsockname.2:103
msgid ""
"SVr4, 4.4BSD (the B<getsockname>()  function call appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr "SVr4, 4.4BSD (вызов B<getsockname>() появился в 4.2BSD), POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/getsockname.2:114
msgid ""
"The third argument of B<getsockname>()  is in reality an I<int\\ *> (and "
"this is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion "
"resulted in the present I<socklen_t>, also used by glibc.  See also "
"B<accept>(2)."
msgstr "Третий аргумент функции B<getsockname>() в действительности имеет тип I<int\\ *> (это именно так в 4.x BSD, libc4 и libc5). Определённое недопонимание привело к тому, что в стандарте POSIX появился тип I<socklen_t> также используемый в glibc. Смотрите также B<accept>(2)."

#. type: Plain text
#: man-pages/man2/getsockname.2:120
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr "B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/getrlimit.2:64
#, no-wrap
msgid "GETRLIMIT"
msgstr "GETRLIMIT"

#. type: TH
#: man-pages/man2/getrlimit.2:64
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: man-pages/man2/getrlimit.2:67
msgid "getrlimit, setrlimit, prlimit - get/set resource limits"
msgstr "getrlimit, setrlimit, prlimit - считывает/устанавливает ограничения использования ресурсов"

#. type: Plain text
#: man-pages/man2/getrlimit.2:73
msgid "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"
msgstr "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:75
msgid "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"
msgstr "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:78
msgid ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"
msgstr "B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit *>I<new_limit>B<,>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:80
msgid "B< struct rlimit *>I<old_limit>B<);>"
msgstr "B< struct rlimit *>I<old_limit>B<);>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:88
msgid "B<prlimit>(): _GNU_SOURCE && _FILE_OFFSET_BITS == 64"
msgstr "B<prlimit>(): _GNU_SOURCE && _FILE_OFFSET_BITS == 64"

#. type: Plain text
#: man-pages/man2/getrlimit.2:97
msgid ""
"The B<getrlimit>()  and B<setrlimit>()  system calls get and set resource "
"limits respectively.  Each resource has an associated soft and hard limit, "
"as defined by the I<rlimit> structure:"
msgstr "Системные вызовы B<getrlimit>() и B<setrlimit>(), соответственно, получают и устанавливают ограничения использования ресурсов. Каждому ресурсу назначается мягкое и жёсткое ограничение, определяемое структурой I<rlimit>:"

#. type: Plain text
#: man-pages/man2/getrlimit.2:104
#, no-wrap
msgid ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* Soft limit */\n"
"    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */\n"
"};\n"
msgstr "struct rlimit {\n    rlim_t rlim_cur;  /* мягкое ограничение */\n    rlim_t rlim_max;  /* жёсткое ограничение (максимум для rlim_cur) */\n};\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:115
msgid ""
"The soft limit is the value that the kernel enforces for the corresponding "
"resource.  The hard limit acts as a ceiling for the soft limit: an "
"unprivileged process may set only its soft limit to a value in the range "
"from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A "
"privileged process (under Linux: one with the B<CAP_SYS_RESOURCE> "
"capability) may make arbitrary changes to either limit value."
msgstr "Мягким ограничением является значение, принудительно устанавливаемое ядром для соответствующего ресурса. Жёсткое ограничение работает как максимальное значение для мягкого ограничения: непривилегированные процессы могут определять только свои мягкие ограничения в диапазоне от 0 до жёсткого ограничения, то есть однозначно меньше жёсткого ограничения. Привилегированные процессы (в  Linux: имеющие мандат B<CAP_SYS_RESOURCE>) могут устанавливать произвольные значения в любых пределах."

#. type: Plain text
#: man-pages/man2/getrlimit.2:122
msgid ""
"The value B<RLIM_INFINITY> denotes no limit on a resource (both in the "
"structure returned by B<getrlimit>()  and in the structure passed to "
"B<setrlimit>())."
msgstr "Значение B<RLIM_INFINITY> означает отсутствие ограничений для ресурса (в структуре, возвращаемой B<getrlimit>() и в структуре, передаваемой в B<setrlimit>())."

#. type: Plain text
#: man-pages/man2/getrlimit.2:126
msgid "The I<resource> argument must be one of:"
msgstr "Значение I<resource> должно быть одним из:"

#. type: TP
#: man-pages/man2/getrlimit.2:126
#, no-wrap
msgid "B<RLIMIT_AS>"
msgstr "B<RLIMIT_AS>"

#.  since 2.0.27 / 2.1.12
#. type: Plain text
#: man-pages/man2/getrlimit.2:146
msgid ""
"The maximum size of the process's virtual memory (address space) in bytes.  "
"This limit affects calls to B<brk>(2), B<mmap>(2)  and B<mremap>(2), which "
"fail with the error B<ENOMEM> upon exceeding this limit.  Also automatic "
"stack expansion will fail (and generate a B<SIGSEGV> that kills the process "
"if no alternate stack has been made available via B<sigaltstack>(2)).  Since"
" the value is a I<long>, on machines with a 32-bit I<long> either this limit"
" is at most 2 GiB, or this resource is unlimited."
msgstr "Максимальный размер виртуальной памяти (адресного пространства) процесса в байтах. Учитывается в вызовах B<brk>(2), B<mmap>(2) и B<mremap>(2), которые завершатся с ошибкой B<ENOMEM>, если будет превышено это ограничение. Также завершится с ошибкой автоматическое расширение стека (и будет сгенерирован сигнал B<SIGSEGV>, по которому завершится процесс, если не было создано с помощью B<sigaltstack>(2) альтернативного стека). Так как значение имеет тип I<long>, на машинах с 32-битным I<long> максимальное значение ограничения будет около 2 ГиБ, или этот ресурс не ограничивается."

#. type: TP
#: man-pages/man2/getrlimit.2:146
#, no-wrap
msgid "B<RLIMIT_CORE>"
msgstr "B<RLIMIT_CORE>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:153
msgid ""
"Maximum size of I<core> file.  When 0 no core dump files are created.  When "
"nonzero, larger dumps are truncated to this size."
msgstr "Максимальный размер файла I<core>. Если значение равно 0, то файлы core не создаются. Если значение больше нуля, то создаваемые дампы обрезаются до этого размера."

#. type: TP
#: man-pages/man2/getrlimit.2:153
#, no-wrap
msgid "B<RLIMIT_CPU>"
msgstr "B<RLIMIT_CPU>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:173
msgid ""
"CPU time limit in seconds.  When the process reaches the soft limit, it is "
"sent a B<SIGXCPU> signal.  The default action for this signal is to "
"terminate the process.  However, the signal can be caught, and the handler "
"can return control to the main program.  If the process continues to consume"
" CPU time, it will be sent B<SIGXCPU> once per second until the hard limit "
"is reached, at which time it is sent B<SIGKILL>.  (This latter point "
"describes Linux behavior.  Implementations vary in how they treat processes "
"which continue to consume CPU time after reaching the soft limit.  Portable "
"applications that need to catch this signal should perform an orderly "
"termination upon first receipt of B<SIGXCPU>.)"
msgstr "Время выполнения на ЦП в секундах. Когда процесс достигает своего мягкого ограничения, то ему отправляется сигнал B<SIGX CPU>. Действием по умолчанию для этого сигнала является завершение процесса. Однако, этот сигнал может быть перехвачен, и обработчик может передать управление в основную программу. Если процесс продолжает потреблять процессорное время, то ему будет отправляться B<SIGXCPU> раз в секунду до тех пор, пока не будет достигнуто жёсткое ограничение, и тогда процессу будет послан сигнал B<SIGKILL>. (Последний пункт описывает поведение Linux. В разных реализациях действия над потребляющими процессорное время после прохождения мягкого ограничения процессами различаются. Переносимые приложения, где требуется перехват сигнала, должны выполнять корректное завершение процесса после первого получения B<SIGXCPU>.)"

#. type: TP
#: man-pages/man2/getrlimit.2:173
#, no-wrap
msgid "B<RLIMIT_DATA>"
msgstr "B<RLIMIT_DATA>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:184
msgid ""
"The maximum size of the process's data segment (initialized data, "
"uninitialized data, and heap).  This limit affects calls to B<brk>(2)  and "
"B<sbrk>(2), which fail with the error B<ENOMEM> upon encountering the soft "
"limit of this resource."
msgstr "Максимальный размер сегмента данных процесса (инициализированные данные, неинициализированные данные, куча). Это ограничение учитывается в вызовах B<brk>(2) и B<sbrk>(2), которые завершатся с ошибкой B<ENOMEM> при достижении мягкого ограничения этого ресурса."

#. type: TP
#: man-pages/man2/getrlimit.2:184
#, no-wrap
msgid "B<RLIMIT_FSIZE>"
msgstr "B<RLIMIT_FSIZE>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:196
msgid ""
"The maximum size of files that the process may create.  Attempts to extend a"
" file beyond this limit result in delivery of a B<SIGXFSZ> signal.  By "
"default, this signal terminates a process, but a process can catch this "
"signal instead, in which case the relevant system call (e.g., B<write>(2), "
"B<truncate>(2))  fails with the error B<EFBIG>."
msgstr "Максимальный размер файлов, создаваемых процессом. Попытки расширить файл сверх этого ограничения приведёт к доставке сигнала B<SIGXFSZ>. По умолчанию по этому сигналу процесс завершается, но процесс может перехватить этот сигнал и в этом случае выполнявшийся системный вызов (например, B<write>(2), B<truncate>(2)) завершится с ошибкой B<EFBIG>."

#. type: TP
#: man-pages/man2/getrlimit.2:196
#, no-wrap
msgid "B<RLIMIT_LOCKS> (Early Linux 2.4 only)"
msgstr "B<RLIMIT_LOCKS> (только в ранних версиях Linux 2.4)"

#.  to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
#. type: Plain text
#: man-pages/man2/getrlimit.2:204
msgid ""
"A limit on the combined number of B<flock>(2)  locks and B<fcntl>(2)  leases"
" that this process may establish."
msgstr "Ограничение на общее количество блокировок B<flock>(2) и аренд  B<fcntl>(2), которое может установить процесс."

#. type: TP
#: man-pages/man2/getrlimit.2:204
#, no-wrap
msgid "B<RLIMIT_MEMLOCK>"
msgstr "B<RLIMIT_MEMLOCK>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:242
msgid ""
"The maximum number of bytes of memory that may be locked into RAM.  In "
"effect this limit is rounded down to the nearest multiple of the system page"
" size.  This limit affects B<mlock>(2)  and B<mlockall>(2)  and the "
"B<mmap>(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9 it also affects the "
"B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the total "
"bytes in shared memory segments (see B<shmget>(2))  that may be locked by "
"the real user ID of the calling process.  The B<shmctl>(2)  B<SHM_LOCK> "
"locks are accounted for separately from the per-process memory locks "
"established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  B<MAP_LOCKED>; a"
" process can lock bytes up to this limit in each of these two categories.  "
"In Linux kernels before 2.6.9, this limit controlled the amount of memory "
"that could be locked by a privileged process.  Since Linux 2.6.9, no limits "
"are placed on the amount of memory that a privileged process may lock, and "
"this limit instead governs the amount of memory that an unprivileged process"
" may lock."
msgstr "Максимальное количество байт памяти, которое может быть заблокировано в ОЗУ. В целях эффективности это ограничение округляется в меньшую сторону до ближайшего значения, кратного размеру системной страницы. Это ограничение учитывается в B<mlock>(2) и B<mlockall>(2) и в B<mmap>(2) при операции B<MAP_LOCKED>. Начиная с Linux 2.6.9, оно также учитывается в B<shmctl>(2) при операции B<SHM_LOCK>, где определяет максимальное количество байт всех общих сегментов памяти (см. B<shmget>(2)), которые могут быть заблокированы вызывающим процессом с реальным идентификатором пользователя. Блокировки по операции B<SHM_LOCK> у B<shmctl>(2) учитываются отдельно от попроцессных блокировок памяти, устанавливаемых B<mlock>(2), B<mlockall>(2) и B<mmap>(2) операцией B<MAP_LOCKED>; процесс может заблокировать пространство до этого значения заданного ограничения байт в каждой из этих двух категорий. В ядрах Linux до версии 2.6.9 этим ограничением контролировалось количество памяти, которое можно было блокировать привилегированному процессу. Начиная с Linux 2.6.9 это ограничение снято и теперь это ограничение управляет количеством памяти, которое может блокировать непривилегированный процесс."

#. type: TP
#: man-pages/man2/getrlimit.2:242
#, no-wrap
msgid "B<RLIMIT_MSGQUEUE> (since Linux 2.6.8)"
msgstr "B<RLIMIT_MSGQUEUE> (начиная с Linux 2.6.8)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:250
msgid ""
"Specifies the limit on the number of bytes that can be allocated for POSIX "
"message queues for the real user ID of the calling process.  This limit is "
"enforced for B<mq_open>(3).  Each message queue that the user creates counts"
" (until it is removed)  against this limit according to the formula:"
msgstr "Ограничение на количество байт, которое может выделяться для очередей сообщений POSIX для вызывающего процесса с реальным идентификатором пользователя. Это ограничение учитывается в B<mq_open>(3). Каждая очередь сообщений, которую создаёт пользователь, учитывается (пока не будет удалена) в формуле:"

#. type: Plain text
#: man-pages/man2/getrlimit.2:254
#, no-wrap
msgid ""
"    bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"            attr.mq_maxmsg * attr.mq_msgsize\n"
msgstr "    bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n            attr.mq_maxmsg * attr.mq_msgsize\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:262
msgid ""
"where I<attr> is the I<mq_attr> structure specified as the fourth argument "
"to B<mq_open>(3)."
msgstr "где I<attr> \\(em структура I<mq_attr>, указанная в четвёртом аргументе B<mq_open>(3)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:268
msgid ""
"The first addend in the formula, which includes I<sizeof(struct msg_msg\\ "
"*)> (4 bytes on Linux/i386), ensures that the user cannot create an "
"unlimited number of zero-length messages (such messages nevertheless each "
"consume some system memory for bookkeeping overhead)."
msgstr "Первое слагаемое в формуле, I<sizeof(struct msg_msg\\ *)> (4 байта в Linux/i386), нужно, чтобы пользователь не смог создать бесконечное количество сообщений нулевой длины (для таких сообщений, тем не менее, потребляется системная память для учёта использования системных ресурсов)."

#. type: TP
#: man-pages/man2/getrlimit.2:268
#, no-wrap
msgid "B<RLIMIT_NICE> (since Linux 2.6.12, but see BUGS below)"
msgstr "B<RLIMIT_NICE> (начиная с Linux 2.6.12, см. ДЕФЕКТЫ далее)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:281
msgid ""
"Specifies a ceiling to which the process's nice value can be raised using "
"B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice value is "
"calculated as I<20\\ -\\ rlim_cur>.  (This strangeness occurs because "
"negative numbers cannot be specified as resource limit values, since they "
"typically have special meanings.  For example, B<RLIM_INFINITY> typically is"
" the same as -1.)"
msgstr "Определяет максимум, до которого может быть увеличено значение nice с помощью B<setpriority>(2) или B<nice>(2). Действительный максимум значения nice высчитывается по формуле: I<20\\ -\\ rlim_cur>. (Так пришлось поступить из-за того, что отрицательные числа нельзя указывать в значениях ограничений ресурсов, так как они, обычно, имеют специальное предназначение. Например, B<RLIM_INFINITY>, обычно равно -1.)"

#. type: TP
#: man-pages/man2/getrlimit.2:281
#, no-wrap
msgid "B<RLIMIT_NOFILE>"
msgstr "B<RLIMIT_NOFILE>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:295
msgid ""
"Specifies a value one greater than the maximum file descriptor number that "
"can be opened by this process.  Attempts (B<open>(2), B<pipe>(2), B<dup>(2),"
" etc.)  to exceed this limit yield the error B<EMFILE>.  (Historically, this"
" limit was named B<RLIMIT_OFILE> on BSD.)"
msgstr "Определяет значение, на 1 больше максимального количества дескрипторов файлов, которое может открыть этот процесс. Попытки (B<open>(2), B<pipe>(2), B<dup>(2) и т.п.) превысить это ограничение приведут к ошибке B<EMFILE>. (Раньше это  ограничение в BSD называлось B<RLIMIT_OFILE>.)"

#. type: TP
#: man-pages/man2/getrlimit.2:295
#, no-wrap
msgid "B<RLIMIT_NPROC>"
msgstr "B<RLIMIT_NPROC>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:308
msgid ""
"The maximum number of processes (or, more precisely on Linux, threads)  that"
" can be created for the real user ID of the calling process.  Upon "
"encountering this limit, B<fork>(2)  fails with the error B<EAGAIN>.  This "
"limit is not enforced for processes that have either the B<CAP_SYS_ADMIN> or"
" the B<CAP_SYS_RESOURCE> capability."
msgstr "Максимальное количество процессов (или, более точно для Linux, нитей), которое может создать вызывающий процесс с реальным идентификатором пользователя. При превышении этого ограничения B<fork>(2) завершается с ошибкой B<EAGAIN>. Данное ограничение не действует на процессы с мандатом B<CAP_SYS_ADMIN> или B<CAP_SYS_RESOURCE>."

#. type: TP
#: man-pages/man2/getrlimit.2:308
#, no-wrap
msgid "B<RLIMIT_RSS>"
msgstr "B<RLIMIT_RSS>"

#.  As at kernel 2.6.12, this limit still does nothing in 2.6 though
#.  talk of making it do something has surfaced from time to time in LKML
#.        -- MTK, Jul 05
#. type: Plain text
#: man-pages/man2/getrlimit.2:320
msgid ""
"Specifies the limit (in pages) of the process's resident set (the number of "
"virtual pages resident in RAM).  This limit has effect only in Linux 2.4.x, "
"x E<lt> 30, and there affects only calls to B<madvise>(2)  specifying "
"B<MADV_WILLNEED>."
msgstr "Максимальное ограничение (в страницах) на число постоянных страниц процесса (числа виртуальных страниц, постоянно присутствующих в ОЗУ). Это ограничение учитывается только начиная с версии Linux 2.4.x, x E<lt> 30, и только в вызовах B<madvise>(2) со значением B<MADV_WILLNEED>."

#. type: TP
#: man-pages/man2/getrlimit.2:320
#, no-wrap
msgid "B<RLIMIT_RTPRIO> (since Linux 2.6.12, but see BUGS)"
msgstr "B<RLIMIT_RTPRIO> (начиная с Linux 2.6.12, смотрите ДЕФЕКТЫ)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:327
msgid ""
"Specifies a ceiling on the real-time priority that may be set for this "
"process using B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr "Определяет максимум для приоритета реального времени, который можно установить для процесса с помощью B<sched_setscheduler>(2) и B<sched_setparam>(2)."

#. type: TP
#: man-pages/man2/getrlimit.2:327
#, no-wrap
msgid "B<RLIMIT_RTTIME> (since Linux 2.6.25)"
msgstr "B<RLIMIT_RTTIME> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man2/getrlimit.2:339
msgid ""
"Specifies a limit (in microseconds)  on the amount of CPU time that a "
"process scheduled under a real-time scheduling policy may consume without "
"making a blocking system call.  For the purpose of this limit, each time a "
"process makes a blocking system call, the count of its consumed CPU time is "
"reset to zero.  The CPU time count is not reset if the process continues "
"trying to use the CPU but is preempted, its time slice expires, or it calls "
"B<sched_yield>(2)."
msgstr "Определяет ограничение (в микросекундах) на количество времени ЦП, которое процесс может быть запланирован выполняться в условиях реального времени без выполнения блокирующего системного вызова. Для работы ограничения, всякий раз когда процесс делает блокирующий системный вызов счётчик использованного времени ЦП сбрасывается в ноль. Счётчик времени ЦП не сбрасывается, если процесс продолжает пытаться использовать ЦП, но был вытеснен, его выделенное время на исполнение истекло или он вызвал B<sched_yield>(2)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:350
msgid ""
"Upon reaching the soft limit, the process is sent a B<SIGXCPU> signal.  If "
"the process catches or ignores this signal and continues consuming CPU time,"
" then B<SIGXCPU> will be generated once each second until the hard limit is "
"reached, at which point the process is sent a B<SIGKILL> signal."
msgstr "При достижении мягкого ограничения процессу посылается сигнал B<SIGXCPU>. Если процесс перехватил сигнал, проигнорировал его и продолжает потреблять время ЦП, то раз в секунду будет генерироваться сигнал B<SIGXCPU> до тех пор, пока не будет достигнуто жёсткое ограничение, и процессу не будет послан сигнал B<SIGKILL>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:353
msgid ""
"The intended use of this limit is to stop a runaway real-time process from "
"locking up the system."
msgstr "Это ограничение предназначено для предотвращения блокировки системы вышедшими из под контроля процессами реального времени."

#. type: TP
#: man-pages/man2/getrlimit.2:353
#, no-wrap
msgid "B<RLIMIT_SIGPENDING> (since Linux 2.6.8)"
msgstr "B<RLIMIT_SIGPENDING> (начиная с Linux 2.6.8)"

#.  This replaces the /proc/sys/kernel/rtsig-max system-wide limit
#.  that was present in kernels <= 2.6.7.  MTK Dec 04
#. type: Plain text
#: man-pages/man2/getrlimit.2:367
msgid ""
"Specifies the limit on the number of signals that may be queued for the real"
" user ID of the calling process.  Both standard and real-time signals are "
"counted for the purpose of checking this limit.  However, the limit is "
"enforced only for B<sigqueue>(3); it is always possible to use B<kill>(2)  "
"to queue one instance of any of the signals that are not already queued to "
"the process."
msgstr "Определяет ограничение на количество сигналов, которые могут быть поставлены в очередь вызывающего процесса с реальным пользовательским идентификатором. При проверке ограничения учитываются обычные сигналы и сигналы реального времени. Однако ограничение учитывается только в B<sigqueue>(3); всегда возможно использовать B<kill>(2) для постановки в очередь любого сигнала, которого ещё нет в очереди процесса."

#. type: TP
#: man-pages/man2/getrlimit.2:367
#, no-wrap
msgid "B<RLIMIT_STACK>"
msgstr "B<RLIMIT_STACK>"

#. type: Plain text
#: man-pages/man2/getrlimit.2:375
msgid ""
"The maximum size of the process stack, in bytes.  Upon reaching this limit, "
"a B<SIGSEGV> signal is generated.  To handle this signal, a process must "
"employ an alternate signal stack (B<sigaltstack>(2))."
msgstr "Максимальный размер стека процесса в байтах. При достижении этого ограничения генерируется сигнал B<SIGSEGV>. Для обработки этого сигнала процесс должен использовать альтернативный стек сигналов (B<sigaltstack>(2))."

#. type: Plain text
#: man-pages/man2/getrlimit.2:380
msgid ""
"Since Linux 2.6.23, this limit also determines the amount of space used for "
"the process's command-line arguments and environment variables; for details,"
" see B<execve>(2)."
msgstr "Начиная с Linux 2.6.23, это ограничение также определяет количество места, используемого для аргументов командной строки процесса и его переменных окружения; подробней об этом смотрите в B<execve>(2)."

#. type: SS
#: man-pages/man2/getrlimit.2:380
#, no-wrap
msgid "prlimit()"
msgstr "prlimit()"

#.  commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Tue May 4 18:03:50 2010 +0200
#. type: Plain text
#: man-pages/man2/getrlimit.2:391
msgid ""
"The Linux-specific B<prlimit>()  system call combines and extends the "
"functionality of B<setrlimit>()  and B<getrlimit>().  It can be used to both"
" set and get the resource limits of an arbitrary process."
msgstr "Системный вызов B<prlimit>(), который есть только в Linux объединяет и расширяет функции B<setrlimit>() и B<getrlimit>(). Он может использоваться для задания и получения ограничений ресурсов произвольного процесса."

#. type: Plain text
#: man-pages/man2/getrlimit.2:398
msgid ""
"The I<resource> argument has the same meaning as for B<setrlimit>()  and "
"B<getrlimit>()."
msgstr "Аргумент I<resource> имеет тот же смысл что и в B<setrlimit>() и B<getrlimit>()."

#. type: Plain text
#: man-pages/man2/getrlimit.2:416
msgid ""
"If the I<new_limit> argument is a not NULL, then the I<rlimit> structure to "
"which it points is used to set new values for the soft and hard limits for "
"I<resource>.  If the I<old_limit> argument is a not NULL, then a successful "
"call to B<prlimit>()  places the previous soft and hard limits for "
"I<resource> in the I<rlimit> structure pointed to by I<old_limit>."
msgstr "Если значение аргумента I<new_limit> не равно NULL, то структура I<rlimit>, на которую он указывает, используется для задания новых значений мягкий и жёстких ограничений для I<resource>. Если значение аргумента I<old_limit> не равно NULL, то успешный вызов B<prlimit>() помещает текущие значения мягких и жёстких ограничений для I<resource> в структуру I<rlimit>, на которую указывает I<old_limit>."

#.  FIXME this permission check is strange
#.  Asked about this on LKML, 7 Nov 2010
#.      "Inconsistent credential checking in prlimit() syscall"
#. type: Plain text
#: man-pages/man2/getrlimit.2:435
msgid ""
"The I<pid> argument specifies the ID of the process on which the call is to "
"operate.  If I<pid> is 0, then the call applies to the calling process.  To "
"set or get the resources of a process other than itself, the caller must "
"have the B<CAP_SYS_RESOURCE> capability, or the real, effective, and saved "
"set user IDs of the target process must match the real user ID of the caller"
" I<and> the real, effective, and saved set group IDs of the target process "
"must match the real group ID of the caller."
msgstr "В аргументе I<pid> задаётся идентификатор процесса с которым работает вызыв. Если I<pid> равно 0, то вызов применяется к вызывающему процессу. Для установки и получения ресурсов не своего процесса, вызывающий должен иметь мандат B<CAP_SYS_RESOURCE> или реальный, эффективный и сохранённый идентификатор пользователя процесса назначения должен совпадать с реальным идентификатором пользователя вызывающего I<и> реальный, эффективный и сохранённый идентификатор группы процесса назначения должны совпадать с реальным идентификатором группы вызывающего."

#. type: Plain text
#: man-pages/man2/getrlimit.2:440
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getrlimit.2:445
msgid ""
"A pointer argument points to a location outside the accessible address "
"space."
msgstr "Аргумент-указатель указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/getrlimit.2:457
msgid ""
"The value specified in I<resource> is not valid; or, for B<setrlimit>()  or "
"B<prlimit>(): I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr "Указано некорректное значение I<resource>; или для B<setrlimit>() или B<prlimit>(): I<rlim-E<gt>rlim_cur> больше чем I<rlim-E<gt>rlim_max>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:469
msgid ""
"An unprivileged process tried to raise the hard limit; the "
"B<CAP_SYS_RESOURCE> capability is required to do this.  Or, the caller tried"
" to increase the hard B<RLIMIT_NOFILE> limit above the current kernel "
"maximum (B<NR_OPEN>).  Or, the calling process did not have permission to "
"set limits for the process specified by I<pid>."
msgstr "Непривилегированный процесс пытался увеличить жёсткое ограничение; для этого требуется мандат B<CAP_SYS_RESOURCE>. Или вызывающий увеличить жёсткое ограничение B<RLIMIT_NOFILE>, превышая текущий максимум ядра (B<NR_OPEN>). Или вызывающий процесс не имеет прав для назначения ограничений процессу, указанному в I<pid>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:473
msgid "Could not find a process with the ID specified in I<pid>."
msgstr "Не удалось найти процесс с идентификатором, указанном в I<pid>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:478
msgid ""
"The B<prlimit>()  system call is available since Linux 2.6.36.  Library "
"support is available since glibc 2.13."
msgstr "Системный вызов B<prlimit>() появился в Linux 2.6.36. Поддержка в glibc доступна начиная с версии 2.13."

#. type: Plain text
#: man-pages/man2/getrlimit.2:482
msgid "B<getrlimit>(), B<setrlimit>(): SVr4, 4.3BSD, POSIX.1-2001."
msgstr "B<getrlimit>(), B<setrlimit>(): SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/getrlimit.2:485
msgid "B<prlimit>(): Linux-specific."
msgstr "B<prlimit>(): только в Linux."

#. type: Plain text
#: man-pages/man2/getrlimit.2:501
msgid ""
"B<RLIMIT_MEMLOCK> and B<RLIMIT_NPROC> derive from BSD and are not specified "
"in POSIX.1-2001; they are present on the BSDs and Linux, but on few other "
"implementations.  B<RLIMIT_RSS> derives from BSD and is not specified in "
"POSIX.1-2001; it is nevertheless present on most implementations.  "
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, and "
"B<RLIMIT_SIGPENDING> are Linux-specific."
msgstr "Ограничение B<RLIMIT_MEMLOCK> и B<RLIMIT_NPROC> появились из BSD и их нет в POSIX.1-2001; они есть в BSD и Linux, но реализации несколько различны. Ограничение B<RLIMIT_RSS> появилось из BSD и его нет в POSIX.1-2001; тем не менее оно есть в большинстве реализаций. Ограничения B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME> и B<RLIMIT_SIGPENDING> есть только в Linux."

#. type: Plain text
#: man-pages/man2/getrlimit.2:507
msgid ""
"A child process created via B<fork>(2)  inherits its parent's resource "
"limits.  Resource limits are preserved across B<execve>(2)."
msgstr "Дочерний процесс, созданный B<fork>(2), наследует ограничения ресурсов родителя. Ограничения ресурсов сохраняются при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:512
msgid ""
"Lowering the soft limit for a resource below the process's current "
"consumption of that resource will succeed (but will prevent the process from"
" further increasing its consumption of the resource)."
msgstr "Уменьшение мягкого ограничения ресурса ниже текущего потребления процесса будет выполнено (но в дальнейшем процесс не сможет увеличить потребление ресурса)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:521
msgid ""
"One can set the resource limits of the shell using the built-in I<ulimit> "
"command (I<limit> in B<csh>(1)).  The shell's resource limits are inherited "
"by the processes that it creates to execute commands."
msgstr "Ограничения ресурсов интерпретатора командной строки можно устанавливать с помощью встроенной команды I<ulimit> (I<limit> в B<csh>(1)). Ограничения ресурсов интерпретатора наследуются дочерними процессами, которые он создаёт при выполнении команд."

#. type: Plain text
#: man-pages/man2/getrlimit.2:526
msgid ""
"Since Linux 2.6.24, the resource limits of any process can be inspected via "
"I</proc/[pid]/limits>; see B<proc>(5)."
msgstr "Начиная с Linux 2.6.24, ограничения ресурсов любого процесса можно узнать с помощью I</proc/[pid]/limits>; смотрите B<proc>(5)."

#. type: Plain text
#: man-pages/man2/getrlimit.2:535
msgid ""
"Ancient systems provided a B<vlimit>()  function with a similar purpose to "
"B<setrlimit>().  For backward compatibility, glibc also provides "
"B<vlimit>().  All new applications should be written using B<setrlimit>()."
msgstr "В старых системах была функция B<vlimit>() с подобным B<setrlimit>() назначением. Для обратной совместимости в glibc также есть функция B<vlimit>(). Во всех новых приложениях должен быть использован B<setrlimit>()."

#.  FIXME prlimit() does not suffer
#.  https://bugzilla.kernel.org/show_bug.cgi?id=5042
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
#.  Since versions 2.13, glibc has library implementations of
#.  getrlimit() and setrlimit() that use prlimit() to work around
#.  this bug.
#. type: Plain text
#: man-pages/man2/getrlimit.2:550
msgid ""
"In older Linux kernels, the B<SIGXCPU> and B<SIGKILL> signals delivered when"
" a process encountered the soft and hard B<RLIMIT_CPU> limits were delivered"
" one (CPU) second later than they should have been.  This was fixed in "
"kernel 2.6.8."
msgstr "В старых ядрах Linux сигналы B<SIGXCPU> и B<SIGKILL>, посылаемые когда у процесса обнаруживается достижение мягкого и жёсткого ограничения B<RLIMIT_CPU>, доставляются на одну секунду (ЦП) позднее чем это должно быть. Это исправлено в ядре версии 2.6.8."

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:558
msgid ""
"In 2.6.x kernels before 2.6.17, a B<RLIMIT_CPU> limit of 0 is wrongly "
"treated as \"no limit\" (like B<RLIM_INFINITY>).  Since Linux 2.6.17, "
"setting a limit of 0 does have an effect, but is actually treated as a limit"
" of 1 second."
msgstr "В ядрах 2.6.x до версии 2.6.17, ограничение B<RLIMIT_CPU> равное 0, неправильно воспринималось как «без ограничения» (подобно B<RLIM_INFINITY>). Начиная с Linux 2.6.17, установка ограничения в 0 действует, но реально обрабатывается как ограничение в 1 секунду."

#.  See https://lwn.net/Articles/145008/
#. type: Plain text
#: man-pages/man2/getrlimit.2:563
msgid ""
"A kernel bug means that B<RLIMIT_RTPRIO> does not work in kernel 2.6.12; the"
" problem is fixed in kernel 2.6.13."
msgstr "Из-за дефекта ядра B<RLIMIT_RTPRIO> не работает в версии 2.6.12; это исправлено в ядре 2.6.13."

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:574
msgid ""
"In kernel 2.6.12, there was an off-by-one mismatch between the priority "
"ranges returned by B<getpriority>(2)  and B<RLIMIT_NICE>.  This had the "
"effect that the actual ceiling for the nice value was calculated as I<19\\ "
"-\\ rlim_cur>.  This was fixed in kernel 2.6.13."
msgstr "В ядре 2.6.12 было несоответствие в единицу между диапазонами приоритетов, возвращаемых B<getpriority>(2) и B<RLIMIT_NICE>. Это приводило к тому, что реальный максимум значения nice вычислялся как I<19\\ - \\ rlim_cur>. Исправлено в ядре 2.6.13."

#.  The relevant patch, sent to LKML, seems to be
#.  http://thread.gmane.org/gmane.linux.kernel/273462
#.  From: Roland McGrath <roland <at> redhat.com>
#.  Subject: [PATCH 7/7] make RLIMIT_CPU/SIGXCPU per-process
#.  Date: 2005-01-23 23:27:46 GMT
#.  Tested Solaris 10, FreeBSD 9, OpenBSD 5.0
#.  FIXME https://bugzilla.kernel.org/show_bug.cgi?id=50951
#. type: Plain text
#: man-pages/man2/getrlimit.2:601
msgid ""
"Since Linux 2.6.12, if a process reaches its soft B<RLIMIT_CPU> limit and "
"has a handler installed for B<SIGXCPU>, then, in addition to invoking the "
"signal handler, the kernel increases the soft limit by one second.  This "
"behavior repeats if the process continues to consume CPU time, until the "
"hard limit is reached, at which point the process is killed.  Other "
"implementations do not change the B<RLIMIT_CPU> soft limit in this manner, "
"and the Linux behavior is probably not standards conformant; portable "
"applications should avoid relying on this Linux-specific behavior.  The "
"Linux-specific B<RLIMIT_RTTIME> limit exhibits the same behavior when the "
"soft limit is encountered."
msgstr "Начиная с Linux 2.6.12, если процесс имеет мягкое ограничение B<RLIMIT_CPU> и установлен обработчик для B<SIGXCPU>, то, помимо вызова обработчика сигнала, ядро увеличивает мягкое ограничение на одну секунду. Такое поведение повторяется, если процесс продолжает потреблять процессорное время, и происходит это до тех пор, пока не будет достигнуто жёсткое ограничение, после чего процесс будет завершён. В других реализациях мягкое ограничение B<RLIMIT_CPU> не меняется подобным образом, и поведение Linux, вероятно, нестандартно; переносимые приложения не должны полагаться на данную специфику Linux. Ограничение Linux B<RLIMIT_RTTIME> демонстрирует такое же поведение, при исчерпании мягкого ограничения."

#. type: Plain text
#: man-pages/man2/getrlimit.2:610
msgid ""
"Kernels before 2.4.22 did not diagnose the error B<EINVAL> for "
"B<setrlimit>()  when I<rlim-E<gt>rlim_cur> was greater than "
"I<rlim-E<gt>rlim_max>."
msgstr "В ядрах до 2.4.22 не определялась ошибка B<EINVAL> в B<setrlimit>(), если значение I<rlim-E<gt>rlim_cur> было больше I<rlim-E<gt>rlim_max>."

#. type: Plain text
#: man-pages/man2/getrlimit.2:613
msgid "The program below demonstrates the use of B<prlimit>()."
msgstr "Представленная ниже программа показывает использование B<prlimit>()."

#. type: Plain text
#: man-pages/man2/getrlimit.2:622
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#define _FILE_OFFSET_BITS 64\n#include E<lt>stdio.hE<gt>\n#include E<lt>time.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>sys/resource.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:625
#, no-wrap
msgid ""
"#define errExit(msg) \tdo { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr "#define errExit(msg) \tdo { perror(msg); exit(EXIT_FAILURE); \\e\n                        } while (0)\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:632
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct rlimit old, new;\n    struct rlimit *newp;\n    pid_t pid;\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:638
#, no-wrap
msgid ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> \"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (!(argc == 2 || argc == 4)) {\n        fprintf(stderr, \"Использование: %s E<lt>pidE<gt> [E<lt>новое-мягкое-ограничениеE<gt> \"\n                \"E<lt>новое-жёсткое-ограничениеE<gt>]\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:640
#, no-wrap
msgid "    pid = atoi(argv[1]);        /* PID of target process */\n"
msgstr "    pid = atoi(argv[1]);        /* PID процесса назначения */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:647
#, no-wrap
msgid ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"
msgstr "    newp = NULL;\n    if (argc == 4) {\n        new.rlim_cur = atoi(argv[2]);\n        new.rlim_max = atoi(argv[3]);\n        newp = &new;\n    }\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:650
#, no-wrap
msgid ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"
msgstr "    /* Установить ограничение на время ЦП процесса назначения; \n       получить и показать предыдущее ограничение */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:655
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr "    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n        errExit(\"prlimit-1\");\n    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n            (long long) old.rlim_cur, (long long) old.rlim_max);\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:657
#, no-wrap
msgid "    /* Retrieve and display new CPU time limit */\n"
msgstr "    /* Получить и показать новое ограничение времени ЦП */\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:662
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr "    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n        errExit(\"prlimit-2\");\n    printf(\"Новые ограничения: мягкое=%lld; жёсткое=%lld\\en\",\n            (long long) old.rlim_cur, (long long) old.rlim_max);\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:665
#, no-wrap
msgid ""
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr "    exit(EXIT_FAILURE);\n}\n"

#. type: Plain text
#: man-pages/man2/getrlimit.2:683
msgid ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), "
"B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), "
"B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), "
"B<capabilities>(7), B<signal>(7)"
msgstr "B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), B<capabilities>(7), B<signal>(7)"

#. type: TH
#: man-pages/man2/getitimer.2:12
#, no-wrap
msgid "GETITIMER"
msgstr "GETITIMER"

#. type: TH
#: man-pages/man2/getitimer.2:12
#, no-wrap
msgid "2014-07-08"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:15
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr "getitimer, setitimer - считывает или устанавливает значение таймера интервалов"

#. type: Plain text
#: man-pages/man2/getitimer.2:18
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:20
#, no-wrap
msgid "B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
msgstr "B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:23
#, no-wrap
msgid ""
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr "B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\nB<              struct itimerval *>I<old_value>B<);>\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:29
msgid ""
"The system provides each process with three interval timers, each "
"decrementing in a distinct time domain.  When a timer expires, a signal is "
"sent to the process, and the timer is reset to the specified interval (if "
"nonzero)."
msgstr ""

#. type: TP
#: man-pages/man2/getitimer.2:29
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr "B<ITIMER_REAL>"

#. type: Plain text
#: man-pages/man2/getitimer.2:34
msgid "decrements in real time, and delivers B<SIGALRM> upon expiration."
msgstr "уменьшается в режиме реального времени и выдаёт сигнал B<SIGALRM>, когда значение таймера становится равным 0."

#. type: TP
#: man-pages/man2/getitimer.2:34
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr "B<ITIMER_VIRTUAL>"

#. type: Plain text
#: man-pages/man2/getitimer.2:39
msgid ""
"decrements only when the process is executing, and delivers B<SIGVTALRM> "
"upon expiration."
msgstr "уменьшается только во время работы процесса и выдаёт сигнал B<SIGVTALRM>, когда значение таймера становится равным 0."

#. type: TP
#: man-pages/man2/getitimer.2:39
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr "B<ITIMER_PROF>"

#. type: Plain text
#: man-pages/man2/getitimer.2:49
msgid ""
"decrements both when the process executes and when the system is executing "
"on behalf of the process.  Coupled with B<ITIMER_VIRTUAL>, this timer is "
"usually used to profile the time spent by the application in user and kernel"
" space.  B<SIGPROF> is delivered upon expiration."
msgstr "уменьшается во время работы процесса и когда система выполняет что-либо по заданию процесса. Этот таймер обычно используется вместе с B<ITIMER_VIRTUAL> для профилирования времени работы приложения в пользовательском режиме и режиме ядра. Когда значение таймера становится равным 0, выдаётся сигнал B<SIGPROF>."

#. type: Plain text
#: man-pages/man2/getitimer.2:51
msgid "Timer values are defined by the following structures:"
msgstr "Величина, на которую устанавливается таймер, определяется следующими структурами:"

#. type: Plain text
#: man-pages/man2/getitimer.2:59
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* Interval for periodic timer */\n"
"    struct timeval it_value;    /* Time until next expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:64
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr "struct timeval {\n    time_t      tv_sec;     /* секунды */\n    suseconds_t tv_usec;    /* микросекунды */\n};\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:90
msgid ""
"The function B<getitimer>()  fills the structure pointed to by I<curr_value>"
" with the current value (i.e., the amount of time remaining until the next "
"expiration)  of the timer specified by I<which> (one of B<ITIMER_REAL>, "
"B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>).  The subfields of the field "
"I<it_value> are set to the amount of time remaining on the timer, or zero if"
" the timer is disabled.  The I<it_interval> field is set to the timer "
"interval (period); a value of zero returned in (both subfields of) this "
"field indicates that this is a single-shot timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:101
msgid ""
"The function B<setitimer>()  sets the specified timer to the value in "
"I<new_value>.  If I<old_value> is non-NULL, the old value of the timer "
"(i.e., the same information as returned by B<getitimer>())  is stored there."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:111
msgid ""
"Timers decrement from I<it_value> to zero, generate a signal, and reset to "
"I<it_interval>.  A timer which is set to zero (I<it_value> is zero or the "
"timer expires and I<it_interval> is zero) stops."
msgstr "Значения таймеров уменьшаются от величины I<it_value> до нуля, выдаётся сигнал, и значения вновь устанавливаются равными I<it_interval>. Таймер, установленный на ноль (его величина I<it_value> равна нулю, или время вышло и величина I<it_interval> равна нулю), останавливается."

#. type: Plain text
#: man-pages/man2/getitimer.2:117
msgid ""
"Both I<tv_sec> and I<tv_usec> are significant in determining the duration of"
" a timer."
msgstr "Величины I<tv_sec> и I<tv_usec> являются основными при установке таймера."

#. type: Plain text
#: man-pages/man2/getitimer.2:129
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  Upon expiration, a "
"signal will be generated and the timer reset.  If the timer expires while "
"the process is active (always true for B<ITIMER_VIRTUAL>), the signal will "
"be delivered immediately when generated.  Otherwise, the delivery will be "
"offset by a small time dependent on the system loading."
msgstr "Срок на таймерах никогда не заканчивается ранее указанного времени, но может (чуть-чуть) опоздать, что зависит от степени разрешения системного таймера и загрузки системы; смотрите B<time>(7) (но смотрите ДЕФЕКТЫ далее). По истечении времени будет послан сигнал, а таймер обнулится. Если время таймера истекает во время работы процесса (всегда, если используется B<ITIMER_VIRTUAL>), то сигнал после создания будет доставлен немедленно. Иначе отсылка сигнала откладывается на небольшой промежуток времени, зависящий от степени загруженности системы."

#. type: Plain text
#: man-pages/man2/getitimer.2:142
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr "Указатели I<new_value>, I<old_value> или I<curr_value> являются некорректными."

#. type: Plain text
#: man-pages/man2/getitimer.2:155
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>;"
" or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr "Значение I<which> не равно B<ITIMER_REAL>, B<ITIMER_VIRTUAL> или B<ITIMER_PROF>; или (начиная с Linux 2.6.22) одно из полей структуры I<tv_usec>, указанной в I<new_value>, содержит значение вне диапазона от 0 до 999999."

#. type: Plain text
#: man-pages/man2/getitimer.2:165
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr "POSIX.1-2001, SVr4, 4.4BSD (впервые этот вызов появился в 4.2BSD). В POSIX.1-2008 вызовы B<getitimer>() и B<setitimer>() помечены как устаревшие, и вместо них рекомендуется использовать программный интерфейс таймеров POSIX (B<timer_gettime>(2), B<timer_settime>(2) и т.д.)."

#. type: Plain text
#: man-pages/man2/getitimer.2:171
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr "Потомок, созданный через B<fork>(2), не наследует таймеры интервалов родителя. При вызове B<execve>(2) таймеры интервалов сохраняются."

#. type: Plain text
#: man-pages/man2/getitimer.2:181
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr "В POSIX.1 не определено взаимодействие между B<setitimer>() и тремя интерфейсами: B<alarm>(2), B<sleep>(3) и B<usleep>(3)."

#. type: Plain text
#: man-pages/man2/getitimer.2:183
msgid "The standards are silent on the meaning of the call:"
msgstr "В стандартах ничего не говорится о значении вызова:"

#. type: Plain text
#: man-pages/man2/getitimer.2:185
#, no-wrap
msgid "    setitimer(which, NULL, &old_value);\n"
msgstr "    setitimer(which, NULL, &old_value);\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:188
msgid ""
"Many systems (Solaris, the BSDs, and perhaps others)  treat this as "
"equivalent to:"
msgstr "В многих системах (Solaris, BSD и, возможно, другие) он считается эквивалентом:"

#. type: Plain text
#: man-pages/man2/getitimer.2:190
#, no-wrap
msgid "    getitimer(which, &old_value);\n"
msgstr "    getitimer(which, &old_value);\n"

#. type: Plain text
#: man-pages/man2/getitimer.2:196
msgid ""
"In Linux, this is treated as being equivalent to a call in which the "
"I<new_value> fields are zero; that is, the timer is disabled.  I<Don't use "
"this Linux misfeature>: it is nonportable and unnecessary."
msgstr "В Linux это эквивалентно вызову, в котором поля I<new_value> равны 0, то есть таймер выключен. I<Не используйте это особенность Linux>: это непереносимо и нецелесообразно."

#. type: Plain text
#: man-pages/man2/getitimer.2:205
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an"
" event will be lost."
msgstr "Генерирование и доставка сигнала разделены, и только один экземпляр каждого сигнала, которые описаны выше, может ожидать передачи в процесс. При очень большой нагрузке, ожидание таймера B<ITIMER_REAL> может завершиться раньше чем будет доставлен сигнал о предыдущем завершении. Второй сигнал об этом событии будет потерян."

#. type: Plain text
#: man-pages/man2/getitimer.2:220
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If"
" a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux"
" 2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr "В ядрах Linux до версии 2.6.16, значения таймеров указывались в мигах. Если запрашивалась установка таймера в значение, представление в мигах которого превышало B<MAX_SEC_IN_JIFFIES> (определено в I<include/linux/jiffies.h>), то значение таймера просто урезалось до этого максимального значения. На Linux/i386 (где, начиная с Linux 2.6.13, по умолчанию миг равен 0.004 секунды), это означало, что максимальное значение таймера приблизительно равнялось 99.42 дня. Начиная с Linux 2.6.16, в ядрах стали использовать другое внутреннее представление времени, и этот предел был снят."

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: man-pages/man2/getitimer.2:227
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy"
" under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr "В некоторых системах (включая i386), ядра Linux до версии 2.6.12 содержали дефект, который при определённых условиях приводил к преждевременному завершению за один миг (jiffy). Этот дефект исправлен в ядре 2.6.12."

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: man-pages/man2/getitimer.2:246
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr "В POSIX.1-2001 сказано, что B<setitimer>() должен завершаться с ошибкой, если значение I<tv_usec> лежит вне диапазона от 0 до 999999. Однако, в ядрах до версии 2.6.21 включительно, в Linux ошибка не выдаётся, а вместо этого значение таймера просто подгоняется под соответствующие секунды. Начиная с ядра 2.6.22, это несоответствие убрано: некорректное значение I<tv_usec> приводит к ошибке B<EINVAL>."

#. type: Plain text
#: man-pages/man2/getitimer.2:252
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr "B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), B<timerfd_create>(2), B<time>(7)"

#. type: TH
#: man-pages/man2/getgroups.2:31
#, no-wrap
msgid "GETGROUPS"
msgstr "GETGROUPS"

#. type: TH
#: man-pages/man2/getgroups.2:31
#, no-wrap
msgid "2013-10-18"
msgstr "2013-10-18"

#. type: Plain text
#: man-pages/man2/getgroups.2:34
msgid "getgroups, setgroups - get/set list of supplementary group IDs"
msgstr "getgroups, setgroups - получить/установить список дополнительных идентификаторов групп"

#. type: Plain text
#: man-pages/man2/getgroups.2:40
msgid "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"
msgstr "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"

#. type: Plain text
#: man-pages/man2/getgroups.2:42
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr "B<#include E<lt>grp.hE<gt>>"

#. type: Plain text
#: man-pages/man2/getgroups.2:44
msgid "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"
msgstr "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"

#. type: Plain text
#: man-pages/man2/getgroups.2:52
msgid "B<setgroups>(): _BSD_SOURCE"
msgstr "B<setgroups>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man2/getgroups.2:70
msgid ""
"B<getgroups>()  returns the supplementary group IDs of the calling process "
"in I<list>.  The argument I<size> should be set to the maximum number of "
"items that can be stored in the buffer pointed to by I<list>.  If the "
"calling process is a member of more than I<size> supplementary groups, then "
"an error results.  It is unspecified whether the effective group ID of the "
"calling process is included in the returned list.  (Thus, an application "
"should also call B<getegid>(2)  and add or remove the resulting value.)"
msgstr "Вызов B<getgroups>() возвращает идентификаторы дополнительных групп вызывающего процесса в списке I<list>. В аргументе I<size> должно быть указано максимальное количество элементов, которые можно сохранить в буфер, указанный I<list>. Если вызывающий процесс является членом в более чем I<size> дополнительных групп, то возвращается ошибка. an error results. Для него не определено, будет ли в этот список включён эффективный идентификатор группы вызывающего процесса. (То есть приложение также должно вызвать B<getegid>(2) и добавить или удалить полученное значение.)"

#. type: Plain text
#: man-pages/man2/getgroups.2:81
msgid ""
"If I<size> is zero, I<list> is not modified, but the total number of "
"supplementary group IDs for the process is returned.  This allows the caller"
" to determine the size of a dynamically allocated I<list> to be used in a "
"further call to B<getgroups>()."
msgstr "Если размер I<size> равен нулю, то список I<list> не изменяется, а просто возвращается общее количество идентификаторов дополнительных групп процесса. Это позволяет вызывающему определить размер динамически выделяемого списка I<list>, который будет использоваться при повторном вызове B<getgroups>()."

#. type: Plain text
#: man-pages/man2/getgroups.2:92
msgid ""
"B<setgroups>()  sets the supplementary group IDs for the calling process.  "
"Appropriate privileges (Linux: the B<CAP_SETGID> capability) are required.  "
"The I<size> argument specifies the number of supplementary group IDs in the "
"buffer pointed to by I<list>."
msgstr "Вызов B<setgroups>() устанавливает идентификаторы дополнительных групп для вызывающего процесса. Для работы требуются привилегии (Linux: мандат B<CAP_SETGID>). В аргументе I<size> задаётся количество дополнительных идентификаторов групп в буфере, указанном I<list>."

#. type: Plain text
#: man-pages/man2/getgroups.2:99
msgid ""
"On success, B<getgroups>()  returns the number of supplementary group IDs.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении B<getgroups>() возвращается количество дополнительных идентификаторов. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getgroups.2:106
msgid ""
"On success, B<setgroups>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "При успешном выполнении B<setgroups>() возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/getgroups.2:111
msgid "I<list> has an invalid address."
msgstr "Значение I<list> является неправильным адресом."

#. type: Plain text
#: man-pages/man2/getgroups.2:114
msgid "B<getgroups>()  can additionally fail with the following error:"
msgstr "Вызов B<getgroups>() также может завершиться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man2/getgroups.2:118
msgid ""
"I<size> is less than the number of supplementary group IDs, but is not zero."
msgstr "Значение I<size> меньше чем количество дополнительных идентификаторов групп, но не ноль."

#. type: Plain text
#: man-pages/man2/getgroups.2:121
msgid "B<setgroups>()  can additionally fail with the following errors:"
msgstr "Вызов B<setgroups>() также может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man2/getgroups.2:127
msgid ""
"I<size> is greater than B<NGROUPS_MAX> (32 before Linux 2.6.4; 65536 since "
"Linux 2.6.4)."
msgstr "Значение I<size> больше чем B<NGROUPS_MAX> (32, до Linux 2.6.4; 65536, начиная с Linux 2.6.4)."

#. type: TP
#: man-pages/man2/getgroups.2:127
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/getgroups.2:130
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: Plain text
#: man-pages/man2/getgroups.2:133
msgid "The calling process has insufficient privilege."
msgstr "Вызывающий процесс не имеет достаточно прав."

#. type: Plain text
#: man-pages/man2/getgroups.2:141
msgid ""
"SVr4, 4.3BSD.  The B<getgroups>()  function is in POSIX.1-2001.  Since "
"B<setgroups>()  requires privilege, it is not covered by POSIX.1-2001."
msgstr "SVr4, 4.3BSD. Функции B<getgroups>() нет в POSIX.1-2001. Так как вызов B<setgroups>() требует привилегий, он не описан в POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/getgroups.2:153
msgid ""
"A process can have up to B<NGROUPS_MAX> supplementary group IDs in addition "
"to the effective group ID.  The constant B<NGROUPS_MAX> is defined in "
"I<E<lt>limits.hE<gt>>.  The set of supplementary group IDs is inherited from"
" the parent process, and preserved across an B<execve>(2)."
msgstr "Процесс может иметь, как минимум, B<NGROUPS_MAX> дополнительных идентификаторов групп в дополнении к эффективному идентификатору группы. Константа B<NGROUPS_MAX> определена в I<E<lt>limits.hE<gt>>. Список дополнительных идентификаторов групп наследуется из родительского процесса и сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/getgroups.2:156
msgid ""
"The maximum number of supplementary group IDs can be found at run time using"
" B<sysconf>(3):"
msgstr "Максимальное количество дополнительных идентификаторов групп можно выяснить с помощью B<sysconf>(3):"

#. type: Plain text
#: man-pages/man2/getgroups.2:160
#, no-wrap
msgid ""
"    long ngroups_max;\n"
"    ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"
msgstr "    long ngroups_max;\n    ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"

#. type: Plain text
#: man-pages/man2/getgroups.2:168
msgid ""
"The maximum return value of B<getgroups>()  cannot be larger than one more "
"than this value.  Since Linux 2.6.4, the maximum number of supplementary "
"group IDs is also exposed via the Linux-specific read-only file, "
"I</proc/sys/kernel/ngroups_max>."
msgstr "Максимальное значение, возвращаемое B<getgroups>(), не может быть больше чем на единицу значения, полученного данным способом. Начиная с Linux 2.6.4, максимальное количество идентификаторов дополнительных групп также видимо через специальный файл Linux, доступный только для чтения — I</proc/sys/kernel/ngroups_max>."

#. type: Plain text
#: man-pages/man2/getgroups.2:178
msgid ""
"The original Linux B<getgroups>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<getgroups32>(), supporting 32-bit IDs."
"  The glibc B<getgroups>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr "Первоначальная версия системного вызова B<getgroups>() в Linux поддерживала только 16-битные идентификаторы групп. Позднее в Linux 2.4 был добавлен вызов B<getgroups32>(), поддерживающий 32-битные идентификаторы. В glibc обёрточная функция B<getgroups>() работает одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getgroups.2:184
msgid ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<initgroups>(3), "
"B<capabilities>(7), B<credentials>(7)"
msgstr "B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/gethostname.2:32
#, no-wrap
msgid "GETHOSTNAME"
msgstr "GETHOSTNAME"

#. type: Plain text
#: man-pages/man2/gethostname.2:35
msgid "gethostname, sethostname - get/set hostname"
msgstr "gethostname, sethostname - получить/установить имя узла"

#. type: Plain text
#: man-pages/man2/gethostname.2:39
msgid "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/gethostname.2:41
msgid "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/gethostname.2:50
msgid "B<gethostname>():"
msgstr "B<gethostname>():"

#. type: Plain text
#: man-pages/man2/gethostname.2:53
msgid "Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "Начиная с glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man2/gethostname.2:55
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "|| /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/gethostname.2:58
msgid "B<sethostname>():"
msgstr "B<sethostname>():"

#. type: Plain text
#: man-pages/man2/gethostname.2:60
msgid "_BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr "_BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: man-pages/man2/gethostname.2:66
msgid ""
"These system calls are used to access or to change the hostname of the "
"current processor."
msgstr "Эти системные вызовы используются для доступа или изменения имени узла текущего процессора."

#. type: Plain text
#: man-pages/man2/gethostname.2:77
msgid ""
"B<sethostname>()  sets the hostname to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr "Вызов B<sethostname>() устанавливает имя узла равны значению, указанному в массиве символов I<name>. Аргумент I<len> определяет количество байт в I<name>. (Таким образом, I<name> не требует наличия завершающего байта с null.)"

#. type: Plain text
#: man-pages/man2/gethostname.2:89
msgid ""
"B<gethostname>()  returns the null-terminated hostname in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"hostname is too large to fit, then the name is truncated, and no error is "
"returned (but see NOTES below).  POSIX.1-2001 says that if such truncation "
"occurs, then it is unspecified whether the returned buffer includes a "
"terminating null byte."
msgstr "B<gethostname>() возвращает имя узла с null на конце в массиве символов I<name> длиной I<len> байт. Если имя узла, оканчивающееся null, не помещается, то имя обрезается и ошибки не происходит (но см. ЗАМЕЧАНИЯ далее). В POSIX.1-2001 сказано, что если обрезание произошло, то неясно, будет ли буфер содержать завершающий байт с null."

#. type: Plain text
#: man-pages/man2/gethostname.2:99
msgid "I<name> is an invalid address."
msgstr "I<name> является неправильным адресом. "

#.  Can't occur for gethostbyname() wrapper, since 'len' has an
#.  unsigned type; can occur for the underlying system call.
#. type: Plain text
#: man-pages/man2/gethostname.2:109
msgid ""
"I<len> is negative or, for B<sethostname>(), I<len> is larger than the "
"maximum allowed size."
msgstr "I<len> имеет отрицательное значение или для B<sethostname>() длина I<len> больше, чем максимально допустимое значение."

#. type: TP
#: man-pages/man2/gethostname.2:109
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/gethostname.2:117
msgid ""
"(glibc B<gethostname>())  I<len> is smaller than the actual size.  (Before "
"version 2.1, glibc uses B<EINVAL> for this case.)"
msgstr "(B<gethostname>() из glibc) I<len> меньше чем реальный размер. (До версии 2.1, glibc возвращала в этом случае B<EINVAL>.)"

#. type: Plain text
#: man-pages/man2/gethostname.2:124
msgid ""
"For B<sethostname>(), the caller did not have the B<CAP_SYS_ADMIN> "
"capability."
msgstr "Для работы с B<sethostname>() у вызывающего нет мандата B<CAP_SYS_ADMIN>."

#. type: Plain text
#: man-pages/man2/gethostname.2:130
msgid ""
"SVr4, 4.4BSD (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 "
"specifies B<gethostname>()  but not B<sethostname>()."
msgstr "SVr4, 4.4BSD (данная функция впервые появилась в 4.2BSD). POSIX.1-2001 определяет B<gethostname>(), но не B<sethostname>()."

#. type: Plain text
#: man-pages/man2/gethostname.2:140
msgid ""
"SUSv2 guarantees that \"Host names are limited to 255 bytes\".  POSIX.1-2001"
" guarantees that \"Host names (not including the terminating null byte) are "
"limited to B<HOST_NAME_MAX> bytes\".  On Linux, B<HOST_NAME_MAX> is defined "
"with the value 64, which has been the limit since Linux 1.0 (earlier kernels"
" imposed a limit of 8 bytes)."
msgstr "SUSv2 гарантирует, что \"Длина имени узла ограничивается 255-ми байтами\".  POSIX.1-2001 гарантирует, что \"Длина имени узла (не включая завершающий нулевой символ) ограничивается B<HOST_NAME_MAX> байтами\".  В Linux, значение B<HOST_NAME_MAX> равно 64, которое было урезано начиная с Linux 1.0 (ранние версии имели предел в 8 байт)."

#. type: SS
#: man-pages/man2/gethostname.2:140
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#. type: Plain text
#: man-pages/man2/gethostname.2:163
msgid ""
"The GNU C library does not employ the B<gethostname>()  system call; "
"instead, it implements B<gethostname>()  as a library function that calls "
"B<uname>(2)  and copies up to I<len> bytes from the returned I<nodename> "
"field into I<name>.  Having performed the copy, the function then checks if "
"the length of the I<nodename> was greater than or equal to I<len>, and if it"
" is, then the function returns -1 with I<errno> set to B<ENAMETOOLONG>; in "
"this case, a terminating null byte is not included in the returned I<name>."
msgstr "Библиотека GNU C library не использует системный вызов B<gethostname>(); вместо этого B<gethostname>() в ней реализован в виде библиотечной функции, которая вызывает B<uname>(2) и копирует до I<len> байт в I<name> из возвращаемого поля I<nodename>. Выполнив копирование, функция проверяет, что длина I<nodename> не больше или равна I<len>, и если это обнаруживается, то функция возвращает -1, устанавливая значение  I<errno> равным B<ENAMETOOLONG>; в этом случае в возвращаемое значение I<name> завершающий null не добавляется."

#.  At least glibc 2.0 and 2.1, older versions not checked
#. type: Plain text
#: man-pages/man2/gethostname.2:176
msgid ""
"Versions of glibc before 2.2 handle the case where the length of the "
"I<nodename> was greater than or equal to I<len> differently: nothing is "
"copied into I<name> and the function returns -1 with I<errno> set to "
"B<ENAMETOOLONG>."
msgstr "Версии glibc до 2.2 обрабатывали случай превышения длины I<nodename> по другому: ничего не копировалось в I<name> и функция возвращала -1, устанавливая I<errno> равным B<ENAMETOOLONG>."

#. type: Plain text
#: man-pages/man2/gethostname.2:179
msgid "B<getdomainname>(2), B<setdomainname>(2), B<uname>(2)"
msgstr "B<getdomainname>(2), B<setdomainname>(2), B<uname>(2)"

#. type: TH
#: man-pages/man2/getpagesize.2:25
#, no-wrap
msgid "GETPAGESIZE"
msgstr "GETPAGESIZE"

#. type: TH
#: man-pages/man2/getpagesize.2:25
#, no-wrap
msgid "2010-11-16"
msgstr "2010-11-16"

#. type: Plain text
#: man-pages/man2/getpagesize.2:28
msgid "getpagesize - get memory page size"
msgstr "getpagesize - определяет размер страницы памяти"

#. type: Plain text
#: man-pages/man2/getpagesize.2:32
msgid "B<int getpagesize(void);>"
msgstr "B<int getpagesize(void);>"

#. type: Plain text
#: man-pages/man2/getpagesize.2:39
msgid "B<getpagesize>():"
msgstr "B<getpagesize>():"

#. type: TP
#: man-pages/man2/getpagesize.2:42
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man2/getpagesize.2:47
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr "_BSD_SOURCE ||\n    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: Plain text
#: man-pages/man2/getpagesize.2:52
msgid ""
"Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr "До glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#.  .SH HISTORY
#.  This call first appeared in 4.2BSD.
#. type: Plain text
#: man-pages/man2/getpagesize.2:64
msgid ""
"The function B<getpagesize>()  returns the number of bytes in a memory page,"
" where \"page\" is a fixed-length block, the unit for memory allocation and "
"file mapping performed by B<mmap>(2)."
msgstr "Вызов B<getpagesize>() возвращает количество байтов в странице памяти, где «страница» представляет собой блок фиксированной длины, единица измерения при выделения памяти и файлового отображения, выполняемого с помощью B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/getpagesize.2:71
msgid ""
"SVr4, 4.4BSD, SUSv2.  In SUSv2 the B<getpagesize>()  call is labeled LEGACY,"
" and in POSIX.1-2001 it has been dropped; HP-UX does not have this call."
msgstr "SVr4, 4.4BSD, SUSv2. В SUSv2 вызов B<getpagesize>() отмечен как УСТАРЕВШИЙ, и был удалён из POSIX.1-2001; в HP-UX такого вызова нет."

#. type: Plain text
#: man-pages/man2/getpagesize.2:76
msgid ""
"Portable applications should employ I<sysconf(_SC_PAGESIZE)> instead of "
"B<getpagesize>():"
msgstr "В переносимых программах вместо B<getpagesize>() следует использовать I<sysconf(_SC_PAGESIZE)>:"

#. type: Plain text
#: man-pages/man2/getpagesize.2:81
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"
msgstr "#include E<lt>unistd.hE<gt>\nlong sz = sysconf(_SC_PAGESIZE);\n"

#. type: Plain text
#: man-pages/man2/getpagesize.2:88
msgid "(Most systems allow the synonym B<_SC_PAGE_SIZE> for B<_SC_PAGESIZE>.)"
msgstr "(большинство систем позволяют использовать B<_SC_PAGE_SIZE> вместо B<_SC_PAGESIZE>.)"

#. type: Plain text
#: man-pages/man2/getpagesize.2:108
msgid ""
"Whether B<getpagesize>()  is present as a Linux system call depends on the "
"architecture.  If it is, it returns the kernel symbol B<PAGE_SIZE>, whose "
"value depends on the architecture and machine model.  Generally, one uses "
"binaries that are dependent on the architecture but not on the machine "
"model, in order to have a single binary distribution per architecture.  This"
" means that a user program should not find B<PAGE_SIZE> at compile time from"
" a header file, but use an actual system call, at least for those "
"architectures (like sun4) where this dependency exists.  Here libc4, libc5, "
"glibc 2.0 fail because their B<getpagesize>()  returns a statically derived "
"value, and does not use a system call.  Things are OK in glibc 2.1."
msgstr "В Linux системный вызов B<getpagesize>() есть не на всех архитектурах. Если он есть, то он возвращает символ ядра B<PAGE_SIZE>, чьё значение зависит от архитектуры и модели компьютера. Как правило, создаваемые двоичные файлы используются для всей архитектуры, а не для конкретной одной модели. Поэтому рекомендуется определять B<PAGE_SIZE> не на стадии компиляции из файла заголовка, а при выполнении программы с помощью данной функции, по крайней мере на тех архитектурах (таких как sun4), где зависимость от модели существует. В этом случае в библиотечные вызовы из libc4, libc5, glibc 2.0 завершатся неудачно, так как их B<getpagesize>() возвращает статически определённое значение, и не использует системный вызов. В glibc 2.1 это исправлено."

#. type: Plain text
#: man-pages/man2/getpagesize.2:110
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr "B<mmap>(2), B<sysconf>(3)"

#. type: TH
#: man-pages/man2/getrusage.2:39
#, no-wrap
msgid "GETRUSAGE"
msgstr "GETRUSAGE"

#. type: Plain text
#: man-pages/man2/getrusage.2:42
msgid "getrusage - get resource usage"
msgstr "getrusage - считывает использованные ресурсы"

#. type: Plain text
#: man-pages/man2/getrusage.2:48
msgid "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"
msgstr "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"

#. type: Plain text
#: man-pages/man2/getrusage.2:54
msgid ""
"B<getrusage>()  returns resource usage measures for I<who>, which can be one"
" of the following:"
msgstr "B<getrusage>() возвращает текущие ограничения на ресурсы для значения I<who>, которое может быть:"

#. type: TP
#: man-pages/man2/getrusage.2:54
#, no-wrap
msgid "B<RUSAGE_SELF>"
msgstr "B<RUSAGE_SELF>"

#. type: Plain text
#: man-pages/man2/getrusage.2:58
msgid ""
"Return resource usage statistics for the calling process, which is the sum "
"of resources used by all threads in the process."
msgstr "Возвращает статистику по использованию ресурсов вызывающим процессом (суммируются значения всех нитей процесса)."

#. type: TP
#: man-pages/man2/getrusage.2:58
#, no-wrap
msgid "B<RUSAGE_CHILDREN>"
msgstr "B<RUSAGE_CHILDREN>"

#. type: Plain text
#: man-pages/man2/getrusage.2:65
msgid ""
"Return resource usage statistics for all children of the calling process "
"that have terminated and been waited for.  These statistics will include the"
" resources used by grandchildren, and further removed descendants, if all of"
" the intervening descendants waited on their terminated children."
msgstr "Возвращает статистику по использованию ресурсов всех потомков вызывающего процесса, которые завершились или завершение которых ожидается. Эта статистика включает в себя ресурсы, использованные внучками и дальнейшими потомками, если все промежуточные потомки завершились или их завершение ожидается."

#. type: TP
#: man-pages/man2/getrusage.2:65
#, no-wrap
msgid "B<RUSAGE_THREAD> (since Linux 2.6.26)"
msgstr "B<RUSAGE_THREAD> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/getrusage.2:75
msgid ""
"Return resource usage statistics for the calling thread.  The B<_GNU_SOURCE>"
" feature test macro must be defined (before including I<any> header file)  "
"in order to obtain the definition of this constant from "
"I<E<lt>sys/resource.hE<gt>>."
msgstr "Возвращает статистику по использованию ресурсов вызывающей нити. Чтобы получить определение этой константы из I<E<lt>sys/resource.hE<gt>> должен быть определён макрос тестирования свойств B<_GNU_SOURCE> (до включения всех заголовочных файлов)."

#. type: Plain text
#: man-pages/man2/getrusage.2:79
msgid ""
"The resource usages are returned in the structure pointed to by I<usage>, "
"which has the following form:"
msgstr "Данные по использованным ресурсам возвращаются в структуре, на которую указывает I<usage>; она имеет следующий вид:"

#. type: Plain text
#: man-pages/man2/getrusage.2:100
#, no-wrap
msgid ""
"struct rusage {\n"
"    struct timeval ru_utime; /* user CPU time used */\n"
"    struct timeval ru_stime; /* system CPU time used */\n"
"    long   ru_maxrss;        /* maximum resident set size */\n"
"    long   ru_ixrss;         /* integral shared memory size */\n"
"    long   ru_idrss;         /* integral unshared data size */\n"
"    long   ru_isrss;         /* integral unshared stack size */\n"
"    long   ru_minflt;        /* page reclaims (soft page faults) */\n"
"    long   ru_majflt;        /* page faults (hard page faults) */\n"
"    long   ru_nswap;         /* swaps */\n"
"    long   ru_inblock;       /* block input operations */\n"
"    long   ru_oublock;       /* block output operations */\n"
"    long   ru_msgsnd;        /* IPC messages sent */\n"
"    long   ru_msgrcv;        /* IPC messages received */\n"
"    long   ru_nsignals;      /* signals received */\n"
"    long   ru_nvcsw;         /* voluntary context switches */\n"
"    long   ru_nivcsw;        /* involuntary context switches */\n"
"};\n"
msgstr "struct rusage {\n    struct timeval ru_utime; /* время ЦП, исполь. в режиме пользователя */\n    struct timeval ru_stime; /* время ЦП, исполь. в режиме системы */\n    long   ru_maxrss;        /* максимальный rss */\n    long   ru_ixrss;         /* полный объём общей памяти */\n    long   ru_idrss;         /* полный объём собственной памяти */\n    long   ru_isrss;         /* полный объём собственного стека */\n    long   ru_minflt;        /* количество восстановленных страниц\n                                (мягких отказов) */\n    long   ru_majflt;        /* количество отказавших страниц\n                                (жёстких отказов) */\n    long   ru_nswap;         /* количество обращений при подкачке */\n    long   ru_inblock;       /* количество операций блокового ввода */\n    long   ru_oublock;       /* количество операций блокового вывода */\n    long   ru_msgsnd;        /* количество посланных сообщений IPC */\n    long   ru_msgrcv;        /* количество принятых сообщений IPC */\n    long   ru_nsignals;      /* количество принятых сигналов */\n    long   ru_nvcsw;         /* количество переключений контекста */\n    long   ru_nivcsw;        /* кол-во принудительных переключений контекста */\n};\n"

#. type: Plain text
#: man-pages/man2/getrusage.2:108
msgid ""
"Not all fields are completed; unmaintained fields are set to zero by the "
"kernel.  (The unmaintained fields are provided for compatibility with other "
"systems, and because they may one day be supported on Linux.)  The fields "
"are interpreted as follows:"
msgstr "Не все поля заполняются; несопровождаемые поля устанавливаются ядром в ноль. (Несопровождаемые поля предоставляются для совместимости с другими системами, и когда-нибудь станут поддерживаться в Linux.) Поля следует понимать так:"

#. type: TP
#: man-pages/man2/getrusage.2:108
#, no-wrap
msgid "I<ru_utime>"
msgstr "I<ru_utime>"

#. type: Plain text
#: man-pages/man2/getrusage.2:114
msgid ""
"This is the total amount of time spent executing in user mode, expressed in "
"a I<timeval> structure (seconds plus microseconds)."
msgstr "Общее количество времени, проведённое в режиме пользователя, выражается структурой I<timeval> (секунды и микросекунды)."

#. type: TP
#: man-pages/man2/getrusage.2:114
#, no-wrap
msgid "I<ru_stime>"
msgstr "I<ru_stime>"

#. type: Plain text
#: man-pages/man2/getrusage.2:120
msgid ""
"This is the total amount of time spent executing in kernel mode, expressed "
"in a I<timeval> structure (seconds plus microseconds)."
msgstr "Общее количество времени, проведённое в режиме ядра, выражается структурой I<timeval> (секунды и микросекунды)."

#. type: TP
#: man-pages/man2/getrusage.2:120
#, no-wrap
msgid "I<ru_maxrss> (since Linux 2.6.32)"
msgstr "I<ru_maxrss> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/getrusage.2:127
msgid ""
"This is the maximum resident set size used (in kilobytes).  For "
"B<RUSAGE_CHILDREN>, this is the resident set size of the largest child, not "
"the maximum resident set size of the process tree."
msgstr "Максимальный используемый размер постоянно занимаемый в памяти (в килобайтах). Для B<RUSAGE_CHILDREN> определяется наибольший размер постоянной памяти среди потомков, а не максимальный размер постоянной памяти всего дерева процесса."

#. type: TP
#: man-pages/man2/getrusage.2:127
#, no-wrap
msgid "I<ru_ixrss> (unmaintained)"
msgstr "I<ru_ixrss> (не ведётся)"

#.  On some systems, this field records the number of signals received.
#. type: Plain text
#: man-pages/man2/getrusage.2:133 man-pages/man2/getrusage.2:138
#: man-pages/man2/getrusage.2:143 man-pages/man2/getrusage.2:155
#: man-pages/man2/getrusage.2:167 man-pages/man2/getrusage.2:173
#: man-pages/man2/getrusage.2:177
msgid "This field is currently unused on Linux."
msgstr "В настоящее время в Linux не учитывается."

#. type: TP
#: man-pages/man2/getrusage.2:133
#, no-wrap
msgid "I<ru_idrss> (unmaintained)"
msgstr "I<ru_idrss> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:138
#, no-wrap
msgid "I<ru_isrss> (unmaintained)"
msgstr "I<ru_isrss> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:143
#, no-wrap
msgid "I<ru_minflt>"
msgstr "I<ru_minflt>"

#. type: Plain text
#: man-pages/man2/getrusage.2:148
msgid ""
"The number of page faults serviced without any I/O activity; here I/O "
"activity is avoided by ``reclaiming'' a page frame from the list of pages "
"awaiting reallocation."
msgstr "Количество сбойных страниц, обслуженных без операций ввода-вывода; в данном случае страницы «восстановлены» из списка страниц, ожидающих перемещения."

#. type: TP
#: man-pages/man2/getrusage.2:148
#, no-wrap
msgid "I<ru_majflt>"
msgstr "I<ru_majflt>"

#. type: Plain text
#: man-pages/man2/getrusage.2:151
msgid "The number of page faults serviced that required I/O activity."
msgstr "Количество сбойных страниц, обслуженных с помощью операций ввода-вывода."

#. type: TP
#: man-pages/man2/getrusage.2:151
#, no-wrap
msgid "I<ru_nswap> (unmaintained)"
msgstr "I<ru_nswap> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:155
#, no-wrap
msgid "I<ru_inblock> (since Linux 2.6.22)"
msgstr "I<ru_inblock> (начиная с Linux 2.6.22)"

#. type: Plain text
#: man-pages/man2/getrusage.2:158
msgid "The number of times the filesystem had to perform input."
msgstr "Количество обращений на чтение из файловой системы."

#. type: TP
#: man-pages/man2/getrusage.2:158
#, no-wrap
msgid "I<ru_oublock> (since Linux 2.6.22)"
msgstr "I<ru_oublock> (начиная с Linux 2.6.22)"

#. type: Plain text
#: man-pages/man2/getrusage.2:161
msgid "The number of times the filesystem had to perform output."
msgstr "Количество обращений на запись в файловую систему."

#. type: TP
#: man-pages/man2/getrusage.2:161
#, no-wrap
msgid "I<ru_msgsnd> (unmaintained)"
msgstr "I<ru_msgsnd> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:167
#, no-wrap
msgid "I<ru_msgrcv> (unmaintained)"
msgstr "I<ru_msgrcv> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:173
#, no-wrap
msgid "I<ru_nsignals> (unmaintained)"
msgstr "I<ru_nsignals> (не ведётся)"

#. type: TP
#: man-pages/man2/getrusage.2:177
#, no-wrap
msgid "I<ru_nvcsw> (since Linux 2.6)"
msgstr "I<ru_nvcsw> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man2/getrusage.2:182
msgid ""
"The number of times a context switch resulted due to a process voluntarily "
"giving up the processor before its time slice was completed (usually to "
"await availability of a resource)."
msgstr "Количество переключений контекста в следствии добровольной отдачи процессом процессора до того, как истёк его рабочий временной интервал (обычно, из-за ожидания доступности ресурса)."

#. type: TP
#: man-pages/man2/getrusage.2:182
#, no-wrap
msgid "I<ru_nivcsw> (since Linux 2.6)"
msgstr "I<ru_nivcsw> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man2/getrusage.2:187
msgid ""
"The number of times a context switch resulted due to a higher priority "
"process becoming runnable or because the current process exceeded its time "
"slice."
msgstr "Количество переключений контекста в следствии вытеснения процессом с более высоким приоритетом или из-за истечения рабочего временного интервала процесса."

#. type: Plain text
#: man-pages/man2/getrusage.2:198
msgid "I<usage> points outside the accessible address space."
msgstr "I<usage> указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/getrusage.2:202
msgid "I<who> is invalid."
msgstr "Неверное значение I<who>."

#. type: Plain text
#: man-pages/man2/getrusage.2:210
msgid ""
"SVr4, 4.3BSD.  POSIX.1-2001 specifies B<getrusage>(), but specifies only the"
" fields I<ru_utime> and I<ru_stime>."
msgstr "SVr4, 4.3BSD. В POSIX.1-2001 вызов B<getrusage>() определён, но указаны только поля I<ru_utime> и I<ru_stime>."

#. type: Plain text
#: man-pages/man2/getrusage.2:213
msgid "B<RUSAGE_THREAD> is Linux-specific."
msgstr "B<RUSAGE_THREAD> есть только в Linux."

#. type: Plain text
#: man-pages/man2/getrusage.2:216
msgid "Resource usage metrics are preserved across an B<execve>(2)."
msgstr "Значения использованных ресурсов сохраняются при B<execve>(2)."

#. type: Plain text
#: man-pages/man2/getrusage.2:224
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<struct timeval> is defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr "Включать I<E<lt>sys/time.hE<gt>> в настоящее время не требуется, но это увеличивает переносимость. (Хотя I<struct timeval> определена в I<E<lt>sys/time.hE<gt>>.)"

#.  See the description of getrusage() in XSH.
#.  A similar statement was also in SUSv2.
#. type: Plain text
#: man-pages/man2/getrusage.2:236
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN> then the resource usages of child processes are "
"automatically included in the value returned by B<RUSAGE_CHILDREN>, although"
" POSIX.1-2001 explicitly prohibits this.  This nonconformance is rectified "
"in Linux 2.6.9 and later."
msgstr "В ядрах Linux до версии 2.6.9, если значение B<SIGCHLD> равно B<SIG_IGN>, то использованные ресурсы потомков процессов автоматически включаются в значение, возвращаемое B<RUSAGE_CHILDREN>, хотя в POSIX.1-2001 это явно запрещено. Это несоответствие исправлено в Linux 2.6.9 и более новых версиях."

#. type: Plain text
#: man-pages/man2/getrusage.2:239
msgid ""
"The structure definition shown at the start of this page was taken from "
"4.3BSD Reno."
msgstr "Определение структуры, показанное в начале страницы, взято из 4.3BSD Reno."

#. type: Plain text
#: man-pages/man2/getrusage.2:248
msgid ""
"Ancient systems provided a B<vtimes>()  function with a similar purpose to "
"B<getrusage>().  For backward compatibility, glibc also provides "
"B<vtimes>().  All new applications should be written using B<getrusage>()."
msgstr "В старых системах была функция B<vtimes>() с подобным B<getrusage>() назначением. Для обратной совместимости в glibc также есть функция B<vtimes>(). Во всех новых приложениях должен быть использован B<getrusage>()."

#. type: Plain text
#: man-pages/man2/getrusage.2:253
msgid "See also the description of I</proc/PID/stat> in B<proc>(5)."
msgstr "Смотрите также описание I</proc/PID/stat> в B<proc>(5)."

#. type: Plain text
#: man-pages/man2/getrusage.2:259
msgid ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"
msgstr "B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), B<clock>(3)"

#. type: TH
#: man-pages/man2/gettimeofday.2:40
#, no-wrap
msgid "GETTIMEOFDAY"
msgstr "GETTIMEOFDAY"

#. type: TH
#: man-pages/man2/gettimeofday.2:40
#, no-wrap
msgid "2012-04-26"
msgstr "2012-04-26"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:43
msgid "gettimeofday, settimeofday - get / set time"
msgstr "gettimeofday, settimeofday - получает/устанавливает время"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:48
#, no-wrap
msgid ""
"B<int gettimeofday(struct timeval *>I<tv>B<, struct timezone *>I<tz>B<);>\n"
msgstr "B<int gettimeofday(struct timeval *>I<tv>B<, struct timezone *>I<tz>B<);>\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:51
#, no-wrap
msgid ""
"B<int settimeofday(const struct timeval *>I<tv>B<, const struct timezone "
"*>I<tz>B<);>\n"
msgstr "B<int settimeofday(const struct timeval *>I<tv>B<, const struct timezone *>I<tz>B<);>\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:60
msgid "B<settimeofday>(): _BSD_SOURCE"
msgstr "B<settimeofday>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:72
msgid ""
"The functions B<gettimeofday>()  and B<settimeofday>()  can get and set the "
"time as well as a timezone.  The I<tv> argument is a I<struct timeval> (as "
"specified in I<E<lt>sys/time.hE<gt>>):"
msgstr "Функция B<gettimeofday>() и B<settimeofday>() позволяют получить и задать время, а также часовой пояс. Аргумент I<tv> имеет тип I<struct timeval> (определён в I<E<lt>sys/time.hE<gt>>):"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:79
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;     /* seconds */\n"
"    suseconds_t tv_usec;    /* microseconds */\n"
"};\n"
msgstr "struct timeval {\n    time_t      tv_sec;     /* секунды */\n    suseconds_t tv_usec;    /* микросекунды */\n};\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:88
msgid ""
"and gives the number of seconds and microseconds since the Epoch (see "
"B<time>(2)).  The I<tz> argument is a I<struct timezone>:"
msgstr "и задаёт количество секунд и микросекунд, прошедших с начала эпохи (см. B<time>(2)). Аргумент I<tz> имеет тип I<struct timezone>:"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:95
#, no-wrap
msgid ""
"struct timezone {\n"
"    int tz_minuteswest;     /* minutes west of Greenwich */\n"
"    int tz_dsttime;         /* type of DST correction */\n"
"};\n"
msgstr "struct timezone {\n    int tz_minuteswest;     /* количество минут западнее Гринвича */\n    int tz_dsttime;         /* тип корректировки DST */\n};\n"

#.  FIXME The compilation warning looks to be going away in 2.17
#.  see glibc commit 4b7634a5e03b0da6f8875de9d3f74c1cf6f2a6e8
#.  The following is covered under EPERM below:
#.  .PP
#.  Only the superuser may use
#.  .BR settimeofday ().
#. type: Plain text
#: man-pages/man2/gettimeofday.2:112
msgid ""
"If either I<tv> or I<tz> is NULL, the corresponding structure is not set or "
"returned.  (However, compilation warnings will result if I<tv> is NULL.)"
msgstr "Если I<tv> или I<tz> имеют значение NULL, то соответствующая структура не задана и не будет возвращена (однако при компиляции будут выдаваться предупреждения, если I<tv> равно NULL)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:119
msgid ""
"The use of the I<timezone> structure is obsolete; the I<tz> argument should "
"normally be specified as NULL.  (See NOTES below.)"
msgstr "Пользоваться структурой I<timezone> не рекомендуется; значением аргумента I<tz> в большинстве случаев должен быть NULL (см. ЗАМЕЧАНИЯ далее)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:138
msgid ""
"Under Linux, there are some peculiar \"warp clock\" semantics associated "
"with the B<settimeofday>()  system call if on the very first call (after "
"booting)  that has a non-NULL I<tz> argument, the I<tv> argument is NULL and"
" the I<tz_minuteswest> field is nonzero.  (The I<tz_dsttime> field should be"
" zero for this case.)  In such a case it is assumed that the CMOS clock is "
"on local time, and that it has to be incremented by this amount to get UTC "
"system time.  No doubt it is a bad idea to use this feature."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:145
msgid ""
"B<gettimeofday>()  and B<settimeofday>()  return 0 for success, or -1 for "
"failure (in which case I<errno> is set appropriately)."
msgstr "При успешном выполнении B<gettimeofday>() и B<settimeofday>() возвращают 0, или -1 в случае ошибки (I<errno> устанавливается в соответствующее значение)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:153
msgid "One of I<tv> or I<tz> pointed outside the accessible address space."
msgstr "Одно из значений в I<tv> или I<tz> находится вне доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:156
msgid "Timezone (or something else) is invalid."
msgstr "Неправильный часовой пояс (или что-то ещё)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:163
msgid ""
"The calling process has insufficient privilege to call B<settimeofday>(); "
"under Linux the B<CAP_SYS_TIME> capability is required."
msgstr "У вызывающего процесса недостаточно прав для вызова B<settimeofday>(); в Linux для этого требуется мандат B<CAP_SYS_TIME>."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:174
msgid ""
"SVr4, 4.3BSD.  POSIX.1-2001 describes B<gettimeofday>()  but not "
"B<settimeofday>().  POSIX.1-2008 marks B<gettimeofday>()  as obsolete, "
"recommending the use of B<clock_gettime>(2)  instead."
msgstr "SVr4, 4.3BSD. В POSIX.1-2001 описан B<gettimeofday>(), но нет B<settimeofday>(). В POSIX.1-2008 вызов B<gettimeofday>() помечен как устаревший, вместо него рекомендуется использовать B<clock_gettime>(2)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:182
msgid ""
"The time returned by B<gettimeofday>()  I<is> affected by discontinuous "
"jumps in the system time (e.g., if the system administrator manually changes"
" the system time).  If you need a monotonically increasing clock, see "
"B<clock_gettime>(2)."
msgstr "На время, возвращаемое B<gettimeofday>(), I<влияют> скачки в системном времени (например, если системный администратор вручную изменил системное время). Если вам требуются однообразно увеличивающееся время, смотрите B<clock_gettime>(2)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:187
msgid ""
"Macros for operating on I<timeval> structures are described in "
"B<timeradd>(3)."
msgstr "Для работы со структурой I<timeval> существуют макросы, описанные в B<timeradd>(3)."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:192
msgid "Traditionally, the fields of I<struct timeval> were of type I<long>."
msgstr "Обычно, поля I<struct timeval> имеют тип I<long>."

#.  it has not
#.  been and will not be supported by libc or glibc.
#.  Each and every occurrence of this field in the kernel source
#.  (other than the declaration) is a bug.
#. type: Plain text
#: man-pages/man2/gettimeofday.2:202
msgid ""
"The I<tz_dsttime> field has never been used under Linux.  Thus, the "
"following is purely of historic interest."
msgstr "Поле I<tz_dsttime> никогда не использовалось в Linux. Таким образом, следующий абзац представляет чисто исторический интерес."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:212
msgid ""
"On old systems, the field I<tz_dsttime> contains a symbolic constant (values"
" are given below)  that indicates in which part of the year Daylight Saving "
"Time is in force.  (Note: this value is constant throughout the year: it "
"does not indicate that DST is in force, it just selects an algorithm.)  The "
"daylight saving time algorithms defined are as follows:"
msgstr "В старых системах поле I<tz_dsttime> содержит символьную константу (значения приведены ниже), которая включает в себя информацию о сезонной коррекции времени (Daylight Saving Time) (замечание: эта величина постоянна и указывает лишь на алгоритм коррекции). Существующие алгоритмы сезонной коррекции:"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:216
#, no-wrap
msgid "B<DST_NONE>     /* not on DST */\n"
msgstr "B<DST_NONE>     /* без коррекции (без DST) */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:218
#, no-wrap
msgid "B<DST_USA>      /* USA style DST */\n"
msgstr "B<DST_USA>      /* коррекция для США */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:220
#, no-wrap
msgid "B<DST_AUST>     /* Australian style DST */\n"
msgstr "B<DST_AUST>     /* коррекция для Австралии */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:222
#, no-wrap
msgid "B<DST_WET>      /* Western European DST */\n"
msgstr "B<DST_WET>      /* коррекция для Западной Европы */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:224
#, no-wrap
msgid "B<DST_MET>      /* Middle European DST */\n"
msgstr "B<DST_MET>      /* коррекция для Центральной Европы */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:226
#, no-wrap
msgid "B<DST_EET>      /* Eastern European DST */\n"
msgstr "B<DST_EET>      /* коррекция для Восточной Европы */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:228
#, no-wrap
msgid "B<DST_CAN>      /* Canada */\n"
msgstr "B<DST_CAN>      /* коррекция для Канады */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:230
#, no-wrap
msgid "B<DST_GB>       /* Great Britain and Eire */\n"
msgstr "B<DST_GB>       /* коррекция для Великобритании и Ирландии */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:232
#, no-wrap
msgid "B<DST_RUM>      /* Romania */\n"
msgstr "B<DST_RUM>      /* коррекция для Румынии */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:234
#, no-wrap
msgid "B<DST_TUR>      /* Turkey */\n"
msgstr "B<DST_TUR>      /* коррекция для Турции */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:236
#, no-wrap
msgid "B<DST_AUSTALT>  /* Australian style with shift in 1986 */\n"
msgstr "B<DST_AUSTALT>  /* коррекция для Австралии начиная с 1986 года */\n"

#. type: Plain text
#: man-pages/man2/gettimeofday.2:246
msgid ""
"Of course it turned out that the period in which Daylight Saving Time is in "
"force cannot be given by a simple algorithm, one per country; indeed, this "
"period is determined by unpredictable political decisions.  So this method "
"of representing timezones has been abandoned."
msgstr "Разумеется, коррекцию для каждой страны нельзя описать простым алгоритмом, так как этот фактор может зависеть даже от непредсказуемых политических решений. Поэтому этот метод представления часовых поясов больше не используется."

#. type: Plain text
#: man-pages/man2/gettimeofday.2:255
msgid ""
"B<date>(1), B<adjtimex>(2), B<clock_gettime>(2), B<time>(2), B<ctime>(3), "
"B<ftime>(3), B<timeradd>(3), B<capabilities>(7), B<time>(7)"
msgstr "B<date>(1), B<adjtimex>(2), B<clock_gettime>(2), B<time>(2), B<ctime>(3), B<ftime>(3), B<timeradd>(3), B<capabilities>(7), B<time>(7)"

#. type: TH
#: man-pages/man2/getresuid.2:28
#, no-wrap
msgid "GETRESUID"
msgstr "GETRESUID"

#. type: Plain text
#: man-pages/man2/getresuid.2:31
msgid "getresuid, getresgid - get real, effective and saved user/group IDs"
msgstr "getresuid, getresgid - получение действительного, эффективного и сохранённого идентификатора пользователя или группы"

#. type: Plain text
#: man-pages/man2/getresuid.2:33
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man2/getresuid.2:37
msgid ""
"B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"
msgstr "B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"

#. type: Plain text
#: man-pages/man2/getresuid.2:39
msgid ""
"B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"
msgstr "B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"

#. type: Plain text
#: man-pages/man2/getresuid.2:50
msgid ""
"B<getresuid>()  returns the real UID, the effective UID, and the saved set-"
"user-ID of the calling process, in the arguments I<ruid>, I<euid>, and "
"I<suid>, respectively.  B<getresgid>()  performs the analogous task for the "
"process's group IDs."
msgstr "B<getresuid>() возвращает действительный (real), эффективный (effective) и сохранённый (saved) set-user-ID идентификатор пользователя вызывающего процесса в аргументах I<ruid>, I<euid> и I<suid>, соответственно. B<getresgid>() выполняет аналогичную задачу для идентификаторов группы процесса."

#. type: Plain text
#: man-pages/man2/getresuid.2:60
msgid ""
"One of the arguments specified an address outside the calling program's "
"address space."
msgstr "В одном из аргументов задан адрес вне области адресного пространства вызывающей программы."

#. type: Plain text
#: man-pages/man2/getresuid.2:62
msgid "These system calls appeared on Linux starting with kernel 2.1.44."
msgstr "Данные системные вызовы появились в Linux, начиная с ядра версии 2.1.44."

#. type: Plain text
#: man-pages/man2/getresuid.2:67
msgid ""
"The prototypes are given by glibc since version 2.3.2, provided "
"B<_GNU_SOURCE> is defined."
msgstr "В glibc прототипы появились в версии 2.3.2, они предоставляются при определении B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man2/getresuid.2:70
msgid ""
"These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr "Это нестандартные вызовы; также они есть в HP-UX и некоторых BSD."

#. type: Plain text
#: man-pages/man2/getresuid.2:86
msgid ""
"The original Linux B<getresuid>()  and B<getresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<getresuid32>()  and B<getresgid32>(), supporting 32-bit IDs.  The glibc "
"B<getresuid>()  and B<getresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr "Первоначальные версии системных вызовов B<getresuid>() и B<getresgid>() в Linux поддерживали только 16-битные идентификаторы пользователей и групп. Позднее в Linux 2.4 были добавлены вызовы B<getresuid32>() и B<getresgid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<getresuid>() и B<getresgid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getresuid.2:91
msgid ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<credentials>(7)"
msgstr "B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr "GET_MEMPOLICY"

#. type: TH
#: man-pages/man2/get_mempolicy.2:27
#, no-wrap
msgid "2008-08-15"
msgstr "2008-08-15"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a process"
msgstr "get_mempolicy - получить политику работы с памятью NUMA для процесса"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr "B<#include E<lt>numaif.hE<gt>>"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<int get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, unsigned long >I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr "B<int get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\nB<                  unsigned long >I<maxnode>B<, unsigned long >I<addr>B<,>\nB<                  unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:39
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "Компонуется при указании параметра I<-lnuma>.\n"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling process or of a"
" memory address, depending on the setting of I<flags>."
msgstr "B<get_mempolicy>() возвращает политику NUMA для вызывающего процесса или адреса памяти (в зависимости от значения I<flags>)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:50
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the process."
msgstr "Машина с NUMA имеет различные контроллеры памяти с различными расстояниями до определённых ЦП. Политикой памяти задаётся узел, на котором выделяется память для процесса."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:67
msgid ""
"If I<flags> is specified as 0, then information about the calling process's "
"default policy (as set by B<set_mempolicy>(2))  is returned.  The policy "
"returned [I<mode> and I<nodemask>] may be used to restore the process's "
"policy to its state at the time of the call to B<get_mempolicy>()  using "
"B<set_mempolicy>(2)."
msgstr "Если I<flags> равно 0, то возвращается информация о политике по умолчанию для вызывающем процесса (которая была задана с помощью B<set_mempolicy>(2)). Возвращаемая политика [I<mode> и I<nodemask>] может использоваться для восстановления политики процесса в его состояние на время вызова B<get_mempolicy>() с помощью B<set_mempolicy>(2)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:89
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24),"
" the I<mode> argument is ignored and the set of nodes [memories] that the "
"process is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  [in the absence of any I<mode flags>] is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr "Если I<flags> равно B<MPOL_F_MEMS_ALLOWED> (доступно, начиная с Linux 2.6.24), то аргумент I<mode> игнорируется и набор узлов [их памяти], которые разрешено указывать процессу в последующих вызовах B<mbind>(2) или B<set_mempolicy>(2)  [в отсутствии любых значений I<флагов режима>], возвращается в I<nodemask>. Не разрешено объединять B<MPOL_F_MEMS_ALLOWED> с B<MPOL_F_ADDR> или B<MPOL_F_NODE>."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:103
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the"
" policy governing the memory address given in I<addr>.  This policy may be "
"different from the process's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr "Если I<flags> равно B<MPOL_F_ADDR>, то возвращается информация об управляющей политике адреса памяти, указанного в I<addr>. Эта политика может отличаться от политики процесса по умолчанию, если B<mbind>(2) или одна из вспомогательных функций, описанных в B<numa>(3), были использованы при установлении политики для диапазона памяти, содержащего I<addr>."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:124
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the"
" policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned long)>."
msgstr "Если аргумент I<mode> не равен NULL, то B<get_mempolicy>() сохранит режим политики и все необязательные I<флаги режима> запрашиваемой политики NUMA в место, указанное этим аргументом. Если I<nodemask> не равно NULL, то значение nodemask, связанной с политикой, будет сохранено в место, указанное этим аргументом. В I<maxnode> задаётся количество идентификаторов узлов, которые могут быть сохранены в I<nodemask> \\(em то есть, максимальный идентификатор узла плюс один. Значение, указанное в I<maxnode>, всегда округляется до кратного I<sizeof(unsigned long)>."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:141
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address"
" I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the process had performed a read [load] access to that"
" address, and return the ID of the node where that page was allocated."
msgstr "Если в I<flags> указано B<MPOL_F_NODE> и B<MPOL_F_ADDR>, то B<get_mempolicy>() вернёт идентификатор узла, на котором расположен адрес I<addr> в расположение, заданное I<mode>. Если для указанного адреса страница ещё не выделена, то B<get_mempolicy>() выделит страницу, как если бы процесс выполнил чтение [загрузку] по этому адресу, и вернёт идентификатор узла, на котором была размещена страница."

#.  Note:  code returns next interleave node via 'mode' argument -Lee
#. Schermerhorn
#. type: Plain text
#: man-pages/man2/get_mempolicy.2:166
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"process's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  "
"will return in the location pointed to by a non-NULL I<mode> argument, the "
"node ID of the next node that will be used for interleaving of internal "
"kernel pages allocated on behalf of the process.  These allocations include "
"pages for memory-mapped files in process memory ranges mapped using the "
"B<mmap>(2)  call with the B<MAP_PRIVATE> flag for read accesses, and in "
"memory ranges mapped with the B<MAP_SHARED> flag for all accesses."
msgstr "Если I<flags> содержит B<MPOL_F_NODE>, но не B<MPOL_F_ADDR>, и значение текущей политики процесса равно B<MPOL_INTERLEAVE>, то B<get_mempolicy>() вернёт в расположение, указанное в аргументе I<mode> (не равно NULL), идентификатор узла следующего узла, который будет использован при чередовании внутренних страниц ядра, выделяемых для процесса. Эти выделения содержат страницы памяти отображённых файлов в диапазоне памяти процесса, отображённых с помощью вызова B<mmap>(2) с флагом B<MAP_PRIVATE> для чтения, и в диапазонах памяти, отображённых с флагом B<MAP_SHARED>, для всех операций."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:168
msgid "Other flag values are reserved."
msgstr "Другие значения флагов зарезервированы."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:171
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr "Обзор возможных политик смотрите в B<set_mempolicy>(2)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:178
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<get_mempolicy>() возвращает 0; при ошибке \\(em -1, а в I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:186
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr "Часть всего диапазона памяти, заданная в I<nodemask> и I<maxnode>, указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:230
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current process policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> "
"specified B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or "
"B<MPOL_F_NODE>.  (And there are other B<EINVAL> cases.)"
msgstr "Значение, указанное в I<maxnode>, меньше количества идентификаторов узлов, поддерживаемых системой. Или в I<flags> указаны значения, отличные от B<MPOL_F_NODE> или B<MPOL_F_ADDR>; или в I<flags> указано B<MPOL_F_ADDR> и I<addr> равно NULL, или в I<flags> не указано B<MPOL_F_ADDR> и I<addr> не равно NULL. Или в I<flags> указано B<MPOL_F_NODE>, но не B<MPOL_F_ADDR> и значение текущей политики процесса не равно B<MPOL_INTERLEAVE>. Или в I<flags> указано B<MPOL_F_MEMS_ALLOWED> вместе с B<MPOL_F_ADDR> или B<MPOL_F_NODE>. (И есть другие случаи возврата B<EINVAL>.)"

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:234
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version"
" 2.6.7."
msgstr "Системный вызов B<get_mempolicy>() был добавлен в ядро Linux версии 2.6.7."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:236
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:239
msgid "For information on library support, see B<numa>(7)."
msgstr "Информация о библиотеке доступна в B<numa>(7)."

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:246
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr "B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), B<numa>(7), B<numactl>(8)"

#. type: TH
#: man-pages/man2/get_robust_list.2:29
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr "GET_ROBUST_LIST"

#. type: TH
#: man-pages/man2/get_robust_list.2:29
#, no-wrap
msgid "Linux System Calls"
msgstr "Системные вызовы Linux"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:32
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:37
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:41
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head **>I<head_ptr>B<,>\n"
"B<                     size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t >I<len>B<);>\n"
msgstr "B<long get_robust_list(int >I<pid>B<, struct robust_list_head **>I<head_ptr>B<,>\nB<                     size_t *>I<len_ptr>B<);>\nB<long set_robust_list(struct robust_list_head *>I<head>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:45
msgid ""
"I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr "I<Замечание>: В glibc нет обёрточных функций для этих системных вызовов; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/get_robust_list.2:50
msgid ""
"The robust futex implementation needs to maintain per-thread lists of robust"
" futexes which are unlocked when the thread exits.  These lists are managed "
"in user space; the kernel is notified about only the location of the head of"
" the list."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:66
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:78
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head"
" of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be "
"I<sizeof(*head)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:85
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero"
" when the operation is successful, an error code otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:89
msgid ""
"The B<set_robust_list>()  system call can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:95
msgid ""
"I<len> does not match the size of structure B<struct robust_list_head> "
"expected by kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:99
msgid ""
"The B<get_robust_list>()  system call can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:107
msgid ""
"The calling process does not have permission to see the robust futex list of"
" the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:112
msgid "No thread with the thread ID I<pid> could be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:116
msgid ""
"The head of the robust futex list can't be stored at the location I<head>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:120
msgid ""
"These system calls were added in Linux 2.6.17.  No library support is "
"provided; use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:125
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc.  In the unlikely event that you want to call them"
" directly, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:129
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr ""

#.  .BR pthread_mutexattr_setrobust_np (3)
#. type: Plain text
#: man-pages/man2/get_robust_list.2:132
msgid "B<futex>(2)"
msgstr "B<futex>(2)"

#. type: Plain text
#: man-pages/man2/get_robust_list.2:136
msgid ""
"I<Documentation/robust-futexes.txt> and I<Documentation/robust-futex-"
"ABI.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man2/getuid.2:26
#, no-wrap
msgid "GETUID"
msgstr "GETUID"

#. type: Plain text
#: man-pages/man2/getuid.2:29
msgid "getuid, geteuid - get user identity"
msgstr "getuid, geteuid - получить идентификатор пользователя"

#. type: Plain text
#: man-pages/man2/getuid.2:35
msgid "B<uid_t getuid(void);>"
msgstr "B<uid_t getuid(void);>"

#. type: Plain text
#: man-pages/man2/getuid.2:37
msgid "B<uid_t geteuid(void);>"
msgstr "B<uid_t geteuid(void);>"

#. type: Plain text
#: man-pages/man2/getuid.2:40
msgid "B<getuid>()  returns the real user ID of the calling process."
msgstr "B<getuid>() возвращает фактический идентификатор (ID) пользователя вызывающего процесса. "

#. type: Plain text
#: man-pages/man2/getuid.2:43
msgid "B<geteuid>()  returns the effective user ID of the calling process."
msgstr "B<geteuid>() возвращает эффективный идентификатор пользователя вызывающего процесса."

#. type: SS
#: man-pages/man2/getuid.2:48
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man2/getuid.2:57
msgid ""
"In UNIX\\ V6 the B<getuid>()  call returned I<(euid E<lt>E<lt> 8) + uid>.  "
"UNIX\\ V7 introduced separate calls B<getuid>()  and B<geteuid>()."
msgstr "В UNIX\\ V6 вызов B<getuid>() возвращал I<(euid E<lt>E<lt> 8) + uid>. В UNIX\\ V7 появились отдельные вызовы B<getuid>() и B<geteuid>()."

#. type: Plain text
#: man-pages/man2/getuid.2:73
msgid ""
"The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
"only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
"B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
"B<geteuid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr "Первоначальные версии системных вызовов B<getuid>() и B<geteuid>() в Linux поддерживали только 16-битные идентификаторы пользователей и групп. Позднее в Linux 2.4 были добавлены вызовы B<getuid32>() и B<geteuid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<getuid>() и B<geteuid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/getuid.2:77
msgid "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"
msgstr "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"

#. type: TH
#: man-pages/man2/getdomainname.2:29
#, no-wrap
msgid "GETDOMAINNAME"
msgstr "GETDOMAINNAME"

#. type: TH
#: man-pages/man2/getdomainname.2:29
#, no-wrap
msgid "2012-10-25"
msgstr "2012-10-25"

#. type: Plain text
#: man-pages/man2/getdomainname.2:32
msgid "getdomainname, setdomainname - get/set NIS domain name"
msgstr "getdomainname, setdomainname - получить/установить имя домена NIS"

#. type: Plain text
#: man-pages/man2/getdomainname.2:36
msgid "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/getdomainname.2:38
msgid "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: man-pages/man2/getdomainname.2:47
msgid "B<getdomainname>(), B<setdomainname>():"
msgstr "B<getdomainname>(), B<setdomainname>():"

#. type: Plain text
#: man-pages/man2/getdomainname.2:54
msgid ""
"These functions are used to access or to change the NIS domain name of the "
"host system."
msgstr "Эти функции используются для доступа к имени узла домена NIS или для его изменения."

#. type: Plain text
#: man-pages/man2/getdomainname.2:65
msgid ""
"B<setdomainname>()  sets the domain name to the value given in the character"
" array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr "B<setdomainname>() изменяет доменное имя на значение, указанное в массиве символов I<name>. В аргументе I<len> задаётся количество байт в I<name>. (То есть I<name> может не завершаться байтом с null.)"

#. type: Plain text
#: man-pages/man2/getdomainname.2:75
msgid ""
"B<getdomainname>()  returns the null-terminated domain name in the character"
" array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"domain name requires more than I<len> bytes, B<getdomainname>()  returns the"
" first I<len> bytes (glibc) or gives an error (libc)."
msgstr "B<getdomainname>() возвращает доменное имя с null на конце в массиве символов I<name>, который имеет длину I<len> байт. Если для доменного имени с null на конце требуется больше чем I<len> байт, то B<getdomainname>() возвращает первые I<len> байт (glibc) или возвращает ошибку (libc)."

#. type: Plain text
#: man-pages/man2/getdomainname.2:83
msgid "B<setdomainname>()  can fail with the following errors:"
msgstr "B<setdomainname>() может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man2/getdomainname.2:87
msgid "I<name> pointed outside of user address space."
msgstr "I<name> указывает за пределы пользовательского адресного пространства."

#. type: Plain text
#: man-pages/man2/getdomainname.2:91
msgid "I<len> was negative or too large."
msgstr "Значение I<len> отрицательно или слишком большое."

#. type: Plain text
#: man-pages/man2/getdomainname.2:96
msgid ""
"the caller is unprivileged (Linux: does not have the B<CAP_SYS_ADMIN> "
"capability)."
msgstr "Вызывающий не имеет прав (Linux: не имеет мандата B<CAP_SYS_ADMIN>)."

#. type: Plain text
#: man-pages/man2/getdomainname.2:99
msgid "B<getdomainname>()  can fail with the following errors:"
msgstr "B<getdomainname>() может завершиться со следующими ошибками:"

#. type: Plain text
#: man-pages/man2/getdomainname.2:110
msgid ""
"For B<getdomainname>()  under libc: I<name> is NULL or I<name> is longer "
"than I<len> bytes."
msgstr "Для B<getdomainname>() в libc: значение I<name> равно NULL или I<name> длиннее чем I<len> байт."

#.  But they appear on most systems...
#. type: Plain text
#: man-pages/man2/getdomainname.2:113
msgid "POSIX does not specify these calls."
msgstr "В POSIX нет этих вызовов."

#. type: Plain text
#: man-pages/man2/getdomainname.2:117
msgid ""
"Since Linux 1.0, the limit on the length of a domain name, including the "
"terminating null byte, is 64 bytes.  In older kernels, it was 8 bytes."
msgstr "Начиная с Linux 1.0, длина доменного имени, включая завершающий байт с null, ограничена 64 байтами. В более старых ядрах ограничение было 8 байт."

#. type: Plain text
#: man-pages/man2/getdomainname.2:127
msgid ""
"On most Linux architectures (including x86), there is no B<getdomainname>()"
"  system call; instead, glibc implements B<getdomainname>()  as a library "
"function that returns a copy of the I<domainname> field returned from a call"
" to B<uname>(2)."
msgstr "На большинстве архитектур Linux (включая x86), системный вызов B<getdomainname>() отсутствует; вместо него в библиотеке glibc реализована функция B<getdomainname>(), которая возвращает копию поля I<domainname>, которую возвращает вызов B<uname>(2)."

#. type: Plain text
#: man-pages/man2/getdomainname.2:130
msgid "B<gethostname>(2), B<sethostname>(2), B<uname>(2)"
msgstr "B<gethostname>(2), B<sethostname>(2), B<uname>(2)"

#. type: TH
#: man-pages/man2/get_kernel_syms.2:10
#, no-wrap
msgid "GET_KERNEL_SYMS"
msgstr "GET_KERNEL_SYMS"

#. type: TH
#: man-pages/man2/get_kernel_syms.2:10
#, no-wrap
msgid "2012-10-18"
msgstr "2012-10-18"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:13
msgid "get_kernel_syms - retrieve exported kernel and module symbols"
msgstr "get_kernel_syms - получить экспортируемые символы ядра и модулей"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:16
#, no-wrap
msgid "B<#include E<lt>linux/module.hE<gt>>\n"
msgstr "B<#include E<lt>linux/module.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:18
#, no-wrap
msgid "B<int get_kernel_syms(struct kernel_sym *>I<table>B<);>\n"
msgstr "B<int get_kernel_syms(struct kernel_sym *>I<table>B<);>\n"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:22
msgid "B<Note>: This system call is present only in kernels before Linux 2.6."
msgstr "B<Замечание>: Данный системный вызов доступен только в ядрах до Linux 2.6."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:29
msgid ""
"If I<table> is NULL, B<get_kernel_syms>()  returns the number of symbols "
"available for query.  Otherwise, it fills in a table of structures:"
msgstr "Если I<table> равно NULL, то B<get_kernel_syms>() возвращает количество символов доступных для запроса. Иначе таблица заполняется структурами:"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:36
#, no-wrap
msgid ""
"struct kernel_sym {\n"
"    unsigned long value;\n"
"    char          name[60];\n"
"};\n"
msgstr "struct kernel_sym {\n    unsigned long value;\n    char          name[60];\n};\n"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:44
msgid ""
"The symbols are interspersed with magic symbols of the form B<#>I<module-"
"name> with the kernel having an empty name.  The value associated with a "
"symbol of this form is the address at which the module is loaded."
msgstr "Символы вида B<#>I<module-name> представляют собой ссылки на модули. Значение, связанное с таким символом, содержит адрес, по которому загружен модуль."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:48
msgid ""
"The symbols exported from each module follow their magic module tag and the "
"modules are returned in the reverse of the order in which they were loaded."
msgstr "К символам, экспортируемым из модуля, добавляется метка модуля, а модули возвращаются в обратном порядке, в котором были загружены."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:54
msgid ""
"On success, returns the number of symbols copied to I<table>.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr "При успешном выполнении возвращается количество символов, скопированных в I<table>. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:56
msgid "There is only one possible error return:"
msgstr "Может возвращаться только одна ошибка:"

#. type: TP
#: man-pages/man2/get_kernel_syms.2:56
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:60
msgid "B<get_kernel_syms>()  is not supported in this version of the kernel."
msgstr "Вызов B<get_kernel_syms>() не поддерживается в этой версии ядра."

#.  Removed in Linux 2.5.48
#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:64
msgid ""
"This system call is present on Linux only up until kernel 2.4; it was "
"removed in Linux 2.6."
msgstr "Данный системный вызов есть только в Linux до версии 2.4; он был удалён в Linux 2.6."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:67
msgid "B<get_kernel_syms>()  is Linux-specific."
msgstr "Вызов B<get_kernel_syms>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:72
msgid ""
"There is no way to indicate the size of the buffer allocated for I<table>.  "
"If symbols have been added to the kernel since the program queried for the "
"symbol table size, memory will be corrupted."
msgstr "Нет способа указать размер буфера, выделенного для I<table>. Если символы были добавлены в ядро после того, какпрограмма запросила размер таблицы символов, то это вызовет повреждение данных в памяти."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:74
msgid "The length of exported symbol names is limited to 59 characters."
msgstr "Длина имён экспортируемых символов ограничена 59 знаками."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:80
msgid ""
"Because of these limitations, this system call is deprecated in favor of "
"B<query_module>(2)  (which is itself nowadays deprecated in favor of other "
"interfaces described on its manual page)."
msgstr "Из-за этих ограничений вместо данного системного вызова рекомендуется использовать B<query_module>(2) (который, в настоящее время, тоже устарел и заменён на другие интерфейсы, перечисленные в конце этой справочной страницы)."

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:84
msgid ""
"B<create_module>(2), B<delete_module>(2), B<init_module>(2), "
"B<query_module>(2)"
msgstr "B<create_module>(2), B<delete_module>(2), B<init_module>(2), B<query_module>(2)"

#. type: TH
#: man-pages/man5/group.5:26
#, no-wrap
msgid "GROUP"
msgstr "GROUP"

#. type: TH
#: man-pages/man5/group.5:26
#, no-wrap
msgid "2010-10-21"
msgstr "2010-10-21"

#. type: Plain text
#: man-pages/man5/group.5:29
msgid "group - user group file"
msgstr "group - файл групп пользователей"

#. type: Plain text
#: man-pages/man5/group.5:34
msgid ""
"The I</etc/group> file is a text file that defines the groups on the system."
"  There is one entry per line, with the following format:"
msgstr "В текстовом файле I</etc/group> описаны группы в системе. В каждой строке файла содержится одна запись следующего формата:"

#. type: Plain text
#: man-pages/man5/group.5:37
msgid "group_name:password:GID:user_list"
msgstr "group_name:password:GID:user_list"

#. type: Plain text
#: man-pages/man5/group.5:40
msgid "The fields are as follows:"
msgstr "Поля:"

#. type: TP
#: man-pages/man5/group.5:40
#, no-wrap
msgid "I<group_name>"
msgstr "I<group_name>"

#. type: Plain text
#: man-pages/man5/group.5:43
msgid "the name of the group."
msgstr "имя группы"

#. type: TP
#: man-pages/man5/group.5:43
#, no-wrap
msgid "I<password>"
msgstr "I<password>"

#. type: Plain text
#: man-pages/man5/group.5:47
msgid ""
"the (encrypted) group password.  If this field is empty, no password is "
"needed."
msgstr "пароль группы (в зашифрованном виде). Если это поле пустое, то пароль не нужен."

#. type: TP
#: man-pages/man5/group.5:47
#, no-wrap
msgid "I<GID>"
msgstr "I<GID>"

#. type: Plain text
#: man-pages/man5/group.5:50
msgid "the numeric group ID."
msgstr "числовой идентификатор (ID) группы."

#. type: TP
#: man-pages/man5/group.5:50
#, no-wrap
msgid "I<user_list>"
msgstr "I<user_list>"

#. type: Plain text
#: man-pages/man5/group.5:53
msgid ""
"a list of the usernames that are members of this group, separated by commas."
msgstr "разделённые запятыми имена всех пользователей, которые являются членами данной группы."

#. type: SH
#: man-pages/man5/group.5:53
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man5/group.5:55
msgid "/etc/group"
msgstr "/etc/group"

#. type: Plain text
#: man-pages/man5/group.5:61
msgid ""
"As the 4.2BSD B<initgroups>(3)  man page says: No-one seems to keep "
"I</etc/group> up-to-date."
msgstr "Согласно справочной странице 4.2BSD B<initgroups>(3): похоже, никто не поддерживает актуальность I</etc/group>."

#. type: Plain text
#: man-pages/man5/group.5:66
msgid ""
"B<login>(1), B<newgrp>(1), B<getgrent>(3), B<getgrnam>(3), B<passwd>(5)"
msgstr "B<login>(1), B<newgrp>(1), B<getgrent>(3), B<getgrnam>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man5/gai.conf.5:19
#, no-wrap
msgid "GAI.CONF"
msgstr "GAI.CONF"

#. type: Plain text
#: man-pages/man5/gai.conf.5:22
msgid "gai.conf - getaddrinfo(3) configuration file"
msgstr "gai.conf - файл настройки getaddrinfo(3)"

#. type: Plain text
#: man-pages/man5/gai.conf.5:36
msgid ""
"A call to B<getaddrinfo>(3)  might return multiple answers.  According to "
"RFC\\ 3484 these answers must be sorted so that the answer with the highest "
"success rate is first in the list.  The RFC provides an algorithm for the "
"sorting.  The static rules are not always adequate, though.  For this "
"reason, the RFC also requires that system administrators should have the "
"possibility to dynamically change the sorting.  For the glibc "
"implementation, this can be achieved with the I</etc/gai.conf> file."
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:40
msgid ""
"Each line in the configuration file consists of a keyword and its "
"parameters.  White spaces in any place are ignored.  Lines starting with "
"\\(aq#\\(aq are comments and are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:42
msgid "The keywords currently recognized are:"
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:42
#, no-wrap
msgid "B<label> I<netmask> I<precedence>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:51
msgid ""
"The value is added to the label table used in the RFC\\ 3484 sorting.  If "
"any B<label> definition is present in the configuration file is present, the"
" default table is not used.  All the label definitions of the default table "
"which are to be maintained have to be duplicated.  Following the keyword, "
"the line has to contain a network mask and a label value."
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:51
#, no-wrap
msgid "B<precedence> I<netmask> I<precedence>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:58
msgid ""
"This keyword is similar to B<label>, but instead the value is added to the "
"precedence table as specified in RFC\\ 3484.  Once again, the presence of a "
"single B<precedence> line in the configuration file causes the default table"
" to not be used."
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:58
#, no-wrap
msgid "B<reload> E<lt>B<yes>|B<no>E<gt>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:67
msgid ""
"This keyword controls whether a process checks whether the configuration "
"file has been changed since the last time it was read.  If the value is "
"\"B<yes>\", the file is reread.  This might cause problems in multithreaded "
"applications and is generally a bad idea.  The default is \"B<no>\"."
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:67
#, no-wrap
msgid "B<scopev4> I<mask> I<value>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:72
msgid ""
"Add another rule to the RFC\\ 3484 scope table for IPv4 address.  By "
"default, the scope IDs described in section 3.2 in RFC\\ 3438 are used.  "
"Changing these defaults should hardly ever be necessary."
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:74
msgid "I</etc/gai.conf>"
msgstr "I</etc/gai.conf>"

#. type: Plain text
#: man-pages/man5/gai.conf.5:77
msgid ""
"The default table according to RFC\\ 3484 would be specified with the "
"following configuration file:"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:89
#, no-wrap
msgid ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:95
msgid "B<getaddrinfo>(3), RFC\\ 3484"
msgstr ""

#. type: TH
#: man-pages/man3/gethostbyname.3:38
#, no-wrap
msgid "GETHOSTBYNAME"
msgstr "GETHOSTBYNAME"

#. type: TH
#: man-pages/man3/gethostbyname.3:38
#, no-wrap
msgid "2014-03-11"
msgstr "2014-03-11"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:46
msgid ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - get network host entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:50
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\nB<extern int h_errno;>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:52
#, no-wrap
msgid "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"
msgstr "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:56
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>       /* for AF_INET */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>       /* для AF_INET */\nB<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\nB<                              socklen_t >I<len>B<, int >I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:58
#, no-wrap
msgid "B<void sethostent(int >I<stayopen>B<);>\n"
msgstr "B<void sethostent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:60
#, no-wrap
msgid "B<void endhostent(void);>\n"
msgstr "B<void endhostent(void);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:62
#, no-wrap
msgid "B<void herror(const char *>I<s>B<);>\n"
msgstr "B<void herror(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:64
#, no-wrap
msgid "B<const char *hstrerror(int >I<err>B<);>\n"
msgstr "B<const char *hstrerror(int >I<err>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:66
#, no-wrap
msgid "/* System V/POSIX extension */\n"
msgstr "/* расширение System V/POSIX */\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:68
#, no-wrap
msgid "B<struct hostent *gethostent(void);>\n"
msgstr "B<struct hostent *gethostent(void);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:70
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr "/* расширения GNU */\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:72
#, no-wrap
msgid ""
"B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"
msgstr "B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:76
#, no-wrap
msgid ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostent_r(>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:80
#, no-wrap
msgid ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:84
#, no-wrap
msgid ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostbyname_r(const char *>I<name>B<,>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:88
#, no-wrap
msgid ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr "B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\nB<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\nB<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:102
msgid ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"
msgstr "B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), B<gethostbyname_r>(), B<gethostbyname2_r>():"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:104 man-pages/man3/gethostbyname.3:112
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:108
msgid "B<herror>(), B<hstrerror>():"
msgstr "B<herror>(), B<hstrerror>():"

#. type: TP
#: man-pages/man3/gethostbyname.3:109
#, no-wrap
msgid "Since glibc 2.8:"
msgstr "Начиная с glibc 2.8:"

#. type: TP
#: man-pages/man3/gethostbyname.3:112
#, no-wrap
msgid "Before glibc 2.8:"
msgstr "До glibc 2.8:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:115 man-pages/man3/gethostbyname.3:126
msgid "none"
msgstr "ни одного"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:118
msgid "B<h_errno>:"
msgstr "B<h_errno>:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:123
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_POSIX_C_SOURCE E<lt> 200809L && _XOPEN_SOURCE E<lt> 700)\n"
msgstr "_BSD_SOURCE || _SVID_SOURCE ||\n    (_POSIX_C_SOURCE E<lt> 200809L && _XOPEN_SOURCE E<lt> 700)\n"

#. type: TP
#: man-pages/man3/gethostbyname.3:123
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:143
msgid ""
"The B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>(), and "
"B<hstrerror>()  functions are obsolete.  Applications should use "
"B<getaddrinfo>(3), B<getnameinfo>(3), and B<gai_strerror>(3)  instead."
msgstr "Функции B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>() и B<hstrerror>() являются устаревшими. Вместо них в  приложениях следует использовать B<getaddrinfo>(3), B<getnameinfo>(3) и B<gai_strerror>(3)."

#. type: Plain text
#: man-pages/man3/gethostbyname.3:184
msgid ""
"The B<gethostbyname>()  function returns a structure of type I<hostent> for "
"the given host I<name>.  Here I<name> is either a hostname, or an IPv4 "
"address in standard dot notation (as for B<inet_addr>(3)), or an IPv6 "
"address in colon (and possibly dot) notation.  (See RFC\\ 1884 for the "
"description of IPv6 addresses.)  If I<name> is an IPv4 or IPv6 address, no "
"lookup is performed and B<gethostbyname>()  simply copies I<name> into the "
"I<h_name> field and its I<struct in_addr> equivalent into the "
"I<h_addr_list[0]> field of the returned I<hostent> structure.  If I<name> "
"doesn't end in a dot and the environment variable B<HOSTALIASES> is set, the"
" alias file pointed to by B<HOSTALIASES> will first be searched for I<name> "
"(see B<hostname>(7)  for the file format).  The current domain and its "
"parents are searched unless I<name> ends in a dot."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:200
msgid ""
"The B<gethostbyaddr>()  function returns a structure of type I<hostent> for "
"the given host address I<addr> of length I<len> and address type I<type>.  "
"Valid address types are B<AF_INET> and B<AF_INET6>.  The host address "
"argument is a pointer to a struct of a type depending on the address type, "
"for example a I<struct in_addr *> (probably obtained via a call to "
"B<inet_addr>(3))  for address type B<AF_INET>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:207
msgid ""
"The B<sethostent>()  function specifies, if I<stayopen> is true (1), that a "
"connected TCP socket should be used for the name server queries and that the"
" connection should remain open during successive queries.  Otherwise, name "
"server queries will use UDP datagrams."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:212
msgid ""
"The B<endhostent>()  function ends the use of a TCP connection for name "
"server queries."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:217
msgid ""
"The (obsolete)  B<herror>()  function prints the error message associated "
"with the current value of I<h_errno> on I<stderr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:222
msgid ""
"The (obsolete)  B<hstrerror>()  function takes an error number (typically "
"I<h_errno>) and returns the corresponding message string."
msgstr ""

#.  (See
#.  .BR resolv+ (8)).
#. type: Plain text
#: man-pages/man3/gethostbyname.3:239
msgid ""
"The domain name queries carried out by B<gethostbyname>()  and "
"B<gethostbyaddr>()  use a combination of any or all of the name server "
"B<named>(8), a broken out line from I</etc/hosts>, and the Network "
"Information Service (NIS or YP), depending upon the contents of the I<order>"
" line in I</etc/host.conf>.  The default action is to query B<named>(8), "
"followed by I</etc/hosts>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:241
msgid ""
"The I<hostent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:253
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* for backward compatibility */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:257
msgid "The members of the I<hostent> structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:257
#, no-wrap
msgid "I<h_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:260
msgid "The official name of the host."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:260
#, no-wrap
msgid "I<h_aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:263
msgid ""
"An array of alternative names for the host, terminated by a null pointer."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:263
#, no-wrap
msgid "I<h_addrtype>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:270
msgid "The type of address; always B<AF_INET> or B<AF_INET6> at present."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:270
#, no-wrap
msgid "I<h_length>"
msgstr "I<h_length>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:273
msgid "The length of the address in bytes."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:273
#, no-wrap
msgid "I<h_addr_list>"
msgstr "I<h_addr_list>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:277
msgid ""
"An array of pointers to network addresses for the host (in network byte "
"order), terminated by a null pointer."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:277
#, no-wrap
msgid "I<h_addr>"
msgstr "I<h_addr>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:280
msgid "The first address in I<h_addr_list> for backward compatibility."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:292
msgid ""
"The B<gethostbyname>()  and B<gethostbyaddr>()  functions return the "
"I<hostent> structure or a null pointer if an error occurs.  On error, the "
"I<h_errno> variable holds an error number.  When non-NULL, the return value "
"may point at static data, see the notes below."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:294
msgid "The variable I<h_errno> can have the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:294
#, no-wrap
msgid "B<HOST_NOT_FOUND>"
msgstr "B<HOST_NOT_FOUND>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:297
msgid "The specified host is unknown."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:297
#, no-wrap
msgid "B<NO_ADDRESS> or B<NO_DATA>"
msgstr "B<NO_ADDRESS> или B<NO_DATA>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:300
msgid "The requested name is valid but does not have an IP address."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:300
#, no-wrap
msgid "B<NO_RECOVERY>"
msgstr "B<NO_RECOVERY>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:303
msgid "A nonrecoverable name server error occurred."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:303
#, no-wrap
msgid "B<TRY_AGAIN>"
msgstr "B<TRY_AGAIN>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:307
msgid ""
"A temporary error occurred on an authoritative name server.  Try again "
"later."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:308
#, no-wrap
msgid "I</etc/host.conf>"
msgstr "I</etc/host.conf>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:311
msgid "resolver configuration file"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:311
#, no-wrap
msgid "I</etc/hosts>"
msgstr "I</etc/hosts>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:314
msgid "host database file"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:314
#, no-wrap
msgid "I</etc/nsswitch.conf>"
msgstr "I</etc/nsswitch.conf>"

#. type: Plain text
#: man-pages/man3/gethostbyname.3:317
msgid "name service switch configuration"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:341
msgid ""
"POSIX.1-2001 specifies B<gethostbyname>(), B<gethostbyaddr>(), "
"B<sethostent>(), B<endhostent>(), B<gethostent>(), and I<h_errno>; "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno> are marked "
"obsolescent in that standard.  POSIX.1-2008 removes the specifications of "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno>, recommending the use"
" of B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:351
msgid ""
"The functions B<gethostbyname>()  and B<gethostbyaddr>()  may return "
"pointers to static data, which may be overwritten by later calls.  Copying "
"the I<struct hostent> does not suffice, since it contains pointers; a deep "
"copy is required."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:375
msgid ""
"In the original BSD implementation the I<len> argument of B<gethostbyname>()"
"  was an I<int>.  The SUSv2 standard is buggy and declares the I<len> "
"argument of B<gethostbyaddr>()  to be of type I<size_t>.  (That is wrong, "
"because it has to be I<int>, and I<size_t> is not.  POSIX.1-2001 makes it "
"I<socklen_t>, which is OK.)  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:381
msgid ""
"The BSD prototype for B<gethostbyaddr>()  uses I<const char\\ *> for the "
"first argument."
msgstr ""

#. type: SS
#: man-pages/man3/gethostbyname.3:381
#, no-wrap
msgid "System V/POSIX extension"
msgstr ""

#.  e.g., Linux, FreeBSD, UnixWare, HP-UX
#.  e.g., FreeBSD, AIX
#. type: Plain text
#: man-pages/man3/gethostbyname.3:398
msgid ""
"POSIX requires the B<gethostent>()  call, that should return the next entry "
"in the host data base.  When using DNS/BIND this does not make much sense, "
"but it may be reasonable if the host data base is a file that can be read "
"line by line.  On many systems a routine of this name reads from the file "
"I</etc/hosts>.  It may be available only when the library was built without "
"DNS support.  The glibc version will ignore ipv6 entries.  This function is "
"not reentrant, and glibc adds a reentrant version B<gethostent_r>()."
msgstr ""

#. type: SS
#: man-pages/man3/gethostbyname.3:398
#, no-wrap
msgid "GNU extensions"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:404
msgid ""
"Glibc2 also has a B<gethostbyname2>()  that works like B<gethostbyname>(), "
"but permits to specify the address family to which the address must belong."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:438
msgid ""
"Glibc2 also has reentrant versions B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>()  and B<gethostbyname2_r>().  The caller supplies a "
"I<hostent> structure I<ret> which will be filled in on success, and a "
"temporary work buffer I<buf> of size I<buflen>.  After the call, I<result> "
"will point to the result on success.  In case of an error or if no entry is "
"found I<result> will be NULL.  The functions return 0 on success and a "
"nonzero error number on failure.  In addition to the errors returned by the "
"nonreentrant versions of these functions, if I<buf> is too small, the "
"functions will return B<ERANGE>, and the call should be retried with a "
"larger buffer.  The global variable I<h_errno> is not modified, but the "
"address of a variable in which to store error numbers is passed in "
"I<h_errnop>."
msgstr ""

#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=482973
#. type: Plain text
#: man-pages/man3/gethostbyname.3:443
msgid ""
"B<gethostbyname>()  does not recognize components of a dotted IPv4 address "
"string that are expressed in hexadecimal."
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: man-pages/man3/gethostbyname.3:455
msgid ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), B<hostname>(7), B<named>(8)"

#. type: TH
#: man-pages/man3/getpwnam.3:37
#, no-wrap
msgid "GETPWNAM"
msgstr "GETPWNAM"

#. type: TH
#: man-pages/man3/getpwnam.3:37
#, no-wrap
msgid "2013-07-22"
msgstr "2013-07-22"

#. type: TH
#: man-pages/man3/getpwnam.3:37
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/getpwnam.3:40
msgid "getpwnam, getpwnam_r, getpwuid, getpwuid_r - get password file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:44
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:46
#, no-wrap
msgid "B<struct passwd *getpwnam(const char *>I<name>B<);>\n"
msgstr "B<struct passwd *getpwnam(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:48
#, no-wrap
msgid "B<struct passwd *getpwuid(uid_t >I<uid>B<);>\n"
msgstr "B<struct passwd *getpwuid(uid_t >I<uid>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:50
#, no-wrap
msgid "B<int getpwnam_r(const char *>I<name>B<, struct passwd *>I<pwd>B<,>\n"
msgstr "B<int getpwnam_r(const char *>I<name>B<, struct passwd *>I<pwd>B<,>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:52 man-pages/man3/getpwnam.3:56
#, no-wrap
msgid ""
"B<            char *>I<buf>B<, size_t >I<buflen>B<, struct passwd "
"**>I<result>B<);>\n"
msgstr "B<            char *>I<buf>B<, size_t >I<buflen>B<, struct passwd **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:54
#, no-wrap
msgid "B<int getpwuid_r(uid_t >I<uid>B<, struct passwd *>I<pwd>B<,>\n"
msgstr "B<int getpwuid_r(uid_t >I<uid>B<, struct passwd *>I<pwd>B<,>\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:66
msgid "B<getpwnam_r>(), B<getpwuid_r>():"
msgstr "B<getpwnam_r>(), B<getpwuid_r>():"

#. type: Plain text
#: man-pages/man3/getpwnam.3:69
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"
" || _POSIX_SOURCE"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/getpwnam.3:81
msgid ""
"The B<getpwnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the password database (e.g., the local "
"password file I</etc/passwd>, NIS, and LDAP)  that matches the username "
"I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:88
msgid ""
"The B<getpwuid>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the password database that matches the "
"user ID I<uid>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:90
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:102
#, no-wrap
msgid ""
"struct passwd {\n"
"    char   *pw_name;       /* username */\n"
"    char   *pw_passwd;     /* user password */\n"
"    uid_t   pw_uid;        /* user ID */\n"
"    gid_t   pw_gid;        /* group ID */\n"
"    char   *pw_gecos;      /* user information */\n"
"    char   *pw_dir;        /* home directory */\n"
"    char   *pw_shell;      /* shell program */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:108
msgid "See B<passwd>(5)  for more information about these fields."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:130
msgid ""
"The B<getpwnam_r>()  and B<getpwuid_r>()  functions obtain the same "
"information as B<getpwnam>()  and B<getpwuid>(), but store the retrieved "
"I<passwd> structure in the space pointed to by I<pwd>.  The string fields "
"pointed to by the members of the I<passwd> structure are stored in the "
"buffer I<buf> of size I<buflen>.  A pointer to the result (in case of "
"success) or NULL (in case no entry was found or an error occurred) is stored"
" in I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:132
msgid "The call"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:134
#, no-wrap
msgid "    sysconf(_SC_GETPW_R_SIZE_MAX)\n"
msgstr "    sysconf(_SC_GETPW_R_SIZE_MAX)\n"

#. type: Plain text
#: man-pages/man3/getpwnam.3:143
msgid ""
"returns either -1, without changing I<errno>, or an initial suggested size "
"for I<buf>.  (If this size is too small, the call fails with B<ERANGE>, in "
"which case the caller can retry with a larger buffer.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:158
msgid ""
"The B<getpwnam>()  and B<getpwuid>()  functions return a pointer to a "
"I<passwd> structure, or NULL if the matching entry is not found or an error "
"occurs.  If an error occurs, I<errno> is set appropriately.  If one wants to"
" check I<errno> after the call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:167
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getpwent>(3), B<getpwnam>(), or B<getpwuid>().  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:181
msgid ""
"On success, B<getpwnam_r>()  and B<getpwuid_r>()  return zero, and set "
"I<*result> to I<pwd>.  If no matching password record was found, these "
"functions return 0 and store NULL in I<*result>.  In case of error, an error"
" number is returned, and NULL is stored in I<*result>."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:182
#, no-wrap
msgid "B<0> or B<ENOENT> or B<ESRCH> or B<EBADF> or B<EPERM> or ... "
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:189
msgid "The given I<name> or I<uid> was not found."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:189
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:192
msgid "A signal was caught."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:192
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:195
msgid "I/O error."
msgstr "Ошибка ввода-вывода."

#. type: TP
#: man-pages/man3/getpwnam.3:195
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:200
msgid ""
"The maximum number (B<OPEN_MAX>)  of files was open already in the calling "
"process."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:200
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:203
msgid "The maximum number of files was open already in the system."
msgstr ""

#.  not in POSIX
#.  This structure is static, allocated 0 or 1 times. No memory leak. (libc45)
#. type: Plain text
#: man-pages/man3/getpwnam.3:210
msgid "Insufficient memory to allocate I<passwd> structure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:213
msgid "Insufficient buffer space supplied."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:214
#, no-wrap
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: man-pages/man3/getpwnam.3:217
msgid "local password database file"
msgstr "файл, содержащий базу локальных паролей"

#. type: SH
#: man-pages/man3/getpwnam.3:217
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/getpwnam.3:218
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/getpwnam.3:224
msgid "The B<getpwnam>()  and B<getpwuid>()  functions are not thread-safe."
msgstr "Функции B<getpwnam>() и B<getpwuid>() нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/getpwnam.3:230
msgid "The B<getpwnam_r>()  and B<getpwuid_r>()  functions are thread-safe."
msgstr "Функции B<getpwnam_r>() и B<getpwuid_r>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/getpwnam.3:235
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  The I<pw_gecos> field is not specified in "
"POSIX, but is present on most implementations."
msgstr "SVr4, 4.3BSD, POSIX.1-2001. Поле I<pw_gecos> не определено в стандарте POSIX, но присутствует в большинстве реализаций."

#.  more precisely:
#.  AIX 5.1 - gives ESRCH
#.  OSF1 4.0g - gives EWOULDBLOCK
#.  libc, glibc up to version 2.6, Irix 6.5 - give ENOENT
#.  glibc since version 2.7 - give 0
#.  FreeBSD 4.8, OpenBSD 3.2, NetBSD 1.6 - give EPERM
#.  SunOS 5.8 - gives EBADF
#.  Tru64 5.1b, HP-UX-11i, SunOS 5.7 - give 0
#. type: Plain text
#: man-pages/man3/getpwnam.3:256
msgid ""
"The formulation given above under \"RETURN VALUE\" is from POSIX.1-2001.  It"
" does not call \"not found\" an error, and hence does not specify what value"
" I<errno> might have in this situation.  But that makes it impossible to "
"recognize errors.  One might argue that according to POSIX I<errno> should "
"be left unchanged if an entry is not found.  Experiments on various UNIX-"
"like systems show that lots of different values occur in this situation: 0, "
"ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM, and probably others."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:274
msgid ""
"The I<pw_dir> field contains the name of the initial working directory of "
"the user.  Login programs use the value of this field to initialize the "
"B<HOME> environment variable for the login shell.  An application that wants"
" to determine its user's home directory should inspect the value of B<HOME> "
"(rather than the value I<getpwuid(getuid())-E<gt>pw_dir>)  since this allows"
" the user to modify their notion of \"the home directory\" during a login "
"session.  To determine the (initial) home directory of another user, it is "
"necessary to use I<getpwnam(\"username\")-E<gt>pw_dir> or similar."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:279
msgid ""
"The program below demonstrates the use of B<getpwnam_r>()  to find the full "
"username and user ID for the username supplied as a command-line argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:286
#, no-wrap
msgid ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:295
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct passwd pwd;\n"
"    struct passwd *result;\n"
"    char *buf;\n"
"    size_t bufsize;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:300
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s username\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:304
#, no-wrap
msgid ""
"    bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n"
"    if (bufsize == -1)          /* Value was indeterminate */\n"
"        bufsize = 16384;        /* Should be more than enough */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:310
#, no-wrap
msgid ""
"    buf = malloc(bufsize);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:321
#, no-wrap
msgid ""
"    s = getpwnam_r(argv[1], &pwd, buf, bufsize, &result);\n"
"    if (result == NULL) {\n"
"        if (s == 0)\n"
"            printf(\"Not found\\en\");\n"
"        else {\n"
"            errno = s;\n"
"            perror(\"getpwnam_r\");\n"
"        }\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:325
#, no-wrap
msgid ""
"    printf(\"Name: %s; UID: %ld\\en\", pwd.pw_gecos, (long) pwd.pw_uid);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:335
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getgrnam>(3), B<getpw>(3), "
"B<getpwent>(3), B<getspnam>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"
msgstr "B<endpwent>(3), B<fgetpwent>(3), B<getgrnam>(3), B<getpw>(3), B<getpwent>(3), B<getspnam>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getservent_r.3:26
#, no-wrap
msgid "GETSERVENT_R"
msgstr "GETSERVENT_R"

#. type: TH
#: man-pages/man3/getservent_r.3:26
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: man-pages/man3/getservent_r.3:30
msgid ""
"getservent_r, getservbyname_r, getservbyport_r - get service entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:33
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:36
#, no-wrap
msgid ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr "B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:40
#, no-wrap
msgid ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr "B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\nB<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:44
#, no-wrap
msgid ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr "B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\nB<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:55
msgid "B<getservent_r>(), B<getservbyname_r>(), B<getservbyport_r>():"
msgstr "B<getservent_r>(), B<getservbyname_r>(), B<getservbyport_r>():"

#. type: Plain text
#: man-pages/man3/getservent_r.3:76
msgid ""
"The B<getservent_r>(), B<getservbyname_r>(), and B<getservbyport_r>()  "
"functions are the reentrant equivalents of, respectively, B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  They differ in the way that "
"the I<servent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:82
msgid ""
"Instead of returning a pointer to a statically allocated I<servent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getservent_r.3:99
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<servent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:107
msgid ""
"If the function call successfully obtains a service record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:110
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in errors."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:118
msgid ""
"On error, record not found (B<getservbyname_r>(), B<getservbyport_r>()), or "
"end of input (B<getservent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:123
msgid "(B<getservent_r>())  No more records in database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:130
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:134
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:148
msgid ""
"The program below uses B<getservbyport_r>()  to retrieve the service record "
"for the port and protocol named in its first command-line argument.  If a "
"third (integer) command-line argument is supplied, it is used as the initial"
" value for I<buflen>; if B<getservbyport_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:158
#, no-wrap
msgid ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:170
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>ctype.hE<gt>\n#include E<lt>netdb.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>errno.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:172
#, no-wrap
msgid "#define MAX_BUF 10000\n"
msgstr "#define MAX_BUF 10000\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:182
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
"    char **p;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int buflen, erange_cnt, port, s;\n    struct servent result_buf;\n    struct servent *result;\n    char buf[MAX_BUF];\n    char *protop;\n    char **p;\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:187
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:191
#, no-wrap
msgid ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"              strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:195
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"
msgstr "    buflen = 1024;\n    if (argc E<gt> 3)\n        buflen = atoi(argv[3]);\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:200
#, no-wrap
msgid ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:209
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:212
#, no-wrap
msgid ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:214
#, no-wrap
msgid "            buflen++;\n"
msgstr "            buflen++;\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:221
#, no-wrap
msgid ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"
msgstr "            if (buflen E<gt> MAX_BUF) {\n                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n                exit(EXIT_FAILURE);\n            }\n        }\n    } while (s == ERANGE);\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:225
#, no-wrap
msgid ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr "    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n            strerror(s), buflen);\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:230
#, no-wrap
msgid ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (s != 0 || result == NULL) {\n        printf(\"Call failed/record not found\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:237
#, no-wrap
msgid ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr "    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n                result_buf.s_name, result_buf.s_proto,\n                ntohs(result_buf.s_port));\n    for (p = result_buf.s_aliases; *p != NULL; p++)\n        printf(\"%s \", *p);\n    printf(\"\\en\");\n"

#. type: Plain text
#: man-pages/man3/getservent_r.3:243
msgid "B<getservent>(3), B<services>(5)"
msgstr "B<getservent>(3), B<services>(5)"

#. type: TH
#: man-pages/man3/gethostid.3:29
#, no-wrap
msgid "GETHOSTID"
msgstr "GETHOSTID"

#. type: TH
#: man-pages/man3/gethostid.3:29
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: man-pages/man3/gethostid.3:32
msgid ""
"gethostid, sethostid - get or set the unique identifier of the current host"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:36
msgid "B<long gethostid(void);>"
msgstr "B<long gethostid(void);>"

#. type: Plain text
#: man-pages/man3/gethostid.3:38
msgid "B<int sethostid(long >I<hostid>B<);>"
msgstr "B<int sethostid(long >I<hostid>B<);>"

#. type: Plain text
#: man-pages/man3/gethostid.3:47
msgid "B<gethostid>():"
msgstr "B<gethostid>():"

#. type: Plain text
#: man-pages/man3/gethostid.3:50
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/gethostid.3:52
msgid "B<sethostid>():"
msgstr "B<sethostid>():"

#. type: Plain text
#: man-pages/man3/gethostid.3:67
msgid ""
"B<gethostid>()  and B<sethostid>()  respectively get or set a unique 32-bit "
"identifier for the current machine.  The 32-bit identifier is intended to be"
" unique among all UNIX systems in existence.  This normally resembles the "
"Internet address for the local machine, as returned by B<gethostbyname>(3), "
"and thus usually never needs to be set."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:71
msgid "The B<sethostid>()  call is restricted to the superuser."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:75
msgid ""
"B<gethostid>()  returns the 32-bit identifier for the current host as set by"
" B<sethostid>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:81
msgid ""
"On success, B<sethostid>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:84
msgid "B<sethostid>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:88
msgid ""
"The caller did not have permission to write to the file used to store the "
"host ID."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:92
msgid ""
"The calling process's effective user or group ID is not the same as its "
"corresponding real ID."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:102
msgid ""
"4.2BSD; these functions were dropped in 4.4BSD.  SVr4 includes "
"B<gethostid>()  but not B<sethostid>().  POSIX.1-2001 specifies "
"B<gethostid>()  but not B<sethostid>()."
msgstr ""

#.  libc5 used /etc/hostid; libc4 didn't have these functions
#. type: Plain text
#: man-pages/man3/gethostid.3:111
msgid ""
"In the glibc implementation, the I<hostid> is stored in the file "
"I</etc/hostid>.  (In glibc versions before 2.2, the file I</var/adm/hostid> "
"was used.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:122
msgid ""
"In the glibc implementation, if B<gethostid>()  cannot open the file "
"containing the host ID, then it obtains the hostname using "
"B<gethostname>(2), passes that hostname to B<gethostbyname_r>(3)  in order "
"to obtain the host's IPv4 address, and returns a value obtained by bit-"
"twiddling the IPv4 address.  (This value may not be unique.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:124
msgid "It is impossible to ensure that the identifier is globally unique."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:126
msgid "B<hostid>(1), B<gethostbyname>(3)"
msgstr "B<hostid>(1), B<gethostbyname>(3)"

#. type: TH
#: man-pages/man3/getgrouplist.3:29
#, no-wrap
msgid "GETGROUPLIST"
msgstr "GETGROUPLIST"

#. type: TH
#: man-pages/man3/getgrouplist.3:29
#, no-wrap
msgid "2008-07-03"
msgstr "2008-07-03"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:32
msgid "getgrouplist - get list of groups to which a user belongs"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:36
msgid "B<int getgrouplist(const char *>I<user>B<, gid_t >I<group>B<,>"
msgstr "B<int getgrouplist(const char *>I<user>B<, gid_t >I<group>B<,>"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:38
msgid "B< gid_t *>I<groups>B<, int *>I<ngroups>B<);>"
msgstr "B< gid_t *>I<groups>B<, int *>I<ngroups>B<);>"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:46
msgid "B<getgrouplist>(): _BSD_SOURCE"
msgstr "B<getgrouplist>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:58
msgid ""
"The B<getgrouplist>()  function scans the group database (see B<group>(5))  "
"to obtain the list of groups that I<user> belongs to.  Up to I<*ngroups> of "
"these groups are returned in the array I<groups>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:68
msgid ""
"If it was not among the groups defined for I<user> in the group database, "
"then I<group> is included in the list of groups returned by "
"B<getgrouplist>(); typically this argument is specified as the group ID from"
" the password record for I<user>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:78
msgid ""
"The I<ngroups> argument is a value-result argument: on return it always "
"contains the number of groups found for I<user>, including I<group>; this "
"value may be greater than the number of groups stored in I<groups>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:86
msgid ""
"If the number of groups of which I<user> is a member is less than or equal "
"to I<*ngroups>, then the value I<*ngroups> is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:96
msgid ""
"If the user is a member of more than I<*ngroups> groups, then "
"B<getgrouplist>()  returns -1.  In this case, the value returned in "
"I<*ngroups> can be used to resize the buffer passed to a further call "
"B<getgrouplist>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:98
msgid "This function is present since glibc 2.2.4."
msgstr "Эта функция доступна в glibc начиная с версии 2.2.4."

#. type: Plain text
#: man-pages/man3/getgrouplist.3:100
msgid "This function is nonstandard; it appears on most BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:109
msgid ""
"In glibc versions before 2.3.3, the implementation of this function contains"
" a buffer-overrun bug: it returns the complete list of groups for I<user> in"
" the array I<groups>, even when the number of groups exceeds I<*ngroups>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:118
msgid ""
"The program below displays the group list for the user named in its first "
"command-line argument.  The second command-line argument specifies the "
"I<ngroups> value to be supplied to B<getgrouplist>().  The following shell "
"session shows examples of the use of this program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:128
#, no-wrap
msgid ""
"$B< ./a.out cecilia 0>\n"
"getgrouplist() returned -1; ngroups = 3\n"
"$B< ./a.out cecilia 3>\n"
"ngroups = 3\n"
"16 (dialout)\n"
"33 (video)\n"
"100 (users)\n"
msgstr "$B< ./a.out cecilia 0>\ngetgrouplist() returned -1; ngroups = 3\n$B< ./a.out cecilia 3>\nngroups = 3\n16 (dialout)\n33 (video)\n100 (users)\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:137
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>grp.hE<gt>\n"
"#include E<lt>pwd.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>grp.hE<gt>\n#include E<lt>pwd.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:145
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, ngroups;\n"
"    gid_t *groups;\n"
"    struct passwd *pw;\n"
"    struct group *gr;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int j, ngroups;\n    gid_t *groups;\n    struct passwd *pw;\n    struct group *gr;\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:150
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>userE<gt> E<lt>ngroupsE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s E<lt>userE<gt> E<lt>ngroupsE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:152
#, no-wrap
msgid "    ngroups = atoi(argv[2]);\n"
msgstr "    ngroups = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:158
#, no-wrap
msgid ""
"    groups = malloc(ngroups * sizeof (gid_t));\n"
"    if (groups == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    groups = malloc(ngroups * sizeof (gid_t));\n    if (groups == NULL) {\n        perror(\"malloc\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:160
#, no-wrap
msgid "    /* Fetch passwd structure (contains first group ID for user) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:166
#, no-wrap
msgid ""
"    pw = getpwnam(argv[1]);\n"
"    if (pw == NULL) {\n"
"        perror(\"getpwnam\");\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr "    pw = getpwnam(argv[1]);\n    if (pw == NULL) {\n        perror(\"getpwnam\");\n        exit(EXIT_SUCCESS);\n    }\n"

#. type: Plain text
#: man-pages/man3/getgrouplist.3:168
#, no-wrap
msgid "    /* Retrieve group list */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:174
#, no-wrap
msgid ""
"    if (getgrouplist(argv[1], pw-E<gt>pw_gid, groups, &ngroups) == -1) {\n"
"        fprintf(stderr, \"getgrouplist() returned -1; ngroups = %d\\en\",\n"
"                ngroups);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:176
#, no-wrap
msgid "    /* Display list of retrieved groups, along with group names */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:185
#, no-wrap
msgid ""
"    fprintf(stderr, \"ngroups = %d\\en\", ngroups);\n"
"    for (j = 0; j E<lt> ngroups; j++) {\n"
"        printf(\"%d\", groups[j]);\n"
"        gr = getgrgid(groups[j]);\n"
"        if (gr != NULL)\n"
"            printf(\" (%s)\", gr-E<gt>gr_name);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:194
msgid ""
"B<getgroups>(2), B<setgroups>(2), B<getgrent>(3), B<group>(5), B<passwd>(5)"
msgstr "B<getgroups>(2), B<setgroups>(2), B<getgrent>(3), B<group>(5), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getw.3:25
#, no-wrap
msgid "GETW"
msgstr "GETW"

#. type: Plain text
#: man-pages/man3/getw.3:28
msgid "getw, putw - input and output of words (ints)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:31
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getw.3:33
#, no-wrap
msgid "B<int getw(FILE *>I<stream>B<);>\n"
msgstr "B<int getw(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getw.3:35
#, no-wrap
msgid "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getw.3:44
msgid "B<getw>(), B<putw>():"
msgstr "B<getw>(), B<putw>():"

#. type: TP
#: man-pages/man3/getw.3:47
#, no-wrap
msgid "Since glibc 2.3.3:"
msgstr "Начиная с glibc 2.3.3:"

#. type: Plain text
#: man-pages/man3/getw.3:50
msgid "_SVID_SOURCE || _BSD_SOURCE ||"
msgstr "_SVID_SOURCE || _BSD_SOURCE ||"

#. type: Plain text
#: man-pages/man3/getw.3:53
#, no-wrap
msgid ""
"(_XOPEN_SOURCE &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600))\n"
msgstr "(_XOPEN_SOURCE &&\n    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600))\n"

#. type: TP
#: man-pages/man3/getw.3:53
#, no-wrap
msgid "Before glibc 2.3.3:"
msgstr "До glibc 2.3.3:"

#. type: Plain text
#: man-pages/man3/getw.3:56
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: man-pages/man3/getw.3:66
msgid ""
"B<getw>()  reads a word (that is, an I<int>) from I<stream>.  It's provided "
"for compatibility with SVr4.  We recommend you use B<fread>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:73
msgid ""
"B<putw>()  writes the word I<w> (that is, an I<int>) to I<stream>.  It is "
"provided for compatibility with SVr4, but we recommend you use B<fwrite>(3)"
"  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:80
msgid ""
"Normally, B<getw>()  returns the word read, and B<putw>()  returns 0.  On "
"error, they return B<EOF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:83
msgid "SVr4, SUSv2.  Not present in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:87
msgid ""
"The value returned on error is also a legitimate data value.  B<ferror>(3)  "
"can be used to distinguish between the two cases."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:92
msgid "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"
msgstr "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"

#. type: TH
#: man-pages/man3/getpwent.3:33
#, no-wrap
msgid "GETPWENT"
msgstr "GETPWENT"

#. type: TH
#: man-pages/man3/getpwent.3:33
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: man-pages/man3/getpwent.3:36
msgid "getpwent, setpwent, endpwent - get password file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:42
#, no-wrap
msgid "B<struct passwd *getpwent(void);>\n"
msgstr "B<struct passwd *getpwent(void);>\n"

#. type: Plain text
#: man-pages/man3/getpwent.3:44
#, no-wrap
msgid "B<void setpwent(void);>\n"
msgstr "B<void setpwent(void);>\n"

#. type: Plain text
#: man-pages/man3/getpwent.3:46
#, no-wrap
msgid "B<void endpwent(void);>\n"
msgstr "B<void endpwent(void);>\n"

#. type: Plain text
#: man-pages/man3/getpwent.3:57
msgid "B<getpwent>(), B<setpwent>(), B<endpwent>():"
msgstr "B<getpwent>(), B<setpwent>(), B<endpwent>():"

#. type: Plain text
#: man-pages/man3/getpwent.3:60
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/getpwent.3:74
msgid ""
"The B<getpwent>()  function returns a pointer to a structure containing the "
"broken-out fields of a record from the password database (e.g., the local "
"password file I</etc/passwd>, NIS, and LDAP).  The first time B<getpwent>()"
"  is called, it returns the first entry; thereafter, it returns successive "
"entries."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:79
msgid ""
"The B<setpwent>()  function rewinds to the beginning of the password "
"database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:84
msgid ""
"The B<endpwent>()  function is used to close the password database after all"
" processing has been performed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:103
msgid ""
"For more information about the fields of this structure, see B<passwd>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:116
msgid ""
"The B<getpwent>()  function returns a pointer to a I<passwd> structure, or "
"NULL if there are no more entries or an error occurred.  If an error occurs,"
" I<errno> is set appropriately.  If one wants to check I<errno> after the "
"call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:125
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getpwent>(), B<getpwnam>(3), or B<getpwuid>(3).  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:159
msgid "The B<getpwent>()  function is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:165
msgid "The B<setpwent>()  and B<endpwent>()  functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:177
msgid ""
"B<fgetpwent>(3), B<getpw>(3), B<getpwent_r>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"
msgstr "B<fgetpwent>(3), B<getpw>(3), B<getpwent_r>(3), B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getnameinfo.3:10
#, no-wrap
msgid "GETNAMEINFO"
msgstr "GETNAMEINFO"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:13
msgid ""
"getnameinfo - address-to-name translation in protocol-independent manner"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:17
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\nB<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:21
#, no-wrap
msgid ""
"B<int getnameinfo(const struct sockaddr *>I<sa>B<, socklen_t >I<salen>B<,>\n"
"B<                char *>I<host>B<, socklen_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, socklen_t >I<servlen>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:31
msgid ""
"B<getnameinfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr "B<getnameinfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:47
msgid ""
"The B<getnameinfo>()  function is the inverse of B<getaddrinfo>(3): it "
"converts a socket address to a corresponding host and service, in a "
"protocol-independent manner.  It combines the functionality of "
"B<gethostbyaddr>(3)  and B<getservbyport>(3), but unlike those functions, "
"B<getnameinfo>()  is reentrant and allows programs to eliminate IPv4-versus-"
"IPv6 dependencies."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:70
msgid ""
"The I<sa> argument is a pointer to a generic socket address structure (of "
"type I<sockaddr_in> or I<sockaddr_in6>)  of size I<salen> that holds the "
"input IP address and port number.  The arguments I<host> and I<serv> are "
"pointers to caller-allocated buffers (of size I<hostlen> and I<servlen> "
"respectively) into which B<getnameinfo>()  places null-terminated strings "
"containing the host and service names respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:83
msgid ""
"The caller can specify that no hostname (or no service name)  is required by"
" providing a NULL I<host> (or I<serv>)  argument or a zero I<hostlen> (or "
"I<servlen>)  argument.  However, at least one of hostname or service name "
"must be requested."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:89
msgid ""
"The I<flags> argument modifies the behavior of B<getnameinfo>()  as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:89
#, no-wrap
msgid "B<NI_NAMEREQD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:92
msgid ""
"If set, then an error is returned if the hostname cannot be determined."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:92
#, no-wrap
msgid "B<NI_DGRAM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:98
msgid ""
"If set, then the service is datagram (UDP) based rather than stream (TCP) "
"based.  This is required for the few ports (512-514)  that have different "
"services for UDP and TCP."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:98
#, no-wrap
msgid "B<NI_NOFQDN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:102
msgid ""
"If set, return only the hostname part of the fully qualified domain name for"
" local hosts."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:102
#, no-wrap
msgid "B<NI_NUMERICHOST>"
msgstr ""

#.  For example, by calling
#.  .BR inet_ntop ()
#.  instead of
#.  .BR gethostbyaddr ().
#.  POSIX.1-2003 has NI_NUMERICSCOPE, but glibc doesn't have it.
#. type: Plain text
#: man-pages/man3/getnameinfo.3:112
msgid ""
"If set, then the numeric form of the hostname is returned.  (When not set, "
"this will still happen in case the node's name cannot be determined.)"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:112
#, no-wrap
msgid "B<NI_NUMERICSERV>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:117
msgid ""
"If set, then the numeric form of the service address is returned.  (When not"
" set, this will still happen in case the service's name cannot be "
"determined.)"
msgstr ""

#. type: SS
#: man-pages/man3/getnameinfo.3:117
#, no-wrap
msgid "Extensions to getnameinfo() for Internationalized Domain Names"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:126
msgid ""
"Starting with glibc 2.3.4, B<getnameinfo>()  has been extended to "
"selectively allow hostnames to be transparently converted to and from the "
"Internationalized Domain Name (IDN) format (see RFC 3490, "
"I<Internationalizing Domain Names in Applications (IDNA)>).  Three new flags"
" are defined:"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:126
#, no-wrap
msgid "B<NI_IDN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:132
msgid ""
"If this flag is used, then the name found in the lookup process is converted"
" from IDN format to the locale's encoding if necessary.  ASCII-only names "
"are not affected by the conversion, which makes this flag usable in existing"
" programs and environments."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:132
#, no-wrap
msgid "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:139
msgid ""
"Setting these flags will enable the IDNA_ALLOW_UNASSIGNED (allow unassigned "
"Unicode code points) and IDNA_USE_STD3_ASCII_RULES (check output to make "
"sure it is a STD3 conforming hostname)  flags respectively to be used in the"
" IDNA handling."
msgstr "Установка этих флагов включает IDNA_ALLOW_UNASSIGNED (разрешать неназначенные кодовые точки Юникода) и IDNA_USE_STD3_ASCII_RULES (проверять вывод на соответствие имени узла STD3) соответственно для возможности работы с IDNA."

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getnameinfo(); they need to
#.  be documented.
#.  #ifdef __USE_GNU
#.  #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.  #define EAI_CANCELED    -101  /* Request canceled.  */
#.  #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.  #define EAI_ALLDONE     -103  /* All requests done.  */
#.  #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.  #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.  #endif
#. type: Plain text
#: man-pages/man3/getnameinfo.3:155
msgid ""
"On success 0 is returned, and node and service names, if requested, are "
"filled with null-terminated strings, possibly truncated to fit the specified"
" buffer lengths.  On error, one of the following nonzero error codes is "
"returned:"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:155
#, no-wrap
msgid "B<EAI_AGAIN>"
msgstr "B<EAI_AGAIN>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:159
msgid "The name could not be resolved at this time.  Try again later."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:159
#, no-wrap
msgid "B<EAI_BADFLAGS>"
msgstr "B<EAI_BADFLAGS>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:164
msgid "The I<flags> argument has an invalid value."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:164
#, no-wrap
msgid "B<EAI_FAIL>"
msgstr "B<EAI_FAIL>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:167
msgid "A nonrecoverable error occurred."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:167
#, no-wrap
msgid "B<EAI_FAMILY>"
msgstr "B<EAI_FAMILY>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:171
msgid ""
"The address family was not recognized, or the address length was invalid for"
" the specified family."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:171
#, no-wrap
msgid "B<EAI_MEMORY>"
msgstr "B<EAI_MEMORY>"

#. type: TP
#: man-pages/man3/getnameinfo.3:174
#, no-wrap
msgid "B<EAI_NONAME>"
msgstr "B<EAI_NONAME>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:180
msgid ""
"The name does not resolve for the supplied arguments.  B<NI_NAMEREQD> is set"
" and the host's name cannot be located, or neither hostname nor service name"
" were requested."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:180
#, no-wrap
msgid "B<EAI_OVERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:187
msgid "The buffer pointed to by I<host> or I<serv> was too small."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:187
#, no-wrap
msgid "B<EAI_SYSTEM>"
msgstr "B<EAI_SYSTEM>"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:192
msgid "A system error occurred.  The error code can be found in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:197
msgid ""
"The B<gai_strerror>(3)  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:199
msgid "/etc/hosts"
msgstr "/etc/hosts"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:201
msgid "/etc/nsswitch.conf"
msgstr "/etc/nsswitch.conf"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:203
msgid "/etc/resolv.conf"
msgstr "/etc/resolv.conf"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:206
msgid "B<getnameinfo>()  is provided in glibc since version 2.1."
msgstr "Функция B<getnameinfo>() появилась в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:208
msgid "RFC\\ 2553, POSIX.1-2001."
msgstr "RFC\\ 2553, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/getnameinfo.3:213
msgid ""
"In order to assist the programmer in choosing reasonable sizes for the "
"supplied buffers, I<E<lt>netdb.hE<gt>> defines the constants"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:218
#, no-wrap
msgid ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"
msgstr "#define NI_MAXHOST      1025\n#define NI_MAXSERV      32\n"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:228
msgid ""
"Since glibc 2.8, these definitions are exposed only if one of the feature "
"test macros B<_BSD_SOURCE>, B<_SVID_SOURCE>, or B<_GNU_SOURCE> is defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:236
msgid ""
"The former is the constant B<MAXDNAME> in recent versions of BIND's "
"I<E<lt>arpa/nameser.hE<gt>> header file.  The latter is a guess based on the"
" services listed in the current Assigned Numbers RFC."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:243
msgid ""
"Before glibc version 2.2, the I<hostlen> and I<servlen> arguments were typed"
" as I<size_t>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:248
msgid ""
"The following code tries to get the numeric hostname and service name, for a"
" given socket address.  Note that there is no hardcoded reference to a "
"particular address family."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:254
#, no-wrap
msgid ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:258
#, no-wrap
msgid ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:263
msgid ""
"The following version checks if the socket address has a reverse address "
"mapping."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:269
#, no-wrap
msgid ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:275
#, no-wrap
msgid ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:282
msgid ""
"An example program using B<getnameinfo>()  can be found in "
"B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:297
msgid ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), "
"B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"
msgstr "B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), B<hostname>(7), B<named>(8)"

#. type: Plain text
#: man-pages/man3/getnameinfo.3:301
msgid ""
"R. Gilligan, S. Thomson, J. Bound and W. Stevens, I<Basic Socket Interface "
"Extensions for IPv6>, RFC\\ 2553, March 1999."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:307
msgid ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR ftp://ftp.ietf.org"
"\\:/internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:312
msgid ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:314
msgid ""
"E<.UR "
"http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/usenix2000\\:/freenix\\:/metzprotocol.html>"
" E<.UE .>"
msgstr ""

#. type: TH
#: man-pages/man3/getgrent.3:30
#, no-wrap
msgid "GETGRENT"
msgstr "GETGRENT"

#. type: Plain text
#: man-pages/man3/getgrent.3:33
msgid "getgrent, setgrent, endgrent - get group file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>grp.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>grp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:39
#, no-wrap
msgid "B<struct group *getgrent(void);>\n"
msgstr "B<struct group *getgrent(void);>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:41
#, no-wrap
msgid "B<void setgrent(void);>\n"
msgstr "B<void setgrent(void);>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:43
#, no-wrap
msgid "B<void endgrent(void);>\n"
msgstr "B<void endgrent(void);>\n"

#. type: Plain text
#: man-pages/man3/getgrent.3:53
msgid "B<setgrent>():"
msgstr "B<setgrent>():"

#. type: Plain text
#: man-pages/man3/getgrent.3:56
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED ||"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED ||"

#. type: Plain text
#: man-pages/man3/getgrent.3:58
msgid "/* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "/* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: man-pages/man3/getgrent.3:62
msgid "B<getgrent>(), B<endgrent>():"
msgstr "B<getgrent>(), B<endgrent>():"

#. type: Plain text
#: man-pages/man3/getgrent.3:65
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/getgrent.3:80
msgid ""
"The B<getgrent>()  function returns a pointer to a structure containing the "
"broken-out fields of a record in the group database (e.g., the local group "
"file I</etc/group>, NIS, and LDAP).  The first time B<getgrent>()  is "
"called, it returns the first entry; thereafter, it returns successive "
"entries."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:85
msgid ""
"The B<setgrent>()  function rewinds to the beginning of the group database, "
"to allow repeated scans."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:90
msgid ""
"The B<endgrent>()  function is used to close the group database after all "
"processing has been performed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:92
msgid "The I<group> structure is defined in I<E<lt>grp.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:102
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;        /* group name */\n"
"    char   *gr_passwd;      /* group password */\n"
"    gid_t   gr_gid;         /* group ID */\n"
"    char  **gr_mem;         /* NULL-terminated array of pointers\n"
"                               to names of group members */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:107
msgid ""
"For more information about the fields of this structure, see B<group>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:114
msgid ""
"The B<getgrent>()  function returns a pointer to a I<group> structure, or "
"NULL if there are no more entries or an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:121
msgid ""
"Upon error, I<errno> may be set.  If one wants to check I<errno> after the "
"call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:130
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getgrent>(), B<getgrgid>(3), or B<getgrnam>(3).  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:140
msgid "The calling process already has too many open files."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:143
msgid "Too many open files in the system."
msgstr ""

#.  not in POSIX
#. type: Plain text
#: man-pages/man3/getgrent.3:149
msgid "Insufficient memory to allocate I<group> structure."
msgstr ""

#. type: TP
#: man-pages/man3/getgrent.3:153
#, no-wrap
msgid "I</etc/group>"
msgstr "I</etc/group>"

#. type: Plain text
#: man-pages/man3/getgrent.3:156
msgid "local group database file"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:161
msgid "The B<getgrent>()  function is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:167
msgid "The B<setgrent>()  and B<endgrent>()  functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:169
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/getgrent.3:176
msgid ""
"B<fgetgrent>(3), B<getgrent_r>(3), B<getgrgid>(3), B<getgrnam>(3), "
"B<getgrouplist>(3), B<putgrent>(3), B<group>(5)"
msgstr "B<fgetgrent>(3), B<getgrent_r>(3), B<getgrgid>(3), B<getgrnam>(3), B<getgrouplist>(3), B<putgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/getauxval.3:29
#, no-wrap
msgid "GETAUXVAL"
msgstr "GETAUXVAL"

#. type: Plain text
#: man-pages/man3/getauxval.3:32
msgid "getauxval - retrieve a value from the auxiliary vector"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:35
#, no-wrap
msgid "B<#include E<lt>sys/auxv.hE<gt>>\n"
msgstr "B<#include E<lt>sys/auxv.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getauxval.3:37
#, no-wrap
msgid "B<unsigned long getauxval(unsigned long >I<type>B<);>\n"
msgstr "B<unsigned long getauxval(unsigned long >I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/getauxval.3:45
msgid ""
"The B<getauxval>()  function retrieves values from the auxiliary vector, a "
"mechanism that the kernel's ELF binary loader uses to pass certain "
"information to user space when a program is executed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:53
msgid ""
"Each entry in the auxiliary vector consists of a pair of values: a type that"
" identifies what this entry represents, and a value for that type.  Given "
"the argument I<type>, B<getauxval>()  returns the corresponding value."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:60
msgid ""
"The value returned for each I<type> is given in the following list.  Not all"
" I<type> values are present on all architectures."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:60
#, no-wrap
msgid "B<AT_BASE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:63
msgid ""
"The base address of the program interpreter (usually, the dynamic linker)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:63
#, no-wrap
msgid "B<AT_BASE_PLATFORM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:68
msgid ""
"A string identifying the real platform; may differ from B<AT_PLATFORM> "
"(PowerPC only)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:68
#, no-wrap
msgid "B<AT_CLKTCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:75
msgid ""
"The frequency with which B<times>(2)  counts.  This value can also be "
"obtained via I<sysconf(_SC_CLK_TCK)>."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:75
#, no-wrap
msgid "B<AT_DCACHEBSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:78
msgid "The data cache block size."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:78
#, no-wrap
msgid "B<AT_EGID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:81
msgid "The effective group ID of the thread."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:81
#, no-wrap
msgid "B<AT_ENTRY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:84
msgid "The entry address of the executable."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:84
#, no-wrap
msgid "B<AT_EUID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:87
msgid "The effective user ID of the thread."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:87
#, no-wrap
msgid "B<AT_EXECFD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:90
msgid "File descriptor of program."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:90
#, no-wrap
msgid "B<AT_EXECFN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:93
msgid "Pathname used to execute program."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:93
#, no-wrap
msgid "B<AT_FLAGS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:96
msgid "Flags (unused)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:96
#, no-wrap
msgid "B<AT_FPUCW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:101
msgid ""
"Used FPU control word (SuperH architecture only).  This gives some "
"information about the FPU initialization performed by the kernel."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:101
#, no-wrap
msgid "B<AT_GID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:104
msgid "The real group ID of the thread."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:104
#, no-wrap
msgid "B<AT_HWCAP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:114
msgid ""
"A pointer to a multibyte mask of bits whose settings indicate detailed "
"processor capabilities.  The contents of the bit mask are hardware dependent"
" (for example, see the kernel source file "
"I<arch/x86/include/asm/cpufeature.h> for details relating to the Intel x86 "
"architecture).  A human-readable version of the same information is "
"available via I</proc/cpuinfo>."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:114
#, no-wrap
msgid "B<AT_ICACHEBSIZE>"
msgstr ""

#.  .TP
#.  .BR AT_IGNORE
#.  .TP
#.  .BR AT_IGNOREPPC
#.  .TP
#.  .BR AT_NOTELF
#. type: Plain text
#: man-pages/man3/getauxval.3:123
msgid "The instruction cache block size."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:123
#, no-wrap
msgid "B<AT_PAGESZ>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:127
msgid ""
"The system page size (the same value returned by I<sysconf(_SC_PAGESIZE)>)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:127
#, no-wrap
msgid "B<AT_PHDR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:130
msgid "The address of the program headers of the executable."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:130
#, no-wrap
msgid "B<AT_PHENT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:133
msgid "The size of program header entry."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:133
#, no-wrap
msgid "B<AT_PHNUM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:136
msgid "The number of program headers."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:136
#, no-wrap
msgid "B<AT_PLATFORM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:143
msgid ""
"A pointer to a string that identifies the hardware platform that the program"
" is running on.  The dynamic linker uses this in the interpretation of "
"I<rpath> values."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:143
#, no-wrap
msgid "B<AT_RANDOM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:146
msgid "The address of sixteen bytes containing a random value."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:146
#, no-wrap
msgid "B<AT_SECURE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:158
msgid ""
"Has a nonzero value if this executable should be treated securely.  Most "
"commonly, a nonzero value indicates that the process is executing a set-"
"user-ID or set-group-ID program; alternatively, a nonzero value may be "
"triggered by a Linux Security Module.  When this value is nonzero, the "
"dynamic linker disables the use of certain environment variables (see B<ld-"
"linux.so>(8))  and glibc changes other aspects of its behavior.  (See also "
"B<secure_getenv>(3).)"
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:158
#, no-wrap
msgid "B<AT_SYSINFO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:162
msgid ""
"The entry point to the system call function in the vDSO.  Not present/needed"
" on all architectures (e.g., absent on x86-64)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:162
#, no-wrap
msgid "B<AT_SYSINFO_EHDR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:167
msgid ""
"The address of a page containing the virtual Dynamic Shared Object (vDSO)  "
"that the kernel creates in order to provide fast implementations of certain "
"system calls."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:167
#, no-wrap
msgid "B<AT_UCACHEBSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:170
msgid "The unified cache block size."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:170
#, no-wrap
msgid "B<AT_UID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:173
msgid "The real user ID of the thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:181
msgid ""
"On success, B<getauxval>()  returns the value corresponding to I<type>.  If "
"I<type> is not found, 0 is returned."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:182
#, no-wrap
msgid "B<ENOENT> (since glibc 2.19)"
msgstr ""

#.  commit b9ab448f980e296eac21ac65f53783967cc6037b
#. type: Plain text
#: man-pages/man3/getauxval.3:188
msgid ""
"No entry corresponding to I<type> could be found in the auxiliary vector."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:192
msgid "The B<getauxval>()  function was added to glibc in version 2.16."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:197
msgid "The B<getauxval>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:199
msgid "This function is a nonstandard glibc extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:208
msgid ""
"The primary consumer of the information in the auxiliary vector is the "
"dynamic linker B<ld-linux.so>(8).  The auxiliary vector is a convenient and "
"efficient shortcut that allows the kernel to communicate a certain set of "
"standard information that the dynamic linker usually or always needs.  In "
"some cases, the same information could be obtained by system calls, but "
"using the auxiliary vector is cheaper."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:214
msgid ""
"The auxiliary vector resides just above the argument list and environment in"
" the process address space.  The auxiliary vector supplied to a program can "
"be viewed by setting the B<LD_SHOW_AUXV> environment variable when running a"
" program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:216
#, no-wrap
msgid "    $ LD_SHOW_AUXV=1 sleep 1\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:223
msgid ""
"The auxiliary vector of any process can (subject to file permissions)  be "
"obtained via I</proc/PID/auxv>; see B<proc>(5)  for more information."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:232
msgid ""
"Before the addition of the B<ENOENT> error in glibc 2.19, there was no way "
"to unambiguously distinguish the case where I<type> could not be found from "
"the case where the value corresponding to I<type> was zer0."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:235
msgid "B<secure_getenv>(3), B<vdso>(7), B<ld-linux.so>(8)"
msgstr "B<secure_getenv>(3), B<vdso>(7), B<ld-linux.so>(8)"

#. type: TH
#: man-pages/man3/getpass.3:24
#, no-wrap
msgid "GETPASS"
msgstr "GETPASS"

#. type: Plain text
#: man-pages/man3/getpass.3:27
msgid "getpass - get a password"
msgstr "getpass - запрашивает пароль"

#. type: Plain text
#: man-pages/man3/getpass.3:31
msgid "B<char *getpass( const char *>I<prompt>B<);>"
msgstr "B<char *getpass( const char *>I<prompt>B<);>"

#. type: Plain text
#: man-pages/man3/getpass.3:38
msgid "B<getpass>():"
msgstr "B<getpass>():"

#. type: TP
#: man-pages/man3/getpass.3:41
#, no-wrap
msgid "Since glibc 2.2.2:"
msgstr "Начиная с glibc 2.2.2:"

#. type: Plain text
#: man-pages/man3/getpass.3:48
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr "_BSD_SOURCE ||\n    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: TP
#: man-pages/man3/getpass.3:49
#, no-wrap
msgid "Before glibc 2.2.2:"
msgstr "До glibc 2.2.2:"

#. type: Plain text
#: man-pages/man3/getpass.3:63
msgid ""
"This function is obsolete.  Do not use it.  If you want to read input "
"without terminal echoing enabled, see the description of the I<ECHO> flag in"
" B<termios>(3)."
msgstr "Эта функция устарела. Не используйте её. Если вы хотите читать вводимые данные без вывода на терминал, смотрите описание флага I<ECHO> в B<termios>(3)."

#. type: Plain text
#: man-pages/man3/getpass.3:74
msgid ""
"The B<getpass>()  function opens I</dev/tty> (the controlling terminal of "
"the process), outputs the string I<prompt>, turns off echoing, reads one "
"line (the \"password\"), restores the terminal state and closes I</dev/tty> "
"again."
msgstr "Функция B<getpass>() открывает I</dev/tty> (управляющий терминал процесса), выводит строку I<prompt>, выключает показ выводимых символов, читает одну строку («пароль»), восстанавливает состояние терминала и закрывает I</dev/tty>."

#. type: Plain text
#: man-pages/man3/getpass.3:85
msgid ""
"The function B<getpass>()  returns a pointer to a static buffer containing "
"(the first B<PASS_MAX> bytes of) the password without the trailing newline, "
"terminated by a null byte (\\(aq\\e0\\(aq).  This buffer may be overwritten "
"by a following call.  On error, the terminal state is restored, I<errno> is "
"set appropriately, and NULL is returned."
msgstr "Функция B<getpass>() возвращает указатель на статический буфер, содержащий (первые B<PASS_MAX> байтов) пароль без символа новой строки, оканчивающийся нулевым байтом («\\e0»). Этот буфер может быть перезаписан следующим вызовом. При ошибке, состояние терминала восстанавливается, значение I<errno> устанавливается соответствующим образом и возвращается NULL."

#. type: Plain text
#: man-pages/man3/getpass.3:87
msgid "The function may fail if"
msgstr "Эта функция может завершаться с ошибками:"

#. type: TP
#: man-pages/man3/getpass.3:87
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man3/getpass.3:90
msgid "The process does not have a controlling terminal."
msgstr "Процесс не имеет управляющего терминала."

#.  .SH HISTORY
#.  A
#.  .BR getpass ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: man-pages/man3/getpass.3:96
msgid "I</dev/tty>"
msgstr "I</dev/tty>"

#. type: Plain text
#: man-pages/man3/getpass.3:101
msgid "The B<getpass>()  function is not thread-safe."
msgstr "Функцию B<getpass>() нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/getpass.3:104
msgid "Present in SUSv2, but marked LEGACY.  Removed in POSIX.1-2001."
msgstr "Есть в SUSv2, но помечена как УСТАРЕВШАЯ. Удалена из POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/getpass.3:125
msgid ""
"For libc4 and libc5, the prompt is not written to I</dev/tty> but to "
"I<stderr>.  Moreover, if I</dev/tty> cannot be opened, the password is read "
"from I<stdin>.  The static buffer has length 128 so that only the first 127 "
"bytes of the password are returned.  While reading the password, signal "
"generation (B<SIGINT>, B<SIGQUIT>, B<SIGSTOP>, B<SIGTSTP>)  is disabled and "
"the corresponding characters (usually control-C, control-\\e, control-Z and "
"control-Y)  are transmitted as part of the password.  Since libc 5.4.19 also"
" line editing is disabled, so that also backspace and the like will be seen "
"as part of the password."
msgstr "В libc4 и libc5 строка приглашения (prompt) не записывается в I</dev/tty>, а отправляется в поток I<stderr>. Кроме того, если файл I</dev/tty> не может быть открыт, то пароль читается из потока I<stdin>. Статический буфер имеет длину 128 байт, т.о. возвращаются только первые 127 символов пароля. Во время чтения пароля генерация сигналов (B<SIGINT>, B<SIGQUIT>, B<SIGSTOP>, B<SIGTSTP>) отключена и соответствующие символы (обычно control-C, control-\\e, control-Z и control-Y) передаются как часть пароля. Начиная с libc 5.4.19 также отключена возможность редактирования, т.е. символ backspace и подобные ему считаются частью пароля."

#. type: Plain text
#: man-pages/man3/getpass.3:134
msgid ""
"For glibc2, if I</dev/tty> cannot be opened, the prompt is written to "
"I<stderr> and the password is read from I<stdin>.  There is no limit on the "
"length of the password.  Line editing is not disabled."
msgstr "В glibc2, если файл I</dev/tty> не может быть открыт, то строка приглашения выводится в поток ошибок I<stderr>, а пароль читается из стандартного потока ввода I<stdin>. Ограничения на длину пароля нет и строку можно редактировать."

#. type: Plain text
#: man-pages/man3/getpass.3:156
msgid ""
"According to SUSv2, the value of B<PASS_MAX> must be defined in "
"I<E<lt>limits.hE<gt>> in case it is smaller than 8, and can in any case be "
"obtained using I<sysconf(_SC_PASS_MAX)>.  However, POSIX.2 withdraws the "
"constants B<PASS_MAX> and B<_SC_PASS_MAX>, and the function B<getpass>().  "
"Libc4 and libc5 have never supported B<PASS_MAX> or B<_SC_PASS_MAX>.  Glibc2"
" accepts B<_SC_PASS_MAX> and returns B<BUFSIZ> (e.g., 8192)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:159
msgid ""
"The calling process should zero the password as soon as possible to avoid "
"leaving the cleartext password visible in the process's address space."
msgstr "Вызывающий процесс должен как можно скорее обнулить пароль во избежание возможности просмотра незашифрованного пароля в адресном пространстве процесса."

#. type: Plain text
#: man-pages/man3/getpass.3:160
msgid "B<crypt>(3)"
msgstr "B<crypt>(3)"

#. type: TH
#: man-pages/man3/getpwent_r.3:24
#, no-wrap
msgid "GETPWENT_R"
msgstr "GETPWENT_R"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:27
msgid "getpwent_r, fgetpwent_r - get passwd file entry reentrantly"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:30
#, no-wrap
msgid "B<#include E<lt>pwd.hE<gt>>\n"
msgstr "B<#include E<lt>pwd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:32
#, no-wrap
msgid "B<int getpwent_r(struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:34
#, no-wrap
msgid "B<               size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"
msgstr "B<               size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:36
#, no-wrap
msgid ""
"B<int fgetpwent_r(FILE *>I<fp>B<, struct passwd *>I<pwbuf>B<, char "
"*>I<buf>B<,>\n"
msgstr "B<int fgetpwent_r(FILE *>I<fp>B<, struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:38
#, no-wrap
msgid "B<                size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"
msgstr "B<                size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:47
msgid "B<getpwent_r>(), _BSD_SOURCE || _SVID_SOURCE"
msgstr "B<getpwent_r>(), _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:50
msgid "B<fgetpwent_r>(): _SVID_SOURCE"
msgstr "B<fgetpwent_r>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:63
msgid ""
"The functions B<getpwent_r>()  and B<fgetpwent_r>()  are the reentrant "
"versions of B<getpwent>(3)  and B<fgetpwent>(3).  The former reads the next "
"passwd entry from the stream initialized by B<setpwent>(3).  The latter "
"reads the next passwd entry from the stream I<fp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:79
#, no-wrap
msgid ""
"struct passwd {\n"
"    char    *pw_name;      /* username */\n"
"    char    *pw_passwd;    /* user password */\n"
"    uid_t    pw_uid;       /* user ID */\n"
"    gid_t    pw_gid;       /* group ID */\n"
"    char    *pw_gecos;     /* user information */\n"
"    char    *pw_dir;       /* home directory */\n"
"    char    *pw_shell;     /* shell program */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:103
msgid ""
"The nonreentrant functions return a pointer to static storage, where this "
"static storage contains further pointers to user name, password, gecos "
"field, home directory and shell.  The reentrant functions described here "
"return all of that in caller-provided buffers.  First of all there is the "
"buffer I<pwbuf> that can hold a I<struct passwd>.  And next the buffer "
"I<buf> of size I<buflen> that can hold additional strings.  The result of "
"these functions, the I<struct passwd> read from the stream, is stored in the"
" provided buffer I<*pwbuf>, and a pointer to this I<struct passwd> is "
"returned in I<*pwbufp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:110
msgid ""
"On success, these functions return 0 and I<*pwbufp> is a pointer to the "
"I<struct passwd>.  On error, these functions return an error value and "
"I<*pwbufp> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:114
msgid "No more entries."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:118
msgid "Insufficient buffer space supplied.  Try again with larger buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:123
msgid ""
"These functions are GNU extensions, done in a style resembling the POSIX "
"version of functions like B<getpwnam_r>(3).  Other systems use prototype"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:128
#, no-wrap
msgid ""
"struct passwd *\n"
"getpwent_r(struct passwd *pwd, char *buf, int buflen);\n"
msgstr "struct passwd *\ngetpwent_r(struct passwd *pwd, char *buf, int buflen);\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:132
msgid "or, better,"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:138
#, no-wrap
msgid ""
"int\n"
"getpwent_r(struct passwd *pwd, char *buf, int buflen,\n"
"           FILE **pw_fp);\n"
msgstr "int\ngetpwent_r(struct passwd *pwd, char *buf, int buflen,\n           FILE **pw_fp);\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:145
msgid ""
"The function B<getpwent_r>()  is not really reentrant since it shares the "
"reading position in the stream with all other threads."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:151
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#define BUFLEN 4096\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>pwd.hE<gt>\n#include E<lt>stdio.hE<gt>\n#define BUFLEN 4096\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:158
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct passwd pw, *pwp;\n"
"    char buf[BUFLEN];\n"
"    int i;\n"
msgstr "int\nmain(void)\n{\n    struct passwd pw, *pwp;\n    char buf[BUFLEN];\n    int i;\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:170
#, no-wrap
msgid ""
"    setpwent();\n"
"    while (1) {\n"
"        i = getpwent_r(&pw, buf, BUFLEN, &pwp);\n"
"        if (i)\n"
"            break;\n"
"        printf(\"%s (%d)\\etHOME %s\\etSHELL %s\\en\", pwp-E<gt>pw_name,\n"
"               pwp-E<gt>pw_uid, pwp-E<gt>pw_dir, pwp-E<gt>pw_shell);\n"
"    }\n"
"    endpwent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    setpwent();\n    while (1) {\n        i = getpwent_r(&pw, buf, BUFLEN, &pwp);\n        if (i)\n            break;\n        printf(\"%s (%d)\\etHOME %s\\etSHELL %s\\en\", pwp-E<gt>pw_name,\n               pwp-E<gt>pw_uid, pwp-E<gt>pw_dir, pwp-E<gt>pw_shell);\n    }\n    endpwent();\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getpwent_r.3:187
msgid ""
"B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"
msgstr "B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), B<getpwnam>(3), B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"

#. type: TH
#: man-pages/man3/getservent.3:34
#, no-wrap
msgid "GETSERVENT"
msgstr "GETSERVENT"

#. type: TH
#: man-pages/man3/getservent.3:34
#, no-wrap
msgid "2008-08-19"
msgstr "2008-08-19"

#. type: Plain text
#: man-pages/man3/getservent.3:38
msgid ""
"getservent, getservbyname, getservbyport, setservent, endservent - get "
"service entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:43
#, no-wrap
msgid "B<struct servent *getservent(void);>\n"
msgstr "B<struct servent *getservent(void);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:45
#, no-wrap
msgid ""
"B<struct servent *getservbyname(const char *>I<name>B<, const char "
"*>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyname(const char *>I<name>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:47
#, no-wrap
msgid ""
"B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"
msgstr "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:49
#, no-wrap
msgid "B<void setservent(int >I<stayopen>B<);>\n"
msgstr "B<void setservent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:51
#, no-wrap
msgid "B<void endservent(void);>\n"
msgstr "B<void endservent(void);>\n"

#. type: Plain text
#: man-pages/man3/getservent.3:62
msgid ""
"The B<getservent>()  function reads the next entry from the services "
"database (see B<services>(5))  and returns a I<servent> structure containing"
" the broken-out fields from the entry.  A connection is opened to the "
"database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:77
msgid ""
"The B<getservbyname>()  function returns a I<servent> structure for the "
"entry from the database that matches the service I<name> using protocol "
"I<proto>.  If I<proto> is NULL, any protocol will be matched.  A connection "
"is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:93
msgid ""
"The B<getservbyport>()  function returns a I<servent> structure for the "
"entry from the database that matches the port I<port> (given in network byte"
" order)  using protocol I<proto>.  If I<proto> is NULL, any protocol will be"
" matched.  A connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:105
msgid ""
"The B<setservent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getserv*>()  functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:109
msgid "The B<endservent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:115
msgid ""
"The I<servent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:124
#, no-wrap
msgid ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:130
msgid "The members of the I<servent> structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:130
#, no-wrap
msgid "I<s_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:133
msgid "The official name of the service."
msgstr "Официальное название сервиса."

#. type: TP
#: man-pages/man3/getservent.3:133
#, no-wrap
msgid "I<s_aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:136
msgid "A NULL-terminated list of alternative names for the service."
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:136
#, no-wrap
msgid "I<s_port>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:139
msgid "The port number for the service given in network byte order."
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:139
#, no-wrap
msgid "I<s_proto>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:142
msgid "The name of the protocol to use with this service."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:153
msgid ""
"The B<getservent>(), B<getservbyname>()  and B<getservbyport>()  functions "
"return a pointer to a statically allocated I<servent> structure, or NULL if "
"an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:154
#, no-wrap
msgid "I</etc/services>"
msgstr "I</etc/services>"

#. type: Plain text
#: man-pages/man3/getservent.3:157
msgid "services database file"
msgstr "Файл, содержащий базу сервисов"

#. type: Plain text
#: man-pages/man3/getservent.3:159
msgid "4.3BSD, POSIX.1-2001."
msgstr "4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/getservent.3:163
msgid "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getfsent.3:27
#, no-wrap
msgid "GETFSENT"
msgstr "GETFSENT"

#. type: TH
#: man-pages/man3/getfsent.3:27
#, no-wrap
msgid "2002-02-28"
msgstr "2002-02-28"

#. type: Plain text
#: man-pages/man3/getfsent.3:30
msgid ""
"getfsent, getfsspec, getfsfile, setfsent, endfsent - handle fstab entries"
msgstr "getfsent, getfsspec, getfsfile, setfsent, endfsent - для работы с записями fstab"

#. type: Plain text
#: man-pages/man3/getfsent.3:32
msgid "B<#include E<lt>fstab.hE<gt>>"
msgstr "B<#include E<lt>fstab.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getfsent.3:34
msgid "B<void endfsent(void);>"
msgstr "B<void endfsent(void);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:36
msgid "B<struct fstab *getfsent(void);>"
msgstr "B<struct fstab *getfsent(void);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:38
msgid "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"
msgstr "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:40
msgid "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"
msgstr "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:42
msgid "B<int setfsent(void);>"
msgstr "B<int setfsent(void);>"

#. type: Plain text
#: man-pages/man3/getfsent.3:48
msgid ""
"These functions read from the file I</etc/fstab>.  The I<struct fstab> is "
"defined by:"
msgstr "Эти функции читают файл I</etc/fstab>. Структура I<struct fstab> определена следующим образом:"

#. type: Plain text
#: man-pages/man3/getfsent.3:60
#, no-wrap
msgid ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:68
msgid ""
"Here the field I<fs_type> contains (on a *BSD system)  one of the five "
"strings \"rw\", \"rq\", \"ro\", \"sw\", \"xx\" (read-write, read-write with "
"quota, read-only, swap, ignore)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:72
msgid ""
"The function B<setfsent>()  opens the file when required and positions it at"
" the first line."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:77
msgid ""
"The function B<getfsent>()  parses the next line from the file.  (After "
"opening it when required.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:81
msgid "The function B<endfsent>()  closes the file when required."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:90
msgid ""
"The function B<getfsspec>()  searches the file from the start and returns "
"the first entry found for which the I<fs_spec> field matches the "
"I<special_file> argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:99
msgid ""
"The function B<getfsfile>()  searches the file from the start and returns "
"the first entry found for which the I<fs_file> field matches the "
"I<mount_point> argument."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR getfsent ()
#.  function appeared in 4.0BSD; the other four functions appeared in 4.3BSD.
#. type: Plain text
#: man-pages/man3/getfsent.3:115
msgid ""
"Upon success, the functions B<getfsent>(), B<getfsfile>(), and "
"B<getfsspec>()  return a pointer to a I<struct fstab>, while B<setfsent>()  "
"returns 1.  Upon failure or end-of-file, these functions return NULL and 0, "
"respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:127
msgid ""
"These functions are not in POSIX.1-2001.  Several operating systems have "
"them, for example, *BSD, SunOS, Digital UNIX, AIX (which also has a "
"B<getfstype>()).  HP-UX has functions of the same names, that however use a "
"I<struct checklist> instead of a I<struct fstab>, and calls these functions "
"obsolete, superseded by B<getmntent>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:129
msgid "These functions are not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:139
msgid ""
"Since Linux allows mounting a block special device in several places, and "
"since several devices can have the same mount point, where the last device "
"with a given mount point is the interesting one, while B<getfsfile>()  and "
"B<getfsspec>()  only return the first occurrence, these two functions are "
"not suitable for use under Linux."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:141
msgid "B<getmntent>(3), B<fstab>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getumask.3:28
#, no-wrap
msgid "GETUMASK"
msgstr "GETUMASK"

#. type: Plain text
#: man-pages/man3/getumask.3:31
msgid "getumask - get file creation mask"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:37
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr "B<#include E<lt>sys/stat.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getumask.3:39
msgid "B<mode_t getumask(void);>"
msgstr "B<mode_t getumask(void);>"

#. type: Plain text
#: man-pages/man3/getumask.3:42
msgid ""
"This function returns the current file creation mask.  It is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:51
#, no-wrap
msgid ""
"mode_t getumask(void)\n"
"{\n"
"    mode_t mask = umask( 0 );\n"
"    umask(mask);\n"
"    return mask;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:58
msgid ""
"except that it is documented to be thread-safe (that is, shares a lock with "
"the B<umask>(2)  library call)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:60
msgid "This is a vaporware GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:63
msgid ""
"This function is documented but not implemented yet in glibc, as at version "
"2.9."
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:64
msgid "B<umask>(2)"
msgstr "B<umask>(2)"

#. type: TH
#: man-pages/man3/getdate.3:30
#, no-wrap
msgid "GETDATE"
msgstr "GETDATE"

#. type: TH
#: man-pages/man3/getdate.3:30
#, no-wrap
msgid "2014-06-13"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:33
msgid ""
"getdate, getdate_r - convert a date-plus-time string to broken-down time"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:35 man-pages/man3/getdate.3:41
msgid "B<#include E<lt>time.hE<gt>>"
msgstr "B<#include E<lt>time.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getdate.3:37
msgid "B<struct tm *getdate(const char *>I<string>B<);>"
msgstr "B<struct tm *getdate(const char *>I<string>B<);>"

#. type: Plain text
#: man-pages/man3/getdate.3:39
msgid "B<extern int getdate_err;>"
msgstr "B<extern int getdate_err;>"

#. type: Plain text
#: man-pages/man3/getdate.3:43
msgid "B<int getdate_r(const char *>I<string>B<, struct tm *>I<res>B<);>"
msgstr "B<int getdate_r(const char *>I<string>B<, struct tm *>I<res>B<);>"

#. type: Plain text
#: man-pages/man3/getdate.3:50
msgid "B<getdate>():"
msgstr "B<getdate>():"

#. type: Plain text
#: man-pages/man3/getdate.3:57
msgid "B<getdate_r>():"
msgstr "B<getdate_r>():"

#. type: Plain text
#: man-pages/man3/getdate.3:60
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getdate.3:78
msgid ""
"The function B<getdate>()  converts a string representation of a date and "
"time, contained in the buffer pointed to by I<string>, into a broken-down "
"time.  The broken-down time is stored in a I<tm> structure, and a pointer to"
" this structure is returned as the function result.  This I<tm> structure is"
" allocated in static storage, and consequently it will be overwritten by "
"further calls to B<getdate>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:90
msgid ""
"In contrast to B<strptime>(3), (which has a I<format> argument), "
"B<getdate>()  uses the formats found in the file whose full pathname is "
"given in the environment variable B<DATEMSK>.  The first line in the file "
"that matches the given input string is used for the conversion."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:94
msgid ""
"The matching is done case insensitively.  Superfluous whitespace, either in "
"the pattern or in the string to be converted, is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:98
msgid ""
"The conversion specifications that a pattern can contain are those given for"
" B<strptime>(3).  One more conversion specification is specified in "
"POSIX.1-2001:"
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:98
#, no-wrap
msgid "B<%Z>"
msgstr "B<%Z>"

#. type: Plain text
#: man-pages/man3/getdate.3:102
msgid "Timezone name.  This is not implemented in glibc."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:111
msgid ""
"When B<%Z> is given, the structure containing the broken-down time is "
"initialized with values corresponding to the current time in the given "
"timezone.  Otherwise, the structure is initialized to the broken-down time "
"corresponding to the current local time (as by a call to B<localtime>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:115
msgid ""
"When only the day of the week is given, the day is taken to be the first "
"such day on or after today."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:119
msgid ""
"When only the month is given (and no year), the month is taken to be the "
"first such month equal to or after the current month.  If no day is given, "
"it is the first day of the month."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:122
msgid ""
"When no hour, minute and second are given, the current hour, minute and "
"second are taken."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:125
msgid ""
"If no date is given, but we know the hour, then that hour is taken to be the"
" first such hour equal to or after the current hour."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:135
msgid ""
"B<getdate_r>()  is a GNU extension that provides a reentrant version of "
"B<getdate>().  Rather than using a global variable to report errors and a "
"static buffer to return the broken down time, it returns errors via the "
"function result value, and returns the resulting broken-down time in the "
"caller-allocated buffer pointed to by the argument I<res>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:146
msgid ""
"When successful, B<getdate>()  returns a pointer to a I<struct tm>.  "
"Otherwise, it returns NULL and sets the global variable I<getdate_err> to "
"one of the error numbers shown below.  Changes to I<errno> are unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:151
msgid ""
"On success B<getdate_r>()  returns 0; on error it returns one of the error "
"numbers shown below."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:158
msgid ""
"The following errors are returned via I<getdate_err> (for B<getdate>())  or "
"as the function result (for B<getdate_r>()):"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:163
msgid ""
"The B<DATEMSK> environment variable is not defined, or its value is an empty"
" string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:168
msgid ""
"The template file specified by B<DATEMSK> cannot be opened for reading."
msgstr ""

#.  stat()
#. type: Plain text
#: man-pages/man3/getdate.3:172
msgid "Failed to get file status information."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:172
#, no-wrap
msgid "B<4>"
msgstr "B<4>"

#. type: Plain text
#: man-pages/man3/getdate.3:175
msgid "The template file is not a regular file."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:175
#, no-wrap
msgid "B<5>"
msgstr "B<5>"

#. type: Plain text
#: man-pages/man3/getdate.3:178
msgid "An error was encountered while reading the template file."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:178
#, no-wrap
msgid "B<6>"
msgstr "B<6>"

#.  Error 6 doesn't seem to occur in glibc
#. type: Plain text
#: man-pages/man3/getdate.3:182
msgid "Memory allocation failed (not enough memory available)."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:182
#, no-wrap
msgid "B<7>"
msgstr "B<7>"

#. type: Plain text
#: man-pages/man3/getdate.3:185
msgid "There is no line in the file that matches the input."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:185
#, no-wrap
msgid "B<8>"
msgstr "B<8>"

#. type: Plain text
#: man-pages/man3/getdate.3:188
msgid "Invalid input specification."
msgstr ""

#. type: SH
#: man-pages/man3/getdate.3:188
#, no-wrap
msgid "ENVIRONMENT"
msgstr "ОКРУЖЕНИЕ"

#. type: TP
#: man-pages/man3/getdate.3:189
#, no-wrap
msgid "B<DATEMSK>"
msgstr "B<DATEMSK>"

#. type: Plain text
#: man-pages/man3/getdate.3:192
msgid "File containing format patterns."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:192
#, no-wrap
msgid "B<TZ>, B<LC_TIME>"
msgstr "B<TZ>, B<LC_TIME>"

#. type: Plain text
#: man-pages/man3/getdate.3:196
msgid "Variables used by B<strptime>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:201
msgid "The B<getdate>()  function is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:205
msgid "The B<getdate_r>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:207
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/getdate.3:221
msgid ""
"The POSIX.1-2001 specification for B<strptime>(3)  contains conversion "
"specifications using the B<%E> or B<%O> modifier, while such specifications "
"are not given for B<getdate>().  In glibc, B<getdate>()  is implemented "
"using B<strptime>(3), so that precisely the same conversions are supported "
"by both."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:229
msgid ""
"The program below calls B<getdate>()  for each of its command-line "
"arguments, and for each call displays the values in the fields of the "
"returned I<tm> structure.  The following shell session demonstrates the "
"operation of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:270
#, no-wrap
msgid ""
"$B< TFILE=$PWD/tfile>\n"
"$B< echo \\(aq%A\\(aq E<gt> $TFILE >      # Full name of the day of the week\n"
"$B< echo \\(aq%T\\(aq E<gt>E<gt> $TFILE>      # ISO date (YYYY-MM-DD)\n"
"$B< echo \\(aq%F\\(aq E<gt>E<gt> $TFILE>      # Time (HH:MM:SS)\n"
"$B< date>\n"
"$B< export DATEMSK=$TFILE>\n"
"$B< ./a.out Tuesday \\(aq2009-12-28\\(aq \\(aq12:22:33\\(aq>\n"
"Sun Sep  7 06:03:36 CEST 2008\n"
"Call 1 (\"Tuesday\") succeeded:\n"
"    tm_sec   = 36\n"
"    tm_min   = 3\n"
"    tm_hour  = 6\n"
"    tm_mday  = 9\n"
"    tm_mon   = 8\n"
"    tm_year  = 108\n"
"    tm_wday  = 2\n"
"    tm_yday  = 252\n"
"    tm_isdst = 1\n"
"Call 2 (\"2009-12-28\") succeeded:\n"
"    tm_sec   = 36\n"
"    tm_min   = 3\n"
"    tm_hour  = 6\n"
"    tm_mday  = 28\n"
"    tm_mon   = 11\n"
"    tm_year  = 109\n"
"    tm_wday  = 1\n"
"    tm_yday  = 361\n"
"    tm_isdst = 0\n"
"Call 3 (\"12:22:33\") succeeded:\n"
"    tm_sec   = 33\n"
"    tm_min   = 22\n"
"    tm_hour  = 12\n"
"    tm_mday  = 7\n"
"    tm_mon   = 8\n"
"    tm_year  = 108\n"
"    tm_wday  = 0\n"
"    tm_yday  = 250\n"
"    tm_isdst = 1\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:279
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:285
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct tm *tmp;\n"
"    int j;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct tm *tmp;\n    int j;\n"

#. type: Plain text
#: man-pages/man3/getdate.3:288
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++) {\n"
"        tmp = getdate(argv[j]);\n"
msgstr "    for (j = 1; j E<lt> argc; j++) {\n        tmp = getdate(argv[j]);\n"

#. type: Plain text
#: man-pages/man3/getdate.3:294
#, no-wrap
msgid ""
"        if (tmp == NULL) {\n"
"            printf(\"Call %d failed; getdate_err = %d\\en\",\n"
"                   j, getdate_err);\n"
"            continue;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:306
#, no-wrap
msgid ""
"        printf(\"Call %d (\\e\"%s\\e\") succeeded:\\en\", j, argv[j]);\n"
"        printf(\"    tm_sec   = %d\\en\", tmp-E<gt>tm_sec);\n"
"        printf(\"    tm_min   = %d\\en\", tmp-E<gt>tm_min);\n"
"        printf(\"    tm_hour  = %d\\en\", tmp-E<gt>tm_hour);\n"
"        printf(\"    tm_mday  = %d\\en\", tmp-E<gt>tm_mday);\n"
"        printf(\"    tm_mon   = %d\\en\", tmp-E<gt>tm_mon);\n"
"        printf(\"    tm_year  = %d\\en\", tmp-E<gt>tm_year);\n"
"        printf(\"    tm_wday  = %d\\en\", tmp-E<gt>tm_wday);\n"
"        printf(\"    tm_yday  = %d\\en\", tmp-E<gt>tm_yday);\n"
"        printf(\"    tm_isdst = %d\\en\", tmp-E<gt>tm_isdst);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:315
msgid ""
"B<time>(2), B<localtime>(3), B<setlocale>(3), B<strftime>(3), B<strptime>(3)"
msgstr "B<time>(2), B<localtime>(3), B<setlocale>(3), B<strftime>(3), B<strptime>(3)"

#. type: TH
#: man-pages/man3/getopt.3:41
#, no-wrap
msgid "GETOPT"
msgstr "GETOPT"

#. type: TH
#: man-pages/man3/getopt.3:41
#, no-wrap
msgid "2014-05-09"
msgstr "2014-05-09"

#. type: Plain text
#: man-pages/man3/getopt.3:45
msgid ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - "
"Parse command-line options"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:48
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:51
#, no-wrap
msgid ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"
msgstr "B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\nB<           const char *>I<optstring>B<);>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:54
#, no-wrap
msgid ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"
msgstr "B<extern char *>I<optarg>B<;>\nB<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:56
#, no-wrap
msgid "B<#include E<lt>getopt.hE<gt>>\n"
msgstr "B<#include E<lt>getopt.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:60
#, no-wrap
msgid ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr "B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\nB<           const char *>I<optstring>B<,>\nB<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:64
#, no-wrap
msgid ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr "B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\nB<           const char *>I<optstring>B<,>\nB<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:74
msgid "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"

#. type: Plain text
#: man-pages/man3/getopt.3:78
msgid "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"
msgstr "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getopt.3:99
msgid ""
"The B<getopt>()  function parses the command-line arguments.  Its arguments "
"I<argc> and I<argv> are the argument count and array as passed to the "
"I<main>()  function on program invocation.  An element of I<argv> that "
"starts with \\(aq-\\(aq (and is not exactly \"-\" or \"--\")  is an option "
"element.  The characters of this element (aside from the initial "
"\\(aq-\\(aq) are option characters.  If B<getopt>()  is called repeatedly, "
"it returns successively each of the option characters from each of the "
"option elements."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:108
msgid ""
"The variable I<optind> is the index of the next element to be processed in "
"I<argv>.  The system initializes this value to 1.  The caller can reset it "
"to 1 to restart scanning of the same I<argv>, or when scanning a new "
"argument vector."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:118
msgid ""
"If B<getopt>()  finds another option character, it returns that character, "
"updating the external variable I<optind> and a static variable I<nextchar> "
"so that the next call to B<getopt>()  can resume the scan with the following"
" option character or I<argv>-element."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:124
msgid ""
"If there are no more option characters, B<getopt>()  returns -1.  Then "
"I<optind> is the index in I<argv> of the first I<argv>-element that is not "
"an option."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:151
msgid ""
"I<optstring> is a string containing the legitimate option characters.  If "
"such a character is followed by a colon, the option requires an argument, so"
" B<getopt>()  places a pointer to the following text in the same "
"I<argv>-element, or the text of the following I<argv>-element, in I<optarg>."
"  Two colons mean an option takes an optional arg; if there is text in the "
"current I<argv>-element (i.e., in the same word as the option name itself, "
"for example, \"-oarg\"), then it is returned in I<optarg>, otherwise "
"I<optarg> is set to zero.  This is a GNU extension.  If I<optstring> "
"contains B<W> followed by a semicolon, then B<-W foo> is treated as the long"
" option B<--foo>.  (The B<-W> option is reserved by POSIX.2 for "
"implementation extensions.)  This behavior is a GNU extension, not available"
" with libraries before glibc 2."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:169
msgid ""
"By default, B<getopt>()  permutes the contents of I<argv> as it scans, so "
"that eventually all the nonoptions are at the end.  Two other modes are also"
" implemented.  If the first character of I<optstring> is \\(aq+\\(aq or the "
"environment variable B<POSIXLY_CORRECT> is set, then option processing stops"
" as soon as a nonoption argument is encountered.  If the first character of "
"I<optstring> is \\(aq-\\(aq, then each nonoption I<argv>-element is handled "
"as if it were the argument of an option with character code 1.  (This is "
"used by programs that were written to expect options and other "
"I<argv>-elements in any order and that care about the ordering of the two.)"
"  The special argument \"--\" forces an end of option-scanning regardless of"
" the scanning mode."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:177
msgid ""
"If B<getopt>()  does not recognize an option character, it prints an error "
"message to I<stderr>, stores the character in I<optopt>, and returns "
"\\(aq?\\(aq.  The calling program may prevent the error message by setting "
"I<opterr> to 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:196
msgid ""
"If B<getopt>()  finds an option character in I<argv> that was not included "
"in I<optstring>, or if it detects a missing option argument, it returns "
"\\(aq?\\(aq and sets the external variable I<optopt> to the actual option "
"character.  If the first character (following any optional \\(aq+\\(aq or "
"\\(aq-\\(aq described above)  of I<optstring> is a colon (\\(aq:\\(aq), then"
" B<getopt>()  returns \\(aq:\\(aq instead of \\(aq?\\(aq to indicate a "
"missing option argument.  If an error was detected, and the first character "
"of I<optstring> is not a colon, and the external variable I<opterr> is "
"nonzero (which is the default), B<getopt>()  prints an error message."
msgstr ""

#. type: SS
#: man-pages/man3/getopt.3:196
#, no-wrap
msgid "getopt_long() and getopt_long_only()"
msgstr "getopt_long() and getopt_long_only()"

#. type: Plain text
#: man-pages/man3/getopt.3:212
msgid ""
"The B<getopt_long>()  function works like B<getopt>()  except that it also "
"accepts long options, started with two dashes.  (If the program accepts only"
" long options, then I<optstring> should be specified as an empty string "
"(\"\"), not NULL.)  Long option names may be abbreviated if the abbreviation"
" is unique or is an exact match for some defined option.  A long option may "
"take a parameter, of the form B<--arg=param> or B<--arg param>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:219
msgid ""
"I<longopts> is a pointer to the first element of an array of I<struct "
"option> declared in I<E<lt>getopt.hE<gt>> as"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:228
#, no-wrap
msgid ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"
msgstr "struct option {\n    const char *name;\n    int         has_arg;\n    int        *flag;\n    int         val;\n};\n"

#. type: Plain text
#: man-pages/man3/getopt.3:232
msgid "The meanings of the different fields are:"
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:232
#, no-wrap
msgid "I<name>"
msgstr "I<имя>"

#. type: Plain text
#: man-pages/man3/getopt.3:235
msgid "is the name of the long option."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:235
#, no-wrap
msgid "I<has_arg>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:241
msgid ""
"is: B<no_argument> (or 0) if the option does not take an argument; "
"B<required_argument> (or 1) if the option requires an argument; or "
"B<optional_argument> (or 2) if the option takes an optional argument."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:241
#, no-wrap
msgid "I<flag>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:255
msgid ""
"specifies how results are returned for a long option.  If I<flag> is NULL, "
"then B<getopt_long>()  returns I<val>.  (For example, the calling program "
"may set I<val> to the equivalent short option character.)  Otherwise, "
"B<getopt_long>()  returns 0, and I<flag> points to a variable which is set "
"to I<val> if the option is found, but left unchanged if the option is not "
"found."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:255
#, no-wrap
msgid "I<val>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:259
msgid ""
"is the value to return, or to load into the variable pointed to by I<flag>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:261
msgid "The last element of the array has to be filled with zeros."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:265
msgid ""
"If I<longindex> is not NULL, it points to a variable which is set to the "
"index of the long option relative to I<longopts>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:274
msgid ""
"B<getopt_long_only>()  is like B<getopt_long>(), but \\(aq-\\(aq as well as "
"\"--\" can indicate a long option.  If an option that starts with "
"\\(aq-\\(aq (not \"--\") doesn't match a long option, but does match a short"
" option, it is parsed as a short option instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:292
msgid ""
"If an option was successfully found, then B<getopt>()  returns the option "
"character.  If all command-line options have been parsed, then B<getopt>()  "
"returns -1.  If B<getopt>()  encounters an option character that was not in "
"I<optstring>, then \\(aq?\\(aq is returned.  If B<getopt>()  encounters an "
"option with a missing argument, then the return value depends on the first "
"character in I<optstring>: if it is \\(aq:\\(aq, then \\(aq:\\(aq is "
"returned; otherwise \\(aq?\\(aq is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:304
msgid ""
"B<getopt_long>()  and B<getopt_long_only>()  also return the option "
"character when a short option is recognized.  For a long option, they return"
" I<val> if I<flag> is NULL, and 0 otherwise.  Error and -1 returns are the "
"same as for B<getopt>(), plus \\(aq?\\(aq for an ambiguous match or an "
"extraneous parameter."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:305
#, no-wrap
msgid "B<POSIXLY_CORRECT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:309
msgid ""
"If this is set, then option processing stops as soon as a nonoption argument"
" is encountered."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:309
#, no-wrap
msgid "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:318
msgid ""
"This variable was used by B<bash>(1)  2.0 to communicate to glibc which "
"arguments are the results of wildcard expansion and so should not be "
"considered as options.  This behavior was removed in B<bash>(1)  version "
"2.01, but the support remains in glibc."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:319
#, no-wrap
msgid "B<getopt>():"
msgstr "B<getopt>():"

#. type: Plain text
#: man-pages/man3/getopt.3:329
msgid ""
"POSIX.2 and POSIX.1-2001, provided the environment variable "
"B<POSIXLY_CORRECT> is set.  Otherwise, the elements of I<argv> aren't really"
" const, because we permute them.  We pretend they're const in the prototype "
"to be compatible with other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:333
msgid "The use of \\(aq+\\(aq and \\(aq-\\(aq in I<optstring> is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:347
msgid ""
"On some older implementations, B<getopt>()  was declared in "
"I<E<lt>stdio.hE<gt>>.  SUSv1 permitted the declaration to appear in either "
"I<E<lt>unistd.hE<gt>> or I<E<lt>stdio.hE<gt>>.  POSIX.1-2001 marked the use "
"of I<E<lt>stdio.hE<gt>> for this purpose as LEGACY.  POSIX.1-2001 does not "
"allow the declaration to appear in I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:347
#, no-wrap
msgid "B<getopt_long>() and B<getopt_long_only>():"
msgstr "B<getopt_long>() и B<getopt_long_only>():"

#. type: Plain text
#: man-pages/man3/getopt.3:350
msgid "These functions are GNU extensions."
msgstr "Эти функции являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/getopt.3:369
msgid ""
"A program that scans multiple argument vectors, or rescans the same vector "
"more than once, and wants to make use of GNU extensions such as \\(aq+\\(aq "
"and \\(aq-\\(aq at the start of I<optstring>, or changes the value of "
"B<POSIXLY_CORRECT> between scans, must reinitialize B<getopt>()  by "
"resetting I<optind> to 0, rather than the traditional value of 1.  "
"(Resetting to 0 forces the invocation of an internal initialization routine "
"that rechecks B<POSIXLY_CORRECT> and checks for GNU extensions in "
"I<optstring>.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:376
msgid ""
"The POSIX.2 specification of B<getopt>()  has a technical error described in"
" POSIX.2 Interpretation 150.  The GNU implementation (and probably all other"
" implementations) implements the correct behavior rather than that "
"specified."
msgstr ""

#. type: SS
#: man-pages/man3/getopt.3:377
#, no-wrap
msgid "getopt()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:385
msgid ""
"The following trivial example program uses B<getopt>()  to handle two "
"program options: I<-n>, with no associated value; and I<-t val>, which "
"expects an associated value."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:390
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:396
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int flags, opt;\n    int nsecs, tfnd;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:415
#, no-wrap
msgid ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:417
#, no-wrap
msgid "    printf(\"flags=%d; tfnd=%d; optind=%d\\en\", flags, tfnd, optind);\n"
msgstr "    printf(\"flags=%d; tfnd=%d; optind=%d\\en\", flags, tfnd, optind);\n"

#. type: Plain text
#: man-pages/man3/getopt.3:422
#, no-wrap
msgid ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:424
#, no-wrap
msgid "    printf(\"name argument = %s\\en\", argv[optind]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:426
#, no-wrap
msgid "    /* Other code omitted */\n"
msgstr ""

#. type: SS
#: man-pages/man3/getopt.3:430
#, no-wrap
msgid "getopt_long()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:434
msgid ""
"The following example program illustrates the use of B<getopt_long>()  with "
"most of its features."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:439
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>     /* для printf */\n#include E<lt>stdlib.hE<gt>    /* для exit */\n#include E<lt>getopt.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getopt.3:445
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int c;\n"
"    int digit_optind = 0;\n"
msgstr "int\nmain(int argc, char **argv)\n{\n    int c;\n    int digit_optind = 0;\n"

#. type: Plain text
#: man-pages/man3/getopt.3:458
#, no-wrap
msgid ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:463
#, no-wrap
msgid ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:471
#, no-wrap
msgid ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:480
#, no-wrap
msgid ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:484
#, no-wrap
msgid ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:488
#, no-wrap
msgid ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:492
#, no-wrap
msgid ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:496
#, no-wrap
msgid ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:499
#, no-wrap
msgid ""
"        case \\(aq?\\(aq:\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:504
#, no-wrap
msgid ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:511
#, no-wrap
msgid ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:516
msgid "B<getsubopt>(3)"
msgstr "B<getsubopt>(3)"

#. type: TH
#: man-pages/man3/getnetent_r.3:26
#, no-wrap
msgid "GETNETENT_R"
msgstr "GETNETENT_R"

#. type: Plain text
#: man-pages/man3/getnetent_r.3:30
msgid ""
"getnetent_r, getnetbyname_r, getnetbyaddr_r - get network entry (reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:37
#, no-wrap
msgid ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:42
#, no-wrap
msgid ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:47
#, no-wrap
msgid ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:58
msgid "B<getnetent_r>(), B<getnetbyname_r>(), B<getnetbyaddr_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:79
msgid ""
"The B<getnetent_r>(), B<getnetbyname_r>(), and B<getnetbyaddr_r>()  "
"functions are the reentrant equivalents of, respectively, B<getnetent>(3), "
"B<getnetbyname>(3), and B<getnetbynumber>(3).  They differ in the way that "
"the I<netent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:85
msgid ""
"Instead of returning a pointer to a statically allocated I<netent> structure"
" as the function result, these functions copy the structure into the "
"location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getnetent_r.3:102
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<netent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:110
msgid ""
"If the function call successfully obtains a network record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#.  getnetent.3 doesn't document any use of h_errno, but nevertheless
#.  the nonreentrant functions no seem to set h_errno.
#. type: Plain text
#: man-pages/man3/getnetent_r.3:118
msgid ""
"The buffer pointed to by I<h_errnop> is used to return the value that would "
"be stored in the global variable I<h_errno> by the nonreentrant versions of "
"these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:121
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:129
msgid ""
"On error, record not found (B<getnetbyname_r>(), B<getnetbyaddr_r>()), or "
"end of input (B<getnetent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:134
msgid "(B<getnetent_r>())  No more records in database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:147
msgid "B<getnetent>(3), B<networks>(5)"
msgstr "B<getnetent>(3), B<networks>(5)"

#. type: TH
#: man-pages/man3/getmntent.3:32
#, no-wrap
msgid "GETMNTENT"
msgstr "GETMNTENT"

#. type: TH
#: man-pages/man3/getmntent.3:32
#, no-wrap
msgid "2009-09-15"
msgstr "2009-09-15"

#. type: Plain text
#: man-pages/man3/getmntent.3:36
msgid ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - get "
"filesystem descriptor file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:40
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\nB<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:42
#, no-wrap
msgid ""
"B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:44
#, no-wrap
msgid "B<struct mntent *getmntent(FILE *>I<fp>B<);>\n"
msgstr "B<struct mntent *getmntent(FILE *>I<fp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:46
#, no-wrap
msgid "B<int addmntent(FILE *>I<fp>B<, const struct mntent *>I<mnt>B<);>\n"
msgstr "B<int addmntent(FILE *>I<fp>B<, const struct mntent *>I<mnt>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:48
#, no-wrap
msgid "B<int endmntent(FILE *>I<fp>B<);>\n"
msgstr "B<int endmntent(FILE *>I<fp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:50
#, no-wrap
msgid ""
"B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"
msgstr "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:53
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr "/* Расширение GNU */\nB<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:56
#, no-wrap
msgid ""
"B<struct mntent *getmntent_r(FILE *>I<fp>B<, struct mntent *>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr "B<struct mntent *getmntent_r(FILE *>I<fp>B<, struct mntent *>I<mntbuf>B<,>\nB<                           char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getmntent.3:65
msgid "B<getmntent_r>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr "B<getmntent_r>(): _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/getmntent.3:70
msgid ""
"These routines are used to access the filesystem description file "
"I</etc/fstab> and the mounted filesystem description file I</etc/mtab>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:84
msgid ""
"The B<setmntent>()  function opens the filesystem description file "
"I<filename> and returns a file pointer which can be used by B<getmntent>()."
"  The argument I<type> is the type of access required and can take the same "
"values as the I<mode> argument of B<fopen>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:96
msgid ""
"The B<getmntent>()  function reads the next line from the filesystem "
"description file I<fp> and returns a pointer to a structure containing the "
"broken out fields from a line in the file.  The pointer points to a static "
"area of memory which is overwritten by subsequent calls to B<getmntent>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:106
msgid ""
"The B<addmntent>()  function adds the I<mntent> structure I<mnt> to the end "
"of the open file I<fp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:111
msgid ""
"The B<endmntent>()  function closes the filesystem description file I<fp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:128
msgid ""
"The B<hasmntopt>()  function scans the I<mnt_opts> field (see below)  of the"
" I<mntent> structure I<mnt> for a substring that matches I<opt>.  See "
"I<E<lt>mntent.hE<gt>> and B<mount>(8)  for valid mount options."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:142
msgid ""
"The reentrant B<getmntent_r>()  function is similar to B<getmntent>(), but "
"stores the I<struct mount> in the provided I<*mntbuf> and stores the strings"
" pointed to by the entries in that struct in the provided array I<buf> of "
"size I<buflen>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:148
msgid ""
"The I<mntent> structure is defined in I<E<lt>mntent.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:159
#, no-wrap
msgid ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted filesystem */\n"
"    char *mnt_dir;      /* filesystem path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:174
msgid ""
"Since fields in the mtab and fstab files are separated by whitespace, octal "
"escapes are used to represent the four characters space (\\e040), tab "
"(\\e011), newline (\\e012) and backslash (\\e134) in those files when they "
"occur in one of the four strings in a I<mntent> structure.  The routines "
"B<addmntent>()  and B<getmntent>()  will convert from string representation "
"to escaped representation and back."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:183
msgid ""
"The B<getmntent>()  and B<getmntent_r>()  functions return a pointer to the "
"I<mntent> structure or NULL on failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:187
msgid "The B<addmntent>()  function returns 0 on success and 1 on failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:191
msgid "The B<endmntent>()  function always returns 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:196
msgid ""
"The B<hasmntopt>()  function returns the address of the substring if a match"
" is found and NULL otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:200
#, no-wrap
msgid ""
"/etc/fstab          filesystem description file\n"
"/etc/mtab           mounted filesystem description file\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:207
msgid ""
"The nonreentrant functions are from SunOS 4.1.3.  A routine B<getmntent_r>()"
"  was introduced in HP-UX 10, but it returns an int.  The prototype shown "
"above is glibc-only."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:219
msgid ""
"System V also has a B<getmntent>()  function but the calling sequence "
"differs, and the returned structure is different.  Under System V "
"I</etc/mnttab> is used.  4.4BSD and Digital UNIX have a routine "
"B<getmntinfo>(), a wrapper around the system call B<getfsstat>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:222
msgid "B<fopen>(3), B<fstab>(5), B<mount>(8)"
msgstr "B<fopen>(3), B<fstab>(5), B<mount>(8)"

#. type: TH
#: man-pages/man3/getprotoent.3:30
#, no-wrap
msgid "GETPROTOENT"
msgstr "GETPROTOENT"

#. type: Plain text
#: man-pages/man3/getprotoent.3:34
msgid ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - "
"get protocol entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:39
#, no-wrap
msgid "B<struct protoent *getprotoent(void);>\n"
msgstr "B<struct protoent *getprotoent(void);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:41
#, no-wrap
msgid "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"
msgstr "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:43
#, no-wrap
msgid "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"
msgstr "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:45
#, no-wrap
msgid "B<void setprotoent(int >I<stayopen>B<);>\n"
msgstr "B<void setprotoent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:47
#, no-wrap
msgid "B<void endprotoent(void);>\n"
msgstr "B<void endprotoent(void);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent.3:58
msgid ""
"The B<getprotoent>()  function reads the next entry from the protocols "
"database (see B<protocols>(5))  and returns a I<protoent> structure "
"containing the broken-out fields from the entry.  A connection is opened to "
"the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:68
msgid ""
"The B<getprotobyname>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol name I<name>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:78
msgid ""
"The B<getprotobynumber>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol number I<number>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:90
msgid ""
"The B<setprotoent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getproto*>()  functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:94
msgid "The B<endprotoent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:100
msgid ""
"The I<protoent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:108
#, no-wrap
msgid ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:114
msgid "The members of the I<protoent> structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/getprotoent.3:114
#, no-wrap
msgid "I<p_name>"
msgstr "I<p_name>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:117
msgid "The official name of the protocol."
msgstr "Официальное название протокола."

#. type: TP
#: man-pages/man3/getprotoent.3:117
#, no-wrap
msgid "I<p_aliases>"
msgstr "I<p_aliases>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:120
msgid "A NULL-terminated list of alternative names for the protocol."
msgstr ""

#. type: TP
#: man-pages/man3/getprotoent.3:120
#, no-wrap
msgid "I<p_proto>"
msgstr "I<p_proto>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:123
msgid "The protocol number."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:134
msgid ""
"The B<getprotoent>(), B<getprotobyname>()  and B<getprotobynumber>()  "
"functions return a pointer to a statically allocated I<protoent> structure, "
"or a null pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: man-pages/man3/getprotoent.3:136
#, no-wrap
msgid "I</etc/protocols>"
msgstr "I</etc/protocols>"

#. type: Plain text
#: man-pages/man3/getprotoent.3:139
msgid "protocol database file"
msgstr "файл, содержащий базу протоколов"

#. type: Plain text
#: man-pages/man3/getprotoent.3:146
msgid ""
"B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"
msgstr "B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"

#. type: TH
#: man-pages/man3/getutent.3:31
#, no-wrap
msgid "GETUTENT"
msgstr "GETUTENT"

#. type: Plain text
#: man-pages/man3/getutent.3:35
msgid ""
"getutent, getutid, getutline, pututline, setutent, endutent, utmpname - "
"access utmp file entries"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:37
msgid "B<#include E<lt>utmp.hE<gt>>"
msgstr "B<#include E<lt>utmp.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getutent.3:39
msgid "B<struct utmp *getutent(void);>"
msgstr "B<struct utmp *getutent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:41
msgid "B<struct utmp *getutid(const struct utmp *>I<ut>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:43
msgid "B<struct utmp *getutline(const struct utmp *>I<ut>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:45
msgid "B<struct utmp *pututline(const struct utmp *>I<ut>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:47
msgid "B<void setutent(void);>"
msgstr "B<void setutent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:49
msgid "B<void endutent(void);>"
msgstr "B<void endutent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:51
msgid "B<int utmpname(const char *>I<file>B<);>"
msgstr "B<int utmpname(const char *>I<file>B<);>"

#. type: Plain text
#: man-pages/man3/getutent.3:54
msgid ""
"New applications should use the POSIX.1-specified \"utmpx\" versions of "
"these functions; see CONFORMING TO."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:63
msgid ""
"B<utmpname>()  sets the name of the utmp-format file for the other utmp "
"functions to access.  If B<utmpname>()  is not used to set the filename "
"before the other functions are used, they assume B<_PATH_UTMP>, as defined "
"in I<E<lt>paths.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:68
msgid ""
"B<setutent>()  rewinds the file pointer to the beginning of the utmp file.  "
"It is generally a good idea to call it before any of the other functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:73
msgid ""
"B<endutent>()  closes the utmp file.  It should be called when the user code"
" is done accessing the file with the other functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:80
msgid ""
"B<getutent>()  reads a line from the current file position in the utmp file."
"  It returns a pointer to a structure containing the fields of the line.  "
"The definition of this structure is shown in B<utmp>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:96
msgid ""
"B<getutid>()  searches forward from the current file position in the utmp "
"file based upon I<ut>.  If I<ut-E<gt>ut_type> is one of B<RUN_LVL>, "
"B<BOOT_TIME>, B<NEW_TIME>, or B<OLD_TIME>, B<getutid>()  will find the first"
" entry whose I<ut_type> field matches I<ut-E<gt>ut_type>.  If "
"I<ut-E<gt>ut_type> is one of B<INIT_PROCESS>, B<LOGIN_PROCESS>, "
"B<USER_PROCESS>, or B<DEAD_PROCESS>, B<getutid>()  will find the first entry"
" whose I<ut_id> field matches I<ut-E<gt>ut_id>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:106
msgid ""
"B<getutline>()  searches forward from the current file position in the utmp "
"file.  It scans entries whose I<ut_type> is B<USER_PROCESS> or "
"B<LOGIN_PROCESS> and returns the first one whose I<ut_line> field matches "
"I<ut-E<gt>ut_line>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:118
msgid ""
"B<pututline>()  writes the I<utmp> structure I<ut> into the utmp file.  It "
"uses B<getutid>()  to search for the proper place in the file to insert the "
"new entry.  If it cannot find an appropriate slot for I<ut>, B<pututline>()"
"  will append the new entry to the end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:127
msgid ""
"B<getutent>(), B<getutid>(), and B<getutline>()  return a pointer to a "
"I<struct utmp> on success, and NULL on failure (which includes the \"record "
"not found\" case).  This I<struct utmp> is allocated in static storage, and "
"may be overwritten by subsequent calls."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:133
msgid "On success B<pututline>()  returns I<ut>; on failure, it returns NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:136
msgid ""
"B<utmpname>()  returns 0 if the new name was successfully stored, or -1 on "
"failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:140
msgid ""
"In the event of an error, these functions I<errno> set to indicate the "
"cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:147
msgid "Record not found."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:154
msgid ""
"B<setutent>(), B<pututline>(), and the B<getut*>()  functions can also fail "
"for the reasons described in B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:156
msgid "/var/run/utmp\tdatabase of currently logged-in users"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:158
msgid "/var/log/wtmp\tdatabase of past user logins"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:160
msgid "XPG2, SVr4."
msgstr "XPG2, SVr4."

#. type: Plain text
#: man-pages/man3/getutent.3:170
msgid ""
"In XPG2 and SVID 2 the function B<pututline>()  is documented to return "
"void, and that is what it does on many systems (AIX, HP-UX, Linux libc5).  "
"HP-UX introduces a new function B<_pututline>()  with the prototype given "
"above for B<pututline>()  (also found in Linux libc5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:174
msgid ""
"All these functions are obsolete now on non-Linux systems.  POSIX.1-2001, "
"following SUSv1, does not have any of these functions, but instead uses"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:176
msgid "B<#include E<lt>utmpx.hE<gt>>"
msgstr "B<#include E<lt>utmpx.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getutent.3:178
msgid "B<struct utmpx *getutxent(void);>"
msgstr "B<struct utmpx *getutxent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:180
msgid "B<struct utmpx *getutxid(const struct utmpx *);>"
msgstr "B<struct utmpx *getutxid(const struct utmpx *);>"

#. type: Plain text
#: man-pages/man3/getutent.3:182
msgid "B<struct utmpx *getutxline(const struct utmpx *);>"
msgstr "B<struct utmpx *getutxline(const struct utmpx *);>"

#. type: Plain text
#: man-pages/man3/getutent.3:184
msgid "B<struct utmpx *pututxline(const struct utmpx *);>"
msgstr "B<struct utmpx *pututxline(const struct utmpx *);>"

#. type: Plain text
#: man-pages/man3/getutent.3:186
msgid "B<void setutxent(void);>"
msgstr "B<void setutxent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:188
msgid "B<void endutxent(void);>"
msgstr "B<void endutxent(void);>"

#. type: Plain text
#: man-pages/man3/getutent.3:197
msgid ""
"These functions are provided by glibc, and perform the same task as their "
"equivalents without the \"x\", but use I<struct utmpx>, defined on Linux to "
"be the same as I<struct utmp>.  For completeness, glibc also provides "
"B<utmpxname>(), although this function is not specified by POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:205
msgid ""
"On some other systems, the I<utmpx> structure is a superset of the I<utmp> "
"structure, with additional fields, and larger versions of the existing "
"fields, and parallel files are maintained, often I</var/*/utmpx> and "
"I</var/*/wtmpx>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:213
msgid ""
"Linux glibc on the other hand does not use a parallel I<utmpx> file since "
"its I<utmp> structure is already large enough.  The \"x\" functions listed "
"above are just aliases for their counterparts without the \"x\" (e.g., "
"B<getutxent>()  is an alias for B<getutent>())."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:217
msgid ""
"The above functions are not thread-safe.  Glibc adds reentrant versions"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:222
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>    /* or _SVID_SOURCE or _BSD_SOURCE;\n"
"\\&                          see B<feature_test_macros>(7) */\n"
"B<#include E<lt>utmp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:224
#, no-wrap
msgid "B<int getutent_r(struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr "B<int getutent_r(struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:227
#, no-wrap
msgid ""
"B<int getutid_r(struct utmp *>I<ut>B<,>\n"
"B<              struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr "B<int getutid_r(struct utmp *>I<ut>B<,>\nB<              struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:230
#, no-wrap
msgid ""
"B<int getutline_r(struct utmp *>I<ut>B<,>\n"
"B<                struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr "B<int getutline_r(struct utmp *>I<ut>B<,>\nB<                struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:242
msgid ""
"These functions are GNU extensions, analogs of the functions of the same "
"name without the _r suffix.  The I<ubuf> argument gives these functions a "
"place to store their result.  On success they return 0, and a pointer to the"
" result is written in I<*ubufp>.  On error, these functions return -1.  "
"There are no utmpx equivalents of the above functions.  (POSIX.1 does not "
"specify such functions.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:250
msgid ""
"The following example adds and removes a utmp record, assuming it is run "
"from within a pseudo terminal.  For usage in a real application, you should "
"check the return values of B<getpwuid>(3)  and B<ttyname>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:257
#, no-wrap
msgid ""
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>utmp.hE<gt>\n"
msgstr "#include E<lt>string.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>pwd.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>utmp.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getutent.3:262
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct utmp entry;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct utmp entry;\n"

#. type: Plain text
#: man-pages/man3/getutent.3:264
#, no-wrap
msgid "    system(\"echo before adding entry:;who\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:276
#, no-wrap
msgid ""
"    entry.ut_type = USER_PROCESS;\n"
"    entry.ut_pid = getpid();\n"
"    strcpy(entry.ut_line, ttyname(STDIN_FILENO) + strlen(\"/dev/\"));\n"
"    /* only correct for ptys named /dev/tty[pqr][0-9a-z] */\n"
"    strcpy(entry.ut_id, ttyname(STDIN_FILENO) + strlen(\"/dev/tty\"));\n"
"    time(&entry.ut_time);\n"
"    strcpy(entry.ut_user, getpwuid(getuid())-E<gt>pw_name);\n"
"    memset(entry.ut_host, 0, UT_HOSTSIZE);\n"
"    entry.ut_addr = 0;\n"
"    setutent();\n"
"    pututline(&entry);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:278
#, no-wrap
msgid "    system(\"echo after adding entry:;who\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:285
#, no-wrap
msgid ""
"    entry.ut_type = DEAD_PROCESS;\n"
"    memset(entry.ut_line, 0, UT_LINESIZE);\n"
"    entry.ut_time = 0;\n"
"    memset(entry.ut_user, 0, UT_NAMESIZE);\n"
"    setutent();\n"
"    pututline(&entry);\n"
msgstr "    entry.ut_type = DEAD_PROCESS;\n    memset(entry.ut_line, 0, UT_LINESIZE);\n    entry.ut_time = 0;\n    memset(entry.ut_user, 0, UT_NAMESIZE);\n    setutent();\n    pututline(&entry);\n"

#. type: Plain text
#: man-pages/man3/getutent.3:287
#, no-wrap
msgid "    system(\"echo after removing entry:;who\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:291
#, no-wrap
msgid ""
"    endutent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    endutent();\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getutent.3:294
msgid "B<getutmp>(3), B<utmp>(5)"
msgstr "B<getutmp>(3), B<utmp>(5)"

#. type: TH
#: man-pages/man3/getrpcport.3:8
#, no-wrap
msgid "GETRPCPORT"
msgstr "GETRPCPORT"

#. type: Plain text
#: man-pages/man3/getrpcport.3:11
msgid "getrpcport - get RPC port number"
msgstr "getrpcport - получение номера порта RPC"

#. type: Plain text
#: man-pages/man3/getrpcport.3:14
#, no-wrap
msgid "B<#include E<lt>rpc/rpc.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/rpc.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getrpcport.3:17
#, no-wrap
msgid ""
"B<int getrpcport(const char *>I<host>B<, unsigned long >I<prognum>B<, "
"unsigned long >I<versnum>B<, unsigned >I<proto>B<);>\n"
msgstr "B<int getrpcport(const char *>I<host>B<, unsigned long >I<prognum>B<, unsigned long >I<versnum>B<, unsigned >I<proto>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcport.3:38
msgid ""
"B<getrpcport>()  returns the port number for version I<versnum> of the RPC "
"program I<prognum> running on I<host> and using protocol I<proto>.  It "
"returns 0 if it cannot contact the portmapper, or if I<prognum> is not "
"registered.  If I<prognum> is registered but not with version I<versnum>, it"
" will still return a port number (for some version of the program)  "
"indicating that the program is indeed registered.  The version mismatch will"
" be detected upon the first call to the service."
msgstr "Функция B<getrpcport>() возвращает номер порта для версии I<versnum> RPC-программы I<prognum>, работающей на I<host> и использующей протокол I<proto>. Она возвращает 0, если не может связаться с portmapper или если I<prognum> не зарегистрирована. Если же I<prognum> зарегистрирована, но не с версией I<versnum>, она все равно будет возвращать номер порта (с версией программы), указывая на то, что программа действительно зарегистрирована. Несоответствие версий будет зарегистрировано при первой попытке вызвать службу."

#. type: Plain text
#: man-pages/man3/getrpcport.3:40
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems."
msgstr "Нет в POSIX.1-2001. Присутствует в BSD, Solaris и многих других системах."

#. type: TH
#: man-pages/man3/gcvt.3:30
#, no-wrap
msgid "GCVT"
msgstr "GCVT"

#. type: Plain text
#: man-pages/man3/gcvt.3:33
msgid "gcvt - convert a floating-point number to a string"
msgstr "gcvt - преобразовать число с плавающей точкой в строку"

#. type: Plain text
#: man-pages/man3/gcvt.3:36
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/gcvt.3:38
#, no-wrap
msgid "B<char *gcvt(double >I<number>B<, int >I<ndigit>B<, char *>I<buf>B<);>\n"
msgstr "B<char *gcvt(double >I<number>B<, int >I<ndigit>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/gcvt.3:46
msgid "B<gcvt>():"
msgstr "B<gcvt>():"

#. type: Plain text
#: man-pages/man3/gcvt.3:56
#, no-wrap
msgid ""
"_SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr "_SVID_SOURCE ||\n    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: Plain text
#: man-pages/man3/gcvt.3:61
msgid ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE && "
"_XOPEN_SOURCE_EXTENDED"
msgstr "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/gcvt.3:72
msgid ""
"The B<gcvt>()  function converts I<number> to a minimal length null-"
"terminated ASCII string and stores the result in I<buf>.  It produces "
"I<ndigit> significant digits in either B<printf>(3)  F format or E format."
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:77
msgid ""
"The B<gcvt>()  function returns the address of the string pointed to by "
"I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:86
msgid ""
"Marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the specification of"
" B<gcvt>(), recommending the use of B<sprintf>(3)  instead (though "
"B<snprintf>(3)  may be preferable)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:89
msgid "B<ecvt>(3), B<fcvt>(3), B<sprintf>(3)"
msgstr "B<ecvt>(3), B<fcvt>(3), B<sprintf>(3)"

#. type: TH
#: man-pages/man3/getcontext.3:25
#, no-wrap
msgid "GETCONTEXT"
msgstr "GETCONTEXT"

#. type: TH
#: man-pages/man3/getcontext.3:25
#, no-wrap
msgid "2014-04-08"
msgstr "2014-04-08"

#. type: Plain text
#: man-pages/man3/getcontext.3:28
msgid "getcontext, setcontext - get or set the user context"
msgstr "getcontext, setcontext - получить или установить пользовательский контекст"

#. type: Plain text
#: man-pages/man3/getcontext.3:30
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr "B<#include E<lt>ucontext.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getcontext.3:32
msgid "B<int getcontext(ucontext_t *>I<ucp>B<);>"
msgstr "B<int getcontext(ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: man-pages/man3/getcontext.3:34
msgid "B<int setcontext(const ucontext_t *>I<ucp>B<);>"
msgstr "B<int setcontext(const ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: man-pages/man3/getcontext.3:49
msgid ""
"In a System V-like environment, one has the two types I<mcontext_t> and "
"I<ucontext_t> defined in I<E<lt>ucontext.hE<gt>> and the four functions "
"B<getcontext>(), B<setcontext>(), B<makecontext>(3)  and B<swapcontext>(3)  "
"that allow user-level context switching between multiple threads of control "
"within a process."
msgstr "В окружении, подобном SysV, существует два типа данных \\(em I<mcontext_t> и I<ucontext_t>, которые определены в файле I<E<lt>ucontext.hE<gt>> и четыре функции \\(em B<getcontext>(), B<setcontext>(), B<makecontext>(3) и B<swapcontext>(3), которые позволяют контексту пользовательского уровня переключаться между несколькими нитями внутри одного процесса."

#. type: Plain text
#: man-pages/man3/getcontext.3:57
msgid ""
"The I<mcontext_t> type is machine-dependent and opaque.  The I<ucontext_t> "
"type is a structure that has at least the following fields:"
msgstr "Тип I<mcontext_t> является машинно-зависимым и примитивным типом данных. Тип I<ucontext_t> является структурой, которая по крайней мере имеет следующие поля:"

#. type: Plain text
#: man-pages/man3/getcontext.3:67
#, no-wrap
msgid ""
"typedef struct ucontext {\n"
"    struct ucontext *uc_link;\n"
"    sigset_t         uc_sigmask;\n"
"    stack_t          uc_stack;\n"
"    mcontext_t       uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"
msgstr "typedef struct ucontext {\n    struct ucontext *uc_link;\n    sigset_t         uc_sigmask;\n    stack_t          uc_stack;\n    mcontext_t       uc_mcontext;\n    ...\n} ucontext_t;\n"

#. type: Plain text
#: man-pages/man3/getcontext.3:94
msgid ""
"with I<sigset_t> and I<stack_t> defined in I<E<lt>signal.hE<gt>>.  Here "
"I<uc_link> points to the context that will be resumed when the current "
"context terminates (in case the current context was created using "
"B<makecontext>(3)), I<uc_sigmask> is the set of signals blocked in this "
"context (see B<sigprocmask>(2)), I<uc_stack> is the stack used by this "
"context (see B<sigaltstack>(2)), and I<uc_mcontext> is the machine-specific "
"representation of the saved context, that includes the calling thread's "
"machine registers."
msgstr "где I<sigset_t> и I<stack_t> определены в файле I<E<lt>signal.hE<gt>>. В этой структуре I<uc_link> указывает на контекст, к которому будет осуществлён переход, когда завершается текущий контекст (в случае, если текущий контекст был создан с помощью  B<makecontext>(3)), в I<uc_sigmask> задаётся список сигналов, которые блокируются в этом контексте (см. B<sigprocmask>(2)), I<uc_stack> \\(em это стек, который используется этим контекстом (см. B<sigaltstack>(2)), а I<uc_mcontext> является машинно-зависимым представлением сохранённого контекста, который содержит регистры вызываемой нити."

#. type: Plain text
#: man-pages/man3/getcontext.3:101
msgid ""
"The function B<getcontext>()  initializes the structure pointed at by I<ucp>"
" to the currently active context."
msgstr "Функция B<getcontext>() инициализирует вышеописанную структуру, указывая через I<ucp> на текущий активный контекст."

#. type: Plain text
#: man-pages/man3/getcontext.3:114
msgid ""
"The function B<setcontext>()  restores the user context pointed at by "
"I<ucp>.  A successful call does not return.  The context should have been "
"obtained by a call of B<getcontext>(), or B<makecontext>(3), or passed as "
"third argument to a signal handler."
msgstr "Функция B<setcontext>() восстанавливает пользовательский контекст, на который указывает I<ucp>. При успешном вызове управление не возвращается обратно. Контекст должен быть получен с помощью вызова B<getcontext>() или B<makecontext>(3) или передан как третий аргумент обработчика сигнала."

#. type: Plain text
#: man-pages/man3/getcontext.3:118
msgid ""
"If the context was obtained by a call of B<getcontext>(), program execution "
"continues as if this call just returned."
msgstr "Если контекст был получен через вызов B<getcontext>(), то выполнение программы продолжается как если бы этот вызов завершился простым возвратом."

#. type: Plain text
#: man-pages/man3/getcontext.3:135
msgid ""
"If the context was obtained by a call of B<makecontext>(3), program "
"execution continues by a call to the function I<func> specified as the "
"second argument of that call to B<makecontext>(3).  When the function "
"I<func> returns, we continue with the I<uc_link> member of the structure "
"I<ucp> specified as the first argument of that call to B<makecontext>(3).  "
"When this member is NULL, the thread exits."
msgstr "Если контекст был получен через вызов B<makecontext>(3), выполнение программы продолжается с помощью вызова функции I<func>, которая задаётся как второй аргумент вызова B<makecontext>(3). Когда происходит возврат из функции I<func>, выполнение продолжается с поля I<uc_link> структуры I<ucp>, которая задаётся как первый аргумент вызова B<makecontext>(3). Если это поле равно NULL, осуществляется выход из нити."

#. type: Plain text
#: man-pages/man3/getcontext.3:142
msgid ""
"If the context was obtained by a call to a signal handler, then old standard"
" text says that \"program execution continues with the program instruction "
"following the instruction interrupted by the signal\".  However, this "
"sentence was removed in SUSv2, and the present verdict is \"the result is "
"unspecified\"."
msgstr "Если контекст был получен с помощью вызова обработчика сигнала, то старый текст стандарта говорит, что \"выполнение программы продолжается с инструкции программы, которая следует за инструкцией, прерванной сигналом\". Однако, этот текст был удалён в SUSv2 с вердиктом \"результат не определён\"."

#. type: Plain text
#: man-pages/man3/getcontext.3:151
msgid ""
"When successful, B<getcontext>()  returns 0 and B<setcontext>()  does not "
"return.  On error, both return -1 and set I<errno> appropriately."
msgstr "В случае успеха B<getcontext>() возвращает 0, а B<setcontext>() не возвращает ничего. В случае ошибки, возвращается -1 и значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man3/getcontext.3:153
msgid "None defined."
msgstr "Не определены. "

#. type: Plain text
#: man-pages/man3/getcontext.3:160
msgid "The B<getcontext>()  and B<setcontext>()  functions are thread-safe."
msgstr "Функции B<getcontext>() и B<setcontext>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/getcontext.3:166
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<getcontext>(), citing portability issues, and recommending that "
"applications be rewritten to use POSIX threads instead."
msgstr "SUSv2, POSIX.1-2001. В POSIX.1-2008 удалено определение B<getcontext>() со ссылкой на проблемы с переносимостью и рекомендацией переписать приложение с использование нитей POSIX."

#. type: Plain text
#: man-pages/man3/getcontext.3:183
msgid ""
"The earliest incarnation of this mechanism was the "
"B<setjmp>(3)/B<longjmp>(3)  mechanism.  Since that does not define the "
"handling of the signal context, the next stage was the "
"B<sigsetjmp>(3)/B<siglongjmp>(3)  pair.  The present mechanism gives much "
"more control.  On the other hand, there is no easy way to detect whether a "
"return from B<getcontext>()  is from the first call, or via a "
"B<setcontext>()  call.  The user has to invent her own bookkeeping device, "
"and a register variable won't do since registers are restored."
msgstr "В ранних версиях этого механизма использовался механизм B<setjmp>(3)/B<longjmp>(3). Так как в нём нет обработки контекста сигнала, было решено использовать следующий вариант пары B<sigsetjmp>(3)/B<siglongjmp>(3). Текущий механизм даёт много больше контроля. С другой стороны, не существует лёгкого способа определить какое из двух значений возвращает при первом запуске вызов B<getcontext>() или вызов B<setcontext>(). Пользователь должен придумать собственный способ и через регистровую переменную это сделать нельзя, так как значения регистров восстанавливаются."

#. type: Plain text
#: man-pages/man3/getcontext.3:194
msgid ""
"When a signal occurs, the current user context is saved and a new context is"
" created by the kernel for the signal handler.  Do not leave the handler "
"using B<longjmp>(3): it is undefined what would happen with contexts.  Use "
"B<siglongjmp>(3)  or B<setcontext>()  instead."
msgstr "Если возникнет сигнал, текущий пользовательский контекст сохраняется и для обработчика сигнала ядром создаётся новый контекст. Не выходите из этого обработчика, используя B<longjmp>(3) \\(em неизвестно, что может случиться с контекстами. Вместо этого используйте вызовы B<siglongjmp>(3) или B<setcontext>()."

#. type: Plain text
#: man-pages/man3/getcontext.3:200
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), "
"B<makecontext>(3), B<sigsetjmp>(3)"
msgstr "B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), B<makecontext>(3), B<sigsetjmp>(3)"

#. type: TH
#: man-pages/man3/grantpt.3:5
#, no-wrap
msgid "GRANTPT"
msgstr "GRANTPT"

#. type: TH
#: man-pages/man3/grantpt.3:5
#, no-wrap
msgid "2008-06-14"
msgstr "2008-06-14"

#. type: Plain text
#: man-pages/man3/grantpt.3:8
msgid "grantpt - grant access to the slave pseudoterminal"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:11
#, no-wrap
msgid "B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
msgstr "B<#define _XOPEN_SOURCE>       /* См. feature_test_macros(7) */\n"

#. type: Plain text
#: man-pages/man3/grantpt.3:15
#, no-wrap
msgid "B<int grantpt(int >I<fd>B<);>\n"
msgstr "B<int grantpt(int >I<fd>B<);>\n"

#. type: Plain text
#: man-pages/man3/grantpt.3:26
msgid ""
"The B<grantpt>()  function changes the mode and owner of the slave "
"pseudoterminal device corresponding to the master pseudoterminal referred to"
" by I<fd>.  The user ID of the slave is set to the real UID of the calling "
"process.  The group ID is set to an unspecified value (e.g., I<tty>).  The "
"mode of the slave is set to 0620 (crw--w----)."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:32
msgid ""
"The behavior of B<grantpt>()  is unspecified if a signal handler is "
"installed to catch B<SIGCHLD> signals."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:39
msgid ""
"When successful, B<grantpt>()  returns 0.  Otherwise, it returns -1 and sets"
" I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:43
msgid "The corresponding slave pseudoterminal could not be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:48
msgid "The I<fd> argument is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:53
msgid ""
"The I<fd> argument is valid but not associated with a master pseudoterminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:56
msgid "B<grantpt>()  is provided in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:64
msgid ""
"This is part of the UNIX 98 pseudoterminal support, see B<pts>(4).  Many "
"systems implement this function via a set-user-ID helper binary called "
"\"pt_chown\".  With Linux devpts no such helper binary is required."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:70
msgid ""
"B<open>(2), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pts>(4), "
"B<pty>(7)"
msgstr "B<open>(2), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pts>(4), B<pty>(7)"

#. type: TH
#: man-pages/man3/getusershell.3:30
#, no-wrap
msgid "GETUSERSHELL"
msgstr "GETUSERSHELL"

#. type: Plain text
#: man-pages/man3/getusershell.3:33
msgid "getusershell, setusershell, endusershell - get permitted user shells"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:38
#, no-wrap
msgid "B<char *getusershell(void);>\n"
msgstr "B<char *getusershell(void);>\n"

#. type: Plain text
#: man-pages/man3/getusershell.3:40
#, no-wrap
msgid "B<void setusershell(void);>\n"
msgstr "B<void setusershell(void);>\n"

#. type: Plain text
#: man-pages/man3/getusershell.3:42
#, no-wrap
msgid "B<void endusershell(void);>\n"
msgstr "B<void endusershell(void);>\n"

#. type: Plain text
#: man-pages/man3/getusershell.3:53
msgid "B<getusershell>(), B<setusershell>(), B<endusershell>():"
msgstr "B<getusershell>(), B<setusershell>(), B<endusershell>():"

#. type: Plain text
#: man-pages/man3/getusershell.3:75
msgid ""
"The B<getusershell>()  function returns the next line from the file "
"I</etc/shells>, opening the file if necessary.  The line should contain the "
"pathname of a valid user shell.  If I</etc/shells> does not exist or is "
"unreadable, B<getusershell>()  behaves as if I</bin/sh> and I</bin/csh> were"
" listed in the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:80
msgid "The B<setusershell>()  function rewinds I</etc/shells>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:85
msgid "The B<endusershell>()  function closes I</etc/shells>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:89
msgid "The B<getusershell>()  function returns NULL on end-of-file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:92
#, no-wrap
msgid "/etc/shells\n"
msgstr "/etc/shells\n"

#. type: Plain text
#: man-pages/man3/getusershell.3:101
msgid ""
"The B<getusershell>(), B<setusershell>()  and B<endusershell>()  functions "
"are not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:103
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: man-pages/man3/getusershell.3:104
msgid "B<shells>(5)"
msgstr "B<shells>(5)"

#. type: TH
#: man-pages/man3/gsignal.3:27
#, no-wrap
msgid "GSIGNAL"
msgstr "GSIGNAL"

#. type: TH
#: man-pages/man3/gsignal.3:27
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: man-pages/man3/gsignal.3:30
msgid "gsignal, ssignal - software signal facility"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:33
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:35
#, no-wrap
msgid "B<typedef void (*sighandler_t)(int);>\n"
msgstr "B<typedef void (*sighandler_t)(int);>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:37
#, no-wrap
msgid "B<int gsignal(int >I<signum>B<);>\n"
msgstr "B<int gsignal(int >I<signum>B<);>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:39
#, no-wrap
msgid "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"
msgstr "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"

#. type: Plain text
#: man-pages/man3/gsignal.3:49
msgid "B<gsignal>(), B<ssignal>(): _SVID_SOURCE"
msgstr "B<gsignal>(), B<ssignal>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/gsignal.3:57
msgid ""
"Don't use these functions under Linux.  Due to a historical mistake, under "
"Linux these functions are aliases for B<raise>(3)  and B<signal>(2), "
"respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:95
msgid ""
"Elsewhere, on System V-like systems, these functions implement software "
"signaling, entirely independent of the classical B<signal>(2)  and "
"B<kill>(2)  functions.  The function B<ssignal>()  defines the action to "
"take when the software signal with number I<signum> is raised using the "
"function B<gsignal>(), and returns the previous such action or B<SIG_DFL>.  "
"The function B<gsignal>()  does the following: if no action (or the action "
"B<SIG_DFL>)  was specified for I<signum>, then it does nothing and returns "
"0.  If the action B<SIG_IGN> was specified for I<signum>, then it does "
"nothing and returns 1.  Otherwise, it resets the action to B<SIG_DFL> and "
"calls the action function with argument I<signum>, and returns the value "
"returned by that function.  The range of possible values I<signum> varies "
"(often 1-15 or 1-17)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:103
msgid ""
"These functions are available under AIX, DG/UX, HP-UX, SCO, Solaris, Tru64."
"  They are called obsolete under most of these systems, and are broken under"
" Linux libc and glibc.  Some systems also have B<gsignal_r>()  and "
"B<ssignal_r>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:106
msgid "B<kill>(2), B<signal>(2), B<raise>(3)"
msgstr "B<kill>(2), B<signal>(2), B<raise>(3)"

#. type: TH
#: man-pages/man3/getlogin.3:28
#, no-wrap
msgid "GETLOGIN"
msgstr "GETLOGIN"

#. type: TH
#: man-pages/man3/getlogin.3:28
#, no-wrap
msgid "2013-04-19"
msgstr "2013-04-19"

#. type: Plain text
#: man-pages/man3/getlogin.3:31
msgid "getlogin, getlogin_r, cuserid - get username"
msgstr "getlogin, getlogin_r, cuserid - получить имя пользователя"

#. type: Plain text
#: man-pages/man3/getlogin.3:35
msgid "B<char *getlogin(void);>"
msgstr "B<char *getlogin(void);>"

#. type: Plain text
#: man-pages/man3/getlogin.3:37
msgid "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"
msgstr "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"

#. type: Plain text
#: man-pages/man3/getlogin.3:39
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getlogin.3:41
msgid "B<char *cuserid(char *>I<string>B<);>"
msgstr "B<char *cuserid(char *>I<string>B<);>"

#. type: Plain text
#: man-pages/man3/getlogin.3:49
msgid "B<getlogin_r>(): _REENTRANT || _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"
msgstr "B<getlogin_r>(): _REENTRANT || _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"

#. type: Plain text
#: man-pages/man3/getlogin.3:52
msgid "B<cuserid>(): _XOPEN_SOURCE"
msgstr "B<cuserid>(): _XOPEN_SOURCE"

#. type: Plain text
#: man-pages/man3/getlogin.3:61
msgid ""
"B<getlogin>()  returns a pointer to a string containing the name of the user"
" logged in on the controlling terminal of the process, or a null pointer if "
"this information cannot be determined.  The string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<cuserid>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:67
msgid ""
"B<getlogin_r>()  returns this same username in the array I<buf> of size "
"I<bufsize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:79
msgid ""
"B<cuserid>()  returns a pointer to a string containing a username associated"
" with the effective user ID of the process.  If I<string> is not a null "
"pointer, it should be an array that can hold at least B<L_cuserid> "
"characters; the string is returned in this array.  Otherwise, a pointer to a"
" string in a static area is returned.  This string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<getlogin>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:83
msgid ""
"The macro B<L_cuserid> is an integer constant that indicates how long an "
"array you might need to store a username.  B<L_cuserid> is declared in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:90
msgid ""
"These functions let your program identify positively the user who is running"
" (B<cuserid>())  or the user who logged in this session (B<getlogin>()).  "
"(These can differ when set-user-ID programs are involved.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:95
msgid ""
"For most purposes, it is more useful to use the environment variable "
"B<LOGNAME> to find out who the user is.  This is more flexible precisely "
"because the user can set B<LOGNAME> arbitrarily."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:103
msgid ""
"B<getlogin>()  returns a pointer to the username when successful, and NULL "
"on failure, with I<errno> set to indicate the cause of the error.  "
"B<getlogin_r>()  returns 0 when successful, and nonzero on failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:105
msgid "POSIX specifies"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:108
msgid ""
"The calling process already has the maximum allowed number of open files."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:111
msgid "The system already has the maximum allowed number of open files."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:114
msgid "The calling process has no controlling terminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:120
msgid ""
"(getlogin_r)  The length of the username, including the terminating null "
"byte (\\(aq\\e0\\(aq), is larger than I<bufsize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:122
msgid "Linux/glibc also has"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:125
msgid "There was no corresponding entry in the utmp-file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:128
msgid "Insufficient memory to allocate passwd structure."
msgstr ""

#. type: TP
#: man-pages/man3/getlogin.3:128
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: man-pages/man3/getlogin.3:132
msgid "Standard input didn't refer to a terminal.  (See BUGS.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:136
msgid "password database file"
msgstr "файл, содержащий базу паролей"

#. type: TP
#: man-pages/man3/getlogin.3:136
#, no-wrap
msgid "I</var/run/utmp>"
msgstr "I</var/run/utmp>"

#. type: Plain text
#: man-pages/man3/getlogin.3:140
msgid "(traditionally I</etc/utmp>; some libc versions used I</var/adm/utmp>)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:145
msgid "The B<getlogin>()  function is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:149
msgid "The B<getlogin_r>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:154
msgid ""
"The B<cuserid>()  function is thread-safe with exceptions.  It is not "
"thread-safe if called with a NULL parameter."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:159
msgid "B<getlogin>()  and B<getlogin_r>()  specified in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:170
msgid ""
"System V has a B<cuserid>()  function which uses the real user ID rather "
"than the effective user ID.  The B<cuserid>()  function was included in the "
"1988 version of POSIX, but removed from the 1990 version.  It was present in"
" SUSv2, but removed in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:177
msgid ""
"OpenBSD has B<getlogin>()  and B<setlogin>(), and a username associated with"
" a session, even if it has no controlling terminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:189
msgid ""
"Unfortunately, it is often rather easy to fool B<getlogin>().  Sometimes it "
"does not work at all, because some program messed up the utmp file.  Often, "
"it gives only the first 8 characters of the login name.  The user currently "
"logged in on the controlling terminal of our program need not be the user "
"who started it.  Avoid B<getlogin>()  for security-related purposes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:199
msgid ""
"Note that glibc does not follow the POSIX specification and uses I<stdin> "
"instead of I</dev/tty>.  A bug.  (Other recent systems, like SunOS 5.8 and "
"HP-UX 11.11 and FreeBSD 4.8 all return the login name also when I<stdin> is "
"redirected.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:209
msgid ""
"Nobody knows precisely what B<cuserid>()  does; avoid it in portable "
"programs.  Or avoid it altogether: use I<getpwuid(geteuid())> instead, if "
"that is what you meant.  B<Do not use> B<cuserid>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:212
msgid "B<geteuid>(2), B<getuid>(2), B<utmp>(5)"
msgstr "B<geteuid>(2), B<getuid>(2), B<utmp>(5)"

#. type: TH
#: man-pages/man3/getutmp.3:26
#, no-wrap
msgid "GETUTMP"
msgstr "GETUTMP"

#. type: Plain text
#: man-pages/man3/getutmp.3:29
msgid "getutmp, getutmpx - copy utmp structure to utmpx, and vice versa"
msgstr "getutmp, getutmpx - копирование структуры utmp в utmpx и наоборот"

#. type: Plain text
#: man-pages/man3/getutmp.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>utmpx.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>             /* См. feature_test_macros(7) */\nB<#include E<lt>utmpx.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getutmp.3:36
#, no-wrap
msgid ""
"B< void getutmp(const struct utmpx *>I<ux>B<, struct utmp *>I<u>B<);>\n"
"B< void getutmpx(const struct utmp *>I<u>B<, struct utmpx *>I<ux>B<);>\n"
msgstr "B< void getutmp(const struct utmpx *>I<ux>B<, struct utmp *>I<u>B<);>\nB< void getutmpx(const struct utmp *>I<u>B<, struct utmpx *>I<ux>B<);>\n"

#. type: Plain text
#: man-pages/man3/getutmp.3:51
msgid ""
"The B<getutmp>()  function copies the fields of the I<utmpx> structure "
"pointed to by I<ux> to the corresponding fields of the I<utmp> structure "
"pointed to by I<u>.  The B<getutmpx>()  function performs the converse "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:53
msgid "These functions do not return a value."
msgstr "Данные функции не возвращают никаких значений."

#. type: Plain text
#: man-pages/man3/getutmp.3:55
msgid "These functions first appeared in glibc in version 2.1.1."
msgstr "Эти функции впервые появились в glibc 2.1.1."

#. type: Plain text
#: man-pages/man3/getutmp.3:62
msgid "The B<getutmp>()  and B<getutmpx>()  functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:65
msgid ""
"These functions are nonstandard, but appear on a few other systems, such as "
"Solaris and NetBSD."
msgstr ""

#.  e.g., on Solaris, the utmpx structure is rather larger than utmp.
#. type: Plain text
#: man-pages/man3/getutmp.3:76
msgid ""
"These functions exist primarily for compatibility with other systems where "
"the I<utmp> and I<utmpx> structures contain different fields, or the size of"
" corresponding fields differs.  On Linux, the two structures contain the "
"same fields, and the fields have the same sizes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:79
msgid "B<utmpdump>(1), B<getutent>(3), B<utmp>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/gnu_get_libc_version.3:26
#, no-wrap
msgid "GNU_GET_LIBC_VERSION"
msgstr "GNU_GET_LIBC_VERSION"

#. type: TH
#: man-pages/man3/gnu_get_libc_version.3:26
#, no-wrap
msgid "2012-08-26"
msgstr "2012-08-26"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:29
msgid ""
"gnu_get_libc_version, gnu_get_libc_release - get glibc version and release"
msgstr "gnu_get_libc_version, gnu_get_libc_release - получение версии и релиза glibc"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:32
#, no-wrap
msgid "B<#include E<lt>gnu/libc-version.hE<gt>>\n"
msgstr "B<#include E<lt>gnu/libc-version.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:35
#, no-wrap
msgid ""
"B<const char *gnu_get_libc_version(void);>\n"
"B<const char *gnu_get_libc_release(void);>\n"
msgstr "B<const char *gnu_get_libc_version(void);>\nB<const char *gnu_get_libc_release(void);>\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:40
msgid ""
"The function B<gnu_get_libc_version>()  returns a string that identifies the"
" glibc version available on the system."
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:47
msgid ""
"The function B<gnu_get_libc_release>()  returns a string indicates the "
"release status of the glibc version available on the system.  This will be a"
" string such as I<stable>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:49
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:51
msgid "These functions are glibc-specific."
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:53
msgid "When run, the program below will produce output such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:59
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"GNU libc version: 2.8\n"
"GNU libc release: stable\n"
msgstr "$B< ./a.out>\nGNU libc version: 2.8\nGNU libc release: stable\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:67
#, no-wrap
msgid ""
"#include E<lt>gnu/libc-version.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>gnu/libc-version.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:75
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"GNU libc version: %s\\en\", gnu_get_libc_version());\n"
"    printf(\"GNU libc release: %s\\en\", gnu_get_libc_release());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    printf(\"GNU libc version: %s\\en\", gnu_get_libc_version());\n    printf(\"GNU libc release: %s\\en\", gnu_get_libc_release());\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:77
msgid "B<confstr>(3)"
msgstr "B<confstr>(3)"

#. type: TH
#: man-pages/man3/getttyent.3:7
#, no-wrap
msgid "GETTTYENT"
msgstr "GETTTYENT"

#. type: Plain text
#: man-pages/man3/getttyent.3:10
msgid "getttyent, getttynam, setttyent, endttyent - get ttys file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:12
msgid "B<#include E<lt>ttyent.hE<gt>>"
msgstr "B<#include E<lt>ttyent.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getttyent.3:14
msgid "B<struct ttyent *getttyent(void);>"
msgstr "B<struct ttyent *getttyent(void);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:16
msgid "B<struct ttyent *getttynam(const char *>I<name>B<);>"
msgstr "B<struct ttyent *getttynam(const char *>I<name>B<);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:18
msgid "B<int setttyent(void);>"
msgstr "B<int setttyent(void);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:20
msgid "B<int endttyent(void);>"
msgstr "B<int endttyent(void);>"

#. type: Plain text
#: man-pages/man3/getttyent.3:25
msgid ""
"These functions provide an interface to the file B<_PATH_TTYS> (e.g., "
"I</etc/ttys>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:29
msgid ""
"The function B<setttyent>()  opens the file or rewinds it if already open."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:33
msgid "The function B<endttyent>()  closes the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:40
msgid ""
"The function B<getttynam>()  searches for a given terminal name in the file."
"  It returns a pointer to a I<ttyent> structure (description below)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:50
msgid ""
"The function B<getttyent>()  opens the file B<_PATH_TTYS> (if necessary) and"
" returns the first entry.  If the file is already open, the next entry.  The"
" I<ttyent> structure has the form:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:61
#, no-wrap
msgid ""
"struct ttyent {\n"
"    char *ty_name;     /* terminal device name */\n"
"    char *ty_getty;    /* command to execute, usually getty */\n"
"    char *ty_type;     /* terminal type for termcap */\n"
"    int   ty_status;   /* status flags */\n"
"    char *ty_window;   /* command to start up window manager */\n"
"    char *ty_comment;  /* comment field */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:66
msgid "I<ty_status> can be:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:71
#, no-wrap
msgid ""
"#define TTY_ON     0x01  /* enable logins (start ty_getty program) */\n"
"#define TTY_SECURE 0x02  /* allow UID 0 to login */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:77
msgid ""
"The B<getttyent>()  function returns a pointer to a static variable, so it "
"is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:83
msgid ""
"The B<setttyent>()  and B<endttyent>()  functions use a static variable, so "
"they are not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:89
msgid ""
"The B<getttynam>()  function calls thread-unsafe function B<getttyent>()  so"
" it is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:92
msgid "Not in POSIX.1-2001.  Present on the BSDs, and perhaps other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:96
msgid ""
"Under Linux, the file I</etc/ttys>, and the functions described above, are "
"not used."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:98
msgid "B<ttyname>(3), B<ttyslot>(3)"
msgstr "B<ttyname>(3), B<ttyslot>(3)"

#. type: TH
#: man-pages/man3/getrpcent.3:8
#, no-wrap
msgid "GETRPCENT"
msgstr "GETRPCENT"

#. type: Plain text
#: man-pages/man3/getrpcent.3:12
msgid ""
"getrpcent, getrpcbyname, getrpcbynumber, setrpcent, endrpcent - get RPC "
"entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:17
#, no-wrap
msgid "B<struct rpcent *getrpcent(void);>\n"
msgstr "B<struct rpcent *getrpcent(void);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:19
#, no-wrap
msgid "B<struct rpcent *getrpcbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:21
#, no-wrap
msgid "B<struct rpcent *getrpcbynumber(int >I<number>B<);>\n"
msgstr "B<struct rpcent *getrpcbynumber(int >I<number>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:23
#, no-wrap
msgid "B<void setrpcent(int >I<stayopen>B<);>\n"
msgstr "B<void setrpcent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:25
#, no-wrap
msgid "B<void endrpcent(void);>\n"
msgstr "B<void endrpcent(void);>\n"

#. type: Plain text
#: man-pages/man3/getrpcent.3:36
msgid ""
"The B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  functions "
"each return a pointer to an object with the following structure containing "
"the broken-out fields of an entry in the RPC program number data base."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:44
#, no-wrap
msgid ""
"struct rpcent {\n"
"    char  *r_name;     /* name of server for this RPC program */\n"
"    char **r_aliases;  /* alias list */\n"
"    long   r_number;   /* RPC program number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:48
msgid "The members of this structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:49
#, no-wrap
msgid "I<r_name>"
msgstr "I<r_name>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:52
msgid "The name of the server for this RPC program."
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:52
#, no-wrap
msgid "I<r_aliases>"
msgstr "I<r_aliases>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:55
msgid "A NULL-terminated list of alternate names for the RPC program."
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:55
#, no-wrap
msgid "I<r_number>"
msgstr "I<r_number>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:58
msgid "The RPC program number for this service."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:64
msgid ""
"The B<getrpcent>()  function reads the next entry from the database.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:76
msgid ""
"The B<setrpcent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getrpc*>()  functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:80
msgid "The B<endrpcent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:88
msgid ""
"The B<getrpcbyname>()  and B<getrpcbynumber>()  functions sequentially "
"search from the beginning of the file until a matching RPC program name or "
"program number is found, or until end-of-file is encountered."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:98
msgid ""
"On success, B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  "
"return a pointer to a statically allocated I<rpcent> structure.  NULL is "
"returned on EOF or error."
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:99
#, no-wrap
msgid "I</etc/rpc>"
msgstr "I</etc/rpc>"

#. type: Plain text
#: man-pages/man3/getrpcent.3:102
msgid "RPC program number database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:110
msgid ""
"All information is contained in a static area so it must be copied if it is "
"to be saved."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:114
msgid "B<getrpcent_r>(3), B<rpc>(5), B<rpcinfo>(8), B<ypserv>(8)"
msgstr "B<getrpcent_r>(3), B<rpc>(5), B<rpcinfo>(8), B<ypserv>(8)"

#. type: TH
#: man-pages/man3/get_nprocs_conf.3:26
#, no-wrap
msgid "GET_NPROCS"
msgstr "GET_NPROCS"

#. type: TH
#: man-pages/man3/get_nprocs_conf.3:26
#, no-wrap
msgid "2012-03-20"
msgstr "2012-03-20"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:29
msgid "get_nprocs, get_nprocs_conf - get number of processors"
msgstr "get_nprocs, get_nprocs_conf - получение количества процессоров"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:31
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr "B<#include E<lt>sys/sysinfo.hE<gt>>"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:33
msgid "B<int get_nprocs(void);>"
msgstr "B<int get_nprocs(void);>"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:35
msgid "B<int get_nprocs_conf(void);>"
msgstr "B<int get_nprocs_conf(void);>"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:39
msgid ""
"The function B<get_nprocs_conf>()  returns the number of processors "
"configured by the operating system."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:46
msgid ""
"The function B<get_nprocs>()  returns the number of processors currently "
"available in the system.  This may be less than the number returned by "
"B<get_nprocs_conf>()  because processors may be offline (e.g., on "
"hotpluggable systems)."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:48
msgid "As given in DESCRIPTION."
msgstr "Как указано в ОПИСАНИИ."

#.  glibc 2.15
#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:57
msgid ""
"The current implementation of these functions is rather expensive, since "
"they open and parse files in the I</sys> filesystem each time they are "
"called."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:62
msgid ""
"The following B<sysconf>(3)  calls make use of the functions documented on "
"this page to return the same information."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:66
#, no-wrap
msgid ""
"    np = sysconf(_SC_NPROCESSORS_CONF);     /* processors configured */\n"
"    np = sysconf(_SC_NPROCESSORS_ONLN);     /* processors available */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:73
msgid ""
"The following example shows how B<get_nprocs>()  and B<get_nprocs_conf>()  "
"can be used."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:77
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>sys/sysinfo.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:86
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %d processors configured and \"\n"
"            \"%d processors available.\\en\",\n"
"            get_nprocs_conf(), get_nprocs());\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: TH
#: man-pages/man3/getifaddrs.3:36
#, no-wrap
msgid "GETIFADDRS"
msgstr "GETIFADDRS"

#. type: TH
#: man-pages/man3/getifaddrs.3:36
#, no-wrap
msgid "2014-02-26"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:39
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr "getifaddrs, freeifaddrs - получение адреса интерфейса"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>ifaddrs.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:45
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:47
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:58
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing"
" the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:77
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:84
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr ""

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: man-pages/man3/getifaddrs.3:91
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:100
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:109
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)  This field may contain a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:116
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family.  This "
"field may contain a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:131
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:136
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:142
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be"
" freed using B<freeifaddrs>()  when no longer needed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:149
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:162
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), B<malloc>(3), or B<realloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:170
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation supported only IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is "
"available only on kernels that support netlink."
msgstr ""

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: man-pages/man3/getifaddrs.3:190
msgid ""
"Not in POSIX.1-2001.  This function first appeared in BSDi and is present on"
" the BSD systems, but with slightly different semantics "
"documented\\(emreturning one entry per interface, not per address.  This "
"means I<ifa_addr> and other fields can actually be NULL if the interface has"
" no address, and no link-level address is returned if the interface has an "
"IP address assigned.  Also, the way of choosing either I<ifa_broadaddr> or "
"I<ifa_dstaddr> differs on various systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:207
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"rtnl_link_stats>, defined in I<E<lt>linux/if_link.hE<gt>> (in Linux 2.4 and "
"earlier, I<struct net_device_stats>, defined in "
"I<E<lt>linux/netdevice.hE<gt>>), which contains various interface attributes"
" and statistics."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:214
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(),"
" and B<getnameinfo>(3).  Here is what we see when running this program on "
"one system:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:235
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo       AF_PACKET (17)\n"
"                tx_packets =        524; rx_packets =        524\n"
"                tx_bytes   =      38788; rx_bytes   =      38788\n"
"wlp3s0   AF_PACKET (17)\n"
"                tx_packets =     108391; rx_packets =     130245\n"
"                tx_bytes   =   30420659; rx_bytes   =   94230014\n"
"em1      AF_PACKET (17)\n"
"                tx_packets =          0; rx_packets =          0\n"
"                tx_bytes   =          0; rx_bytes   =          0\n"
"lo       AF_INET (2)\n"
"                address: E<lt>127.0.0.1E<gt>\n"
"wlp3s0   AF_INET (2)\n"
"                address: E<lt>192.168.235.137E<gt>\n"
"lo       AF_INET6 (10)\n"
"                address: E<lt>::1E<gt>\n"
"wlp3s0   AF_INET6 (10)\n"
"                address: E<lt>fe80::7ee9:d3ff:fef5:1a91%wlp3s0E<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:249
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get defns of NI_MAXSERV and NI_MAXHOST */\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/if_link.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:255
#, no-wrap
msgid ""
"int main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr, *ifa;\n"
"    int family, s, n;\n"
"    char host[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:260
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (getifaddrs(&ifaddr) == -1) {\n        perror(\"getifaddrs\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:263
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:267
#, no-wrap
msgid ""
"    for (ifa = ifaddr, n = 0; ifa != NULL; ifa = ifa-E<gt>ifa_next, n++) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:269
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:272
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:279
#, no-wrap
msgid ""
"        printf(\"%-8s %s (%d)\\en\",\n"
"               ifa-E<gt>ifa_name,\n"
"               (family == AF_PACKET) ? \"AF_PACKET\" :\n"
"               (family == AF_INET) ? \"AF_INET\" :\n"
"               (family == AF_INET6) ? \"AF_INET6\" : \"???\",\n"
"               family);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:281
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:292
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST,\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:294
#, no-wrap
msgid "            printf(\"\\et\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:297
#, no-wrap
msgid ""
"        } else if (family == AF_PACKET && ifa-E<gt>ifa_data != NULL) {\n"
"            struct rtnl_link_stats *stats = ifa-E<gt>ifa_data;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:304
#, no-wrap
msgid ""
"            printf(\"\\et\\ettx_packets = %10u; rx_packets = %10u\\en\"\n"
"                   \"\\et\\ettx_bytes   = %10u; rx_bytes   = %10u\\en\",\n"
"                   stats-E<gt>tx_packets, stats-E<gt>rx_packets,\n"
"                   stats-E<gt>tx_bytes, stats-E<gt>rx_bytes);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:308
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    freeifaddrs(ifaddr);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getifaddrs.3:314
msgid ""
"B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr "B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"

#. type: TH
#: man-pages/man3/getline.3:26
#, no-wrap
msgid "GETLINE"
msgstr "GETLINE"

#. type: Plain text
#: man-pages/man3/getline.3:29
msgid "getline, getdelim - delimited string input"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:34
#, no-wrap
msgid ""
"B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE "
"*>I<stream>B<);>\n"
msgstr "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getline.3:37
#, no-wrap
msgid ""
"B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, "
"FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/getline.3:47
msgid "B<getline>(), B<getdelim>():"
msgstr "B<getline>(), B<getdelim>():"

#. type: TP
#: man-pages/man3/getline.3:49
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man3/getline.3:52
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"

#. type: TP
#: man-pages/man3/getline.3:52
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man3/getline.3:65
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is null-"
"terminated and includes the newline character, if one was found."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:77
msgid ""
"If I<*lineptr> is set to NULL and I<*n> is set 0 before the call, then "
"B<getline>()  will allocate a buffer for storing the line.  This buffer "
"should be freed by the user program even if B<getline>()  failed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:95
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:101
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:112
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:121
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters"
" read, including the delimiter character, but not including the terminating "
"null byte (\\(aq\\e0\\(aq).  This value can be used to handle embedded null "
"bytes in the line read."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:127
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition).  In the event of an error, I<errno> is set to indicate the "
"cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:137
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:139
msgid "These functions are available since libc 4.6.27."
msgstr "Эти функции доступны в libc начиная с 4.6.27."

#. type: Plain text
#: man-pages/man3/getline.3:146
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr "Функции B<getline>() и B<getdelim>() изначально были расширениями GNU. Позднее они были стандартизированы в POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/getline.3:151
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getline.3:159
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t read;\n"
msgstr "int\nmain(void)\n{\n    FILE *fp;\n    char *line = NULL;\n    size_t len = 0;\n    ssize_t read;\n"

#. type: Plain text
#: man-pages/man3/getline.3:163
#, no-wrap
msgid ""
"    fp = fopen(\"/etc/motd\", \"r\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"
msgstr "    fp = fopen(\"/etc/motd\", \"r\");\n    if (fp == NULL)\n        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: man-pages/man3/getline.3:168
#, no-wrap
msgid ""
"    while ((read = getline(&line, &len, fp)) != -1) {\n"
"        printf(\"Retrieved line of length %zu :\\en\", read);\n"
"        printf(\"%s\", line);\n"
"    }\n"
msgstr "    while ((read = getline(&line, &len, fp)) != -1) {\n        printf(\"Retrieved line of length %zu :\\en\", read);\n        printf(\"%s\", line);\n    }\n"

#. type: Plain text
#: man-pages/man3/getline.3:172
#, no-wrap
msgid ""
"    free(line);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    free(line);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getline.3:178
msgid "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<scanf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/glob.3:34
#, no-wrap
msgid "2007-10-10"
msgstr "2007-10-10"

#. type: Plain text
#: man-pages/man3/glob.3:37
msgid ""
"glob, globfree - find pathnames matching a pattern, free memory from glob()"
msgstr "glob, globfree - поиск имен путей по шаблону, освобождение памяти после glob()"

#. type: Plain text
#: man-pages/man3/glob.3:40
#, no-wrap
msgid "B<#include E<lt>glob.hE<gt>>\n"
msgstr "B<#include E<lt>glob.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/glob.3:42
#, no-wrap
msgid "B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"
msgstr "B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"

#. type: Plain text
#: man-pages/man3/glob.3:44
#, no-wrap
msgid ""
"B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int "
">I<eerrno>B<),>\n"
msgstr "B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int >I<eerrno>B<),>\n"

#. type: Plain text
#: man-pages/man3/glob.3:46
#, no-wrap
msgid "B<         glob_t *>I<pglob>B<);>\n"
msgstr "B<         glob_t *>I<pglob>B<);>\n"

#. type: Plain text
#: man-pages/man3/glob.3:48
#, no-wrap
msgid "B<void globfree(glob_t *>I<pglob>B<);>\n"
msgstr "B<void globfree(glob_t *>I<pglob>B<);>\n"

#. type: Plain text
#: man-pages/man3/glob.3:59
msgid ""
"The B<glob>()  function searches for all the pathnames matching I<pattern> "
"according to the rules used by the shell (see B<glob>(7)).  No tilde "
"expansion or parameter substitution is done; if you want these, use "
"B<wordexp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:65
msgid ""
"The B<globfree>()  function frees the dynamically allocated storage from an "
"earlier call to B<glob>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:76
msgid ""
"The results of a B<glob>()  call are stored in the structure pointed to by "
"I<pglob>.  This structure is of type I<glob_t> (declared in "
"I<E<lt>glob.hE<gt>>)  and includes the following elements defined by POSIX.2"
" (more may be present as an extension):"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:85
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t   gl_pathc;    /* Count of paths matched so far  */\n"
"    char   **gl_pathv;    /* List of matched pathnames.  */\n"
"    size_t   gl_offs;     /* Slots to reserve in I<gl_pathv>.  */\n"
"} glob_t;\n"
msgstr "typedef struct {\n    size_t   gl_pathc;    /* Число совпавших путей  */\n    char   **gl_pathv;    /* Список совпавших имен путей.  */\n    size_t   gl_offs;     /* Зарезервированные в I<gl_pathv> слоты.  */\n} glob_t;\n"

#. type: Plain text
#: man-pages/man3/glob.3:89
msgid "Results are stored in dynamically allocated storage."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:95
msgid ""
"The argument I<flags> is made up of the bitwise OR of zero or more the "
"following symbolic constants, which modify the behavior of B<glob>():"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:95
#, no-wrap
msgid "B<GLOB_ERR>"
msgstr "B<GLOB_ERR>"

#. type: Plain text
#: man-pages/man3/glob.3:103
msgid ""
"Return upon a read error (because a directory does not have read permission,"
" for example).  By default, B<glob>()  attempts carry on despite errors, "
"reading all of the directories that it can."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:103
#, no-wrap
msgid "B<GLOB_MARK>"
msgstr "B<GLOB_MARK>"

#. type: Plain text
#: man-pages/man3/glob.3:106
msgid "Append a slash to each path which corresponds to a directory."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:106
#, no-wrap
msgid "B<GLOB_NOSORT>"
msgstr "B<GLOB_NOSORT>"

#. type: Plain text
#: man-pages/man3/glob.3:111
msgid ""
"Don't sort the returned pathnames.  The only reason to do this is to save "
"processing time.  By default, the returned pathnames are sorted."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:111
#, no-wrap
msgid "B<GLOB_DOOFFS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:118
msgid ""
"Reserve I<pglob-E<gt>gl_offs> slots at the beginning of the list of strings "
"in I<pglob-E<gt>pathv>.  The reserved slots contain null pointers."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:118
#, no-wrap
msgid "B<GLOB_NOCHECK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:126
msgid ""
"If no pattern matches, return the original pattern.  By default, B<glob>()  "
"returns B<GLOB_NOMATCH> if there are no matches."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:126
#, no-wrap
msgid "B<GLOB_APPEND>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:133
msgid ""
"Append the results of this call to the vector of results returned by a "
"previous call to B<glob>().  Do not set this flag on the first invocation of"
" B<glob>()."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:133
#, no-wrap
msgid "B<GLOB_NOESCAPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:140
msgid ""
"Don't allow backslash (\\(aq\\e\\(aq) to be used as an escape character.  "
"Normally, a backslash can be used to quote the following character, "
"providing a mechanism to turn off the special meaning metacharacters."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:144
msgid ""
"I<flags> may also include any of the following, which are GNU extensions and"
" not defined by POSIX.2:"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:144
#, no-wrap
msgid "B<GLOB_PERIOD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:148
msgid ""
"Allow a leading period to be matched by metacharacters.  By default, "
"metacharacters can't match a leading period."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:148
#, no-wrap
msgid "B<GLOB_ALTDIRFUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:158
msgid ""
"Use alternative functions I<pglob-E<gt>gl_closedir>, "
"I<pglob-E<gt>gl_readdir>, I<pglob-E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat>, "
"and I<pglob-E<gt>gl_stat> for filesystem access instead of the normal "
"library functions."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:158
#, no-wrap
msgid "B<GLOB_BRACE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:174
msgid ""
"Expand B<csh>(1)  style brace expressions of the form B<{a,b}>.  Brace "
"expressions can be nested.  Thus, for example, specifying the pattern "
"\"{foo/{,cat,dog},bar}\" would return the same results as four separate "
"B<glob>()  calls using the strings: \"foo/\", \"foo/cat\", \"foo/dog\", and "
"\"bar\"."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:174
#, no-wrap
msgid "B<GLOB_NOMAGIC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:179
msgid ""
"If the pattern contains no metacharacters, then it should be returned as the"
" sole matching word, even if there is no file with that name."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:179
#, no-wrap
msgid "B<GLOB_TILDE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:191
msgid ""
"Carry out tilde expansion.  If a tilde (\\(aq~\\(aq) is the only character "
"in the pattern, or an initial tilde is followed immediately by a slash "
"(\\(aq/\\(aq), then the home directory of the caller is substituted for the "
"tilde.  If an initial tilde is followed by a username (e.g., "
"\"~andrea/bin\"), then the tilde and username are substituted by the home "
"directory of that user.  If the username is invalid, or the home directory "
"cannot be determined, then no substitution is performed."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:191
#, no-wrap
msgid "B<GLOB_TILDE_CHECK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:202
msgid ""
"This provides behavior similar to that of B<GLOB_TILDE>.  The difference is "
"that if the username is invalid, or the home directory cannot be determined,"
" then instead of using the pattern itself as the name, B<glob>()  returns "
"B<GLOB_NOMATCH> to indicate an error."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:202
#, no-wrap
msgid "B<GLOB_ONLYDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:215
msgid ""
"This is a I<hint> to B<glob>()  that the caller is interested only in "
"directories that match the pattern.  If the implementation can easily "
"determine file-type information, then nondirectory files are not returned to"
" the caller.  However, the caller must still check that returned files are "
"directories.  (The purpose of this flag is merely to optimize performance "
"when the caller is interested only in directories.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:238
msgid ""
"If I<errfunc> is not NULL, it will be called in case of an error with the "
"arguments I<epath>, a pointer to the path which failed, and I<eerrno>, the "
"value of I<errno> as returned from one of the calls to B<opendir>(3), "
"B<readdir>(3), or B<stat>(2).  If I<errfunc> returns nonzero, or if "
"B<GLOB_ERR> is set, B<glob>()  will terminate after the call to I<errfunc>."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:245
msgid ""
"Upon successful return, I<pglob-E<gt>gl_pathc> contains the number of "
"matched pathnames and I<pglob-E<gt>gl_pathv> contains a pointer to the list "
"of pointers to matched pathnames.  The list of pointers is terminated by a "
"null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:254
msgid ""
"It is possible to call B<glob>()  several times.  In that case, the "
"B<GLOB_APPEND> flag has to be set in I<flags> on the second and later "
"invocations."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:262
msgid ""
"As a GNU extension, I<pglob-E<gt>gl_flags> is set to the flags specified, "
"B<or>ed with B<GLOB_MAGCHAR> if any metacharacters were found."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:267
msgid ""
"On successful completion, B<glob>()  returns zero.  Other possible returns "
"are:"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:267
#, no-wrap
msgid "B<GLOB_NOSPACE>"
msgstr "B<GLOB_NOSPACE>"

#. type: Plain text
#: man-pages/man3/glob.3:270
msgid "for running out of memory,"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:270
#, no-wrap
msgid "B<GLOB_ABORTED>"
msgstr "B<GLOB_ABORTED>"

#. type: Plain text
#: man-pages/man3/glob.3:273
msgid "for a read error, and"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:273
#, no-wrap
msgid "B<GLOB_NOMATCH>"
msgstr "B<GLOB_NOMATCH>"

#. type: Plain text
#: man-pages/man3/glob.3:276
msgid "for no found matches."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:278
msgid "POSIX.2, POSIX.1-2001."
msgstr "POSIX.2, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/glob.3:289
msgid ""
"The structure elements I<gl_pathc> and I<gl_offs> are declared as I<size_t> "
"in glibc 2.1, as they should be according to POSIX.2, but are declared as "
"I<int> in libc4, libc5 and glibc 2.0."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:298
msgid ""
"The B<glob>()  function may fail due to failure of underlying function "
"calls, such as B<malloc>(3)  or B<opendir>(3).  These will store their error"
" code in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:300
msgid "One example of use is the following code, which simulates typing"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:303
msgid "ls -l *.c ../*.c"
msgstr "ls -l *.c ../*.c"

#. type: Plain text
#: man-pages/man3/glob.3:306
msgid "in the shell:"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:310
#, no-wrap
msgid "glob_t globbuf;\n"
msgstr "glob_t globbuf;\n"

#. type: Plain text
#: man-pages/man3/glob.3:317
#, no-wrap
msgid ""
"globbuf.gl_offs = 2;\n"
"glob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\n"
"glob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\n"
"globbuf.gl_pathv[0] = \"ls\";\n"
"globbuf.gl_pathv[1] = \"-l\";\n"
"execvp(\"ls\", &globbuf.gl_pathv[0]);\n"
msgstr "globbuf.gl_offs = 2;\nglob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\nglob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\nglobbuf.gl_pathv[0] = \"ls\";\nglobbuf.gl_pathv[1] = \"-l\";\nexecvp(\"ls\", &globbuf.gl_pathv[0]);\n"

#. type: Plain text
#: man-pages/man3/glob.3:329
msgid ""
"B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"
msgstr "B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"

#. type: TH
#: man-pages/man3/getaddrinfo_a.3:29
#, no-wrap
msgid "GETADDRINFO_A"
msgstr "GETADDRINFO_A"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:33
msgid ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - asynchronous network "
"address and service translation"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* См. feature_test_macros(7) */\nB<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:40
#, no-wrap
msgid ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr "B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\nB<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:43
#, no-wrap
msgid ""
"B<int gai_suspend(const struct gaicb * const >I<list[]>B<, int >I<nitems>B<,>\n"
"B<                const struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:45
#, no-wrap
msgid "B<int gai_error(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_error(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:47
#, no-wrap
msgid "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"
msgstr "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:49
#, no-wrap
msgid "Link with I<-lanl>.\n"
msgstr "Компонуется при указании параметра I<-lanl>.\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:57
msgid ""
"The B<getaddrinfo_a>()  function performs the same task as "
"B<getaddrinfo>(3), but allows multiple name look-ups to be performed "
"asynchronously, with optional notification on completion of look-up "
"operations."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:61
msgid "The I<mode> argument has one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:61
#, no-wrap
msgid "B<GAI_WAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:65
msgid ""
"Perform the look-ups synchronously.  The call blocks until the look-ups have"
" completed."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:65
#, no-wrap
msgid "B<GAI_NOWAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:73
msgid ""
"Perform the look-ups asynchronously.  The call returns immediately, and the "
"requests are resolved in the background.  See the discussion of the I<sevp> "
"argument below."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:88
msgid ""
"The array I<list> specifies the look-up requests to process.  The I<nitems> "
"argument specifies the number of elements in I<list>.  The requested look-up"
" operations are started in parallel.  NULL elements in I<list> are ignored."
"  Each request is described by a I<gaicb> structure, defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:97
#, no-wrap
msgid ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:128
msgid ""
"The elements of this structure correspond to the arguments of "
"B<getaddrinfo>(3).  Thus, I<ar_name> corresponds to the I<node> argument and"
" I<ar_service> to the I<service> argument, identifying an Internet host and "
"a service.  The I<ar_request> element corresponds to the I<hints> argument, "
"specifying the criteria for selecting the returned socket address "
"structures.  Finally, I<ar_result> corresponds to the I<res> argument; you "
"do not need to initialize this element, it will be automatically set when "
"the request is resolved.  The I<addrinfo> structure referenced by the last "
"two elements is described in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:144
msgid ""
"When I<mode> is specified as B<GAI_NOWAIT>, notifications about resolved "
"requests can be obtained by employing the I<sigevent> structure pointed to "
"by the I<sevp> argument.  For the definition and general details of this "
"structure, see B<sigevent>(7).  The I<sevp-E<gt>sigev_notify> field can have"
" the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:144
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:147
msgid "Don't provide any notification."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:147
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#.  si_pid and si_uid are also set, to the values of the calling process,
#.  which doesn't provide useful information, so we'll skip mentioning it.
#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:163
msgid ""
"When a look-up completes, generate the signal I<sigev_signo> for the "
"process.  See B<sigevent>(7)  for general details.  The I<si_code> field of "
"the I<siginfo_t> structure will be set to B<SI_ASYNCNL>."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:163
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:171
msgid ""
"When a look-up completes, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:180
msgid ""
"For B<SIGEV_SIGNAL> and B<SIGEV_THREAD>, it may be useful to point "
"I<sevp-E<gt>sigev_value.sival_ptr> to I<list>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:191
msgid ""
"The B<gai_suspend>()  function suspends execution of the calling thread, "
"waiting for the completion of one or more requests in the array I<list>.  "
"The I<nitems> argument specifies the size of the array I<list>.  The call "
"blocks until one of the following occurs:"
msgstr ""

#. type: IP
#: man-pages/man3/getaddrinfo_a.3:191 man-pages/man3/getaddrinfo_a.3:195
#: man-pages/man3/getaddrinfo_a.3:197
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:195
msgid "One or more of the operations in I<list> completes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:197
msgid "The call is interrupted by a signal that is caught."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:210
msgid ""
"The time interval specified in I<timeout> elapses.  This argument specifies "
"a timeout in seconds plus nanoseconds (see B<nanosleep>(2)  for details of "
"the I<timespec> structure).  If I<timeout> is NULL, then the call blocks "
"indefinitely (until one of the events above occurs)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:215
msgid ""
"No explicit indication of which request was completed is given; you must "
"determine which request(s) have completed by iterating with B<gai_error>()  "
"over the list of requests."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:225
msgid ""
"The B<gai_error>()  function returns the status of the request I<req>: "
"either B<EAI_INPROGRESS> if the request was not completed yet, 0 if it was "
"handled successfully, or an error code if the request could not be resolved."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:242
msgid ""
"The B<gai_cancel>()  function cancels the request I<req>.  If the request "
"has been canceled successfully, the error status of the request will be set "
"to B<EAI_CANCELLED> and normal asynchronous notification will be performed."
"  The request cannot be canceled if it is currently being processed; in that"
" case, it will be handled as if B<gai_cancel>()  has never been called.  If "
"I<req> is NULL, an attempt is made to cancel all outstanding requests that "
"the process has made."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:247
msgid ""
"The B<getaddrinfo_a>()  function returns 0 if all of the requests have been "
"enqueued successfully, or one of the following nonzero error codes:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:252
msgid ""
"The resources necessary to enqueue the look-up requests were not available."
"  The application may check the error status of each request to determine "
"which ones failed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:259
msgid "I<mode> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:264
msgid ""
"The B<gai_suspend>()  function returns 0 if at least one of the listed "
"requests has been completed.  Otherwise, it returns one of the following "
"nonzero error codes:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:267
msgid ""
"The given timeout expired before any of the requests could be completed."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:267 man-pages/man3/getaddrinfo_a.3:297
#, no-wrap
msgid "B<EAI_ALLDONE>"
msgstr "B<EAI_ALLDONE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:270
msgid "There were no actual requests given to the function."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:270
#, no-wrap
msgid "B<EAI_INTR>"
msgstr "B<EAI_INTR>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:275
msgid ""
"A signal has interrupted the function.  Note that this interruption might "
"have been caused by signal notification of some completed look-up request."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:287
msgid ""
"The B<gai_error>()  function can return B<EAI_INPROGRESS> for an unfinished "
"look-up request, 0 for a successfully completed look-up (as described "
"above), one of the error codes that could be returned by B<getaddrinfo>(3), "
"or the error code B<EAI_CANCELLED> if the request has been canceled "
"explicitly before it could be finished."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:291
msgid "The B<gai_cancel>()  function can return one of these values:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:291
#, no-wrap
msgid "B<EAI_CANCELLED>"
msgstr "B<EAI_CANCELLED>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:294
msgid "The request has been canceled successfully."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:294
#, no-wrap
msgid "B<EAI_NOTCANCELLED>"
msgstr "B<EAI_NOTCANCELLED>"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:297
msgid "The request has not been canceled."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:300
msgid "The request has already completed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:308
msgid ""
"These functions are GNU extensions; they first appeared in glibc in version "
"2.2.3."
msgstr "Эти функции являются расширениями GNU, доступными в glibc начиная с версии 2.2.3."

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:314
msgid ""
"The interface of B<getaddrinfo_a>()  was modeled after the B<lio_listio>(3)"
"  interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:318
msgid ""
"Two examples are provided: a simple example that resolves several requests "
"in parallel synchronously, and a complex example showing some of the "
"asynchronous capabilities."
msgstr ""

#. type: SS
#: man-pages/man3/getaddrinfo_a.3:318
#, no-wrap
msgid "Synchronous example"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:323
msgid ""
"The program below simply resolves several hostnames in parallel, giving a "
"speed-up compared to resolving the hostnames sequentially using "
"B<getaddrinfo>(3).  The program might be used like this:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:330
#, no-wrap
msgid ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:334
msgid "Here is the program source code"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:341 man-pages/man3/getaddrinfo_a.3:430
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>netdb.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:349
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int i, ret;\n    struct gaicb *reqs[argc - 1];\n    char host[NI_MAXHOST];\n    struct addrinfo *res;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:354
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:364
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"
msgstr "    for (i = 0; i E<lt> argc - 1; i++) {\n        reqs[i] = malloc(sizeof(*reqs[0]));\n        if (reqs[i] == NULL) {\n            perror(\"malloc\");\n            exit(EXIT_FAILURE);\n        }\n        memset(reqs[i], 0, sizeof(*reqs[0]));\n        reqs[i]-E<gt>ar_name = argv[i + 1];\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:371
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n    if (ret != 0) {\n        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n                gai_strerror(ret));\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:377
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr "    for (i = 0; i E<lt> argc - 1; i++) {\n        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n        ret = gai_error(reqs[i]);\n        if (ret == 0) {\n            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:387
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
msgstr "            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n                    host, sizeof(host),\n                    NULL, 0, NI_NUMERICHOST);\n            if (ret != 0) {\n                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n                        gai_strerror(ret));\n                exit(EXIT_FAILURE);\n            }\n            puts(host);\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:394
#, no-wrap
msgid ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "        } else {\n            puts(gai_strerror(ret));\n        }\n    }\n    exit(EXIT_SUCCESS);\n}\n"

#. type: SS
#: man-pages/man3/getaddrinfo_a.3:395
#, no-wrap
msgid "Asynchronous example"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:400
msgid ""
"This example shows a simple interactive B<getaddrinfo_a>()  front-end.  The "
"notification facility is not demonstrated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:402
msgid "An example session might look like this:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:419
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"
msgstr "$ B<./a.out>\nE<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\nE<gt> c 2\n[2] gnu.cz: Request not canceled\nE<gt> w 0 1\n[00] ftp.us.kernel.org: Finished\nE<gt> l\n[00] ftp.us.kernel.org: 216.165.129.139\n[01] enoent.linuxfoundation.org: Processing request in progress\n[02] gnu.cz: 87.236.197.13\nE<gt> l\n[00] ftp.us.kernel.org: 216.165.129.139\n[01] enoent.linuxfoundation.org: Name or service not known\n[02] gnu.cz: 87.236.197.13\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:423
msgid "The program source is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:433
#, no-wrap
msgid ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"
msgstr "static struct gaicb **reqs = NULL;\nstatic int nreqs = 0;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:438
#, no-wrap
msgid ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"
msgstr "static char *\ngetcmd(void)\n{\n    static char buf[256];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:442
#, no-wrap
msgid ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"
msgstr "    fputs(\"E<gt> \", stdout); fflush(stdout);\n    if (fgets(buf, sizeof(buf), stdin) == NULL)\n        return NULL;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:445
#, no-wrap
msgid ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"
msgstr "    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n        buf[strlen(buf) - 1] = 0;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:448
#, no-wrap
msgid ""
"    return buf;\n"
"}\n"
msgstr "    return buf;\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:456
#, no-wrap
msgid ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:460
#, no-wrap
msgid ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"
msgstr "    while ((host = strtok(NULL, \" \"))) {\n        nreqs++;\n        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:464
#, no-wrap
msgid ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"
msgstr "        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:466
#, no-wrap
msgid "    /* Queue nreqs_base..nreqs requests. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:475
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:484
#, no-wrap
msgid ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int i, ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:487 man-pages/man3/getaddrinfo_a.3:524
#, no-wrap
msgid ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"
msgstr "    while ((id = strtok(NULL, \" \")) != NULL) {\n        n = atoi(id);\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:492 man-pages/man3/getaddrinfo_a.3:529
#, no-wrap
msgid ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:495
#, no-wrap
msgid ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"
msgstr "        wait_reqs[n] = reqs[n];\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:501
#, no-wrap
msgid ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:505
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"
msgstr "    for (i = 0; i E<lt> nreqs; i++) {\n        if (wait_reqs[i] == NULL)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:509
#, no-wrap
msgid ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"
msgstr "        ret = gai_error(reqs[i]);\n        if (ret == EAI_INPROGRESS)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:514
#, no-wrap
msgid ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr "        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n               ret == 0 ? \"Finished\" : gai_strerror(ret));\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:521
#, no-wrap
msgid ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:535
#, no-wrap
msgid ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr "        ret = gai_cancel(reqs[n]);\n        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n               gai_strerror(ret));\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:543
#, no-wrap
msgid ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int i, ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:547
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
msgstr "    for (i = 0; i E<lt> nreqs; i++) {\n        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n        ret = gai_error(reqs[i]);\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:550
#, no-wrap
msgid ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr "        if (!ret) {\n            res = reqs[i]-E<gt>ar_result;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:565
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"
msgstr "            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n                              host, sizeof(host),\n                              NULL, 0, NI_NUMERICHOST);\n            if (ret) {\n                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n                        gai_strerror(ret));\n                exit(EXIT_FAILURE);\n            }\n            puts(host);\n        } else {\n            puts(gai_strerror(ret));\n        }\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:571
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char *cmdline;\n    char *cmd;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:574
#, no-wrap
msgid ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"
msgstr "    while ((cmdline = getcmd()) != NULL) {\n        cmd = strtok(cmdline, \" \");\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:599
#, no-wrap
msgid ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "        if (cmd == NULL) {\n            list_requests();\n        } else {\n            switch (cmd[0]) {\n            case \\(aqa\\(aq:\n                add_requests();\n                break;\n            case \\(aqw\\(aq:\n                wait_requests();\n                break;\n            case \\(aqc\\(aq:\n                cancel_requests();\n                break;\n            case \\(aql\\(aq:\n                list_requests();\n                break;\n            default:\n                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n                break;\n            }\n        }\n    }\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:606
msgid ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"
msgstr "B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), B<sigevent>(7)"

#. type: TH
#: man-pages/man3/getnetent.3:30
#, no-wrap
msgid "GETNETENT"
msgstr "GETNETENT"

#. type: Plain text
#: man-pages/man3/getnetent.3:34
msgid ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - get network "
"entry"
msgstr "getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - получить запись сети"

#. type: Plain text
#: man-pages/man3/getnetent.3:39
#, no-wrap
msgid "B<struct netent *getnetent(void);>\n"
msgstr "B<struct netent *getnetent(void);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:41
#, no-wrap
msgid "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"
msgstr "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:43
#, no-wrap
msgid "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"
msgstr "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:45
#, no-wrap
msgid "B<void setnetent(int >I<stayopen>B<);>\n"
msgstr "B<void setnetent(int >I<stayopen>B<);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:47
#, no-wrap
msgid "B<void endnetent(void);>\n"
msgstr "B<void endnetent(void);>\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:57
msgid ""
"The B<getnetent>()  function reads the next entry from the networks database"
" and returns a I<netent> structure containing the broken-out fields from the"
" entry.  A connection is opened to the database if necessary."
msgstr "Функция B<getnetent>() считывает следующую запись из файла, содержащего базу сетей, и возвращает структуру I<netent>, содержащую поля из этой записи. При необходимости будет открыто подключение к базе."

#. type: Plain text
#: man-pages/man3/getnetent.3:66
msgid ""
"The B<getnetbyname>()  function returns a I<netent> structure for the entry "
"from the database that matches the network I<name>."
msgstr "Функция B<getnetbyname>() возвращает структуру I<netent> для записи из базы, соответствующей сети I<name>."

#. type: Plain text
#: man-pages/man3/getnetent.3:80
msgid ""
"The B<getnetbyaddr>()  function returns a I<netent> structure for the entry "
"from the database that matches the network number I<net> of type I<type>.  "
"The I<net> argument must be in host byte order."
msgstr "Функция B<getnetbyaddr>() возвращает структуру I<netent> для записи из базы, которая соответствует номеру сети  I<net> типа  I<type>. Аргумент I<net> должен использовать порядок байтов, использующийся на машине."

#. type: Plain text
#: man-pages/man3/getnetent.3:92
msgid ""
"The B<setnetent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getnet*>()  functions."
msgstr "Функция B<setnetent>() открывает соединение к базе и устанавливает следующую запись к первой записи. Если I<stayopen> не равен нулю, то подключение к базе между вызовами нескольких функций B<getnet*>() не будет закрыто."

#. type: Plain text
#: man-pages/man3/getnetent.3:96
msgid "The B<endnetent>()  function closes the connection to the database."
msgstr "Функция B<endnetent>() закрывает подключение к базе."

#. type: Plain text
#: man-pages/man3/getnetent.3:102
msgid "The I<netent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr "Структура I<netent> определена в I<E<lt>netdb.hE<gt>> таким образом:"

#. type: Plain text
#: man-pages/man3/getnetent.3:111
#, no-wrap
msgid ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"
msgstr "struct netent {\n    char      *n_name;     /* официальное имя сети */\n    char     **n_aliases;  /* список псевдонимов */\n    int        n_addrtype; /* тип сетевого адреса */\n    uint32_t   n_net;      /* номер сети */\n}\n"

#. type: Plain text
#: man-pages/man3/getnetent.3:117
msgid "The members of the I<netent> structure are:"
msgstr "Члены структуры I<netent>:"

#. type: TP
#: man-pages/man3/getnetent.3:117
#, no-wrap
msgid "I<n_name>"
msgstr "I<n_name>"

#. type: Plain text
#: man-pages/man3/getnetent.3:120
msgid "The official name of the network."
msgstr "Официальное название сети."

#. type: TP
#: man-pages/man3/getnetent.3:120
#, no-wrap
msgid "I<n_aliases>"
msgstr "I<n_aliases>"

#. type: Plain text
#: man-pages/man3/getnetent.3:123
msgid "A NULL-terminated list of alternative names for the network."
msgstr "Список альтернативных имен сети, завершенных символом NULL."

#. type: TP
#: man-pages/man3/getnetent.3:123
#, no-wrap
msgid "I<n_addrtype>"
msgstr "I<n_addrtype>"

#. type: Plain text
#: man-pages/man3/getnetent.3:127
msgid "The type of the network number; always B<AF_INET>."
msgstr "Тип номера сети, всегда равно B<AF_INET>."

#. type: TP
#: man-pages/man3/getnetent.3:127
#, no-wrap
msgid "I<n_net>"
msgstr "I<n_net>"

#. type: Plain text
#: man-pages/man3/getnetent.3:130
msgid "The network number in host byte order."
msgstr "Номер сети в порядке байтов, использующемся на машине."

#. type: Plain text
#: man-pages/man3/getnetent.3:141
msgid ""
"The B<getnetent>(), B<getnetbyname>()  and B<getnetbyaddr>()  functions "
"return a pointer to a statically allocated I<netent> structure, or a null "
"pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: man-pages/man3/getnetent.3:142
#, no-wrap
msgid "I</etc/networks>"
msgstr "I</etc/networks>"

#. type: Plain text
#: man-pages/man3/getnetent.3:145
msgid "networks database file"
msgstr "Файл, содержащий базу сетей"

#. type: Plain text
#: man-pages/man3/getnetent.3:154
msgid ""
"In glibc versions before 2.2, the I<net> argument of B<getnetbyaddr>()  was "
"of type I<long>."
msgstr "В версия glibc ниже 2.2 аргумент I<net> из B<getnetbyaddr>() имел тип I<long>."

#.  .BR networks (5)
#. type: Plain text
#: man-pages/man3/getnetent.3:159
msgid "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"
msgstr "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"

#. type: Plain text
#: man-pages/man3/getnetent.3:160
msgid "RFC\\ 1101"
msgstr "RFC\\ 1101"

#. type: TH
#: man-pages/man3/getgrent_r.3:24
#, no-wrap
msgid "GETGRENT_R"
msgstr "GETGRENT_R"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:27
msgid "getgrent_r, fgetgrent_r - get group file entry reentrantly"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:30
#, no-wrap
msgid "B<#include E<lt>grp.hE<gt>>\n"
msgstr "B<#include E<lt>grp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:32
#, no-wrap
msgid "B<int getgrent_r(struct group *>I<gbuf>B<, char *>I<buf>B<,>\n"
msgstr "B<int getgrent_r(struct group *>I<gbuf>B<, char *>I<buf>B<,>\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:34
#, no-wrap
msgid "B<               size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"
msgstr "B<               size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:36
#, no-wrap
msgid ""
"B<int fgetgrent_r(FILE *>I<fp>B<, struct group *>I<gbuf>B<, char "
"*>I<buf>B<,>\n"
msgstr "B<int fgetgrent_r(FILE *>I<fp>B<, struct group *>I<gbuf>B<, char *>I<buf>B<,>\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:38
#, no-wrap
msgid "B<                size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"
msgstr "B<                size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"

#.  FIXME . The FTM requirements seem inconsistent here.  File a glibc bug?
#. type: Plain text
#: man-pages/man3/getgrent_r.3:48
msgid "B<getgrent_r>(): _GNU_SOURCE"
msgstr "B<getgrent_r>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:51
msgid "B<fgetgrent_r>(): _SVID_SOURCE"
msgstr "B<fgetgrent_r>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:64
msgid ""
"The functions B<getgrent_r>()  and B<fgetgrent_r>()  are the reentrant "
"versions of B<getgrent>(3)  and B<fgetgrent>(3).  The former reads the next "
"group entry from the stream initialized by B<setgrent>(3).  The latter reads"
" the next group entry from the stream I<fp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:102
msgid ""
"The nonreentrant functions return a pointer to static storage, where this "
"static storage contains further pointers to group name, password and "
"members.  The reentrant functions described here return all of that in "
"caller-provided buffers.  First of all there is the buffer I<gbuf> that can "
"hold a I<struct group>.  And next the buffer I<buf> of size I<buflen> that "
"can hold additional strings.  The result of these functions, the I<struct "
"group> read from the stream, is stored in the provided buffer I<*gbuf>, and "
"a pointer to this I<struct group> is returned in I<*gbufp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:109
msgid ""
"On success, these functions return 0 and I<*gbufp> is a pointer to the "
"I<struct group>.  On error, these functions return an error value and "
"I<*gbufp> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:127
#, no-wrap
msgid ""
"struct group *getgrent_r(struct group *grp, char *buf,\n"
"                         int buflen);\n"
msgstr "struct group *getgrent_r(struct group *grp, char *buf,\n                         int buflen);\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:136
#, no-wrap
msgid ""
"int getgrent_r(struct group *grp, char *buf, int buflen,\n"
"               FILE **gr_fp);\n"
msgstr "int getgrent_r(struct group *grp, char *buf, int buflen,\n               FILE **gr_fp);\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:143
msgid ""
"The function B<getgrent_r>()  is not really reentrant since it shares the "
"reading position in the stream with all other threads."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:150
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>grp.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#define BUFLEN 4096\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>grp.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#define BUFLEN 4096\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:157
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct group grp, *grpp;\n"
"    char buf[BUFLEN];\n"
"    int i;\n"
msgstr "int\nmain(void)\n{\n    struct group grp, *grpp;\n    char buf[BUFLEN];\n    int i;\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:174
#, no-wrap
msgid ""
"    setgrent();\n"
"    while (1) {\n"
"        i = getgrent_r(&grp, buf, BUFLEN, &grpp);\n"
"        if (i)\n"
"            break;\n"
"        printf(\"%s (%d):\", grpp-E<gt>gr_name, grpp-E<gt>gr_gid);\n"
"        for (i = 0; ; i++) {\n"
"            if (grpp-E<gt>gr_mem[i] == NULL)\n"
"                break;\n"
"            printf(\" %s\", grpp-E<gt>gr_mem[i]);\n"
"        }\n"
"        printf(\"\\en\");\n"
"    }\n"
"    endgrent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    setgrent();\n    while (1) {\n        i = getgrent_r(&grp, buf, BUFLEN, &grpp);\n        if (i)\n            break;\n        printf(\"%s (%d):\", grpp-E<gt>gr_name, grpp-E<gt>gr_gid);\n        for (i = 0; ; i++) {\n            if (grpp-E<gt>gr_mem[i] == NULL)\n                break;\n            printf(\" %s\", grpp-E<gt>gr_mem[i]);\n        }\n        printf(\"\\en\");\n    }\n    endgrent();\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/getgrent_r.3:190
msgid ""
"B<fgetgrent>(3), B<getgrent>(3), B<getgrgid>(3), B<getgrnam>(3), "
"B<putgrent>(3), B<group>(5)"
msgstr "B<fgetgrent>(3), B<getgrent>(3), B<getgrgid>(3), B<getgrnam>(3), B<putgrent>(3), B<group>(5)"

#. type: TH
#: man-pages/man3/getspnam.3:8
#, no-wrap
msgid "GETSPNAM"
msgstr "GETSPNAM"

#. type: Plain text
#: man-pages/man3/getspnam.3:13
msgid ""
"getspnam, getspnam_r, getspent, getspent_r, setspent, endspent, fgetspent, "
"fgetspent_r, sgetspent, sgetspent_r, putspent, lckpwdf, ulckpwdf - get "
"shadow password file entry"
msgstr "getspnam, getspnam_r, getspent, getspent_r, setspent, endspent, fgetspent, fgetspent_r, sgetspent, sgetspent_r, putspent, lckpwdf, ulckpwdf - получение записи из теневого файла паролей"

#. type: Plain text
#: man-pages/man3/getspnam.3:16
#, no-wrap
msgid "/* General shadow password file API */\n"
msgstr "/* Основной API теневого файла паролей */\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:18 man-pages/man3/getspnam.3:40
#, no-wrap
msgid "B<#include E<lt>shadow.hE<gt>>\n"
msgstr "B<#include E<lt>shadow.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:20
#, no-wrap
msgid "B<struct spwd *getspnam(const char *>I<name>B<);>\n"
msgstr "B<struct spwd *getspnam(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:22
#, no-wrap
msgid "B<struct spwd *getspent(void);>\n"
msgstr "B<struct spwd *getspent(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:24
#, no-wrap
msgid "B<void setspent(void);>\n"
msgstr "B<void setspent(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:26
#, no-wrap
msgid "B<void endspent(void);>\n"
msgstr "B<void endspent(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:28
#, no-wrap
msgid "B<struct spwd *fgetspent(FILE *>I<fp>B<);>\n"
msgstr "B<struct spwd *fgetspent(FILE *>I<fp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:30
#, no-wrap
msgid "B<struct spwd *sgetspent(const char *>I<s>B<);>\n"
msgstr "B<struct spwd *sgetspent(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:32
#, no-wrap
msgid "B<int putspent(const struct spwd *>I<p>B<, FILE *>I<fp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:34
#, no-wrap
msgid "B<int lckpwdf(void);>\n"
msgstr "B<int lckpwdf(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:36
#, no-wrap
msgid "B<int ulckpwdf(void);>\n"
msgstr "B<int ulckpwdf(void);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:38
#, no-wrap
msgid "/* GNU extension */\n"
msgstr "/* Расширение GNU */\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:42
#, no-wrap
msgid "B<int getspent_r(struct spwd *>I<spbuf>B<,>\n"
msgstr "B<int getspent_r(struct spwd *>I<spbuf>B<,>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:44 man-pages/man3/getspnam.3:48
#: man-pages/man3/getspnam.3:52 man-pages/man3/getspnam.3:56
#, no-wrap
msgid ""
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd "
"**>I<spbufp>B<);>\n"
msgstr "B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:46
#, no-wrap
msgid "B<int getspnam_r(const char *>I<name>B<, struct spwd *>I<spbuf>B<,>\n"
msgstr "B<int getspnam_r(const char *>I<name>B<, struct spwd *>I<spbuf>B<,>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:50
#, no-wrap
msgid "B<int fgetspent_r(FILE *>I<fp>B<, struct spwd *>I<spbuf>B<,>\n"
msgstr "B<int fgetspent_r(FILE *>I<fp>B<, struct spwd *>I<spbuf>B<,>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:54
#, no-wrap
msgid "B<int sgetspent_r(const char *>I<s>B<, struct spwd *>I<spbuf>B<,>\n"
msgstr "B<int sgetspent_r(const char *>I<s>B<, struct spwd *>I<spbuf>B<,>\n"

#. type: Plain text
#: man-pages/man3/getspnam.3:68
msgid "B<getspent_r>(), B<getspnam_r>(), B<fgetspent_r>(), B<sgetspent_r>():"
msgstr "B<getspent_r>(), B<getspnam_r>(), B<fgetspent_r>(), B<sgetspent_r>():"

#. type: Plain text
#: man-pages/man3/getspnam.3:84
msgid ""
"Long ago it was considered safe to have encrypted passwords openly visible "
"in the password file.  When computers got faster and people got more "
"security-conscious, this was no longer acceptable.  Julianne Frances Haugh "
"implemented the shadow password suite that keeps the encrypted passwords in "
"the shadow password database (e.g., the local shadow password file "
"I</etc/shadow>, NIS, and LDAP), readable only by root."
msgstr "В давние времена считалось, что хранить зашифрованные пароли в открытом доступе достаточно безопасно. Со временем компьютеры стали быстрее, а люди - более обеспокоенными проблемами безопасности, и данный подход стал неприемлемым. Джулиан Франс Хог (Julianne Frances Haugh) реализовал набор программ для теневых паролей, который хранит зашифрованные пароли в теневой файловой базе данных (например в теневом файле паролей I</etc/shadow>, NIS или LDAP), доступной для чтения только root."

#.  FIXME I've commented out the following for the
#.  moment.  The relationship between PAM and nsswitch.conf needs
#.  to be clearly documented in one place, which is pointed to by
#.  the pages for the user, group, and shadow password functions.
#.  (Jul 2005, mtk)
#.  This shadow password setup has been superseded by PAM
#.  (pluggable authentication modules), and the file
#.  .I /etc/nsswitch.conf
#.  now describes the sources to be used.
#. type: Plain text
#: man-pages/man3/getspnam.3:101
msgid ""
"The functions described below resemble those for the traditional password "
"database (e.g., see B<getpwnam>(3)  and B<getpwent>(3))."
msgstr "Описанные ниже функции соответствуют аналогами для традиционной базы паролей (см. B<getpwnam>(3) and B<getpwent>(3))."

#. type: Plain text
#: man-pages/man3/getspnam.3:108
msgid ""
"The B<getspnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the shadow password database that matches"
" the username I<name>."
msgstr ""

#.  some systems require a call of setspent() before the first getspent()
#.  glibc does not
#. type: Plain text
#: man-pages/man3/getspnam.3:120
msgid ""
"The B<getspent>()  function returns a pointer to the next entry in the "
"shadow password database.  The position in the input stream is initialized "
"by B<setspent>().  When done reading, the program may call B<endspent>()  so"
" that resources can be deallocated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:127
msgid ""
"The B<fgetspent>()  function is similar to B<getspent>()  but uses the "
"supplied stream instead of the one implicitly opened by B<setspent>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:134
msgid ""
"The B<sgetspent>()  function parses the supplied string I<s> into a struct "
"I<spwd>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:144
msgid ""
"The B<putspent>()  function writes the contents of the supplied struct "
"I<spwd> I<*p> as a text line in the shadow password file format to the "
"stream I<fp>.  String entries with value NULL and numerical entries with "
"value -1 are written as an empty string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:159
msgid ""
"The B<lckpwdf>()  function is intended to protect against multiple "
"simultaneous accesses of the shadow password database.  It tries to acquire "
"a lock, and returns 0 on success, or -1 on failure (lock not obtained within"
" 15 seconds).  The B<ulckpwdf>()  function releases the lock again.  Note "
"that there is no protection against direct access of the shadow password "
"file.  Only programs that use B<lckpwdf>()  will notice the lock."
msgstr ""

#.  Also in libc5
#.  SUN doesn't have sgetspent()
#. type: Plain text
#: man-pages/man3/getspnam.3:164
msgid ""
"These were the functions that formed the original shadow API.  They are "
"widely available."
msgstr ""

#. type: SS
#: man-pages/man3/getspnam.3:164
#, no-wrap
msgid "Reentrant versions"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:181
msgid ""
"Analogous to the reentrant functions for the password database, glibc also "
"has reentrant functions for the shadow password database.  The "
"B<getspnam_r>()  function is like B<getspnam>()  but stores the retrieved "
"shadow password structure in the space pointed to by I<spbuf>.  This shadow "
"password structure contains pointers to strings, and these strings are "
"stored in the buffer I<buf> of size I<buflen>.  A pointer to the result (in "
"case of success) or NULL (in case no entry was found or an error occurred) "
"is stored in I<*spbufp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:188
msgid ""
"The functions B<getspent_r>(), B<fgetspent_r>(), and B<sgetspent_r>()  are "
"similarly analogous to their nonreentrant counterparts."
msgstr ""

#.  SUN doesn't have sgetspent_r()
#. type: Plain text
#: man-pages/man3/getspnam.3:192
msgid ""
"Some non-glibc systems also have functions with these names, often with "
"different prototypes."
msgstr ""

#. type: SS
#: man-pages/man3/getspnam.3:192
#, no-wrap
msgid "Structure"
msgstr "Структура"

#. type: Plain text
#: man-pages/man3/getspnam.3:194
msgid ""
"The shadow password structure is defined in I<E<lt>shadow.hE<gt>> as "
"follows:"
msgstr "Структура теневого пароля определена в I<E<lt>shadow.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/getspnam.3:214
#, no-wrap
msgid ""
"struct spwd {\n"
"    char *sp_namp;     /* Login name */\n"
"    char *sp_pwdp;     /* Encrypted password */\n"
"    long  sp_lstchg;   /* Date of last change\n"
"                          (measured in days since\n"
"                          1970-01-01 00:00:00 +0000 (UTC)) */\n"
"    long  sp_min;      /* Min # of days between changes */\n"
"    long  sp_max;      /* Max # of days between changes */\n"
"    long  sp_warn;     /* # of days before password expires\n"
"                          to warn user to change it */\n"
"    long  sp_inact;    /* # of days after password expires\n"
"                          until account is disabled */\n"
"    long  sp_expire;   /* Date when account expires\n"
"                          (measured in days since\n"
"                          1970-01-01 00:00:00 +0000 (UTC)) */\n"
"    unsigned long sp_flag;  /* Reserved */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:223
msgid ""
"The functions that return a pointer return NULL if no more entries are "
"available or if an error occurs during processing.  The functions which have"
" I<int> as the return value return 0 for success and -1 for failure, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:226
msgid ""
"For the nonreentrant functions, the return value may point to static area, "
"and may be overwritten by subsequent calls to these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:229
msgid ""
"The reentrant functions return zero on success.  In case of error, an error "
"number is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:233
msgid ""
"The caller does not have permission to access the shadow password file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:236
msgid "Supplied buffer is too small."
msgstr "Указанный буфер слишком мал."

#. type: TP
#: man-pages/man3/getspnam.3:237
#, no-wrap
msgid "I</etc/shadow>"
msgstr "I</etc/shadow>"

#. type: Plain text
#: man-pages/man3/getspnam.3:240
msgid "local shadow password database file"
msgstr "файл, содержащий базу локальных теневых паролей"

#. type: TP
#: man-pages/man3/getspnam.3:240
#, no-wrap
msgid "I</etc/.pwd.lock>"
msgstr "I</etc/.pwd.lock>"

#. type: Plain text
#: man-pages/man3/getspnam.3:243
msgid "lock file"
msgstr "файл блокировки"

#. type: Plain text
#: man-pages/man3/getspnam.3:249
msgid ""
"The include file I<E<lt>paths.hE<gt>> defines the constant B<_PATH_SHADOW> "
"to the pathname of the shadow password file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:253
msgid ""
"The shadow password database and its associated API are not specified in "
"POSIX.1-2001.  However, many other systems provide a similar API."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:257
msgid "B<getgrnam>(3), B<getpwnam>(3), B<getpwnam_r>(3), B<shadow>(5)"
msgstr "B<getgrnam>(3), B<getpwnam>(3), B<getpwnam_r>(3), B<shadow>(5)"

#. type: TH
#: man-pages/man3/getaddrinfo.3:43
#, no-wrap
msgid "GETADDRINFO"
msgstr "GETADDRINFO"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:47
msgid ""
"getaddrinfo, freeaddrinfo, gai_strerror - network address and service "
"translation"
msgstr "getaddrinfo, freeaddrinfo, gai_strerror - трансляция сетевого адреса и сервиса"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:52
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/socket.hE<gt>>\nB<#include E<lt>netdb.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:56
#, no-wrap
msgid ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"
msgstr "B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\nB<                const struct addrinfo *>I<hints>B<,>\nB<                struct addrinfo **>I<res>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:58
#, no-wrap
msgid "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"
msgstr "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:60
#, no-wrap
msgid "B<const char *gai_strerror(int >I<errcode>B<);>\n"
msgstr "B<const char *gai_strerror(int >I<errcode>B<);>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:71
msgid "B<getaddrinfo>(), B<freeaddrinfo>(), B<gai_strerror>():"
msgstr "B<getaddrinfo>(), B<freeaddrinfo>(), B<gai_strerror>():"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:73
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#.  .BR getipnodebyname (3),
#.  .BR getipnodebyaddr (3),
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:100
msgid ""
"Given I<node> and I<service>, which identify an Internet host and a service,"
" B<getaddrinfo>()  returns one or more I<addrinfo> structures, each of which"
" contains an Internet address that can be specified in a call to B<bind>(2)"
"  or B<connect>(2).  The B<getaddrinfo>()  function combines the "
"functionality provided by the B<gethostbyname>(3)  and B<getservbyname>(3)  "
"functions into a single interface, but unlike the latter functions, "
"B<getaddrinfo>()  is reentrant and allows programs to eliminate IPv4-versus-"
"IPv6 dependencies."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:106
msgid ""
"The I<addrinfo> structure used by B<getaddrinfo>()  contains the following "
"fields:"
msgstr "Структура I<addrinfo>, используемая в B<getaddrinfo>(), содержит следующие поля:"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:119
#, no-wrap
msgid ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"
msgstr "struct addrinfo {\n    int              ai_flags;\n    int              ai_family;\n    int              ai_socktype;\n    int              ai_protocol;\n    socklen_t        ai_addrlen;\n    struct sockaddr *ai_addr;\n    char            *ai_canonname;\n    struct addrinfo *ai_next;\n};\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:141
msgid ""
"The I<hints> argument points to an I<addrinfo> structure that specifies "
"criteria for selecting the socket address structures returned in the list "
"pointed to by I<res>.  If I<hints> is not NULL it points to an I<addrinfo> "
"structure whose I<ai_family>, I<ai_socktype>, and I<ai_protocol> specify "
"criteria that limit the set of socket addresses returned by "
"B<getaddrinfo>(), as follows:"
msgstr "Аргумент I<hints> указывает на структуру I<addrinfo>, которая определяет критерии выбора структур адреса сокета, возвращаемых в списке, указанном в I<res>. Если I<hints> не является NULL, то он указывает на структуру I<addrinfo>. В ней с помощью I<ai_family>, I<ai_socktype> и I<ai_protocol> определяются критерии, ограничивающие набор адресов сокета, возвращаемых B<getaddrinfo>():"

#. type: TP
#: man-pages/man3/getaddrinfo.3:141
#, no-wrap
msgid "I<ai_family>"
msgstr "I<ai_family>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:157
msgid ""
"This field specifies the desired address family for the returned addresses."
"  Valid values for this field include B<AF_INET> and B<AF_INET6>.  The value"
" B<AF_UNSPEC> indicates that B<getaddrinfo>()  should return socket "
"addresses for any address family (either IPv4 or IPv6, for example) that can"
" be used with I<node> and I<service>."
msgstr "Это поле определяет предпочитаемое семейство адресов для возвращаемых адресов. Правильными значениями для данного поля могут быть B<AF_INET> и B<AF_INET6>. Значение B<AF_UNSPEC> отображает, что B<getaddrinfo>() должна возвращать адреса сокета для любого семейства адресов (например, либо IPv4, либо IPv6), которые в дальнейшем могут быть использованы вместе с I<node> и I<service>."

#. type: TP
#: man-pages/man3/getaddrinfo.3:157
#, no-wrap
msgid "I<ai_socktype>"
msgstr "I<ai_socktype>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:166
msgid ""
"This field specifies the preferred socket type, for example B<SOCK_STREAM> "
"or B<SOCK_DGRAM>.  Specifying 0 in this field indicates that socket "
"addresses of any type can be returned by B<getaddrinfo>()."
msgstr "Это поле определяет предпочитаемы тип сокета, например, B<SOCK_STREAM> или B<SOCK_DGRAM>. Если в этом поле указан 0, то это означает, что B<getaddrinfo>() может вернуть адреса сокета любого типа."

#. type: TP
#: man-pages/man3/getaddrinfo.3:166
#, no-wrap
msgid "I<ai_protocol>"
msgstr "I<ai_protocol>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:172
msgid ""
"This field specifies the protocol for the returned socket addresses.  "
"Specifying 0 in this field indicates that socket addresses with any protocol"
" can be returned by B<getaddrinfo>()."
msgstr "Это поле определяет протокол для возвращаемых адресов сокета. Если в этом поле указан 0, то это означает, что B<getaddrinfo>() может вернуть адрес сокета с любым протоколом."

#. type: TP
#: man-pages/man3/getaddrinfo.3:172
#, no-wrap
msgid "I<ai_flags>"
msgstr "I<ai_flags>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:176
msgid ""
"This field specifies additional options, described below.  Multiple flags "
"are specified by bitwise OR-ing them together."
msgstr "Это поле определяет дополнительные параметры, описываемые ниже. Несколько флагов указываются с логическим ИЛИ."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:180
msgid ""
"All the other fields in the structure pointed to by I<hints> must contain "
"either 0 or a null pointer, as appropriate."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:215
msgid ""
"Specifying I<hints> as NULL is equivalent to setting I<ai_socktype> and "
"I<ai_protocol> to 0; I<ai_family> to B<AF_UNSPEC>; and I<ai_flags> to "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>.  (POSIX specifies different defaults "
"for I<ai_flags>; see NOTES.)  I<node> specifies either a numerical network "
"address (for IPv4, numbers-and-dots notation as supported by "
"B<inet_aton>(3); for IPv6, hexadecimal string format as supported by "
"B<inet_pton>(3)), or a network hostname, whose network addresses are looked "
"up and resolved.  If I<hints.ai_flags> contains the B<AI_NUMERICHOST> flag, "
"then I<node> must be a numerical network address.  The B<AI_NUMERICHOST> "
"flag suppresses any potentially lengthy network host address lookups."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:240
msgid ""
"If the B<AI_PASSIVE> flag is specified in I<hints.ai_flags>, and I<node> is "
"NULL, then the returned socket addresses will be suitable for B<bind>(2)ing "
"a socket that will B<accept>(2)  connections.  The returned socket address "
"will contain the \"wildcard address\" (B<INADDR_ANY> for IPv4 addresses, "
"B<IN6ADDR_ANY_INIT> for IPv6 address).  The wildcard address is used by "
"applications (typically servers)  that intend to accept connections on any "
"of the hosts's network addresses.  If I<node> is not NULL, then the "
"B<AI_PASSIVE> flag is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:260
msgid ""
"If the B<AI_PASSIVE> flag is not set in I<hints.ai_flags>, then the returned"
" socket addresses will be suitable for use with B<connect>(2), B<sendto>(2),"
" or B<sendmsg>(2).  If I<node> is NULL, then the network address will be set"
" to the loopback interface address (B<INADDR_LOOPBACK> for IPv4 addresses, "
"B<IN6ADDR_LOOPBACK_INIT> for IPv6 address); this is used by applications "
"that intend to communicate with peers running on the same host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:283
msgid ""
"I<service> sets the port in each returned address structure.  If this "
"argument is a service name (see B<services>(5)), it is translated to the "
"corresponding port number.  This argument can also be specified as a decimal"
" number, which is simply converted to binary.  If I<service> is NULL, then "
"the port number of the returned socket addresses will be left uninitialized."
"  If B<AI_NUMERICSERV> is specified in I<hints.ai_flags> and I<service> is "
"not NULL, then I<service> must point to a string containing a numeric port "
"number.  This flag is used to inhibit the invocation of a name resolution "
"service in cases where it is known not to be required."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:289
msgid "Either I<node> or I<service>, but not both, may be NULL."
msgstr "Либо  I<node>, либо I<service> (но не оба одновременно) могут принимать значение NULL."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:305
msgid ""
"The B<getaddrinfo>()  function allocates and initializes a linked list of "
"I<addrinfo> structures, one for each network address that matches I<node> "
"and I<service>, subject to any restrictions imposed by I<hints>, and returns"
" a pointer to the start of the list in I<res>.  The items in the linked list"
" are linked by the I<ai_next> field."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:327
msgid ""
"There are several reasons why the linked list may have more than one "
"I<addrinfo> structure, including: the network host is multihomed, accessible"
" over multiple protocols (e.g., both B<AF_INET> and B<AF_INET6>); or the "
"same service is available from multiple socket types (one B<SOCK_STREAM> "
"address and another B<SOCK_DGRAM> address, for example).  Normally, the "
"application should try using the addresses in the order in which they are "
"returned.  The sorting function used within B<getaddrinfo>()  is defined in "
"RFC\\ 3484; the order can be tweaked for a particular system by editing "
"I</etc/gai.conf> (available since glibc 2.5)."
msgstr ""

#.  In glibc prior to 2.3.4, the ai_canonname of each addrinfo
#.  structure was set pointing to the canonical name; that was
#.  more than POSIX.1-2001 specified, or other implementations provided.
#.  MTK, Aug 05
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:342
msgid ""
"If I<hints.ai_flags> includes the B<AI_CANONNAME> flag, then the "
"I<ai_canonname> field of the first of the I<addrinfo> structures in the "
"returned list is set to point to the official name of the host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:346
msgid ""
"The remaining fields of each returned I<addrinfo> structure are initialized "
"as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:369
msgid ""
"The I<ai_family>, I<ai_socktype>, and I<ai_protocol> fields return the "
"socket creation parameters (i.e., these fields have the same meaning as the "
"corresponding arguments of B<socket>(2)).  For example, I<ai_family> might "
"return B<AF_INET> or B<AF_INET6>; I<ai_socktype> might return B<SOCK_DGRAM> "
"or B<SOCK_STREAM>; and I<ai_protocol> returns the protocol for the socket."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:376
msgid ""
"A pointer to the socket address is placed in the I<ai_addr> field, and the "
"length of the socket address, in bytes, is placed in the I<ai_addrlen> "
"field."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:395
msgid ""
"If I<hints.ai_flags> includes the B<AI_ADDRCONFIG> flag, then IPv4 addresses"
" are returned in the list pointed to by I<res> only if the local system has "
"at least one IPv4 address configured, and IPv6 addresses are returned only "
"if the local system has at least one IPv6 address configured.  The loopback "
"address is not considered for this case as valid as a configured address.  "
"This flag is useful on, for example, IPv4-only systems, to ensure that "
"B<getaddrinfo>()  does not return IPv6 socket addresses that would always "
"fail in B<connect>(2)  or B<bind>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:420
msgid ""
"If I<hints.ai_flags> specifies the B<AI_V4MAPPED> flag, and "
"I<hints.ai_family> was specified as B<AF_INET6>, and no matching IPv6 "
"addresses could be found, then return IPv4-mapped IPv6 addresses in the list"
" pointed to by I<res>.  If both B<AI_V4MAPPED> and B<AI_ALL> are specified "
"in I<hints.ai_flags>, then return both IPv6 and IPv4-mapped IPv6 addresses "
"in the list pointed to by I<res>.  B<AI_ALL> is ignored if B<AI_V4MAPPED> is"
" not also specified."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:426
msgid ""
"The B<freeaddrinfo>()  function frees the memory that was allocated for the "
"dynamically allocated linked list I<res>."
msgstr ""

#. type: SS
#: man-pages/man3/getaddrinfo.3:426
#, no-wrap
msgid "Extensions to getaddrinfo() for Internationalized Domain Names"
msgstr "Расширения getaddrinfo() для интернациональный доменных имен"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:435
msgid ""
"Starting with glibc 2.3.4, B<getaddrinfo>()  has been extended to "
"selectively allow the incoming and outgoing hostnames to be transparently "
"converted to and from the Internationalized Domain Name (IDN) format (see "
"RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>).  Four "
"new flags are defined:"
msgstr "Начиная с glibc 2.3.4, B<getaddrinfo>() был расширен для выборочного прозрачного разрешения исходящих и входящих адресов в формате интернациональных доменных имен (IDN, см. RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>). Было определено четыре новых флага:"

#. type: TP
#: man-pages/man3/getaddrinfo.3:435
#, no-wrap
msgid "B<AI_IDN>"
msgstr "B<AI_IDN>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:441
msgid ""
"If this flag is specified, then the node name given in I<node> is converted "
"to IDN format if necessary.  The source encoding is that of the current "
"locale."
msgstr "Если указан этот флаг, то, в случае необходимости, имя узла, указанного в I<node>, будет преобразовано в IDN-формат. Исходной кодировкой будет текущая локаль."

#.  Implementation Detail:
#.  To minimize effects on system performance the implementation might
#.  want to check whether the input string contains any non-ASCII
#.  characters.  If there are none the IDN step can be skipped completely.
#.  On systems which allow not-ASCII safe encodings for a locale this
#.  might be a problem.
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:453
msgid ""
"If the input name contains non-ASCII characters, then the IDN encoding is "
"used.  Those parts of the node name (delimited by dots) that contain non-"
"ASCII characters are encoded using ASCII Compatible Encoding (ACE)  before "
"being passed to the name resolution functions."
msgstr "Если имя на входе содержит символы не-ASCII, то будет задействовано кодирование IDN. Части имени узла (разделенные точками), которые содержат символы не-ASCII, будут закодированы с помощью ASCII Compatible Encoding (ACE) прежде, чем будут переданы функциям преобразования имен"

#. type: TP
#: man-pages/man3/getaddrinfo.3:453
#, no-wrap
msgid "B<AI_CANONIDN>"
msgstr "B<AI_CANONIDN>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:465
msgid ""
"After a successful name lookup, and if the B<AI_CANONNAME> flag was "
"specified, B<getaddrinfo>()  will return the canonical name of the node "
"corresponding to the I<addrinfo> structure value passed back.  The return "
"value is an exact copy of the value returned by the name resolution "
"function."
msgstr "При указанном флаге B<AI_CANONNAME> после успешного преобразования имени B<getaddrinfo>() вернет каноничное имя узла согласно значению структуры I<addrinfo>. Возвращаемое значение будет точной копией значения, возвращенного функцией разрешения имени."

#. Implementation Detail:
#. If no component of the returned name starts with xn\-\- the IDN
#. step can be skipped, therefore avoiding unnecessary slowdowns.
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:478
msgid ""
"If the name is encoded using ACE, then it will contain the I<xn--> prefix "
"for one or more components of the name.  To convert these components into a "
"readable form the B<AI_CANONIDN> flag can be passed in addition to "
"B<AI_CANONNAME>.  The resulting string is encoded using the current locale's"
" encoding."
msgstr "Если имя закодировано с помощью ACE, то оно будет содержать префикс I<xn--> для каждого из закодированных компонентов имени. Чтобы преобразовать эти компоненты в читаемый вид, вместе с флагом B<AI_CANONNAME> следует передать B<AI_CANONIDN>. Итоговая строка будет кодирована при помощи текущей локали."

#. type: TP
#: man-pages/man3/getaddrinfo.3:478
#, no-wrap
msgid "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"
msgstr "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getaddrinfo(); they need to
#.  be documented.
#.  #ifdef __USE_GNU
#.  #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.  #define EAI_CANCELED    -101  /* Request canceled.  */
#.  #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.  #define EAI_ALLDONE     -103  /* All requests done.  */
#.  #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.  #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.  #endif
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:499
msgid ""
"B<getaddrinfo>()  returns 0 if it succeeds, or one of the following nonzero "
"error codes:"
msgstr "В случае успеха B<getaddrinfo>() возвращает 0, либо один из следующие ненулевых кодов ошибки:"

#. type: TP
#: man-pages/man3/getaddrinfo.3:499
#, no-wrap
msgid "B<EAI_ADDRFAMILY>"
msgstr "B<EAI_ADDRFAMILY>"

#.  Not in SUSv3
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:504
msgid ""
"The specified network host does not have any network addresses in the "
"requested address family."
msgstr "У указанного сетевого узла нет сетевых адресов в запрашиваемом семействе адресов."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:508
msgid ""
"The name server returned a temporary failure indication.  Try again later."
msgstr "Сервер имен вернул временную ошибку. Попробуйте позднее."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:518
msgid ""
"I<hints.ai_flags> contains invalid flags; or, I<hints.ai_flags> included "
"B<AI_CANONNAME> and I<name> was NULL."
msgstr "В I<hints.ai_flags> содержатся неправильные флаги, либо I<hints.ai_flags> содержит B<AI_CANONNAME>, а I<name> - NULL."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:521
msgid "The name server returned a permanent failure indication."
msgstr "Сервер имен вернул постоянную ошибку."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:524
msgid "The requested address family is not supported."
msgstr "Запрашиваемое семейство адресов не поддерживается."

#. type: TP
#: man-pages/man3/getaddrinfo.3:527
#, no-wrap
msgid "B<EAI_NODATA>"
msgstr "B<EAI_NODATA>"

#.  Not in SUSv3
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:532
msgid ""
"The specified network host exists, but does not have any network addresses "
"defined."
msgstr "Указанный сетевой узел существует, однако не имеет ни одного определенного сетевого адреса."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:549
msgid ""
"The I<node> or I<service> is not known; or both I<node> and I<service> are "
"NULL; or B<AI_NUMERICSERV> was specified in I<hints.ai_flags> and I<service>"
" was not a numeric port-number string."
msgstr "I<node> или I<service> неизвестно; либо и I<node>, и I<service> равны NULL; либо в I<hints.ai_flags> указан флаг B<AI_NUMERICSERV>, а I<service> не является числовой строкой порта."

#. type: TP
#: man-pages/man3/getaddrinfo.3:549
#, no-wrap
msgid "B<EAI_SERVICE>"
msgstr "B<EAI_SERVICE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:570
msgid ""
"The requested service is not available for the requested socket type.  It "
"may be available through another socket type.  For example, this error could"
" occur if I<service> was \"shell\" (a service available only on stream "
"sockets), and either I<hints.ai_protocol> was B<IPPROTO_UDP>, or "
"I<hints.ai_socktype> was B<SOCK_DGRAM>; or the error could occur if "
"I<service> was not NULL, and I<hints.ai_socktype> was B<SOCK_RAW> (a socket "
"type that does not support the concept of services)."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:570
#, no-wrap
msgid "B<EAI_SOCKTYPE>"
msgstr "B<EAI_SOCKTYPE>"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:582
msgid ""
"The requested socket type is not supported.  This could occur, for example, "
"if I<hints.ai_socktype> and I<hints.ai_protocol> are inconsistent (e.g., "
"B<SOCK_DGRAM> and B<IPPROTO_TCP>, respectively)."
msgstr "Запрашиваемый тип сокетов не поддерживается. Такая ошибка может возникнуть, если I<hints.ai_socktype> и I<hints.ai_protocol> противоречат друг другу (например, B<SOCK_DGRAM> и B<IPPROTO_TCP> соответственно)."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:587
msgid "Other system error, check I<errno> for details."
msgstr "Для других системных ошибок следует проверять I<errno>."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:592
msgid ""
"The B<gai_strerror>()  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr "Функция B<gai_strerror>() транслирует эти коды ошибок в читаемый формат, подходящий для сообщений об ошибке."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:599
msgid ""
"POSIX.1-2001.  The B<getaddrinfo>()  function is documented in RFC\\ 2553."
msgstr "POSIX.1-2001. Функция B<getaddrinfo>() описана в RFC\\ 2553."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:604
msgid ""
"B<getaddrinfo>()  supports the I<address>B<%>I<scope-id> notation for "
"specifying the IPv6 scope-ID."
msgstr "B<getaddrinfo>() поддерживает нотацию I<address>B<%>I<scope-id> для указания IPv6 scope-ID."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:612
msgid ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, and B<AI_V4MAPPED> are available since glibc "
"2.3.3.  B<AI_NUMERICSERV> is available since glibc 2.3.4."
msgstr "B<AI_ADDRCONFIG>, B<AI_ALL> и B<AI_V4MAPPED> доступны, начиная с glibc 2.3.3.  B<AI_NUMERICSERV> доступен, начиная с glibc 2.3.4."

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:622
msgid ""
"According to POSIX.1-2001, specifying I<hints> as NULL should cause "
"I<ai_flags> to be assumed as 0.  The GNU C library instead assumes a value "
"of B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> for this case, since this value is "
"considered an improvement on the specification."
msgstr "Согласно POSIX.1-2001, при указании I<hints> в NULL I<ai_flags> должен предполагаться как равный 0. Вместо этого библиотека GNU C в данном случае предполагает значение B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>, так как данное значение было принято в качестве улучшения спецификации."

#.  getnameinfo.3 refers to this example
#.  socket.2 refers to this example
#.  bind.2 refers to this example
#.  connect.2 refers to this example
#.  recvfrom.2 refers to this example
#.  sendto.2 refers to this example
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:636
msgid ""
"The following programs demonstrate the use of B<getaddrinfo>(), "
"B<gai_strerror>(), B<freeaddrinfo>(), and B<getnameinfo>(3).  The programs "
"are an echo server and client for UDP datagrams."
msgstr "Следующие программы демонстрируют использование B<getaddrinfo>(), B<gai_strerror>(), B<freeaddrinfo>() и B<getnameinfo>(3). Это программы эхосервера и клиента UDP-дейтаграмм."

#. type: SS
#: man-pages/man3/getaddrinfo.3:636
#, no-wrap
msgid "Server program"
msgstr "Серверная программа"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:646
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr "#include E<lt>sys/types.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>sys/socket.hE<gt>\n#include E<lt>netdb.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:648 man-pages/man3/getaddrinfo.3:743
#, no-wrap
msgid "#define BUF_SIZE 500\n"
msgstr "#define BUF_SIZE 500\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:659
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct addrinfo hints;\n    struct addrinfo *result, *rp;\n    int sfd, s;\n    struct sockaddr_storage peer_addr;\n    socklen_t peer_addr_len;\n    ssize_t nread;\n    char buf[BUF_SIZE];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:664
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:673
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"
msgstr "    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    /* Разрешены IPv4 и IPv6 */\n    hints.ai_socktype = SOCK_DGRAM; /* Сокет для дейтаграмм */\n    hints.ai_flags = AI_PASSIVE;    /* Для wildcard IP-адреса */\n    hints.ai_protocol = 0;          /* Любой протокол */\n    hints.ai_canonname = NULL;\n    hints.ai_addr = NULL;\n    hints.ai_next = NULL;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:679
#, no-wrap
msgid ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    s = getaddrinfo(NULL, argv[1], &hints, &result);\n    if (s != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:684
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr "    /* getaddrinfo() возвращает список структур адресов.\n       Идет проверка каждого адреса до успешного bind(2).\n       Если socket(2) (или bind(2)) терпит неудачу, мы (закрываем\n       сокет и) пробуем следующий. */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:690
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr "    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n                rp-E<gt>ai_protocol);\n        if (sfd == -1)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:693
#, no-wrap
msgid ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"
msgstr "        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n            break;                  /* Успех */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:696 man-pages/man3/getaddrinfo.3:789
#, no-wrap
msgid ""
"        close(sfd);\n"
"    }\n"
msgstr "        close(sfd);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:701
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (rp == NULL) {               /* Нет успешных адресов */\n        fprintf(stderr, \"Could not bind\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:703 man-pages/man3/getaddrinfo.3:796
#, no-wrap
msgid "    freeaddrinfo(result);           /* No longer needed */\n"
msgstr "    freeaddrinfo(result);           /* Больше не нужен */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:705
#, no-wrap
msgid "    /* Read datagrams and echo them back to sender */\n"
msgstr "    /* Читаем дейтаграмму и пересылаем ее назад отправителю */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:712
#, no-wrap
msgid ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(struct sockaddr_storage);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"
msgstr "    for (;;) {\n        peer_addr_len = sizeof(struct sockaddr_storage);\n        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n                (struct sockaddr *) &peer_addr, &peer_addr_len);\n        if (nread == -1)\n            continue;               /* Игнорируем неуспешный запрос */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:714
#, no-wrap
msgid "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"
msgstr "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:723
#, no-wrap
msgid ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"       if (s == 0)\n"
"            printf(\"Received %zd bytes from %s:%s\\en\",\n"
"                    nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:730
#, no-wrap
msgid ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"
msgstr "        if (sendto(sfd, buf, nread, 0,\n                    (struct sockaddr *) &peer_addr,\n                    peer_addr_len) != nread)\n            fprintf(stderr, \"Error sending response\\en\");\n    }\n}\n"

#. type: SS
#: man-pages/man3/getaddrinfo.3:731
#, no-wrap
msgid "Client program"
msgstr "Клиентская программа"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:741
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#include E<lt>sys/types.hE<gt>\n#include E<lt>sys/socket.hE<gt>\n#include E<lt>netdb.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:753
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s, j;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct addrinfo hints;\n    struct addrinfo *result, *rp;\n    int sfd, s, j;\n    size_t len;\n    ssize_t nread;\n    char buf[BUF_SIZE];\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:758
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 3) {\n        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:760
#, no-wrap
msgid "    /* Obtain address(es) matching host/port */\n"
msgstr "    /* Получаем адрес(а), соответствующие узлу/порту */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:766
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
msgstr "    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    /* Разрешены IPv4 и IPv6 */\n    hints.ai_socktype = SOCK_DGRAM; /* Сокет дейтаграмм */\n    hints.ai_flags = 0;\n    hints.ai_protocol = 0;          /* Любой протокол */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:772
#, no-wrap
msgid ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n    if (s != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:777
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr "    /* getaddrinfo() возвращает список структур адресов.\n       Идет проверка каждого адреса до успешного connect(2).\n       Если socket(2) (или connect(2)) терпит неудачу, мы (закрываем\n       сокет и) пробуем следующий. */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:783
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr "    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n                     rp-E<gt>ai_protocol);\n        if (sfd == -1)\n            continue;\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:786
#, no-wrap
msgid ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"
msgstr "        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n            break;                  /* Успех */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:794
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (rp == NULL) {               /* Нет успешных адресов */\n        fprintf(stderr, \"Could not connect\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:799
#, no-wrap
msgid ""
"    /* Send remaining command-line arguments as separate\n"
"       datagrams, and read responses from server */\n"
msgstr "    /* Отправляем оставшиеся аргументы командной строки\n       в виде отдельных дейтаграмм и ждем ответа от сервера */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:803
#, no-wrap
msgid ""
"    for (j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"
msgstr "    for (j = 3; j E<lt> argc; j++) {\n        len = strlen(argv[j]) + 1;\n                /* +1 для завершающего null-байта */\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:809
#, no-wrap
msgid ""
"        if (len + 1 E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"
msgstr "        if (len + 1 E<gt> BUF_SIZE) {\n            fprintf(stderr,\n                    \"Ignoring long message in argument %d\\en\", j);\n            continue;\n        }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:814
#, no-wrap
msgid ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr "        if (write(sfd, argv[j], len) != len) {\n            fprintf(stderr, \"partial/failed write\\en\");\n            exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:820
#, no-wrap
msgid ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr "        nread = read(sfd, buf, BUF_SIZE);\n        if (nread == -1) {\n            perror(\"read\");\n            exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:823
#, no-wrap
msgid ""
"        printf(\"Received %zd bytes: %s\\en\", nread, buf);\n"
"    }\n"
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:836
msgid ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"
msgstr "B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), B<gai.conf>(5), B<hostname>(7), B<ip>(7)"

#. type: TH
#: man-pages/man3/getsubopt.3:25
#, no-wrap
msgid "GETSUBOPT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:28
msgid "getsubopt - parse suboption arguments from a string"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:30
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getsubopt.3:33
msgid ""
"B<int getsubopt(char **>I<optionp>B<, char * const *>I<tokens>B<, char "
"**>I<valuep>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:40
msgid "B<getsubopt>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:45
msgid "_XOPEN_SOURCE\\ E<gt>= 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:64
msgid ""
"B<getsubopt>()  parses the list of comma-separated suboptions provided in "
"I<optionp>.  (Such a suboption list is typically produced when B<getopt>(3)"
"  is used to parse a command line; see for example the I<-o> option of "
"B<mount>(8).)  Each suboption may include an associated value, which is "
"separated from the suboption name by an equal sign.  The following is an "
"example of the kind of string that might be passed in I<optionp>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:67
msgid "B<ro,name=xyz>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:77
msgid ""
"The I<tokens> argument is a pointer to a NULL-terminated array of pointers "
"to the tokens that B<getsubopt>()  will look for in I<optionp>.  The tokens "
"should be distinct, null-terminated strings containing at least one "
"character, with no embedded equal signs or commas."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:98
msgid ""
"Each call to B<getsubopt>()  returns information about the next unprocessed "
"suboption in I<optionp>.  The first equal sign in a suboption (if any) is "
"interpreted as a separator between the name and the value of that suboption."
"  The value extends to the next comma, or (for the last suboption) to the "
"end of the string.  If the name of the suboption matches a known name from "
"I<tokens>, and a value string was found, B<getsubopt>()  sets I<*valuep> to "
"the address of that string.  The first comma in I<optionp> is overwritten "
"with a null byte, so I<*valuep> is precisely the \"value string\" for that "
"suboption."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:102
msgid ""
"If the suboption is recognized, but no value string was found, I<*valuep> is"
" set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:110
msgid ""
"When B<getsubopt>()  returns, I<optionp> points to the next suboption, or to"
" the null byte (\\(aq\\e0\\(aq) at the end of the string if the last "
"suboption was just processed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:122
msgid ""
"If the first suboption in I<optionp> is recognized, B<getsubopt>()  returns "
"the index of the matching suboption element in I<tokens>.  Otherwise, -1 is "
"returned and I<*valuep> is the entire I<name>B<[=>I<value>B<]> string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:129
msgid ""
"Since I<*optionp> is changed, the first suboption before the call to "
"B<getsubopt>()  is not (necessarily) the same as the first suboption after "
"B<getsubopt>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:134
msgid "The B<getsubopt>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:143
msgid ""
"Since B<getsubopt>()  overwrites any commas it finds in the string "
"I<*optionp>, that string must be writable; it cannot be a string constant."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:145
msgid "The following program expects suboptions following a \"-o\" option."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:151
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:169
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    enum {\n"
"        RO_OPT = 0,\n"
"        RW_OPT,\n"
"        NAME_OPT\n"
"    };\n"
"    char *const token[] = {\n"
"        [RO_OPT]   = \"ro\",\n"
"        [RW_OPT]   = \"rw\",\n"
"        [NAME_OPT] = \"name\",\n"
"        NULL\n"
"    };\n"
"    char *subopts;\n"
"    char *value;\n"
"    int opt;\n"
msgstr "int\nmain(int argc, char **argv)\n{\n    enum {\n        RO_OPT = 0,\n        RW_OPT,\n        NAME_OPT\n    };\n    char *const token[] = {\n        [RO_OPT]   = \"ro\",\n        [RW_OPT]   = \"rw\",\n        [NAME_OPT] = \"name\",\n        NULL\n    };\n    char *subopts;\n    char *value;\n    int opt;\n"

#. type: Plain text
#: man-pages/man3/getsubopt.3:174
#, no-wrap
msgid ""
"    int readonly = 0;\n"
"    int readwrite = 0;\n"
"    char *name = NULL;\n"
"    int errfnd = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:180
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"o:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqo\\(aq:\n"
"            subopts = optarg;\n"
"            while (*subopts != \\(aq\\e0\\(aq && !errfnd) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:185
#, no-wrap
msgid ""
"            switch (getsubopt(&subopts, token, &value)) {\n"
"            case RO_OPT:\n"
"                readonly = 1;\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:189
#, no-wrap
msgid ""
"            case RW_OPT:\n"
"                readwrite = 1;\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:197
#, no-wrap
msgid ""
"            case NAME_OPT:\n"
"                if (value == NULL) {\n"
"                    fprintf(stderr, \"Missing value for \"\n"
"                            \"suboption \\(aq%s\\(aq\\en\", token[NAME_OPT]);\n"
"                    errfnd = 1;\n"
"                    continue;\n"
"                }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:200
#, no-wrap
msgid ""
"                name = value;\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:214
#, no-wrap
msgid ""
"            default:\n"
"                fprintf(stderr, \"No match found \"\n"
"                        \"for token: /%s/\\en\", value);\n"
"                errfnd = 1;\n"
"                break;\n"
"            }\n"
"        }\n"
"        if (readwrite && readonly) {\n"
"            fprintf(stderr, \"Only one of \\(aq%s\\(aq and \\(aq%s\\(aq can be \"\n"
"                    \"specified\\en\", token[RO_OPT], token[RW_OPT]);\n"
"            errfnd = 1;\n"
"        }\n"
"        break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:219
#, no-wrap
msgid ""
"        default:\n"
"            errfnd = 1;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:226
#, no-wrap
msgid ""
"    if (errfnd || argc == 1) {\n"
"        fprintf(stderr, \"\\enUsage: %s -o E<lt>suboptstringE<gt>\\en\", argv[0]);\n"
"        fprintf(stderr, \"suboptions are \\(aqro\\(aq, \\(aqrw\\(aq, \"\n"
"                \"and \\(aqname=E<lt>valueE<gt>\\(aq\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:228
#, no-wrap
msgid "    /* Remainder of program... */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:233
msgid "B<getopt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getrpcent_r.3:26
#, no-wrap
msgid "GETRPCENT_R"
msgstr "GETRPCENT_R"

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:30
msgid ""
"getrpcent_r, getrpcbyname_r, getrpcbynumber_r - get RPC entry (reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:36
#, no-wrap
msgid ""
"B<int getrpcent_r(struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:40
#, no-wrap
msgid ""
"B<int getrpcbyname_r(const char *>I<name>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:44
#, no-wrap
msgid ""
"B<int getrpcbynumber_r(int >I<number>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:55
msgid "B<getrpcent_r>(), B<getrpcbyname_r>(), B<getrpcbynumber_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:76
msgid ""
"The B<getrpcent_r>(), B<getrpcbyname_r>(), and B<getrpcbynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getrpcent>(3), "
"B<getrpcbyname>(3), and B<getrpcbynumber>(3).  They differ in the way that "
"the I<rpcent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:82
msgid ""
"Instead of returning a pointer to a statically allocated I<rpcent> structure"
" as the function result, these functions copy the structure into the "
"location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getrpcent_r.3:99
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<rpcent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:107
msgid ""
"If the function call successfully obtains an RPC record, then I<*result> is "
"set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:118
msgid ""
"On error, record not found (B<getrpcbyname_r>(), B<getrpcbynumber_r>()), or "
"end of input (B<getrpcent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:123
msgid "(B<getrpcent_r>())  No more records in database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:136
msgid "B<getrpcent>(3), B<rpc>(5)"
msgstr "B<getrpcent>(3), B<rpc>(5)"

#. type: TH
#: man-pages/man3/getdtablesize.3:27
#, no-wrap
msgid "GETDTABLESIZE"
msgstr "GETDTABLESIZE"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:30
msgid "getdtablesize - get descriptor table size"
msgstr "getdtablesize - получить размер таблицы дескрипторов"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:34
msgid "B<int getdtablesize(void);>"
msgstr "B<int getdtablesize(void);>"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:41
msgid "B<getdtablesize>():"
msgstr "B<getdtablesize>():"

#. type: Plain text
#: man-pages/man3/getdtablesize.3:61
msgid ""
"B<getdtablesize>()  returns the maximum number of files a process can have "
"open, one more than the largest possible value for a file descriptor."
msgstr "B<getdtablesize>() возвращает максимальное количество файлов, которое может быть открыто в процессе, на единицу больше, чем наибольшее возможное значение для дескриптора файла."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:63
msgid "The current limit on the number of open files per process."
msgstr "Текущее ограничение на количество открытых файлов для процесса."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:69
msgid ""
"On Linux, B<getdtablesize>()  can return any of the errors described for "
"B<getrlimit>(2); see NOTES below."
msgstr "В Linux, B<getdtablesize>() может вернуть любую ошибку из описанных в B<getrlimit>(2); см. ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:74
msgid "The B<getdtablesize>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:82
msgid ""
"SVr4, 4.4BSD (the B<getdtablesize>()  function first appeared in 4.2BSD).  "
"It is not specified in POSIX.1-2001; portable applications should employ "
"I<sysconf(_SC_OPEN_MAX)> instead of this call."
msgstr "SVr4, 4.4BSD (функция B<getdtablesize>() впервые появилась в 4.2BSD). Она отсутствует в POSIX.1-2001; переносимые приложения вместо неё должны применять I<sysconf(_SC_OPEN_MAX)>."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:95
msgid ""
"B<getdtablesize>()  is implemented as a libc library function.  The glibc "
"version calls B<getrlimit>(2)  and returns the current B<RLIMIT_NOFILE> "
"limit, or B<OPEN_MAX> when that fails.  The libc4 and libc5 versions return "
"B<OPEN_MAX> (set to 256 since Linux 0.98.4)."
msgstr "B<getdtablesize>() реализуется как библиотечная функция libc. glibc вызывает B<getrlimit>(2) и возвращает текущее значение ограничения B<RLIMIT_NOFILE> или B<OPEN_MAX>, если это не удаётся. Версии libc4 и libc5 возвращают B<OPEN_MAX> (установленное в 256, начиная с Linux 0.98.4)."

#. type: Plain text
#: man-pages/man3/getdtablesize.3:99
msgid "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"
msgstr "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"

#. type: TH
#: man-pages/man3/getcwd.3:32
#, no-wrap
msgid "GETCWD"
msgstr "GETCWD"

#. type: Plain text
#: man-pages/man3/getcwd.3:35
msgid "getcwd, getwd, get_current_dir_name - get current working directory"
msgstr "getcwd, getwd, get_current_dir_name - получить текущую рабочую директорию"

#. type: Plain text
#: man-pages/man3/getcwd.3:40
#, no-wrap
msgid "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:42
#, no-wrap
msgid "B<char *getwd(char *>I<buf>B<);>\n"
msgstr "B<char *getwd(char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:44
#, no-wrap
msgid "B<char *get_current_dir_name(void);>\n"
msgstr "B<char *get_current_dir_name(void);>\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:52
msgid "B<get_current_dir_name>():"
msgstr "B<get_current_dir_name>():"

#. type: Plain text
#: man-pages/man3/getcwd.3:57
msgid "B<getwd>():"
msgstr "B<getwd>():"

#. type: Plain text
#: man-pages/man3/getcwd.3:67
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700)\n"
msgstr "_BSD_SOURCE ||\n    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700)\n"

#. type: Plain text
#: man-pages/man3/getcwd.3:82
msgid ""
"These functions return a null-terminated string containing an absolute "
"pathname that is the current working directory of the calling process.  The "
"pathname is returned as the function result and via the argument I<buf>, if "
"present."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:90
msgid ""
"The B<getcwd>()  function copies an absolute pathname of the current working"
" directory to the array pointed to by I<buf>, which is of length I<size>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:100
msgid ""
"If the length of the absolute pathname of the current working directory, "
"including the terminating null byte, exceeds I<size> bytes, NULL is "
"returned, and I<errno> is set to B<ERANGE>; an application should check for "
"this error, and allocate a larger buffer if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:118
msgid ""
"As an extension to the POSIX.1-2001 standard, Linux (libc4, libc5, glibc)  "
"B<getcwd>()  allocates the buffer dynamically using B<malloc>(3)  if I<buf> "
"is NULL.  In this case, the allocated buffer has the length I<size> unless "
"I<size> is zero, when I<buf> is allocated as big as necessary.  The caller "
"should B<free>(3)  the returned buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:131
msgid ""
"B<get_current_dir_name>()  will B<malloc>(3)  an array big enough to hold "
"the absolute pathname of the current working directory.  If the environment "
"variable B<PWD> is set, and its value is correct, then that value will be "
"returned.  The caller should B<free>(3)  the returned buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:156
msgid ""
"B<getwd>()  does not B<malloc>(3)  any memory.  The I<buf> argument should "
"be a pointer to an array at least B<PATH_MAX> bytes long.  If the length of "
"the absolute pathname of the current working directory, including the "
"terminating null byte, exceeds B<PATH_MAX> bytes, NULL is returned, and "
"I<errno> is set to B<ENAMETOOLONG>.  (Note that on some systems, B<PATH_MAX>"
" may not be a compile-time constant; furthermore, its value may depend on "
"the filesystem, see B<pathconf>(3).)  For portability and security reasons, "
"use of B<getwd>()  is deprecated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:165
msgid ""
"On success, these functions return a pointer to a string containing the "
"pathname of the current working directory.  In the case B<getcwd>()  and "
"B<getwd>()  this is the same value as I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:172
msgid ""
"On failure, these functions return NULL, and I<errno> is set to indicate the"
" error.  The contents of the array pointed to by I<buf> are undefined on "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:176
msgid "Permission to read or search a component of the filename was denied."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:180
msgid "I<buf> points to a bad address."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:187
msgid "The I<size> argument is zero and I<buf> is not a null pointer."
msgstr ""

#. type: TP
#: man-pages/man3/getcwd.3:187
#, no-wrap
msgid "EINVAL"
msgstr "EINVAL"

#. type: Plain text
#: man-pages/man3/getcwd.3:192
msgid "B<getwd>(): I<buf> is NULL."
msgstr "B<getwd>(): I<buf> равно NULL."

#. type: TP
#: man-pages/man3/getcwd.3:192
#, no-wrap
msgid "ENAMETOOLONG"
msgstr "ENAMETOOLONG"

#. type: Plain text
#: man-pages/man3/getcwd.3:198
msgid ""
"B<getwd>(): The size of the null-terminated absolute pathname string exceeds"
" B<PATH_MAX> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:201
msgid "The current working directory has been unlinked."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:208
msgid ""
"The I<size> argument is less than the length of the absolute pathname of the"
" working directory, including the terminating null byte.  You need to "
"allocate a bigger array and try again."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:216
msgid ""
"B<getcwd>()  conforms to POSIX.1-2001.  Note however that POSIX.1-2001 "
"leaves the behavior of B<getcwd>()  unspecified if I<buf> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:227
msgid ""
"B<getwd>()  is present in POSIX.1-2001, but marked LEGACY.  POSIX.1-2008 "
"removes the specification of B<getwd>().  Use B<getcwd>()  instead.  "
"POSIX.1-2001 does not define any errors for B<getwd>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:230
msgid "B<get_current_dir_name>()  is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:241
msgid ""
"Under Linux, the function B<getcwd>()  is a system call (since 2.1.92).  On "
"older systems it would query I</proc/self/cwd>.  If both system call and "
"proc filesystem are missing, a generic implementation is called.  Only in "
"that case can these calls fail under Linux with B<EACCES>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:249
msgid ""
"These functions are often used to save the location of the current working "
"directory for the purpose of returning to it later.  Opening the current "
"directory (\".\") and calling B<fchdir>(2)  to return is usually a faster "
"and more reliable alternative when sufficiently many file descriptors are "
"available, especially on platforms other than Linux."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:255
msgid ""
"B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), "
"B<malloc>(3)"
msgstr "B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), B<malloc>(3)"

#. type: TH
#: man-pages/man3/getpt.3:7
#, no-wrap
msgid "GETPT"
msgstr ""

#. type: TH
#: man-pages/man3/getpt.3:7
#, no-wrap
msgid "2014-04-01"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:10
msgid "getpt - open the pseudoterminal master (PTM)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:14
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:16
#, no-wrap
msgid "B<int getpt(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:21
msgid ""
"B<getpt>()  opens a pseudoterminal master and returns its file descriptor.  "
"It is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:24
#, no-wrap
msgid "    open(/dev/ptmx, O_RDWR | O_NOCTTY);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:28
msgid ""
"on Linux systems, though the pseudoterminal master is located elsewhere on "
"some systems that use GNU Libc."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:35
msgid ""
"B<getpt>()  returns an open file descriptor upon successful completion.  "
"Otherwise, it returns -1 and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:39
msgid "B<getpt>()  can fail with various errors described in B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:42
msgid "B<getpt>()  is provided in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:47
msgid "The B<getpt>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:53
msgid "B<getpt>()  is glibc-specific; use B<posix_openpt>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:59
msgid ""
"B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), "
"B<ptmx>(4), B<pty>(7)"
msgstr "B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), B<ptmx>(4), B<pty>(7)"

#. type: TH
#: man-pages/man3/getloadavg.3:34
#, no-wrap
msgid "GETLOADAVG"
msgstr "GETLOADAVG"

#. type: Plain text
#: man-pages/man3/getloadavg.3:37
msgid "getloadavg - get system load averages"
msgstr "getloadavg - получение средней загруженности системы"

#. type: Plain text
#: man-pages/man3/getloadavg.3:41
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:43
#, no-wrap
msgid "B<int getloadavg(double >I<loadavg[]>B<, int >I<nelem>B<);>\n"
msgstr "B<int getloadavg(double >I<loadavg[]>B<, int >I<nelem>B<);>\n"

#. type: Plain text
#: man-pages/man3/getloadavg.3:55
msgid ""
"The B<getloadavg>()  function returns the number of processes in the system "
"run queue averaged over various periods of time.  Up to I<nelem> samples are"
" retrieved and assigned to successive elements of I<loadavg>[].  The system "
"imposes a maximum of 3 samples, representing averages over the last 1, 5, "
"and 15 minutes, respectively."
msgstr ""

#.  .SH HISTORY
#.  The
#.  BR getloadavg ()
#.  function appeared in
#.  4.3BSD Reno .
#. type: Plain text
#: man-pages/man3/getloadavg.3:63
msgid ""
"If the load average was unobtainable, -1 is returned; otherwise, the number "
"of samples actually retrieved is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:65
msgid "This function is available in glibc since version 2.2."
msgstr "Эта функция доступна в glibc начиная с версии 2.2."

#. type: Plain text
#: man-pages/man3/getloadavg.3:70
msgid "The B<getloadavg>()  function is thread-safe."
msgstr ""

#.  mdoc seems to have a bug - there must be no newline here
#. type: Plain text
#: man-pages/man3/getloadavg.3:74
msgid "Not in POSIX.1-2001.  Present on the BSDs and Solaris."
msgstr "Не является частью POSIX.1-2001. Присутствует в BSD и Solaris."

#. type: Plain text
#: man-pages/man3/getloadavg.3:76
msgid "B<uptime>(1), B<proc>(5)"
msgstr "B<uptime>(1), B<proc>(5)"

#. type: TH
#: man-pages/man3/getprotoent_r.3:26
#, no-wrap
msgid "GETPROTOENT_R"
msgstr "GETPROTOENT_R"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:30
msgid ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - get protocol entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:36
#, no-wrap
msgid ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr "B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:40
#, no-wrap
msgid ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr "B<int getprotobyname_r(const char *>I<name>B<,>\nB<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:44
#, no-wrap
msgid ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr "B<int getprotobynumber_r(int >I<proto>B<,>\nB<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\nB<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:55
msgid "B<getprotoent_r>(), B<getprotobyname_r>(), B<getprotobynumber_r>():"
msgstr "B<getprotoent_r>(), B<getprotobyname_r>(), B<getprotobynumber_r>():"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:76
msgid ""
"The B<getprotoent_r>(), B<getprotobyname_r>(), and B<getprotobynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getprotoent>(3),"
" B<getprotobyname>(3), and B<getprotobynumber>(3).  They differ in the way "
"that the I<protoent> structure is returned, and in the function calling "
"signature and return value.  This manual page describes just the differences"
" from the nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:82
msgid ""
"Instead of returning a pointer to a statically allocated I<protoent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer.
#.  The 1024 byte value is also what the Solaris man page suggests. -- mtk
#. type: Plain text
#: man-pages/man3/getprotoent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<protoent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:108
msgid ""
"If the function call successfully obtains a protocol record, then I<*result>"
" is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:119
msgid ""
"On error, record not found (B<getprotobyname_r>(), B<getprotobynumber_r>()),"
" or end of input (B<getprotoent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:124
msgid "(B<getprotoent_r>())  No more records in database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:149
msgid ""
"The program below uses B<getprotobyname_r>()  to retrieve the protocol "
"record for the protocol named in its first command-line argument.  If a "
"second (integer) command-line argument is supplied, it is used as the "
"initial value for I<buflen>; if B<getprotobyname_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:160
#, no-wrap
msgid ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:183
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
"    char **p;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:188
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:192
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"
msgstr "    buflen = 1024;\n    if (argc E<gt> 2)\n        buflen = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:206
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:222
#, no-wrap
msgid ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:233
#, no-wrap
msgid ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:239
msgid "B<getprotoent>(3), B<protocols>(5)"
msgstr "B<getprotoent>(3), B<protocols>(5)"

#. type: TH
#: man-pages/man3/getenv.3:33
#, no-wrap
msgid "GETENV"
msgstr "GETENV"

#. type: TH
#: man-pages/man3/getenv.3:33
#, no-wrap
msgid "2012-08-14"
msgstr "2012-08-14"

#. type: Plain text
#: man-pages/man3/getenv.3:36
msgid "getenv, secure_getenv - get an environment variable"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:41
#, no-wrap
msgid "B<char *getenv(const char *>I<name>B<);>\n"
msgstr "B<char *getenv(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getenv.3:43
#, no-wrap
msgid "B<char *secure_getenv(const char *>I<name>B<);>\n"
msgstr "B<char *secure_getenv(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getenv.3:52
msgid "B<secure_getenv>(): _GNU_SOURCE"
msgstr "B<secure_getenv>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/getenv.3:61
msgid ""
"The B<getenv>()  function searches the environment list to find the "
"environment variable I<name>, and returns a pointer to the corresponding "
"I<value> string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:69
msgid ""
"The GNU-specific B<secure_getenv>()  function is just like B<getenv>()  "
"except that it returns NULL in cases where \"secure execution\" is required."
"  Secure execution is required if one of the following conditions was true "
"when the program run by the calling process was loaded:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:74
msgid ""
"the process's effective user ID did not match its real user ID or the "
"process's effective group ID did not match its real group ID (typically this"
" is the result of executing a set-user-ID or set-group-ID program);"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:76
msgid "the effective capability bit was set on the executable file; or"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:78
msgid "the process has a nonempty permitted capability set."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:81
msgid ""
"Secure execution may also required if triggered by some Linux security "
"modules."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:88
msgid ""
"The B<secure_getenv>()  function is intended for use in general-purpose "
"libraries to avoid vulnerabilities that could occur if set-user-ID or set-"
"group-ID programs accidentally trusted the environment."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:93
msgid ""
"The B<getenv>()  function returns a pointer to the value in the environment,"
" or NULL if there is no match."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:96
msgid "B<secure_getenv>()  first appeared in glibc 2.17."
msgstr "Функция B<secure_getenv>() впервые появилась в glibc версии 2.17."

#. type: Plain text
#: man-pages/man3/getenv.3:99
msgid "B<getenv>(): SVr4, POSIX.1-2001, 4.3BSD, C89, C99."
msgstr "B<getenv>(): SVr4, POSIX.1-2001, 4.3BSD, C89, C99."

#. type: Plain text
#: man-pages/man3/getenv.3:102
msgid "B<secure_getenv>()  is a GNU extension."
msgstr "Функция B<secure_getenv>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/getenv.3:104
msgid "The strings in the environment list are of the form I<name=value>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:110
msgid ""
"As typically implemented, B<getenv>()  returns a pointer to a string within "
"the environment list.  The caller must take care not to modify this string, "
"since that would change the environment of the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:123
msgid ""
"The implementation of B<getenv>()  is not required to be reentrant.  The "
"string pointed to by the return value of B<getenv>()  may be statically "
"allocated, and can be modified by a subsequent call to B<getenv>(), "
"B<putenv>(3), B<setenv>(3), or B<unsetenv>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:129
msgid ""
"The \"secure execution\" mode of B<secure_getenv>()  is controlled by the "
"B<AT_SECURE> flag contained in the auxiliary vector passed from the kernel "
"to user space."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:136
msgid ""
"B<clearenv>(3), B<getauxval>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3),"
" B<capabilities>(7), B<environ>(7)"
msgstr "B<clearenv>(3), B<getauxval>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<capabilities>(7), B<environ>(7)"

#. type: TH
#: man-pages/man3/getpw.3:32
#, no-wrap
msgid "GETPW"
msgstr "GETPW"

#. type: Plain text
#: man-pages/man3/getpw.3:35
msgid "getpw - reconstruct password line entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:40
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:42
#, no-wrap
msgid "B<int getpw(uid_t >I<uid>B<, char *>I<buf>B<);>\n"
msgstr "B<int getpw(uid_t >I<uid>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/getpw.3:49
msgid ""
"The B<getpw>()  function reconstructs the password line entry for the given "
"user ID I<uid> in the buffer I<buf>.  The returned buffer contains a line of"
" format"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:52
msgid "B<name:passwd:uid:gid:gecos:dir:shell>"
msgstr "B<name:passwd:uid:gid:gecos:dir:shell>"

#. type: Plain text
#: man-pages/man3/getpw.3:78
msgid ""
"The B<getpw>()  function returns 0 on success; on error, it returns -1, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:83
msgid "I<buf> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:87
msgid "No user corresponding to I<uid>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:98
msgid "SVr2."
msgstr "SVr2."

#. type: Plain text
#: man-pages/man3/getpw.3:105
msgid ""
"The B<getpw>()  function is dangerous as it may overflow the provided buffer"
" I<buf>.  It is obsoleted by B<getpwuid>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:113
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getpwent>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getipnodebyname.3:26
#, no-wrap
msgid "GETIPNODEBYNAME"
msgstr "GETIPNODEBYNAME"

#. type: TH
#: man-pages/man3/getipnodebyname.3:26
#, no-wrap
msgid "2010-09-04"
msgstr "2010-09-04"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:30
msgid ""
"getipnodebyname, getipnodebyaddr, freehostent - get network hostnames and "
"addresses"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:38
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"
msgstr "B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\nB<                                int >I<flags>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:41
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"
msgstr "B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\nB<                                int >I<af>B<, int *>I<error_num>B<);>\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:43
#, no-wrap
msgid "B<void freehostent(struct hostent *>I<ip>B<);>\n"
msgstr "B<void freehostent(struct hostent *>I<ip>B<);>\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:51
msgid ""
"These functions are deprecated (and unavailable in glibc).  Use "
"B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:59
msgid ""
"The B<getipnodebyname>()  and B<getipnodebyaddr>()  functions return the "
"names and addresses of a network host.  These functions return a pointer to "
"the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:69
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"
msgstr "struct hostent {\n    char  *h_name;\n    char **h_aliases;\n    int    h_addrtype;\n    int    h_length;\n    char **h_addr_list;\n};\n"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:82
msgid ""
"These functions replace the B<gethostbyname>(3)  and B<gethostbyaddr>(3)  "
"functions, which could access only the IPv4 network address family.  The "
"B<getipnodebyname>()  and B<getipnodebyaddr>()  functions can access "
"multiple network address families."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:93
msgid ""
"Unlike the B<gethostby> functions, these functions return pointers to "
"dynamically allocated memory.  The B<freehostent>()  function is used to "
"release the dynamically allocated memory after the caller no longer needs "
"the I<hostent> structure."
msgstr ""

#. type: SS
#: man-pages/man3/getipnodebyname.3:93
#, no-wrap
msgid "getipnodebyname() arguments"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:104
msgid ""
"The B<getipnodebyname>()  function looks up network addresses for the host "
"specified by the I<name> argument.  The I<af> argument specifies one of the "
"following values:"
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:104 man-pages/man3/getipnodebyname.3:166
#, no-wrap
msgid "B<AF_INET>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:110
msgid ""
"The I<name> argument points to a dotted-quad IPv4 address or a name of an "
"IPv4 network host."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:110 man-pages/man3/getipnodebyname.3:176
#, no-wrap
msgid "B<AF_INET6>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:116
msgid ""
"The I<name> argument points to a hexadecimal IPv6 address or a name of an "
"IPv6 network host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:125
msgid ""
"The I<flags> argument specifies additional options.  More than one option "
"can be specified by bitwise OR-ing them together.  I<flags> should be set to"
" 0 if no options are desired."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:125
#, no-wrap
msgid "B<AI_V4MAPPED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:132
msgid ""
"This flag is used with B<AF_INET6> to request a query for IPv4 addresses "
"instead of IPv6 addresses; the IPv4 addresses will be mapped to IPv6 "
"addresses."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:132
#, no-wrap
msgid "B<AI_ALL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:138
msgid ""
"This flag is used with B<AI_V4MAPPED> to request a query for both IPv4 and "
"IPv6 addresses.  Any IPv4 address found will be mapped to an IPv6 address."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:138
#, no-wrap
msgid "B<AI_ADDRCONFIG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:150
msgid ""
"This flag is used with B<AF_INET6> to further request that queries for IPv6 "
"addresses should not be made unless the system has at least one IPv6 address"
" assigned to a network interface, and that queries for IPv4 addresses should"
" not be made unless the system has at least one IPv4 address assigned to a "
"network interface.  This flag may be used by itself or with the "
"B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:150
#, no-wrap
msgid "B<AI_DEFAULT>"
msgstr "B<AI_DEFAULT>"

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:154
msgid "This flag is equivalent to B<(AI_ADDRCONFIG | AI_V4MAPPED)>."
msgstr ""

#. type: SS
#: man-pages/man3/getipnodebyname.3:154
#, no-wrap
msgid "getipnodebyaddr() arguments"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:166
msgid ""
"The B<getipnodebyaddr>()  function looks up the name of the host whose "
"network address is specified by the I<addr> argument.  The I<af> argument "
"specifies one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:176
msgid ""
"The I<addr> argument points to a I<struct in_addr> and I<len> must be set to"
" I<sizeof(struct in_addr)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:186
msgid ""
"The I<addr> argument points to a I<struct in6_addr> and I<len> must be set "
"to I<sizeof(struct in6_addr)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:190
msgid ""
"NULL is returned if an error occurred, and I<error_num> will contain an "
"error code from the following list:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:193
msgid "The hostname or network address was not found."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:193
#, no-wrap
msgid "B<NO_ADDRESS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:199
msgid ""
"The domain name server recognized the network address or name, but no answer"
" was returned.  This can happen if the network host has only IPv4 addresses "
"and a request has been made for IPv6 information only, or vice versa."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:202
msgid "The domain name server returned a permanent failure response."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:206
msgid ""
"The domain name server returned a temporary failure response.  You might "
"have better luck next time."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:210
msgid ""
"A successful query returns a pointer to a I<hostent> structure that contains"
" the following fields:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:213
msgid "This is the official name of this network host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:217
msgid ""
"This is an array of pointers to unofficial aliases for the same host.  The "
"array is terminated by a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:239
msgid ""
"This is a copy of the I<af> argument to B<getipnodebyname>()  or "
"B<getipnodebyaddr>().  I<h_addrtype> will always be B<AF_INET> if the I<af> "
"argument was B<AF_INET>.  I<h_addrtype> will always be B<AF_INET6> if the "
"I<af> argument was B<AF_INET6>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:253
msgid ""
"This field will be set to I<sizeof(struct in_addr)> if I<h_addrtype> is "
"B<AF_INET>, and to I<sizeof(struct in6_addr)> if I<h_addrtype> is "
"B<AF_INET6>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:258
msgid ""
"This is an array of one or more pointers to network address structures for "
"the network host.  The array is terminated by a null pointer."
msgstr ""

#.  Not in POSIX.1-2001.
#. type: Plain text
#: man-pages/man3/getipnodebyname.3:261
msgid "RFC\\ 2553."
msgstr "RFC\\ 2553."

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:266
msgid ""
"These functions were present in glibc 2.1.91-95, but were removed again.  "
"Several UNIX-like systems support them, but all call them deprecated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:270
msgid "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getgrnam.3:33
#, no-wrap
msgid "GETGRNAM"
msgstr "GETGRNAM"

#. type: Plain text
#: man-pages/man3/getgrnam.3:36
msgid "getgrnam, getgrnam_r, getgrgid, getgrgid_r - get group file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:42
#, no-wrap
msgid "B<struct group *getgrnam(const char *>I<name>B<);>\n"
msgstr "B<struct group *getgrnam(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:44
#, no-wrap
msgid "B<struct group *getgrgid(gid_t >I<gid>B<);>\n"
msgstr "B<struct group *getgrgid(gid_t >I<gid>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:46
#, no-wrap
msgid "B<int getgrnam_r(const char *>I<name>B<, struct group *>I<grp>B<,>\n"
msgstr "B<int getgrnam_r(const char *>I<name>B<, struct group *>I<grp>B<,>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:48 man-pages/man3/getgrnam.3:52
#, no-wrap
msgid ""
"B<          char *>I<buf>B<, size_t >I<buflen>B<, struct group "
"**>I<result>B<);>\n"
msgstr "B<          char *>I<buf>B<, size_t >I<buflen>B<, struct group **>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:50
#, no-wrap
msgid "B<int getgrgid_r(gid_t >I<gid>B<, struct group *>I<grp>B<,>\n"
msgstr "B<int getgrgid_r(gid_t >I<gid>B<, struct group *>I<grp>B<,>\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:62
msgid "B<getgrnam_r>(), B<getgrgid_r>():"
msgstr "B<getgrnam_r>(), B<getgrgid_r>():"

#. type: Plain text
#: man-pages/man3/getgrnam.3:77
msgid ""
"The B<getgrnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the group database (e.g., the local group"
" file I</etc/group>, NIS, and LDAP)  that matches the group name I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:84
msgid ""
"The B<getgrgid>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the group database that matches the group"
" ID I<gid>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:124
msgid ""
"The B<getgrnam_r>()  and B<getgrgid_r>()  functions obtain the same "
"information as B<getgrnam>()  and B<getgrgid>(), but store the retrieved "
"I<group> structure in the space pointed to by I<grp>.  The string fields "
"pointed to by the members of the I<group> structure are stored in the buffer"
" I<buf> of size I<buflen>.  A pointer to the result (in case of success) or "
"NULL (in case no entry was found or an error occurred) is stored in "
"I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:128
#, no-wrap
msgid "    sysconf(_SC_GETGR_R_SIZE_MAX)\n"
msgstr "    sysconf(_SC_GETGR_R_SIZE_MAX)\n"

#. type: Plain text
#: man-pages/man3/getgrnam.3:152
msgid ""
"The B<getgrnam>()  and B<getgrgid>()  functions return a pointer to a "
"I<group> structure, or NULL if the matching entry is not found or an error "
"occurs.  If an error occurs, I<errno> is set appropriately.  If one wants to"
" check I<errno> after the call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:161
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getgrent>(3), B<getgrgid>(), or B<getgrnam>().  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:175
msgid ""
"On success, B<getgrnam_r>()  and B<getgrgid_r>()  return zero, and set "
"I<*result> to I<grp>.  If no matching group record was found, these "
"functions return 0 and store NULL in I<*result>.  In case of error, an error"
" number is returned, and NULL is stored in I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:183
msgid "The given I<name> or I<gid> was not found."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:218
msgid "The B<getgrnam>()  and B<getgrgid>()  functions are not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:224
msgid "The B<getgrnam_r>()  and B<getgrgid_r>()  functions are thread-safe."
msgstr ""

#.  more precisely:
#.  AIX 5.1 - gives ESRCH
#.  OSF1 4.0g - gives EWOULDBLOCK
#.  libc, glibc up to version 2.6, Irix 6.5 - give ENOENT
#.  glibc since version 2.7 - give 0
#.  FreeBSD 4.8, OpenBSD 3.2, NetBSD 1.6 - give EPERM
#.  SunOS 5.8 - gives EBADF
#.  Tru64 5.1b, HP-UX-11i, SunOS 5.7 - give 0
#. type: Plain text
#: man-pages/man3/getgrnam.3:247
msgid ""
"The formulation given above under \"RETURN VALUE\" is from POSIX.1-2001.  It"
" does not call \"not found\" an error, hence does not specify what value "
"I<errno> might have in this situation.  But that makes it impossible to "
"recognize errors.  One might argue that according to POSIX I<errno> should "
"be left unchanged if an entry is not found.  Experiments on various UNIX-"
"like systems shows that lots of different values occur in this situation: 0,"
" ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM, and probably others."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:253
msgid ""
"B<endgrent>(3), B<fgetgrent>(3), B<getgrent>(3), B<getpwnam>(3), "
"B<setgrent>(3), B<group>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/gamma.3:9
#, no-wrap
msgid "GAMMA"
msgstr "GAMMA"

#. type: TH
#: man-pages/man3/gamma.3:9
#, no-wrap
msgid "2008-08-05"
msgstr "2008-08-05"

#. type: Plain text
#: man-pages/man3/gamma.3:12
msgid "gamma, gammaf, gammal - (logarithm of the) gamma function"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:14
msgid "B<#include E<lt>math.hE<gt>>"
msgstr "B<#include E<lt>math.hE<gt>>"

#. type: Plain text
#: man-pages/man3/gamma.3:16
msgid "B<double gamma(double >I<x>B<);>"
msgstr "B<double gamma(double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/gamma.3:18
msgid "B<float gammaf(float >I<x>B<);>"
msgstr "B<float gammaf(float >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/gamma.3:20
msgid "B<long double gammal(long double >I<x>B<);>"
msgstr "B<long double gammal(long double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/gamma.3:22
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/gamma.3:30
msgid "B<gamma>():"
msgstr "B<gamma>():"

#. type: Plain text
#: man-pages/man3/gamma.3:32
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: man-pages/man3/gamma.3:35
msgid "B<gammaf>(), B<gammal>():"
msgstr "B<gammaf>(), B<gammal>():"

#.  Also seems to work: -std=c99 -D_XOPEN_SOURCE
#. type: Plain text
#: man-pages/man3/gamma.3:38
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/gamma.3:46
msgid ""
"These functions are deprecated: instead, use either the B<tgamma>(3)  or the"
" B<lgamma>(3)  functions, as appropriate."
msgstr "Данные функции устарели. Используйте вместо них, по возможности, B<tgamma>(3) либо B<lgamma>(3)."

#. type: Plain text
#: man-pages/man3/gamma.3:49
msgid "For the definition of the Gamma function, see B<tgamma>(3)."
msgstr "Определение гамма-функции смотрите в B<tgamma>(3)."

#. type: SS
#: man-pages/man3/gamma.3:49
#, no-wrap
msgid "*BSD version"
msgstr "Версия *BSD"

#. type: Plain text
#: man-pages/man3/gamma.3:53
msgid ""
"The libm in 4.4BSD and some versions of FreeBSD had a B<gamma>()  function "
"that computes the Gamma function, as one would expect."
msgstr ""

#. type: SS
#: man-pages/man3/gamma.3:53
#, no-wrap
msgid "glibc version"
msgstr "Версия glibc"

#. type: Plain text
#: man-pages/man3/gamma.3:59
msgid ""
"Glibc has a B<gamma>()  function that is equivalent to B<lgamma>(3)  and "
"computes the natural logarithm of the Gamma function."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:62 man-pages/man3/gamma.3:65
msgid "See B<lgamma>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:68
msgid ""
"Because of historical variations in behavior across systems, this function "
"is not specified in any standard."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:81
msgid ""
"4.2BSD had a B<gamma>()  that computed ln(|Gamma(|I<x>|)|), leaving the sign"
" of Gamma(|I<x>|)  in the external integer I<signgam>.  In 4.3BSD the name "
"was changed to B<lgamma>(3), and the man page promises"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:85
msgid ""
"At some time in the future the name gamma will be rehabilitated and used for"
" the Gamma function"
msgstr ""

#.  The FreeBSD man page says about gamma() that it is like lgamma()
#.  except that is does not set signgam.
#.  Also, that 4.4BSD has a gamma() that computes the true gamma function.
#. type: Plain text
#: man-pages/man3/gamma.3:97
msgid ""
"This did indeed happen in 4.4BSD, where B<gamma>()  computes the Gamma "
"function (with no effect on I<signgam>).  However, this came too late, and "
"we now have B<tgamma>(3), the \"true gamma\" function."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:100
msgid "B<lgamma>(3), B<signgam>(3), B<tgamma>(3)"
msgstr "B<lgamma>(3), B<signgam>(3), B<tgamma>(3)"

#. type: TH
#: man-pages/man3/getwchar.3:17
#, no-wrap
msgid "GETWCHAR"
msgstr "GETWCHAR"

#. type: TH
#: man-pages/man3/getwchar.3:17
#, no-wrap
msgid "1999-07-25"
msgstr "1999-07-25"

#. type: Plain text
#: man-pages/man3/getwchar.3:20
msgid "getwchar - read a wide character from standard input"
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:23
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/getwchar.3:25
#, no-wrap
msgid "B<wint_t getwchar(void);>\n"
msgstr "B<wint_t getwchar(void);>\n"

#. type: Plain text
#: man-pages/man3/getwchar.3:46
msgid ""
"The B<getwchar>()  function is the wide-character equivalent of the "
"B<getchar>(3)  function.  It reads a wide character from I<stdin> and "
"returns it.  If the end of stream is reached, or if I<ferror(stdin)> becomes"
" true, it returns B<WEOF>.  If a wide-character conversion error occurs, it "
"sets I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:49
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:55
msgid ""
"The B<getwchar>()  function returns the next wide-character from standard "
"input, or B<WEOF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:57
msgid "C99."
msgstr "C99."

#. type: Plain text
#: man-pages/man3/getwchar.3:64
msgid ""
"The behavior of B<getwchar>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:70
msgid ""
"It is reasonable to expect that B<getwchar>()  will actually read a "
"multibyte sequence from standard input and then convert it to a wide "
"character."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:72
msgid "B<fgetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: man-pages/man3/getdirentries.3:27
#, no-wrap
msgid "GETDIRENTRIES"
msgstr "GETDIRENTRIES"

#. type: Plain text
#: man-pages/man3/getdirentries.3:30
msgid ""
"getdirentries - get directory entries in a filesystem-independent format"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:32
msgid "B<#include E<lt>dirent.hE<gt>>"
msgstr "B<#include E<lt>dirent.hE<gt>>"

#. type: Plain text
#: man-pages/man3/getdirentries.3:35
msgid ""
"B<ssize_t getdirentries(int >I<fd>B<, char *>I<buf>B<, size_t >I<nbytes> B<,"
" off_t *>I<basep>B<);>"
msgstr "B<ssize_t getdirentries(int >I<fd>B<, char *>I<buf>B<, size_t >I<nbytes> B<, off_t *>I<basep>B<);>"

#. type: Plain text
#: man-pages/man3/getdirentries.3:43
msgid "B<getdirentries>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr "B<getdirentries>(): _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/getdirentries.3:56
msgid ""
"Read directory entries from the directory specified by I<fd> into I<buf>.  "
"At most I<nbytes> are read.  Reading starts at offset I<*basep>, and "
"I<*basep> is updated with the new position after reading."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:62
msgid ""
"B<getdirentries>()  returns the number of bytes read or zero when at the end"
" of the directory.  If an error occurs, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:64
msgid "See the Linux library source code for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:69
msgid "The B<getdirentries>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:77
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs, and a few other systems.  Use "
"B<opendir>(3)  and B<readdir>(3)  instead."
msgstr "Нет в POSIX.1-2001. Присутствует в BSD и многих других системах. Используйте вместо нее B<opendir>(3) и B<readdir>(3)."

#. type: Plain text
#: man-pages/man3/getdirentries.3:79
msgid "B<lseek>(2), B<open>(2)"
msgstr "B<lseek>(2), B<open>(2)"

#. type: TH
#: man-pages/man3/gets.3:29
#, no-wrap
msgid "GETS"
msgstr "GETS"

#. type: TH
#: man-pages/man3/gets.3:29
#, no-wrap
msgid "2014-01-24"
msgstr "2014-01-24"

#. type: Plain text
#: man-pages/man3/gets.3:32
msgid "gets - get a string from standard input (DEPRECATED)"
msgstr "gets - получить строки из стандартного потока ввода (ФУНКЦИЯ УСТАРЕЛА)"

#. type: Plain text
#: man-pages/man3/gets.3:37
#, no-wrap
msgid "B<char *gets(char *>I<s>B<);>\n"
msgstr "B<char *gets(char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/gets.3:40
msgid "I<Never use this function>."
msgstr "I<Никогда не используйте эту функцию>."

#. type: Plain text
#: man-pages/man3/gets.3:50
msgid ""
"B<gets>()  reads a line from I<stdin> into the buffer pointed to by I<s> "
"until either a terminating newline or B<EOF>, which it replaces with a null "
"byte (\\(aq\\e0\\(aq).  No check for buffer overrun is performed (see BUGS "
"below)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:58
msgid ""
"B<gets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read.  However, given the lack of "
"buffer overrun checking, there can be no guarantees that the function will "
"even return."
msgstr "Функция B<gets>() возвращает I<s> при удачном выполнении и NULL при ошибке или если достигнут конец файла, а символы остались несчитанными. Тем не менее, из-за невозможности проверить переполнение буфера, нет гарантии, что функция вообще что-нибудь сможет вернуть."

#. type: Plain text
#: man-pages/man3/gets.3:60
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/gets.3:72
msgid ""
"LSB deprecates B<gets>().  POSIX.1-2008 marks B<gets>()  obsolescent.  ISO "
"C11 removes the specification of B<gets>()  from the C language, and since "
"version 2.16, glibc header files don't expose the function declaration if "
"the B<_ISOC11_SOURCE> feature test macro is defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:86
msgid ""
"Never use B<gets>().  Because it is impossible to tell without knowing the "
"data in advance how many characters B<gets>()  will read, and because "
"B<gets>()  will continue to store characters past the end of the buffer, it "
"is extremely dangerous to use.  It has been used to break computer security."
"  Use B<fgets>()  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:90
msgid ""
"For more information, see CWE-242 (aka \"Use of Inherently Dangerous "
"Function\") at http://cwe.mitre.org/data/definitions/242.html"
msgstr "Для более детальной информации, смотрите CWE-242 (или \"Use of Inherently Dangerous Function\") на http://cwe.mitre.org/data/definitions/242.html"

#. type: Plain text
#: man-pages/man3/gets.3:107
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), "
"B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), "
"B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr "B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), B<unlocked_stdio>(3), B<feature_test_macros>(7)"
