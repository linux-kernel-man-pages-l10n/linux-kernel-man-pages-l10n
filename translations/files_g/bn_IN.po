# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-04-01 18:52+0300\n"
"PO-Revision-Date: 2019-04-02 15:54+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Bengali (India) (http://www.transifex.com/kruvalig/man-pages/language/bn_IN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: bn_IN\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "GETENT"
msgstr ""

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man1/getent.1:25
#, no-wrap
msgid "User Commands"
msgstr ""

#. type: SH
#: man-pages/man1/getent.1:26
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:28
msgid "getent - get entries from Name Service Switch libraries"
msgstr ""

#. type: SH
#: man-pages/man1/getent.1:28
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:30
msgid "B<getent\\ [>I<option>B<]...\\ >I<database>B<\\ >I<key>B<...>"
msgstr ""

#. type: SH
#: man-pages/man1/getent.1:30
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:45
msgid ""
"The B<getent> command displays entries from databases supported by the Name "
"Service Switch libraries, which are configured in I</etc/nsswitch.conf>.  If"
" one or more I<key> arguments are provided, then only the entries that match"
" the supplied keys will be displayed.  Otherwise, if no I<key> is provided, "
"all entries will be displayed (unless the database does not support "
"enumeration)."
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:49
msgid ""
"The I<database> may be any of those supported by the GNU C Library, listed "
"below:"
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:50
#, no-wrap
msgid "B<ahosts>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:71
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  This is identical to "
"using B<hosts>.  When one or more I<key> arguments are provided, pass each "
"I<key> in succession to B<getaddrinfo>(3)  with the address family "
"B<AF_UNSPEC>, enumerating each socket address structure returned."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:71
#, no-wrap
msgid "B<ahostsv4>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:77
msgid "Same as B<ahosts>, but use the address family B<AF_INET>."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:77
#, no-wrap
msgid "B<ahostsv6>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:88
msgid ""
"Same as B<ahosts>, but use the address family B<AF_INET6>.  The call to "
"B<getaddrinfo>(3)  in this case includes the B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:88
#, no-wrap
msgid "B<aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:105
msgid ""
"When no I<key> is provided, use B<setaliasent>(3), B<getaliasent>(3), and "
"B<endaliasent>(3)  to enumerate the aliases database.  When one or more "
"I<key> arguments are provided, pass each I<key> in succession to "
"B<getaliasbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:105
#, no-wrap
msgid "B<ethers>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:121
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<ether_aton>(3)  and B<ether_hostton>(3)  until a result is "
"obtained, and display the result.  Enumeration is not supported on "
"B<ethers>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:121
#, no-wrap
msgid "B<group>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:142
msgid ""
"When no I<key> is provided, use B<setgrent>(3), B<getgrent>(3), and "
"B<endgrent>(3)  to enumerate the group database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getgrgid>(3)  and each"
" nonnumeric I<key> to B<getgrnam>(3)  and display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:142
#, no-wrap
msgid "B<gshadow>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:159
msgid ""
"When no I<key> is provided, use B<setsgent>(3), B<getsgent>(3), and "
"B<endsgent>(3)  to enumerate the gshadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getsgnam>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:159
#, no-wrap
msgid "B<hosts>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:182
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  When one or more I<key> "
"arguments are provided, pass each I<key> to B<gethostbyaddr>(3)  or "
"B<gethostbyname2>(3), depending on whether a call to B<inet_pton>(3)  "
"indicates that the I<key> is an IPv6 or IPv4 address or not, and display the"
" result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:182
#, no-wrap
msgid "B<initgroups>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:196
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<getgrouplist>(3)  and display the result.  Enumeration is "
"not supported on B<initgroups>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:196
#, no-wrap
msgid "B<netgroup>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:222
msgid ""
"When one I<key> is provided, pass the I<key> to B<setnetgrent>(3)  and, "
"using B<getnetgrent>(3)  display the resulting string triple (I<hostname>, "
"I<username>, I<domainname>).  Alternatively, three I<keys> may be provided, "
"which are interpreted as the I<hostname>, I<username> and I<domainname> to "
"match to a netgroup name via B<innetgr>(3).  Enumeration is not supported on"
" B<netgroup>, so either one or three I<keys> must be provided."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:222
#, no-wrap
msgid "B<networks>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:243
msgid ""
"When no I<key> is provided, use B<setnetent>(3), B<getnetent>(3), and "
"B<endnetent>(3)  to enumerate the networks database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getnetbyaddr>(3)  and each nonnumeric I<key> to B<getnetbyname>(3)  and "
"display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:243
#, no-wrap
msgid "B<passwd>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:264
msgid ""
"When no I<key> is provided, use B<setpwent>(3), B<getpwent>(3), and "
"B<endpwent>(3)  to enumerate the passwd database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getpwuid>(3)  and each"
" nonnumeric I<key> to B<getpwnam>(3)  and display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:264
#, no-wrap
msgid "B<protocols>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:285
msgid ""
"When no I<key> is provided, use B<setprotoent>(3), B<getprotoent>(3), and "
"B<endprotoent>(3)  to enumerate the protocols database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getprotobynumber>(3)  and each nonnumeric I<key> to B<getprotobyname>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:285
#, no-wrap
msgid "B<rpc>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:306
msgid ""
"When no I<key> is provided, use B<setrpcent>(3), B<getrpcent>(3), and "
"B<endrpcent>(3)  to enumerate the rpc database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getrpcbynumber>(3)  "
"and each nonnumeric I<key> to B<getrpcbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:306
#, no-wrap
msgid "B<services>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:327
msgid ""
"When no I<key> is provided, use B<setservent>(3), B<getservent>(3), and "
"B<endservent>(3)  to enumerate the services database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getservbynumber>(3)  and each nonnumeric I<key> to B<getservbyname>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:327
#, no-wrap
msgid "B<shadow>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:344
msgid ""
"When no I<key> is provided, use B<setspent>(3), B<getspent>(3), and "
"B<endspent>(3)  to enumerate the shadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getspnam>(3)  "
"and display the result."
msgstr ""

#. type: SH
#: man-pages/man1/getent.1:345
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:346
#, no-wrap
msgid "B<-s\\ >I<service>, B<--service\\ >I<service>"
msgstr ""

#.  commit 9d0881aa76b399e6a025c5cf44bebe2ae0efa8af (glibc)
#. type: Plain text
#: man-pages/man1/getent.1:351
msgid ""
"Override all databases with the specified service.  (Since glibc 2.2.5.)"
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:351
#, no-wrap
msgid ""
"B<-s\\ >I<database>B<:>I<service>, B<--service\\ >I<database>B<:>I<service>"
msgstr ""

#.  commit b4f6f4be85d32b9c03361c38376e36f08100e3e8 (glibc)
#. type: Plain text
#: man-pages/man1/getent.1:359
msgid ""
"Override only specified databases with the specified service.  The option "
"may be used multiple times, but only the last service for each database will"
" be used.  (Since glibc 2.4.)"
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:359
#, no-wrap
msgid "B<-i>, B<--no-idn>"
msgstr ""

#.  commit a160f8d808cf8020b13bd0ef4a9eaf3c11f964ad (glibc)
#. type: Plain text
#: man-pages/man1/getent.1:365
msgid ""
"Disables IDN encoding in lookups for B<ahosts>/B<getaddrinfo>(3)  (Since "
"glibc-2.13.)"
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:365
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:368
msgid "Print a usage summary and exit."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:368
#, no-wrap
msgid "B<--usage>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:371
msgid "Print a short usage summary and exit."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:371
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:375
msgid ""
"Print the version number, license, and disclaimer of warranty for B<getent>."
msgstr ""

#. type: SH
#: man-pages/man1/getent.1:375
#, no-wrap
msgid "EXIT STATUS"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:378
msgid "One of the following exit values can be returned by B<getent>:"
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:379
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:382
msgid "Command completed successfully."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:382
#, no-wrap
msgid "B<1>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:387
msgid "Missing arguments, or I<database> unknown."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:387
#, no-wrap
msgid "B<2>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:393
msgid "One or more supplied I<key> could not be found in the I<database>."
msgstr ""

#. type: TP
#: man-pages/man1/getent.1:393
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:397
msgid "Enumeration not supported on this I<database>."
msgstr ""

#. type: SH
#: man-pages/man1/getent.1:398
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man1/getent.1:399
msgid "B<nsswitch.conf>(5)"
msgstr ""

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "GLOB"
msgstr ""

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "2016-10-08"
msgstr ""

#. type: TH
#: man-pages/man7/glob.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:29
msgid "glob - globbing pathnames"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:34
msgid ""
"Long ago, in UNIX\\ V6, there was a program I</etc/glob> that would expand "
"wildcard patterns.  Soon afterward this became a shell built-in."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:38
msgid ""
"These days there is also a library routine B<glob>(3)  that will perform "
"this function for a user program."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:40
msgid "The rules are as follows (POSIX.2, 3.13)."
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:40
#, no-wrap
msgid "Wildcard matching"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:47
msgid ""
"A string is a wildcard pattern if it contains one of the characters "
"\\(aq?\\(aq, \\(aq*\\(aq or \\(aq[\\(aq.  Globbing is the operation that "
"expands a wildcard pattern into the list of pathnames matching the pattern."
"  Matching is defined by:"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:49
msgid "A \\(aq?\\(aq (not between brackets) matches any single character."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:52
msgid ""
"A \\(aq*\\(aq (not between brackets) matches any string, including the empty"
" string."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:54
msgid "B<Character classes>"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:63
msgid ""
"An expression \"I<[...]>\" where the first character after the leading "
"\\(aq[\\(aq is not an \\(aq!\\(aq matches a single character, namely any of "
"the characters enclosed by the brackets.  The string enclosed by the "
"brackets cannot be empty; therefore \\(aq]\\(aq can be allowed between the "
"brackets, provided that it is the first character.  (Thus, \"I<[][!]>\" "
"matches the three characters \\(aq[\\(aq, \\(aq]\\(aq and \\(aq!\\(aq.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:65
msgid "B<Ranges>"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:76
msgid ""
"There is one special convention: two characters separated by \\(aq-\\(aq "
"denote a range.  (Thus, \"I<[A-Fa-f0-9]>\" is equivalent to "
"\"I<[ABCDEFabcdef0123456789]>\".)  One may include \\(aq-\\(aq in its "
"literal meaning by making it the first or last character between the "
"brackets.  (Thus, \"I<[]-]>\" matches just the two characters \\(aq]\\(aq "
"and \\(aq-\\(aq, and \"I<[--0]>\" matches the three characters \\(aq-\\(aq, "
"\\(aq.\\(aq, \\(aq0\\(aq, since \\(aq/\\(aq cannot be matched.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:78
msgid "B<Complementation>"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:84
msgid ""
"An expression \"I<[!...]>\" matches a single character, namely any character"
" that is not matched by the expression obtained by removing the first "
"\\(aq!\\(aq from it.  (Thus, \"I<[!]a-]>\" matches any single character "
"except \\(aq]\\(aq, \\(aqa\\(aq and \\(aq-\\(aq.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:91
msgid ""
"One can remove the special meaning of \\(aq?\\(aq, \\(aq*\\(aq and "
"\\(aq[\\(aq by preceding them by a backslash, or, in case this is part of a "
"shell command line, enclosing them in quotes.  Between brackets these "
"characters stand for themselves.  Thus, \"I<[[?*\\e]>\" matches the four "
"characters \\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq and \\(aq\\e\\(aq."
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:91
#, no-wrap
msgid "Pathnames"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:98
msgid ""
"Globbing is applied on each of the components of a pathname separately.  A "
"\\(aq/\\(aq in a pathname cannot be matched by a \\(aq?\\(aq or \\(aq*\\(aq "
"wildcard, or by a range like \"I<[.-0]>\".  A range containing an explicit "
"\\(aq/\\(aq character is syntactically incorrect.  (POSIX requires that "
"syntactically incorrect patterns are left unchanged.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:103
msgid ""
"If a filename starts with a \\(aq.\\(aq, this character must be matched "
"explicitly.  (Thus, I<rm\\ *> will not remove .profile, and I<tar\\ c\\ *> "
"will not archive all your files; I<tar\\ c\\ .> is better.)"
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:103
#, no-wrap
msgid "Empty lists"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:109
msgid ""
"The nice and simple rule given above: \"expand a wildcard pattern into the "
"list of matching pathnames\" was the original UNIX definition.  It allowed "
"one to have patterns that expand into an empty list, as in"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:112
#, no-wrap
msgid "    xv -wait 0 *.gif *.jpg\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:122
msgid ""
"where perhaps no *.gif files are present (and this is not an error).  "
"However, POSIX requires that a wildcard pattern is left unchanged when it is"
" syntactically incorrect, or the list of matching pathnames is empty.  With "
"I<bash> one can force the classical behavior using this command:"
msgstr ""

#.  In Bash v1, by setting allow_null_glob_expansion=true
#. type: Plain text
#: man-pages/man7/glob.7:125
#, no-wrap
msgid "    shopt -s nullglob\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:128
msgid ""
"(Similar problems occur elsewhere.  For example, where old scripts have"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:131
#, no-wrap
msgid "    rm \\`find . -name \"*~\"\\`\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:134
msgid "new scripts require"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:137
#, no-wrap
msgid "    rm -f nosuchfile \\`find . -name \"*~\"\\`\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:142
msgid ""
"to avoid error messages from I<rm> called with an empty argument list.)"
msgstr ""

#. type: SH
#: man-pages/man7/glob.7:142
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:143
#, no-wrap
msgid "Regular expressions"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:150
msgid ""
"Note that wildcard patterns are not regular expressions, although they are a"
" bit similar.  First of all, they match filenames, rather than text, and "
"secondly, the conventions are not the same: for example, in a regular "
"expression \\(aq*\\(aq means zero or more copies of the preceding thing."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:154
msgid ""
"Now that regular expressions have bracket expressions where the negation is "
"indicated by a \\(aq^\\(aq, POSIX has declared the effect of a wildcard "
"pattern \"I<[^...]>\" to be undefined."
msgstr ""

#. type: SS
#: man-pages/man7/glob.7:154
#, no-wrap
msgid "Character classes and internationalization"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:172
msgid ""
"Of course ranges were originally meant to be ASCII ranges, so that \"I<[\\ "
"-%]>\" stands for \"I<[\\ !\"#$%]>\" and \"I<[a-z]>\" stands for \"any "
"lowercase letter\".  Some UNIX implementations generalized this so that a "
"range X-Y stands for the set of characters with code between the codes for X"
" and for Y.  However, this requires the user to know the character coding in"
" use on the local system, and moreover, is not convenient if the collating "
"sequence for the local alphabet differs from the ordering of the character "
"codes.  Therefore, POSIX extended the bracket notation greatly, both for "
"wildcard patterns and for regular expressions.  In the above we saw three "
"types of items that can occur in a bracket expression: namely (i) the "
"negation, (ii) explicit single characters, and (iii) ranges.  POSIX "
"specifies ranges in an internationally more useful way and adds three more "
"types:"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:178
msgid ""
"(iii) Ranges X-Y comprise all characters that fall between X and Y "
"(inclusive) in the current collating sequence as defined by the "
"B<LC_COLLATE> category in the current locale."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:180
msgid "(iv) Named character classes, like"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:185
#, no-wrap
msgid ""
"[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n"
"[:digit:]  [:graph:]  [:lower:]  [:print:]\n"
"[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:194
msgid ""
"so that one can say \"I<[[:lower:]]>\" instead of \"I<[a-z]>\", and have "
"things work in Denmark, too, where there are three letters past \\(aqz\\(aq "
"in the alphabet.  These character classes are defined by the B<LC_CTYPE> "
"category in the current locale."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:200
msgid ""
"(v) Collating symbols, like \"I<[.ch.]>\" or \"I<[.a-acute.]>\", where the "
"string between \"I<[.>\" and \"I<.]>\" is a collating element defined for "
"the current locale.  Note that this may be a multicharacter element."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:208
msgid ""
"(vi) Equivalence class expressions, like \"I<[=a=]>\", where the string "
"between \"I<[=>\" and \"I<=]>\" is any collating element from its "
"equivalence class, as defined for the current locale.  For example, "
"\"I<[[=a=]]>\" might be equivalent to \"I<[a\\('a\\(`a\\(:a\\(^a]>\", that "
"is, to \"I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/glob.7:213
msgid "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getsid.2:27
#, no-wrap
msgid "GETSID"
msgstr ""

#. type: TH
#: man-pages/man2/getsid.2:27
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:30
msgid "getsid - get session ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:32
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:34
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:36
msgid "B<pid_t getsid(pid_t>I< pid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:40
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:45
msgid "B<getsid>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/getsid.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:50
#, no-wrap
msgid "    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:64
msgid ""
"I<getsid(0)> returns the session ID of the calling process.  B<getsid>()  "
"returns the session ID of the process with process ID I<pid>.  If I<pid> is "
"0, B<getsid>()  returns the session ID of the calling process."
msgstr ""

#. type: SH
#: man-pages/man2/getsid.2:64
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:69
msgid ""
"On success, a session ID is returned.  On error, I<(pid_t)\\ -1> will be "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: SH
#: man-pages/man2/getsid.2:69
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man2/getsid.2:70
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:76
msgid ""
"A process with process ID I<pid> exists, but it is not in the same session "
"as the calling process, and the implementation considers this an error."
msgstr ""

#. type: TP
#: man-pages/man2/getsid.2:76
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:81
msgid "No process with process ID I<pid> was found."
msgstr ""

#. type: SH
#: man-pages/man2/getsid.2:81
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  Linux has this system call since Linux 1.3.44.
#.  There is libc support since libc 5.2.19.
#. type: Plain text
#: man-pages/man2/getsid.2:85
msgid "This system call is available on Linux since version 2.0."
msgstr ""

#. type: SH
#: man-pages/man2/getsid.2:85
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:87
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:90
msgid "Linux does not return B<EPERM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:94
msgid "See B<credentials>(7)  for a description of sessions and session IDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:97
msgid "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getpid.2:25
#, no-wrap
msgid "GETPID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:28
msgid "getpid, getppid - get process identification"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:34
msgid "B<pid_t getpid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:36
msgid "B<pid_t getppid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:41
msgid ""
"B<getpid>()  returns the process ID (PID) of the calling process.  (This is "
"often used by routines that generate unique temporary filenames.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:53
msgid ""
"B<getppid>()  returns the process ID of the parent of the calling process.  "
"This will be either the ID of the process that created this process using "
"B<fork>(), or, if that process has already terminated, the ID of the process"
" to which this process has been reparented (either B<init>(1)  or a "
"\"subreaper\" process defined via the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER>"
" operation)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:55
msgid "These functions are always successful."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:57
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:62
msgid ""
"If the caller's parent is in a different PID namespace (see "
"B<pid_namespaces>(7)), B<getppid>()  returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:75
msgid ""
"From a kernel perspective, the PID (which is shared by all of the threads in"
" a multithreaded process)  is sometimes also known as the thread group ID "
"(TGID).  This contrasts with the kernel thread ID (TID), which is unique for"
" each thread.  For further details, see B<gettid>(2)  and the discussion of "
"the B<CLONE_THREAD> flag in B<clone>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/getpid.2:75
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#.  The following program demonstrates this "feature":
#.  #define _GNU_SOURCE
#.  #include <sys/syscall.h>
#.  #include <sys/wait.h>
#.  #include <stdio.h>
#.  #include <stdlib.h>
#.  #include <unistd.h>
#.  int
#.  main(int argc, char *argv[])
#.  {
#.     /* The following statement fills the getpid() cache */
#.     printf("parent PID = %ld
#. ", (long) getpid());
#.     if (syscall(SYS_fork) == 0) {
#.         if (getpid() != syscall(SYS_getpid))
#.             printf("child getpid() mismatch: getpid()=%ld; "
#.                     "syscall(SYS_getpid)=%ld
#. ",
#.                     (long) getpid(), (long) syscall(SYS_getpid));
#.         exit(EXIT_SUCCESS);
#.     }
#.     wait(NULL);
#. }
#. type: Plain text
#: man-pages/man2/getpid.2:129
msgid ""
"From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper"
" function for B<getpid>()  cached PIDs, with the goal of avoiding additional"
" system calls when a process calls B<getpid>()  repeatedly.  Normally this "
"caching was invisible, but its correct operation relied on support in the "
"wrapper functions for B<fork>(2), B<vfork>(2), and B<clone>(2): if an "
"application bypassed the glibc wrappers for these system calls by using "
"B<syscall>(2), then a call to B<getpid>()  in the child would return the "
"wrong value (to be precise: it would return the PID of the parent process)."
"  In addition, there were cases where B<getpid>()  could return the wrong "
"value even when invoking B<clone>(2)  via the glibc wrapper function.  (For "
"a discussion of one such case, see BUGS in B<clone>(2).)  Furthermore, the "
"complexity of the caching code had been the source of a few bugs within "
"glibc over the years."
msgstr ""

#.  commit c579f48edba88380635ab98cb612030e3ed8691e
#.  https://sourceware.org/glibc/wiki/Release/2.25#pid_cache_removal
#.  FIXME .
#.  Review progress of https://bugzilla.redhat.com/show_bug.cgi?id=1469757
#. type: Plain text
#: man-pages/man2/getpid.2:139
msgid ""
"Because of the aforementioned problems, since glibc version 2.25, the PID "
"cache is removed: calls to B<getpid>()  always invoke the actual system "
"call, rather than returning a cached value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:155
msgid ""
"On Alpha, instead of a pair of B<getpid>()  and B<getppid>()  system calls, "
"a single B<getxpid>()  system call is provided, which returns a pair of PID "
"and parent PID.  The glibc B<getpid>()  and B<getppid>()  wrapper functions "
"transparently deal with this.  See B<syscall>(2)  for details regarding "
"register mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:166
msgid ""
"B<clone>(2), B<fork>(2), B<gettid>(2), B<kill>(2), B<exec>(3), "
"B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), "
"B<credentials>(7), B<pid_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getpriority.2:45
#, no-wrap
msgid "GETPRIORITY"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:48
msgid "getpriority, setpriority - get/set program scheduling priority"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:50
msgid "B<#include E<lt>sys/time.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:52
msgid "B<#include E<lt>sys/resource.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:54
msgid "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:56
msgid "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:70
msgid ""
"The scheduling priority of the process, process group, or user, as indicated"
" by I<which> and I<who> is obtained with the B<getpriority>()  call and set "
"with the B<setpriority>()  call.  The process attribute dealt with by these "
"system calls is the same attribute (also known as the \"nice\" value) that "
"is dealt with by B<nice>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:93
msgid ""
"The value I<which> is one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>,"
" and I<who> is interpreted relative to I<which> (a process identifier for "
"B<PRIO_PROCESS>, process group identifier for B<PRIO_PGRP>, and a user ID "
"for B<PRIO_USER>).  A zero value for I<who> denotes (respectively) the "
"calling process, the process group of the calling process, or the real user "
"ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:102
msgid ""
"The I<prio> argument is a value in the range -20 to 19 (but see NOTES "
"below).  with -20 being the highest priority and 19 being the lowest "
"priority.  Attempts to set a priority outside this range are silently "
"clamped to the range.  The default priority is 0; lower values give a "
"process a higher scheduling priority."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:111
msgid ""
"The B<getpriority>()  call returns the highest priority (lowest numerical "
"value)  enjoyed by any of the specified processes.  The B<setpriority>()  "
"call sets the priorities of all of the specified processes to the specified "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:120
msgid ""
"Traditionally, only a privileged process could lower the nice value (i.e., "
"set a higher priority).  However, since Linux 2.6.12, an unprivileged "
"process can decrease the nice value of a target process that has a suitable "
"B<RLIMIT_NICE> soft limit; see B<getrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:135
msgid ""
"On success, B<getpriority>()  returns the calling thread's nice value, which"
" may be a negative number.  On error, it returns -1 and sets I<errno> to "
"indicate the cause of the error.  Since a successful call to "
"B<getpriority>()  can legitimately return the value -1, it is necessary to "
"clear the external variable I<errno> prior to the call, then check it "
"afterward to determine if -1 is an error or a legitimate value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:141
msgid ""
"B<setpriority>()  returns 0 on success.  On error, it returns -1 and sets "
"I<errno> to indicate the cause of the error."
msgstr ""

#. type: TP
#: man-pages/man2/getpriority.2:142
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:150
msgid ""
"I<which> was not one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:157
msgid "No process was located using the I<which> and I<who> values specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:161
msgid ""
"In addition to the errors indicated above, B<setpriority>()  may fail if:"
msgstr ""

#. type: TP
#: man-pages/man2/getpriority.2:161
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:168
msgid ""
"The caller attempted to set a lower nice value (i.e., a higher process "
"priority), but did not have the required privilege (on Linux: did not have "
"the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:176
msgid ""
"A process was located, but its effective user ID did not match either the "
"effective or the real user ID of the caller, and was not privileged (on "
"Linux: did not have the B<CAP_SYS_NICE> capability).  But see NOTES below."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:179
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these interfaces first appeared in"
" 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:182
msgid "For further details on the nice value, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:188
msgid ""
"I<Note>: the addition of the \"autogroup\" feature in Linux 2.6.38 means "
"that the nice value no longer has its traditional effect in many "
"circumstances.  For details, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:194
msgid ""
"A child created by B<fork>(2)  inherits its parent's nice value.  The nice "
"value is preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:209
msgid ""
"The details on the condition for B<EPERM> depend on the system.  The above "
"description is what POSIX.1-2001 says, and seems to be followed on all "
"System\\ V-like systems.  Linux kernels before 2.6.12 required the real or "
"effective user ID of the caller to match the real user of the process I<who>"
" (instead of its effective user ID).  Linux 2.6.12 and later require the "
"effective user ID of the caller to match the real or effective user ID of "
"the process I<who>.  All BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, "
"FreeBSD 4.3, OpenBSD-2.5, ...) behave in the same manner as Linux 2.6.12 and"
" later."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:222
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:237
msgid ""
"Within the kernel, nice values are actually represented using the range "
"40..1 (since negative numbers are error codes) and these are the values "
"employed by the B<setpriority>()  and B<getpriority>()  system calls.  The "
"glibc wrapper functions for these system calls handle the translations "
"between the user-land and kernel representations of the nice value according"
" to the formula I<unice\\ =\\ 20\\ -\\ knice>.  (Thus, the kernel's 40..1 "
"range corresponds to the range -20..19 as seen by user space.)"
msgstr ""

#. type: SH
#: man-pages/man2/getpriority.2:237
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:244
msgid ""
"According to POSIX, the nice value is a per-process setting.  However, under"
" the current Linux/NPTL implementation of POSIX threads, the nice value is a"
" per-thread attribute: different threads in the same process can have "
"different nice values.  Portable applications should avoid relying on the "
"Linux behavior, which may be made standards conformant in the future."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:250
msgid "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:252
msgid ""
"I<Documentation/scheduler/sched-nice-design.txt> in the Linux kernel source "
"tree (since Linux 2.6.23)"
msgstr ""

#. type: TH
#: man-pages/man2/getpeername.2:42
#, no-wrap
msgid "GETPEERNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:45
msgid "getpeername - get name of connected peer socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:47
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:50
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:63
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by I<addr>."
"  On return it contains the actual size of the name returned (in bytes).  "
"The name is truncated if the buffer provided is too small."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:68
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/getpeername.2:74
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:79
msgid "The argument I<sockfd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/getpeername.2:79
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:85
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:89
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr ""

#. type: TP
#: man-pages/man2/getpeername.2:89
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:93
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr ""

#. type: TP
#: man-pages/man2/getpeername.2:93
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:96
msgid "The socket is not connected."
msgstr ""

#. type: TP
#: man-pages/man2/getpeername.2:96
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:101
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:105
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getpeername>()  first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:110
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:137
msgid ""
"For stream sockets, once a B<connect>(2)  has been performed, either socket "
"can call B<getpeername>()  to obtain the address of the peer socket.  On the"
" other hand, datagram sockets are connectionless.  Calling B<connect>(2)  on"
" a datagram socket merely sets the peer address for outgoing datagrams sent "
"with B<write>(2)  or B<recv>(2).  The caller of B<connect>(2)  can use "
"B<getpeername>()  to obtain the peer address that it earlier set for the "
"socket.  However, the peer socket is unaware of this information, and "
"calling B<getpeername>()  on the peer socket will return no useful "
"information (unless a B<connect>(2)  call was also executed on the peer).  "
"Note also that the receiver of a datagram can obtain the address of the "
"sender when using B<recvfrom>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:143
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getgid.2:25
#, no-wrap
msgid "GETGID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:28
msgid "getgid, getegid - get group identity"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:34
msgid "B<gid_t getgid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:36
msgid "B<gid_t getegid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:39
msgid "B<getgid>()  returns the real group ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:42
msgid "B<getegid>()  returns the effective group ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:46
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:62
msgid ""
"The original Linux B<getgid>()  and B<getegid>()  system calls supported "
"only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
"B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and "
"B<getegid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:78
msgid ""
"On Alpha, instead of a pair of B<getgid>()  and B<getegid>()  system calls, "
"a single B<getxgid>()  system call is provided, which returns a pair of real"
" and effective GIDs.  The glibc B<getgid>()  and B<getegid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:82
msgid "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getdents.2:31
#, no-wrap
msgid "GETDENTS"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:34
msgid "getdents, getdents64 - get directory entries"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:40
#, no-wrap
msgid ""
"B<int getdents(unsigned int >I<fd>B<, struct linux_dirent *>I<dirp>B<,>\n"
"B<             unsigned int >I<count>B<);>\n"
"B<int getdents64(unsigned int >I<fd>B<, struct linux_dirent64 *>I<dirp>B<,>\n"
"B<             unsigned int >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:44
msgid ""
"I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:50
msgid ""
"These are not the interfaces you are interested in.  Look at B<readdir>(3)  "
"for the POSIX-conforming C library interface.  This page documents the bare "
"kernel system call interfaces."
msgstr ""

#. type: SS
#: man-pages/man2/getdents.2:50
#, no-wrap
msgid "getdents()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:63
msgid ""
"The system call B<getdents>()  reads several I<linux_dirent> structures from"
" the directory referred to by the open file descriptor I<fd> into the buffer"
" pointed to by I<dirp>.  The argument I<count> specifies the size of that "
"buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:67
msgid "The I<linux_dirent> structure is declared as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:83
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    unsigned long  d_ino;     /* Inode number */\n"
"    unsigned long  d_off;     /* Offset to next I<linux_dirent> */\n"
"    unsigned short d_reclen;  /* Length of this I<linux_dirent> */\n"
"    char           d_name[];  /* Filename (null-terminated) */\n"
"                      /* length is actually (d_reclen - 2 -\n"
"                         offsetof(struct linux_dirent, d_name)) */\n"
"    /*\n"
"    char           pad;       // Zero padding byte\n"
"    char           d_type;    // File type (only since Linux\n"
"                              // 2.6.4); offset is (d_reclen - 1)\n"
"    */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:96
msgid ""
"I<d_ino> is an inode number.  I<d_off> is the distance from the start of the"
" directory to the start of the next I<linux_dirent>.  I<d_reclen> is the "
"size of this entire I<linux_dirent>.  I<d_name> is a null-terminated "
"filename."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:101
msgid ""
"I<d_type> is a byte at the end of the structure that indicates the file "
"type.  It contains one of the following values (defined in "
"I<E<lt>dirent.hE<gt>>):"
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:101
#, no-wrap
msgid "B<DT_BLK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:104
msgid "This is a block device."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:104
#, no-wrap
msgid "B<DT_CHR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:107
msgid "This is a character device."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:107
#, no-wrap
msgid "B<DT_DIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:110
msgid "This is a directory."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:110
#, no-wrap
msgid "B<DT_FIFO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:113
msgid "This is a named pipe (FIFO)."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:113
#, no-wrap
msgid "B<DT_LNK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:116
msgid "This is a symbolic link."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:116
#, no-wrap
msgid "B<DT_REG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:119
msgid "This is a regular file."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:119
#, no-wrap
msgid "B<DT_SOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:122
msgid "This is a UNIX domain socket."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:122
#, no-wrap
msgid "B<DT_UNKNOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:125
msgid "The file type is unknown."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:135
msgid ""
"The I<d_type> field is implemented since Linux 2.6.4.  It occupies a space "
"that was previously a zero-filled padding byte in the I<linux_dirent> "
"structure.  Thus, on kernels up to and including 2.6.3, attempting to access"
" this field always provides the value 0 (B<DT_UNKNOWN>)."
msgstr ""

#.  kernel 2.6.27
#.  The same sentence is in readdir.2
#. type: Plain text
#: man-pages/man2/getdents.2:144
msgid ""
"Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4)  "
"have full support for returning the file type in I<d_type>.  All "
"applications must properly handle a return of B<DT_UNKNOWN>."
msgstr ""

#. type: SS
#: man-pages/man2/getdents.2:144
#, no-wrap
msgid "getdents64()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:160
msgid ""
"The original Linux B<getdents>()  system call did not handle large "
"filesystems and large file offsets.  Consequently, Linux 2.4 added "
"B<getdents64>(), with wider types for the I<d_ino> and I<d_off> fields.  In "
"addition, B<getdents64>()  supports an explicit I<d_type> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:167
msgid ""
"The B<getdents64>()  system call is like B<getdents>(), except that its "
"second argument is a pointer to a buffer containing structures of the "
"following type:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:177
#, no-wrap
msgid ""
"struct linux_dirent64 {\n"
"    ino64_t        d_ino;    /* 64-bit inode number */\n"
"    off64_t        d_off;    /* 64-bit offset to next structure */\n"
"    unsigned short d_reclen; /* Size of this dirent */\n"
"    unsigned char  d_type;   /* File type */\n"
"    char           d_name[]; /* Filename (null-terminated) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:185
msgid ""
"On success, the number of bytes read is returned.  On end of directory, 0 is"
" returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:190
msgid "Invalid file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:193
msgid "Argument points outside the calling process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:196
msgid "Result buffer is too small."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:196
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:199
msgid "No such directory."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:199
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:202
msgid "File descriptor does not refer to a directory."
msgstr ""

#.  SVr4 documents additional ENOLINK, EIO error conditions.
#. type: Plain text
#: man-pages/man2/getdents.2:205
msgid "SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:216
msgid ""
"Glibc does not provide a wrapper for these system calls; call them using "
"B<syscall>(2).  You will need to define the I<linux_dirent> or "
"I<linux_dirent64> structure yourself.  However, you probably want to use "
"B<readdir>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:219
msgid "These calls supersede B<readdir>(2)."
msgstr ""

#. type: SH
#: man-pages/man2/getdents.2:219
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#.  FIXME The example program needs to be revised, since it uses the older
#.  getdents() system call and the structure with smaller field widths.
#. type: Plain text
#: man-pages/man2/getdents.2:226
msgid ""
"The program below demonstrates the use of B<getdents>().  The following "
"output shows an example of what we see when running this program on an ext2 "
"directory:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:239
#, no-wrap
msgid ""
"$B< ./a.out /testfs/>\n"
"--------------- nread=120 ---------------\n"
"inode#    file type  d_reclen  d_off   d_name\n"
"       2  directory    16         12  .\n"
"       2  directory    16         24  ..\n"
"      11  directory    24         44  lost+found\n"
"      12  regular      16         56  a\n"
"  228929  directory    16         68  sub\n"
"   16353  directory    16         80  sub2\n"
"  130817  directory    16       4096  sub3\n"
msgstr ""

#. type: SS
#: man-pages/man2/getdents.2:241
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:252
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>dirent.hE<gt>     /* Defines DT_* constants */\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:255
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:262
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    long           d_ino;\n"
"    off_t          d_off;\n"
"    unsigned short d_reclen;\n"
"    char           d_name[];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:264
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:273
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd, nread;\n"
"    char buf[BUF_SIZE];\n"
"    struct linux_dirent *d;\n"
"    int bpos;\n"
"    char d_type;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:277
#, no-wrap
msgid ""
"    fd = open(argc E<gt> 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:282
#, no-wrap
msgid ""
"    for ( ; ; ) {\n"
"        nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);\n"
"        if (nread == -1)\n"
"            handle_error(\"getdents\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:285
#, no-wrap
msgid ""
"        if (nread == 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:304
#, no-wrap
msgid ""
"        printf(\"--------------- nread=%d ---------------\\en\", nread);\n"
"        printf(\"inode#    file type  d_reclen  d_off   d_name\\en\");\n"
"        for (bpos = 0; bpos E<lt> nread;) {\n"
"            d = (struct linux_dirent *) (buf + bpos);\n"
"            printf(\"%8ld  \", d-E<gt>d_ino);\n"
"            d_type = *(buf + bpos + d-E<gt>d_reclen - 1);\n"
"            printf(\"%-10s \", (d_type == DT_REG) ?  \"regular\" :\n"
"                             (d_type == DT_DIR) ?  \"directory\" :\n"
"                             (d_type == DT_FIFO) ? \"FIFO\" :\n"
"                             (d_type == DT_SOCK) ? \"socket\" :\n"
"                             (d_type == DT_LNK) ?  \"symlink\" :\n"
"                             (d_type == DT_BLK) ?  \"block dev\" :\n"
"                             (d_type == DT_CHR) ?  \"char dev\" : \"???\");\n"
"            printf(\"%4d %10lld  %s\\en\", d-E<gt>d_reclen,\n"
"                    (long long) d-E<gt>d_off, d-E<gt>d_name);\n"
"            bpos += d-E<gt>d_reclen;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:307
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:311
msgid "B<readdir>(2), B<readdir>(3), B<inode>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getsockopt.2:44
#, no-wrap
msgid "GETSOCKOPT"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:47
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:56
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:66
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple"
" protocol levels; they are always present at the uppermost socket level."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:85
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option"
" is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:107
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:117
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file "
"I<E<lt>sys/socket.hE<gt>> contains definitions for socket level options, "
"described below.  Options at other protocol levels vary in format and name; "
"consult the appropriate entries in section 4 of the manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:126
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:130
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:135
msgid ""
"On success, zero is returned for the standard options.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:139
msgid ""
"Netfilter allows the programmer to define custom socket options with "
"associated handlers; for such options, the return value on success is the "
"value returned by the handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:155
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:166
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/getsockopt.2:166
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:169
msgid "The option is unknown at the level indicated."
msgstr ""

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: man-pages/man2/getsockopt.2:181
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these system calls first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:187
msgid ""
"POSIX.1 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and this"
" header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:195
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:205
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), "
"B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:15
msgid ""
"getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:21
#, no-wrap
msgid ""
"B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache "
"*>I<tcache>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:39
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a"
" unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:43
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:58
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:63
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:67
msgid "Arguments point outside the calling process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:74
msgid ""
"B<getcpu>()  was added in kernel 2.6.19 for x86-64 and i386.  Library "
"support was added in glibc 2.29 (Earlier glibc versions did not provide a "
"wrapper for this system call, necessitating the use of B<syscall>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:77
msgid "B<getcpu>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:85
msgid ""
"Linux makes a best effort to make this call as fast as possible.  (On some "
"architectures, this is done via an implementation in the B<vdso>(7).)  The "
"intention of B<getcpu>()  is to allow programs to make optimizations with "
"per-CPU data or for NUMA optimization."
msgstr ""

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: man-pages/man2/getcpu.2:136
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if"
" this argument was non-NULL, then it specified a pointer to a caller-"
"allocated buffer in thread-local storage that was used to provide a caching "
"mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  calls,"
" at the cost that there was a very small chance that the returned "
"information would be out of date.  The caching mechanism was considered to "
"cause problems when migrating threads between CPUs, and so the argument is "
"now ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:142
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7), B<vdso>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/gettid.2:26
#, no-wrap
msgid "GETTID"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:29
msgid "gettid - get thread identification"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:32
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:34
#, no-wrap
msgid "B<pid_t gettid(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:47
msgid ""
"B<gettid>()  returns the caller's thread ID (TID).  In a single-threaded "
"process, the thread ID is equal to the process ID (PID, as returned by "
"B<getpid>(2)).  In a multithreaded process, all threads have the same PID, "
"but each one has a unique TID.  For further details, see the discussion of "
"B<CLONE_THREAD> in B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:49
msgid "On success, returns the thread ID of the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:51
msgid "This call is always successful."
msgstr ""

#.  FIXME . See http://sourceware.org/bugzilla/show_bug.cgi?id=6399
#.  "gettid() should have a wrapper"
#. type: Plain text
#: man-pages/man2/gettid.2:61
msgid ""
"The B<gettid>()  system call first appeared on Linux in kernel 2.4.11.  "
"Library support was added in glibc 2.30.  (Earlier glibc versions did not "
"provide a wrapper for this system call, necessitating the use of "
"B<syscall>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:65
msgid ""
"B<gettid>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:69
msgid ""
"The thread ID returned by this call is not the same thing as a POSIX thread "
"ID (i.e., the opaque value returned by B<pthread_self>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:81
msgid ""
"In a new thread group created by a B<clone>(2)  call that does not specify "
"the B<CLONE_THREAD> flag (or, equivalently, a new process created by "
"B<fork>(2)), the new process is a thread group leader, and its thread group "
"ID (the value returned by B<getpid>(2))  is the same as its thread ID (the "
"value returned by B<gettid>())."
msgstr ""

#.  .BR kcmp (2),
#.  .BR move_pages (2),
#.  .BR migrate_pages (2),
#.  .BR process_vm_readv (2),
#.  .BR ptrace (2),
#. type: Plain text
#: man-pages/man2/gettid.2:99
msgid ""
"B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<getpid>(2), "
"B<get_robust_list>(2), B<ioprio_set>(2), B<perf_event_open>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<tgkill>(2), B<timer_create>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/getrandom.2:27
#, no-wrap
msgid "GETRANDOM"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:30
msgid "getrandom - obtain a series of random bytes"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:32
msgid "B<#include E<lt>sys/random.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:34
msgid ""
"B<ssize_t getrandom(void *>I<buf>B<, size_t >I<buflen>B<, unsigned int "
">I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:44
msgid ""
"The B<getrandom>()  system call fills the buffer pointed to by I<buf> with "
"up to I<buflen> random bytes.  These bytes can be used to seed user-space "
"random number generators or for cryptographic purposes."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:55
msgid ""
"By default, B<getrandom>()  draws entropy from the I<urandom> source (i.e., "
"the same source as the I</dev/urandom> device).  This behavior can be "
"changed via the I<flags> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:65
msgid ""
"If the I<urandom> source has been initialized, reads of up to 256 bytes will"
" always return as many bytes as requested and will not be interrupted by "
"signals.  No such guarantees apply for larger buffer sizes.  For example, if"
" the call is interrupted by a signal handler, it may return a partially "
"filled buffer, or fail with the error B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:74
msgid ""
"If the I<urandom> source has not yet been initialized, then B<getrandom>()  "
"will block, unless B<GRND_NONBLOCK> is specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:79
msgid ""
"The I<flags> argument is a bit mask that can contain zero or more of the "
"following values ORed together:"
msgstr ""

#. type: TP
#: man-pages/man2/getrandom.2:79
#, no-wrap
msgid "B<GRND_RANDOM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:104
msgid ""
"If this bit is set, then random bytes are drawn from the I<random> source "
"(i.e., the same source as the I</dev/random> device)  instead of the "
"I<urandom> source.  The I<random> source is limited based on the entropy "
"that can be obtained from environmental noise.  If the number of available "
"bytes in the I<random> source is less than requested in I<buflen>, the call "
"returns just the available random bytes.  If no random bytes are available, "
"the behavior depends on the presence of B<GRND_NONBLOCK> in the I<flags> "
"argument."
msgstr ""

#. type: TP
#: man-pages/man2/getrandom.2:104
#, no-wrap
msgid "B<GRND_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:122
msgid ""
"By default, when reading from the I<random> source, B<getrandom>()  blocks "
"if no random bytes are available, and when reading from the I<urandom> "
"source, it blocks if the entropy pool has not yet been initialized.  If the "
"B<GRND_NONBLOCK> flag is set, then B<getrandom>()  does not block in these "
"cases, but instead immediately returns -1 with I<errno> set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:136
msgid ""
"On success, B<getrandom>()  returns the number of bytes that were copied to "
"the buffer I<buf>.  This may be less than the number of bytes requested via "
"I<buflen> if either B<GRND_RANDOM> was specified in I<flags> and "
"insufficient entropy was present in the I<random> source or the system call "
"was interrupted by a signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:140
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/getrandom.2:141
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:148
msgid ""
"The requested entropy was not available, and B<getrandom>()  would have "
"blocked if the B<GRND_NONBLOCK> flag was not set."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:153
msgid ""
"The address referred to by I<buf> is outside the accessible address space."
msgstr ""

#. type: TP
#: man-pages/man2/getrandom.2:153
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:163
msgid ""
"The call was interrupted by a signal handler; see the description of how "
"interrupted B<read>(2)  calls on \"slow\" devices are handled with and "
"without the B<SA_RESTART> flag in the B<signal>(7)  man page."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:167
msgid "An invalid flag was specified in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/getrandom.2:167
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:172
msgid ""
"The glibc wrapper function for B<getrandom>()  determined that the "
"underlying kernel does not implement this system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:176
msgid ""
"B<getrandom>()  was introduced in version 3.17 of the Linux kernel.  Support"
" was added to glibc in version 2.25."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:178
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:182
msgid ""
"For an overview and comparison of the various interfaces that can be used to"
" obtain randomness, see B<random>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:200
msgid ""
"Unlike I</dev/random> and I</dev/urandom>, B<getrandom>()  does not involve "
"the use of pathnames or file descriptors.  Thus, B<getrandom>()  can be "
"useful in cases where B<chroot>(2)  makes I</dev> pathnames invisible, and "
"where an application (e.g., a daemon during start-up)  closes a file "
"descriptor for one of these files that was opened by a library."
msgstr ""

#. type: SS
#: man-pages/man2/getrandom.2:200
#, no-wrap
msgid "Maximum number of bytes returned"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:202
msgid "As of Linux 3.19 the following limits apply:"
msgstr ""

#. type: IP
#: man-pages/man2/getrandom.2:202 man-pages/man2/getrandom.2:210
#: man-pages/man2/getrandom.2:301
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:210
msgid ""
"When reading from the I<urandom> source, a maximum of 33554431 bytes is "
"returned by a single call to B<getrandom>()  on systems where I<int> has a "
"size of 32 bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:214
msgid ""
"When reading from the I<random> source, a maximum of 512 bytes is returned."
msgstr ""

#. type: SS
#: man-pages/man2/getrandom.2:214
#, no-wrap
msgid "Interruption by a signal handler"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:240
msgid ""
"When reading from the I<urandom> source (B<GRND_RANDOM> is not set), "
"B<getrandom>()  will block until the entropy pool has been initialized "
"(unless the B<GRND_NONBLOCK> flag was specified).  If a request is made to "
"read a large number of bytes (more than 256), B<getrandom>()  will block "
"until those bytes have been generated and transferred from kernel memory to "
"I<buf>.  When reading from the I<random> source (B<GRND_RANDOM> is set), "
"B<getrandom>()  will block until some random bytes become available (unless "
"the B<GRND_NONBLOCK> flag was specified)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:265
msgid ""
"The behavior when a call to B<getrandom>()  that is blocked while reading "
"from the I<urandom> source is interrupted by a signal handler depends on the"
" initialization state of the entropy buffer and on the request size, "
"I<buflen>.  If the entropy is not yet initialized, then the call fails with "
"the B<EINTR> error.  If the entropy pool has been initialized and the "
"request size is large (I<buflen>\\ E<gt>\\ 256), the call either succeeds, "
"returning a partially filled buffer, or fails with the error B<EINTR>.  If "
"the entropy pool has been initialized and the request size is small "
"(I<buflen>\\ E<lt>=\\ 256), then B<getrandom>()  will not fail with "
"B<EINTR>.  Instead, it will return all of the bytes that have been "
"requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:271
msgid ""
"When reading from the I<random> source, blocking requests of any size can be"
" interrupted by a signal handler (the call fails with the error B<EINTR>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:277
msgid ""
"Using B<getrandom>()  to read small buffers (E<lt>=\\ 256 bytes) from the "
"I<urandom> source is the preferred mode of usage."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:284
msgid ""
"The special treatment of small values of I<buflen> was designed for "
"compatibility with OpenBSD's B<getentropy>(3), which is nowadays supported "
"by glibc."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:298
msgid ""
"The user of B<getrandom>()  I<must> always check the return value, to "
"determine whether either an error occurred or fewer bytes than requested "
"were returned.  In the case where B<GRND_RANDOM> is not specified and "
"I<buflen> is less than or equal to 256, a return of fewer bytes than "
"requested should never happen, but the careful programmer will check for "
"this anyway!"
msgstr ""

#.  FIXME patch proposed https://lkml.org/lkml/2014/11/29/16
#. type: Plain text
#: man-pages/man2/getrandom.2:301
msgid "As of Linux 3.19, the following bug exists:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:305
msgid ""
"Depending on CPU load, B<getrandom>()  does not react to interrupts before "
"reading all bytes requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:310
msgid ""
"B<getentropy>(3), B<random>(4), B<urandom>(4), B<random>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:66
msgid ""
"B<getxattr>()  retrieves the value of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"attribute value is placed in the buffer pointed to by I<value>; I<size> "
"specifies the size of that buffer.  The return value of the call is the "
"number of bytes placed in I<value>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:72
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:82
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:91
msgid ""
"An extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data that was assigned using "
"B<setxattr>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"named extended attribute (and leave I<value> unchanged).  This can be used "
"to determine the size of the buffer that should be supplied in a subsequent "
"call.  (But, bear in mind that there is a possibility that the attribute "
"value may change between the two calls, so that it is still necessary to "
"check the return status from the second call.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:110
msgid ""
"On success, these calls return a nonnegative value which is the size (in "
"bytes) of the extended attribute value.  On failure, -1 is returned and "
"I<errno> is set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/getxattr.2:111
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:117
msgid ""
"The size of the attribute value is larger than the maximum size allowed; the"
" attribute cannot be retrieved.  This can happen on filesystems that support"
" very large attribute values such as NFSv4, for example."
msgstr ""

#. type: TP
#: man-pages/man2/getxattr.2:117
#, no-wrap
msgid "B<ENODATA>"
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/getxattr.2:126
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute."
msgstr ""

#. type: TP
#: man-pages/man2/getxattr.2:126
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:129
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""

#. type: TP
#: man-pages/man2/getxattr.2:129
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:136
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:140
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:143
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@computer.org >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#.  Please send any bug reports or comments to these addresses.
#. type: Plain text
#: man-pages/man2/getxattr.2:151
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:154
msgid "See B<listxattr>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:163
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getunwind.2:27
#, no-wrap
msgid "GETUNWIND"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:30
msgid "getunwind - copy the unwind data to caller's buffer"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:36
#, no-wrap
msgid "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:42
msgid "I<Note: this function is obsolete.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:52
msgid ""
"The IA-64-specific B<getunwind>()  system call copies the kernel's call "
"frame unwind data into the buffer pointed to by I<buf> and returns the size "
"of the unwind data; this data describes the gate page (kernel code that is "
"mapped into user space)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:64
msgid ""
"The size of the buffer I<buf> is specified in I<buf_size>.  The data is "
"copied only if I<buf_size> is greater than or equal to the size of the "
"unwind data and I<buf> is not NULL; otherwise, no data is copied, and the "
"call succeeds, returning the size that would be needed to store the unwind "
"data."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:68
msgid ""
"The first part of the unwind data contains an unwind table.  The rest "
"contains the associated unwind information, in no particular order.  The "
"unwind table contains entries of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:74
#, no-wrap
msgid ""
"u64 start;      (64-bit address of start of function)\n"
"u64 end;        (64-bit address of end of function)\n"
"u64 info;       (BUF-relative offset to unwind info)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:83
msgid ""
"An entry whose I<start> value is zero indicates the end of the table.  For "
"more information about the format, see the I<IA-64 Software Conventions and "
"Runtime Architecture> manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:90
msgid ""
"On success, B<getunwind>()  returns the size of the unwind data.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:96
msgid ""
"B<getunwind>()  fails with the error B<EFAULT> if the unwind info can't be "
"stored in the space specified by I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:98
msgid "This system call is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:101
msgid ""
"This system call is Linux-specific, and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:105
msgid ""
"This system call has been deprecated.  The modern way to obtain the kernel's"
" unwind data is via the B<vdso>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:109
msgid ""
"Glibc does not provide a wrapper for this system call; in the unlikely event"
" that you want to call it, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:110
msgid "B<getauxval>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/getsockname.2:40
#, no-wrap
msgid "GETSOCKNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:43
msgid "getsockname - get socket name"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:46
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:49
#, no-wrap
msgid ""
"B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:62
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr ""

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: man-pages/man2/getsockname.2:103
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getsockname>()  first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:114
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getrlimit.2:64
#, no-wrap
msgid "GETRLIMIT"
msgstr ""

#. type: TH
#: man-pages/man2/getrlimit.2:64
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:67
msgid "getrlimit, setrlimit, prlimit - get/set resource limits"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:73
msgid "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:75
msgid "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:78
msgid ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:80
msgid "B< struct rlimit *>I<old_limit>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:88
msgid "B<prlimit>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:97
msgid ""
"The B<getrlimit>()  and B<setrlimit>()  system calls get and set resource "
"limits.  Each resource has an associated soft and hard limit, as defined by "
"the I<rlimit> structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:104
#, no-wrap
msgid ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* Soft limit */\n"
"    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:116
msgid ""
"The soft limit is the value that the kernel enforces for the corresponding "
"resource.  The hard limit acts as a ceiling for the soft limit: an "
"unprivileged process may set only its soft limit to a value in the range "
"from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A "
"privileged process (under Linux: one with the B<CAP_SYS_RESOURCE> capability"
" in the initial user namespace)  may make arbitrary changes to either limit "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:123
msgid ""
"The value B<RLIM_INFINITY> denotes no limit on a resource (both in the "
"structure returned by B<getrlimit>()  and in the structure passed to "
"B<setrlimit>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:127
msgid "The I<resource> argument must be one of:"
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:127
#, no-wrap
msgid "B<RLIMIT_AS>"
msgstr ""

#.  since 2.0.27 / 2.1.12
#. type: Plain text
#: man-pages/man2/getrlimit.2:149
msgid ""
"This is the maximum size of the process's virtual memory (address space).  "
"The limit is specified in bytes, and is rounded down to the system page "
"size.  This limit affects calls to B<brk>(2), B<mmap>(2), and B<mremap>(2), "
"which fail with the error B<ENOMEM> upon exceeding this limit.  In addition,"
" automatic stack expansion fails (and generates a B<SIGSEGV> that kills the "
"process if no alternate stack has been made available via "
"B<sigaltstack>(2)).  Since the value is a I<long>, on machines with a 32-bit"
" I<long> either this limit is at most 2\\ GiB, or this resource is "
"unlimited."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:149
#, no-wrap
msgid "B<RLIMIT_CORE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:158
msgid ""
"This is the maximum size of a I<core> file (see B<core>(5))  in bytes that "
"the process may dump.  When 0 no core dump files are created.  When nonzero,"
" larger dumps are truncated to this size."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:158
#, no-wrap
msgid "B<RLIMIT_CPU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:179
msgid ""
"This is a limit, in seconds, on the amount of CPU time that the process can "
"consume.  When the process reaches the soft limit, it is sent a B<SIGXCPU> "
"signal.  The default action for this signal is to terminate the process.  "
"However, the signal can be caught, and the handler can return control to the"
" main program.  If the process continues to consume CPU time, it will be "
"sent B<SIGXCPU> once per second until the hard limit is reached, at which "
"time it is sent B<SIGKILL>.  (This latter point describes Linux behavior.  "
"Implementations vary in how they treat processes which continue to consume "
"CPU time after reaching the soft limit.  Portable applications that need to "
"catch this signal should perform an orderly termination upon first receipt "
"of B<SIGXCPU>.)"
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:179
#, no-wrap
msgid "B<RLIMIT_DATA>"
msgstr ""

#.  commits 84638335900f1995495838fe1bd4870c43ec1f67
#.  ("mm: rework virtual memory accounting"),
#.  f4fcd55841fc9e46daac553b39361572453c2b88
#.  (mm: enable RLIMIT_DATA by default with workaround for valgrind).
#. type: Plain text
#: man-pages/man2/getrlimit.2:197
msgid ""
"This is the maximum size of the process's data segment (initialized data, "
"uninitialized data, and heap).  The limit is specified in bytes, and is "
"rounded down to the system page size.  This limit affects calls to "
"B<brk>(2), B<sbrk>(2), and (since Linux 4.7)  B<mmap>(2), which fail with "
"the error B<ENOMEM> upon encountering the soft limit of this resource."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:197
#, no-wrap
msgid "B<RLIMIT_FSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:209
msgid ""
"This is the maximum size in bytes of files that the process may create.  "
"Attempts to extend a file beyond this limit result in delivery of a "
"B<SIGXFSZ> signal.  By default, this signal terminates a process, but a "
"process can catch this signal instead, in which case the relevant system "
"call (e.g., B<write>(2), B<truncate>(2))  fails with the error B<EFBIG>."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:209
#, no-wrap
msgid "B<RLIMIT_LOCKS> (early Linux 2.4 only)"
msgstr ""

#.  to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
#. type: Plain text
#: man-pages/man2/getrlimit.2:217
msgid ""
"This is a limit on the combined number of B<flock>(2)  locks and B<fcntl>(2)"
"  leases that this process may establish."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:217
#, no-wrap
msgid "B<RLIMIT_MEMLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:249
msgid ""
"This is the maximum number of bytes of memory that may be locked into RAM.  "
"This limit is in effect rounded down to the nearest multiple of the system "
"page size.  This limit affects B<mlock>(2), B<mlockall>(2), and the "
"B<mmap>(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9, it also affects the"
" B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the total "
"bytes in shared memory segments (see B<shmget>(2))  that may be locked by "
"the real user ID of the calling process.  The B<shmctl>(2)  B<SHM_LOCK> "
"locks are accounted for separately from the per-process memory locks "
"established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  B<MAP_LOCKED>; a"
" process can lock bytes up to this limit in each of these two categories."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:255
msgid ""
"In Linux kernels before 2.6.9, this limit controlled the amount of memory "
"that could be locked by a privileged process.  Since Linux 2.6.9, no limits "
"are placed on the amount of memory that a privileged process may lock, and "
"this limit instead governs the amount of memory that an unprivileged process"
" may lock."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:255
#, no-wrap
msgid "B<RLIMIT_MSGQUEUE> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:263
msgid ""
"This is a limit on the number of bytes that can be allocated for POSIX "
"message queues for the real user ID of the calling process.  This limit is "
"enforced for B<mq_open>(3).  Each message queue that the user creates counts"
" (until it is removed)  against this limit according to the formula:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:265
#, no-wrap
msgid "    Since Linux 3.5:\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:273
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +\n"
"                min(attr.mq_maxmsg, MQ_PRIO_MAX) *\n"
"                      sizeof(struct posix_msg_tree_node)+\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:276
#, no-wrap
msgid "    Linux 3.4 and earlier:\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:282
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:295
msgid ""
"where I<attr> is the I<mq_attr> structure specified as the fourth argument "
"to B<mq_open>(3), and the I<msg_msg> and I<posix_msg_tree_node> structures "
"are kernel-internal structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:301
msgid ""
"The \"overhead\" addend in the formula accounts for overhead bytes required "
"by the implementation and ensures that the user cannot create an unlimited "
"number of zero-length messages (such messages nevertheless each consume some"
" system memory for bookkeeping overhead)."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:301
#, no-wrap
msgid "B<RLIMIT_NICE> (since Linux 2.6.12, but see BUGS below)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:320
msgid ""
"This specifies a ceiling to which the process's nice value can be raised "
"using B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice "
"value is calculated as I<20\\ -\\ rlim_cur>.  The useful range for this "
"limit is thus from 1 (corresponding to a nice value of 19) to 40 "
"(corresponding to a nice value of -20).  This unusual choice of range was "
"necessary because negative numbers cannot be specified as resource limit "
"values, since they typically have special meanings.  For example, "
"B<RLIM_INFINITY> typically is the same as -1.  For more detail on the nice "
"value, see B<sched>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:320
#, no-wrap
msgid "B<RLIMIT_NOFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:334
msgid ""
"This specifies a value one greater than the maximum file descriptor number "
"that can be opened by this process.  Attempts (B<open>(2), B<pipe>(2), "
"B<dup>(2), etc.)  to exceed this limit yield the error B<EMFILE>.  "
"(Historically, this limit was named B<RLIMIT_OFILE> on BSD.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:346
msgid ""
"Since Linux 4.5, this limit also defines the maximum number of file "
"descriptors that an unprivileged process (one without the "
"B<CAP_SYS_RESOURCE> capability) may have \"in flight\" to other processes, "
"by being passed across UNIX domain sockets.  This limit applies to the "
"B<sendmsg>(2)  system call.  For further details, see B<unix>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:346
#, no-wrap
msgid "B<RLIMIT_NPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:356
msgid ""
"This is a limit on the number of extant process (or, more precisely on "
"Linux, threads)  for the real user ID of the calling process.  So long as "
"the current number of processes belonging to this process's real user ID is "
"greater than or equal to this limit, B<fork>(2)  fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:364
msgid ""
"The B<RLIMIT_NPROC> limit is not enforced for processes that have either the"
" B<CAP_SYS_ADMIN> or the B<CAP_SYS_RESOURCE> capability."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:364
#, no-wrap
msgid "B<RLIMIT_RSS>"
msgstr ""

#.  As at kernel 2.6.12, this limit still does nothing in 2.6 though
#.  talk of making it do something has surfaced from time to time in LKML
#.        -- MTK, Jul 05
#. type: Plain text
#: man-pages/man2/getrlimit.2:376
msgid ""
"This is a limit (in bytes) on the process's resident set (the number of "
"virtual pages resident in RAM).  This limit has effect only in Linux 2.4.x, "
"x E<lt> 30, and there affects only calls to B<madvise>(2)  specifying "
"B<MADV_WILLNEED>."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:376
#, no-wrap
msgid "B<RLIMIT_RTPRIO> (since Linux 2.6.12, but see BUGS)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:383
msgid ""
"This specifies a ceiling on the real-time priority that may be set for this "
"process using B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:386 man-pages/man2/getrlimit.2:415
msgid "For further details on real-time scheduling policies, see B<sched>(7)"
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:386
#, no-wrap
msgid "B<RLIMIT_RTTIME> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:398
msgid ""
"This is a limit (in microseconds)  on the amount of CPU time that a process "
"scheduled under a real-time scheduling policy may consume without making a "
"blocking system call.  For the purpose of this limit, each time a process "
"makes a blocking system call, the count of its consumed CPU time is reset to"
" zero.  The CPU time count is not reset if the process continues trying to "
"use the CPU but is preempted, its time slice expires, or it calls "
"B<sched_yield>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:409
msgid ""
"Upon reaching the soft limit, the process is sent a B<SIGXCPU> signal.  If "
"the process catches or ignores this signal and continues consuming CPU time,"
" then B<SIGXCPU> will be generated once each second until the hard limit is "
"reached, at which point the process is sent a B<SIGKILL> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:412
msgid ""
"The intended use of this limit is to stop a runaway real-time process from "
"locking up the system."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:415
#, no-wrap
msgid "B<RLIMIT_SIGPENDING> (since Linux 2.6.8)"
msgstr ""

#.  This replaces the /proc/sys/kernel/rtsig-max system-wide limit
#.  that was present in kernels <= 2.6.7.  MTK Dec 04
#. type: Plain text
#: man-pages/man2/getrlimit.2:429
msgid ""
"This is a limit on the number of signals that may be queued for the real "
"user ID of the calling process.  Both standard and real-time signals are "
"counted for the purpose of checking this limit.  However, the limit is "
"enforced only for B<sigqueue>(3); it is always possible to use B<kill>(2)  "
"to queue one instance of any of the signals that are not already queued to "
"the process."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:429
#, no-wrap
msgid "B<RLIMIT_STACK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:437
msgid ""
"This is the maximum size of the process stack, in bytes.  Upon reaching this"
" limit, a B<SIGSEGV> signal is generated.  To handle this signal, a process "
"must employ an alternate signal stack (B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:442
msgid ""
"Since Linux 2.6.23, this limit also determines the amount of space used for "
"the process's command-line arguments and environment variables; for details,"
" see B<execve>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/getrlimit.2:442
#, no-wrap
msgid "prlimit()"
msgstr ""

#.  commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Tue May 4 18:03:50 2010 +0200
#.      rlimits: implement prlimit64 syscall
#.  commit 6a1d5e2c85d06da35cdfd93f1a27675bfdc3ad8c
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Wed Mar 24 17:06:58 2010 +0100
#.      rlimits: add rlimit64 structure
#. type: Plain text
#: man-pages/man2/getrlimit.2:462
msgid ""
"The Linux-specific B<prlimit>()  system call combines and extends the "
"functionality of B<setrlimit>()  and B<getrlimit>().  It can be used to both"
" set and get the resource limits of an arbitrary process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:469
msgid ""
"The I<resource> argument has the same meaning as for B<setrlimit>()  and "
"B<getrlimit>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:487
msgid ""
"If the I<new_limit> argument is a not NULL, then the I<rlimit> structure to "
"which it points is used to set new values for the soft and hard limits for "
"I<resource>.  If the I<old_limit> argument is a not NULL, then a successful "
"call to B<prlimit>()  places the previous soft and hard limits for "
"I<resource> in the I<rlimit> structure pointed to by I<old_limit>."
msgstr ""

#.  FIXME . this permission check is strange
#.  Asked about this on LKML, 7 Nov 2010
#.      "Inconsistent credential checking in prlimit() syscall"
#. type: Plain text
#: man-pages/man2/getrlimit.2:507
msgid ""
"The I<pid> argument specifies the ID of the process on which the call is to "
"operate.  If I<pid> is 0, then the call applies to the calling process.  To "
"set or get the resources of a process other than itself, the caller must "
"have the B<CAP_SYS_RESOURCE> capability in the user namespace of the process"
" whose resource limits are being changed, or the real, effective, and saved "
"set user IDs of the target process must match the real user ID of the caller"
" I<and> the real, effective, and saved set group IDs of the target process "
"must match the real group ID of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:512
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:517
msgid ""
"A pointer argument points to a location outside the accessible address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:529
msgid ""
"The value specified in I<resource> is not valid; or, for B<setrlimit>()  or "
"B<prlimit>(): I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:534
msgid ""
"An unprivileged process tried to raise the hard limit; the "
"B<CAP_SYS_RESOURCE> capability is required to do this."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:542
msgid ""
"The caller tried to increase the hard B<RLIMIT_NOFILE> limit above the "
"maximum defined by I</proc/sys/fs/nr_open> (see B<proc>(5))"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:548
msgid ""
"(B<prlimit>())  The calling process did not have permission to set limits "
"for the process specified by I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:552
msgid "Could not find a process with the ID specified in I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:557
msgid ""
"The B<prlimit>()  system call is available since Linux 2.6.36.  Library "
"support is available since glibc 2.13."
msgstr ""

#. type: SH
#: man-pages/man2/getrlimit.2:557
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:560
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:564
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:564
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:564
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:569
#, no-wrap
msgid ""
"B<getrlimit>(),\n"
"B<setrlimit>(),\n"
"B<prlimit>()"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:569
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:569
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:576
msgid ""
"B<getrlimit>(), B<setrlimit>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:579
msgid "B<prlimit>(): Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:595
msgid ""
"B<RLIMIT_MEMLOCK> and B<RLIMIT_NPROC> derive from BSD and are not specified "
"in POSIX.1; they are present on the BSDs and Linux, but on few other "
"implementations.  B<RLIMIT_RSS> derives from BSD and is not specified in "
"POSIX.1; it is nevertheless present on most implementations.  "
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, and "
"B<RLIMIT_SIGPENDING> are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:601
msgid ""
"A child process created via B<fork>(2)  inherits its parent's resource "
"limits.  Resource limits are preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:604
msgid ""
"Resource limits are per-process attributes that are shared by all of the "
"threads in a process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:609
msgid ""
"Lowering the soft limit for a resource below the process's current "
"consumption of that resource will succeed (but will prevent the process from"
" further increasing its consumption of the resource)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:618
msgid ""
"One can set the resource limits of the shell using the built-in I<ulimit> "
"command (I<limit> in B<csh>(1)).  The shell's resource limits are inherited "
"by the processes that it creates to execute commands."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:623
msgid ""
"Since Linux 2.6.24, the resource limits of any process can be inspected via "
"I</proc/[pid]/limits>; see B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:632
msgid ""
"Ancient systems provided a B<vlimit>()  function with a similar purpose to "
"B<setrlimit>().  For backward compatibility, glibc also provides "
"B<vlimit>().  All new applications should be written using B<setrlimit>()."
msgstr ""

#. type: SS
#: man-pages/man2/getrlimit.2:632
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:641
msgid ""
"Since version 2.13, the glibc B<getrlimit>()  and B<setrlimit>()  wrapper "
"functions no longer invoke the corresponding system calls, but instead "
"employ B<prlimit>(), for the reasons described in BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:646
msgid ""
"The name of the glibc wrapper function is B<prlimit>(); the underlying "
"system call is B<prlimit64>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:655
msgid ""
"In older Linux kernels, the B<SIGXCPU> and B<SIGKILL> signals delivered when"
" a process encountered the soft and hard B<RLIMIT_CPU> limits were delivered"
" one (CPU) second later than they should have been.  This was fixed in "
"kernel 2.6.8."
msgstr ""

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:663
msgid ""
"In 2.6.x kernels before 2.6.17, a B<RLIMIT_CPU> limit of 0 is wrongly "
"treated as \"no limit\" (like B<RLIM_INFINITY>).  Since Linux 2.6.17, "
"setting a limit of 0 does have an effect, but is actually treated as a limit"
" of 1 second."
msgstr ""

#.  See https://lwn.net/Articles/145008/
#. type: Plain text
#: man-pages/man2/getrlimit.2:668
msgid ""
"A kernel bug means that B<RLIMIT_RTPRIO> does not work in kernel 2.6.12; the"
" problem is fixed in kernel 2.6.13."
msgstr ""

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:679
msgid ""
"In kernel 2.6.12, there was an off-by-one mismatch between the priority "
"ranges returned by B<getpriority>(2)  and B<RLIMIT_NICE>.  This had the "
"effect that the actual ceiling for the nice value was calculated as I<19\\ "
"-\\ rlim_cur>.  This was fixed in kernel 2.6.13."
msgstr ""

#.  The relevant patch, sent to LKML, seems to be
#.  http://thread.gmane.org/gmane.linux.kernel/273462
#.  From: Roland McGrath <roland <at> redhat.com>
#.  Subject: [PATCH 7/7] make RLIMIT_CPU/SIGXCPU per-process
#.  Date: 2005-01-23 23:27:46 GMT
#.  Tested Solaris 10, FreeBSD 9, OpenBSD 5.0
#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=50951
#. type: Plain text
#: man-pages/man2/getrlimit.2:706
msgid ""
"Since Linux 2.6.12, if a process reaches its soft B<RLIMIT_CPU> limit and "
"has a handler installed for B<SIGXCPU>, then, in addition to invoking the "
"signal handler, the kernel increases the soft limit by one second.  This "
"behavior repeats if the process continues to consume CPU time, until the "
"hard limit is reached, at which point the process is killed.  Other "
"implementations do not change the B<RLIMIT_CPU> soft limit in this manner, "
"and the Linux behavior is probably not standards conformant; portable "
"applications should avoid relying on this Linux-specific behavior.  The "
"Linux-specific B<RLIMIT_RTTIME> limit exhibits the same behavior when the "
"soft limit is encountered."
msgstr ""

#.  d3561f78fd379a7110e46c87964ba7aa4120235c
#. type: Plain text
#: man-pages/man2/getrlimit.2:716
msgid ""
"Kernels before 2.4.22 did not diagnose the error B<EINVAL> for "
"B<setrlimit>()  when I<rlim-E<gt>rlim_cur> was greater than "
"I<rlim-E<gt>rlim_max>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:721
msgid ""
"Linux doesn't return an error when an attempt to set B<RLIMIT_CPU> has "
"failed, for compatibility reasons."
msgstr ""

#. type: SS
#: man-pages/man2/getrlimit.2:721
#, no-wrap
msgid "Representation of \"large\" resource limit values on 32-bit platforms"
msgstr ""

#.  Linux still uses long for limits internally:
#.  c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  kernel/sys.c:do_prlimit() still uses struct rlimit which
#.  uses kernel_ulong_t for its members, i.e. 32-bit  on 32-bit kernel.
#.  https://bugzilla.kernel.org/show_bug.cgi?id=5042
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: man-pages/man2/getrlimit.2:756
msgid ""
"The glibc B<getrlimit>()  and B<setrlimit>()  wrapper functions use a 64-bit"
" I<rlim_t> data type, even on 32-bit platforms.  However, the I<rlim_t> data"
" type used in the B<getrlimit>()  and B<setrlimit>()  system calls is a "
"(32-bit)  I<unsigned long>.  Furthermore, in Linux, the kernel represents "
"resource limits on 32-bit platforms as I<unsigned long>.  However, a 32-bit "
"data type is not wide enough.  The most pertinent limit here is "
"B<RLIMIT_FSIZE>, which specifies the maximum size to which a file can grow: "
"to be useful, this limit must be represented using a type that is as wide as"
" the type used to represent file offsets\\(emthat is, as wide as a 64-bit "
"B<off_t> (assuming a program compiled with I<_FILE_OFFSET_BITS=64>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:766
msgid ""
"To work around this kernel limitation, if a program tried to set a resource "
"limit to a value larger than can be represented in a 32-bit I<unsigned "
"long>, then the glibc B<setrlimit>()  wrapper function silently converted "
"the limit value to B<RLIM_INFINITY>.  In other words, the requested resource"
" limit setting was silently ignored."
msgstr ""

#.  https://www.sourceware.org/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: man-pages/man2/getrlimit.2:779
msgid ""
"Since version 2.13, glibc works around the limitations of the B<getrlimit>()"
"  and B<setrlimit>()  system calls by implementing B<setrlimit>()  and "
"B<getrlimit>()  as wrapper functions that call B<prlimit>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:782
msgid "The program below demonstrates the use of B<prlimit>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:791
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:794
#, no-wrap
msgid ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:801
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:807
#, no-wrap
msgid ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> \"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:809
#, no-wrap
msgid "    pid = atoi(argv[1]);        /* PID of target process */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:816
#, no-wrap
msgid ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:819
#, no-wrap
msgid ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:824
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:826
#, no-wrap
msgid "    /* Retrieve and display new CPU time limit */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:831
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:854
msgid ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), "
"B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), "
"B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), "
"B<capabilities>(7), B<cgroups>(7), B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getitimer.2:13
#, no-wrap
msgid "GETITIMER"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:16
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:19
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:23
#, no-wrap
msgid ""
"B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:31
msgid ""
"These system calls provide access to interval timers, that is, timers that "
"initially expire at some point in the future, and (optionally) at regular "
"intervals after that.  When a timer expires, a signal is generated for the "
"calling process, and the timer is reset to the specified interval (if the "
"interval is nonzero)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:37
msgid ""
"Three types of timers\\(emspecified via the I<which> argument\\(emare "
"provided, each of which counts against a different clock and generates a "
"different signal on timer expiration:"
msgstr ""

#. type: TP
#: man-pages/man2/getitimer.2:37
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:43
msgid ""
"This timer counts down in real (i.e., wall clock) time.  At each expiration,"
" a B<SIGALRM> signal is generated."
msgstr ""

#. type: TP
#: man-pages/man2/getitimer.2:43
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:50
msgid ""
"This timer counts down against the user-mode CPU time consumed by the "
"process.  (The measurement includes CPU time consumed by all threads in the "
"process.)  At each expiration, a B<SIGVTALRM> signal is generated."
msgstr ""

#. type: TP
#: man-pages/man2/getitimer.2:50
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:58
msgid ""
"This timer counts down against the total (i.e., both user and system)  CPU "
"time consumed by the process.  (The measurement includes CPU time consumed "
"by all threads in the process.)  At each expiration, a B<SIGPROF> signal is "
"generated."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:63
msgid ""
"In conjunction with B<ITIMER_VIRTUAL>, this timer can be used to profile "
"user and system CPU time consumed by the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:65
msgid "A process has only one of each of the three types of timers."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:67
msgid "Timer values are defined by the following structures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:74
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* Interval for periodic timer */\n"
"    struct timeval it_value;    /* Time until next expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:79
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""

#. type: SS
#: man-pages/man2/getitimer.2:82
#, no-wrap
msgid "getitimer()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:89
msgid ""
"The function B<getitimer>()  places the current value of the timer specified"
" by I<which> in the buffer pointed to by I<curr_value>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:100
msgid ""
"The I<it_value> substructure is populated with the amount of time remaining "
"until the next expiration of the specified timer.  This value changes as the"
" timer counts down, and will be reset to I<it_interval> when the timer "
"expires.  If both fields of I<it_value> are zero, then this timer is "
"currently disarmed (inactive)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:107
msgid ""
"The I<it_interval> substructure is populated with the timer interval.  If "
"both fields of I<it_interval> are zero, then this is a single-shot timer "
"(i.e., it expires just once)."
msgstr ""

#. type: SS
#: man-pages/man2/getitimer.2:107
#, no-wrap
msgid "setitimer()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:120
msgid ""
"The function B<setitimer>()  arms or disarms the timer specified by "
"I<which>, by setting the timer to the value specified by I<new_value>.  If "
"I<old_value> is non-NULL, the buffer it points to is used to return the "
"previous value of the timer (i.e., the same information that is returned by "
"B<getitimer>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:128
msgid ""
"If either field in I<new_value.it_value> is nonzero, then the timer is armed"
" to initially expire at the specified time.  If both fields in "
"I<new_value.it_value> are zero, then the timer is disarmed."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:133
msgid ""
"The I<new_value.it_interval> field specifies the new interval for the timer;"
" if both of its subfields are zero, the timer is single-shot."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:146
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:159
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>;"
" or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:169
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:178
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  If the timer "
"expires while the process is active (always true for B<ITIMER_VIRTUAL>), the"
" signal will be delivered immediately when generated."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:184
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:194
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:196
msgid "The standards are silent on the meaning of the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:198
#, no-wrap
msgid "    setitimer(which, NULL, &old_value);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:201
msgid ""
"Many systems (Solaris, the BSDs, and perhaps others)  treat this as "
"equivalent to:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:203
#, no-wrap
msgid "    getitimer(which, &old_value);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:209
msgid ""
"In Linux, this is treated as being equivalent to a call in which the "
"I<new_value> fields are zero; that is, the timer is disabled.  I<Don't use "
"this Linux misfeature>: it is nonportable and unnecessary."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:218
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an"
" event will be lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:233
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If"
" a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux"
" 2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr ""

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: man-pages/man2/getitimer.2:240
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy"
" under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr ""

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: man-pages/man2/getitimer.2:259
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:265
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getgroups.2:32
#, no-wrap
msgid "GETGROUPS"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:35
msgid "getgroups, setgroups - get/set list of supplementary group IDs"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:41
msgid "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:43
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:45
msgid "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:56
#, no-wrap
msgid ""
"B<setgroups>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:74
msgid ""
"B<getgroups>()  returns the supplementary group IDs of the calling process "
"in I<list>.  The argument I<size> should be set to the maximum number of "
"items that can be stored in the buffer pointed to by I<list>.  If the "
"calling process is a member of more than I<size> supplementary groups, then "
"an error results.  It is unspecified whether the effective group ID of the "
"calling process is included in the returned list.  (Thus, an application "
"should also call B<getegid>(2)  and add or remove the resulting value.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:85
msgid ""
"If I<size> is zero, I<list> is not modified, but the total number of "
"supplementary group IDs for the process is returned.  This allows the caller"
" to determine the size of a dynamically allocated I<list> to be used in a "
"further call to B<getgroups>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:97
msgid ""
"B<setgroups>()  sets the supplementary group IDs for the calling process.  "
"Appropriate privileges are required (see the description of the B<EPERM> "
"error, below).  The I<size> argument specifies the number of supplementary "
"group IDs in the buffer pointed to by I<list>.  A process can drop all of "
"its supplementary groups with the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:101
#, no-wrap
msgid "setgroups(0, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:110
msgid ""
"On success, B<getgroups>()  returns the number of supplementary group IDs.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:117
msgid ""
"On success, B<setgroups>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:122
msgid "I<list> has an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:125
msgid "B<getgroups>()  can additionally fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:129
msgid ""
"I<size> is less than the number of supplementary group IDs, but is not zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:132
msgid "B<setgroups>()  can additionally fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:138
msgid ""
"I<size> is greater than B<NGROUPS_MAX> (32 before Linux 2.6.4; 65536 since "
"Linux 2.6.4)."
msgstr ""

#. type: TP
#: man-pages/man2/getgroups.2:138
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:141
msgid "Out of memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:147
msgid ""
"The calling process has insufficient privilege (the caller does not have the"
" B<CAP_SETGID> capability in the user namespace in which it resides)."
msgstr ""

#. type: TP
#: man-pages/man2/getgroups.2:147
#, no-wrap
msgid "B<EPERM> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:156
msgid ""
"The use of B<setgroups>()  is denied in this user namespace.  See the "
"description of I</proc/[pid]/setgroups> in B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:159
msgid "B<getgroups>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:165
msgid ""
"B<setgroups>(): SVr4, 4.3BSD.  Since B<setgroups>()  requires privilege, it "
"is not covered by POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:177
msgid ""
"A process can have up to B<NGROUPS_MAX> supplementary group IDs in addition "
"to the effective group ID.  The constant B<NGROUPS_MAX> is defined in "
"I<E<lt>limits.hE<gt>>.  The set of supplementary group IDs is inherited from"
" the parent process, and preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:180
msgid ""
"The maximum number of supplementary group IDs can be found at run time using"
" B<sysconf>(3):"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:185
#, no-wrap
msgid ""
"long ngroups_max;\n"
"ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:194
msgid ""
"The maximum return value of B<getgroups>()  cannot be larger than one more "
"than this value.  Since Linux 2.6.4, the maximum number of supplementary "
"group IDs is also exposed via the Linux-specific read-only file, "
"I</proc/sys/kernel/ngroups_max>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:205
msgid ""
"The original Linux B<getgroups>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<getgroups32>(), supporting 32-bit IDs."
"  The glibc B<getgroups>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:219
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgroups>())  employ a signal-based technique to ensure that when"
" one thread changes credentials, all of the other threads in the process "
"also change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:226
msgid ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<group_member>(3), "
"B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/gethostname.2:32
#, no-wrap
msgid "GETHOSTNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:35
msgid "gethostname, sethostname - get/set hostname"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:39
msgid "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:41
msgid "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:50
msgid "B<gethostname>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:53
msgid "Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:55
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:58
msgid "B<sethostname>():"
msgstr ""

#. 		commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: man-pages/man2/gethostname.2:66
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:72
msgid ""
"These system calls are used to access or to change the hostname of the "
"current processor."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:83
msgid ""
"B<sethostname>()  sets the hostname to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:95
msgid ""
"B<gethostname>()  returns the null-terminated hostname in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"hostname is too large to fit, then the name is truncated, and no error is "
"returned (but see NOTES below).  POSIX.1 says that if such truncation "
"occurs, then it is unspecified whether the returned buffer includes a "
"terminating null byte."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:105
msgid "I<name> is an invalid address."
msgstr ""

#.  Can't occur for gethostbyname() wrapper, since 'len' has an
#.  unsigned type; can occur for the underlying system call.
#. type: Plain text
#: man-pages/man2/gethostname.2:115
msgid ""
"I<len> is negative or, for B<sethostname>(), I<len> is larger than the "
"maximum allowed size."
msgstr ""

#. type: TP
#: man-pages/man2/gethostname.2:115
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:123
msgid ""
"(glibc B<gethostname>())  I<len> is smaller than the actual size.  (Before "
"version 2.1, glibc uses B<EINVAL> for this case.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:131
msgid ""
"For B<sethostname>(), the caller did not have the B<CAP_SYS_ADMIN> "
"capability in the user namespace associated with its UTS namespace (see "
"B<namespaces>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:137
msgid ""
"SVr4, 4.4BSD (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 and "
"POSIX.1-2008 specify B<gethostname>()  but not B<sethostname>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:147
msgid ""
"SUSv2 guarantees that \"Host names are limited to 255 bytes\".  POSIX.1 "
"guarantees that \"Host names (not including the terminating null byte) are "
"limited to B<HOST_NAME_MAX> bytes\".  On Linux, B<HOST_NAME_MAX> is defined "
"with the value 64, which has been the limit since Linux 1.0 (earlier kernels"
" imposed a limit of 8 bytes)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:170
msgid ""
"The GNU C library does not employ the B<gethostname>()  system call; "
"instead, it implements B<gethostname>()  as a library function that calls "
"B<uname>(2)  and copies up to I<len> bytes from the returned I<nodename> "
"field into I<name>.  Having performed the copy, the function then checks if "
"the length of the I<nodename> was greater than or equal to I<len>, and if it"
" is, then the function returns -1 with I<errno> set to B<ENAMETOOLONG>; in "
"this case, a terminating null byte is not included in the returned I<name>."
msgstr ""

#.  At least glibc 2.0 and 2.1, older versions not checked
#. type: Plain text
#: man-pages/man2/gethostname.2:183
msgid ""
"Versions of glibc before 2.2 handle the case where the length of the "
"I<nodename> was greater than or equal to I<len> differently: nothing is "
"copied into I<name> and the function returns -1 with I<errno> set to "
"B<ENAMETOOLONG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:187
msgid "B<hostname>(1), B<getdomainname>(2), B<setdomainname>(2), B<uname>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/getpagesize.2:25
#, no-wrap
msgid "GETPAGESIZE"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:28
msgid "getpagesize - get memory page size"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:32
msgid "B<int getpagesize(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:39
msgid "B<getpagesize>():"
msgstr ""

#. type: TP
#: man-pages/man2/getpagesize.2:42
#, no-wrap
msgid "Since glibc 2.19:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:46
#, no-wrap
msgid "_DEFAULT_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:49
msgid "From glibc 2.12 to 2.19:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:51
#, no-wrap
msgid "_BSD_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/getpagesize.2:56
msgid "Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#.  .SH HISTORY
#.  This call first appeared in 4.2BSD.
#. type: Plain text
#: man-pages/man2/getpagesize.2:68
msgid ""
"The function B<getpagesize>()  returns the number of bytes in a memory page,"
" where \"page\" is a fixed-length block, the unit for memory allocation and "
"file mapping performed by B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:75
msgid ""
"SVr4, 4.4BSD, SUSv2.  In SUSv2 the B<getpagesize>()  call is labeled LEGACY,"
" and in POSIX.1-2001 it has been dropped; HP-UX does not have this call."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:80
msgid ""
"Portable applications should employ I<sysconf(_SC_PAGESIZE)> instead of "
"B<getpagesize>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:85
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:92
msgid "(Most systems allow the synonym B<_SC_PAGE_SIZE> for B<_SC_PAGESIZE>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:112
msgid ""
"Whether B<getpagesize>()  is present as a Linux system call depends on the "
"architecture.  If it is, it returns the kernel symbol B<PAGE_SIZE>, whose "
"value depends on the architecture and machine model.  Generally, one uses "
"binaries that are dependent on the architecture but not on the machine "
"model, in order to have a single binary distribution per architecture.  This"
" means that a user program should not find B<PAGE_SIZE> at compile time from"
" a header file, but use an actual system call, at least for those "
"architectures (like sun4) where this dependency exists.  Here glibc 2.0 "
"fails because its B<getpagesize>()  returns a statically derived value, and "
"does not use a system call.  Things are OK in glibc 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:114
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/getrusage.2:39
#, no-wrap
msgid "GETRUSAGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:42
msgid "getrusage - get resource usage"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:48
msgid "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:54
msgid ""
"B<getrusage>()  returns resource usage measures for I<who>, which can be one"
" of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:54
#, no-wrap
msgid "B<RUSAGE_SELF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:58
msgid ""
"Return resource usage statistics for the calling process, which is the sum "
"of resources used by all threads in the process."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:58
#, no-wrap
msgid "B<RUSAGE_CHILDREN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:65
msgid ""
"Return resource usage statistics for all children of the calling process "
"that have terminated and been waited for.  These statistics will include the"
" resources used by grandchildren, and further removed descendants, if all of"
" the intervening descendants waited on their terminated children."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:65
#, no-wrap
msgid "B<RUSAGE_THREAD> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:75
msgid ""
"Return resource usage statistics for the calling thread.  The B<_GNU_SOURCE>"
" feature test macro must be defined (before including I<any> header file)  "
"in order to obtain the definition of this constant from "
"I<E<lt>sys/resource.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:79
msgid ""
"The resource usages are returned in the structure pointed to by I<usage>, "
"which has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:100
#, no-wrap
msgid ""
"struct rusage {\n"
"    struct timeval ru_utime; /* user CPU time used */\n"
"    struct timeval ru_stime; /* system CPU time used */\n"
"    long   ru_maxrss;        /* maximum resident set size */\n"
"    long   ru_ixrss;         /* integral shared memory size */\n"
"    long   ru_idrss;         /* integral unshared data size */\n"
"    long   ru_isrss;         /* integral unshared stack size */\n"
"    long   ru_minflt;        /* page reclaims (soft page faults) */\n"
"    long   ru_majflt;        /* page faults (hard page faults) */\n"
"    long   ru_nswap;         /* swaps */\n"
"    long   ru_inblock;       /* block input operations */\n"
"    long   ru_oublock;       /* block output operations */\n"
"    long   ru_msgsnd;        /* IPC messages sent */\n"
"    long   ru_msgrcv;        /* IPC messages received */\n"
"    long   ru_nsignals;      /* signals received */\n"
"    long   ru_nvcsw;         /* voluntary context switches */\n"
"    long   ru_nivcsw;        /* involuntary context switches */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:108
msgid ""
"Not all fields are completed; unmaintained fields are set to zero by the "
"kernel.  (The unmaintained fields are provided for compatibility with other "
"systems, and because they may one day be supported on Linux.)  The fields "
"are interpreted as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:108
#, no-wrap
msgid "I<ru_utime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:114
msgid ""
"This is the total amount of time spent executing in user mode, expressed in "
"a I<timeval> structure (seconds plus microseconds)."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:114
#, no-wrap
msgid "I<ru_stime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:120
msgid ""
"This is the total amount of time spent executing in kernel mode, expressed "
"in a I<timeval> structure (seconds plus microseconds)."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:120
#, no-wrap
msgid "I<ru_maxrss> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:127
msgid ""
"This is the maximum resident set size used (in kilobytes).  For "
"B<RUSAGE_CHILDREN>, this is the resident set size of the largest child, not "
"the maximum resident set size of the process tree."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:127
#, no-wrap
msgid "I<ru_ixrss> (unmaintained)"
msgstr ""

#.  On some systems, this field records the number of signals received.
#. type: Plain text
#: man-pages/man2/getrusage.2:133 man-pages/man2/getrusage.2:138
#: man-pages/man2/getrusage.2:143 man-pages/man2/getrusage.2:155
#: man-pages/man2/getrusage.2:167 man-pages/man2/getrusage.2:173
#: man-pages/man2/getrusage.2:177
msgid "This field is currently unused on Linux."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:133
#, no-wrap
msgid "I<ru_idrss> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:138
#, no-wrap
msgid "I<ru_isrss> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:143
#, no-wrap
msgid "I<ru_minflt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:148
msgid ""
"The number of page faults serviced without any I/O activity; here I/O "
"activity is avoided by ``reclaiming'' a page frame from the list of pages "
"awaiting reallocation."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:148
#, no-wrap
msgid "I<ru_majflt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:151
msgid "The number of page faults serviced that required I/O activity."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:151
#, no-wrap
msgid "I<ru_nswap> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:155
#, no-wrap
msgid "I<ru_inblock> (since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:158
msgid "The number of times the filesystem had to perform input."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:158
#, no-wrap
msgid "I<ru_oublock> (since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:161
msgid "The number of times the filesystem had to perform output."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:161
#, no-wrap
msgid "I<ru_msgsnd> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:167
#, no-wrap
msgid "I<ru_msgrcv> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:173
#, no-wrap
msgid "I<ru_nsignals> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:177
#, no-wrap
msgid "I<ru_nvcsw> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:182
msgid ""
"The number of times a context switch resulted due to a process voluntarily "
"giving up the processor before its time slice was completed (usually to "
"await availability of a resource)."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:182
#, no-wrap
msgid "I<ru_nivcsw> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:187
msgid ""
"The number of times a context switch resulted due to a higher priority "
"process becoming runnable or because the current process exceeded its time "
"slice."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:198
msgid "I<usage> points outside the accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:202
msgid "I<who> is invalid."
msgstr ""

#. type: tbl table
#: man-pages/man2/getrusage.2:212
#, no-wrap
msgid "B<getrusage>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:223
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX.1 specifies B<getrusage>(),"
" but specifies only the fields I<ru_utime> and I<ru_stime>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:226
msgid "B<RUSAGE_THREAD> is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:229
msgid "Resource usage metrics are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:237
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<struct timeval> is defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#.  See the description of getrusage() in XSH.
#.  A similar statement was also in SUSv2.
#. type: Plain text
#: man-pages/man2/getrusage.2:249
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN> then the resource usages of child processes are "
"automatically included in the value returned by B<RUSAGE_CHILDREN>, although"
" POSIX.1-2001 explicitly prohibits this.  This nonconformance is rectified "
"in Linux 2.6.9 and later."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:252
msgid ""
"The structure definition shown at the start of this page was taken from "
"4.3BSD Reno."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:261
msgid ""
"Ancient systems provided a B<vtimes>()  function with a similar purpose to "
"B<getrusage>().  For backward compatibility, glibc also provides "
"B<vtimes>().  All new applications should be written using B<getrusage>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:266
msgid "See also the description of I</proc/[pid]/stat> in B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:272
msgid ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/gettimeofday.2:40
#, no-wrap
msgid "GETTIMEOFDAY"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:43
msgid "gettimeofday, settimeofday - get / set time"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:48
#, no-wrap
msgid ""
"B<int gettimeofday(struct timeval *>I<tv>B<, struct timezone *>I<tz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:51
#, no-wrap
msgid ""
"B<int settimeofday(const struct timeval *>I<tv>B<, const struct timezone "
"*>I<tz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:63
#, no-wrap
msgid ""
"B<settimeofday>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:75
msgid ""
"The functions B<gettimeofday>()  and B<settimeofday>()  can get and set the "
"time as well as a timezone.  The I<tv> argument is a I<struct timeval> (as "
"specified in I<E<lt>sys/time.hE<gt>>):"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:82
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;     /* seconds */\n"
"    suseconds_t tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:91
msgid ""
"and gives the number of seconds and microseconds since the Epoch (see "
"B<time>(2)).  The I<tz> argument is a I<struct timezone>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:98
#, no-wrap
msgid ""
"struct timezone {\n"
"    int tz_minuteswest;     /* minutes west of Greenwich */\n"
"    int tz_dsttime;         /* type of DST correction */\n"
"};\n"
msgstr ""

#.  FIXME . The compilation warning looks to be going away in 2.17
#.  see glibc commit 4b7634a5e03b0da6f8875de9d3f74c1cf6f2a6e8
#.  The following is covered under EPERM below:
#.  .PP
#.  Only the superuser may use
#.  .BR settimeofday ().
#. type: Plain text
#: man-pages/man2/gettimeofday.2:115
msgid ""
"If either I<tv> or I<tz> is NULL, the corresponding structure is not set or "
"returned.  (However, compilation warnings will result if I<tv> is NULL.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:122
msgid ""
"The use of the I<timezone> structure is obsolete; the I<tz> argument should "
"normally be specified as NULL.  (See NOTES below.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:141
msgid ""
"Under Linux, there are some peculiar \"warp clock\" semantics associated "
"with the B<settimeofday>()  system call if on the very first call (after "
"booting)  that has a non-NULL I<tz> argument, the I<tv> argument is NULL and"
" the I<tz_minuteswest> field is nonzero.  (The I<tz_dsttime> field should be"
" zero for this case.)  In such a case it is assumed that the CMOS clock is "
"on local time, and that it has to be incremented by this amount to get UTC "
"system time.  No doubt it is a bad idea to use this feature."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:148
msgid ""
"B<gettimeofday>()  and B<settimeofday>()  return 0 for success, or -1 for "
"failure (in which case I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:156
msgid "One of I<tv> or I<tz> pointed outside the accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:161
msgid "(B<settimeofday>()): I<timezone> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:168
msgid ""
"(B<settimeofday>()): I<tv.tv_sec> is negative or I<tv.tv_usec> is outside "
"the range [0..999,999]."
msgstr ""

#. type: TP
#: man-pages/man2/gettimeofday.2:168
#, no-wrap
msgid "B<EINVAL> (since Linux 4.3)"
msgstr ""

#.  commit e1d7ba8735551ed79c7a0463a042353574b96da3
#. type: Plain text
#: man-pages/man2/gettimeofday.2:177
msgid ""
"(B<settimeofday>()): An attempt was made to set the time to a value less "
"than the current value of the B<CLOCK_MONOTONIC> clock (see "
"B<clock_gettime>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:184
msgid ""
"The calling process has insufficient privilege to call B<settimeofday>(); "
"under Linux the B<CAP_SYS_TIME> capability is required."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:195
msgid ""
"SVr4, 4.3BSD.  POSIX.1-2001 describes B<gettimeofday>()  but not "
"B<settimeofday>().  POSIX.1-2008 marks B<gettimeofday>()  as obsolete, "
"recommending the use of B<clock_gettime>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:203
msgid ""
"The time returned by B<gettimeofday>()  I<is> affected by discontinuous "
"jumps in the system time (e.g., if the system administrator manually changes"
" the system time).  If you need a monotonically increasing clock, see "
"B<clock_gettime>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:208
msgid ""
"Macros for operating on I<timeval> structures are described in "
"B<timeradd>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:214
msgid "Traditionally, the fields of I<struct timeval> were of type I<long>."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:220
msgid ""
"On some architectures, an implementation of B<gettimeofday>()  is provided "
"in the B<vdso>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/gettimeofday.2:220
#, no-wrap
msgid "The tz_dsttime field"
msgstr ""

#.  it has not
#.  been and will not be supported by libc or glibc.
#.  Each and every occurrence of this field in the kernel source
#.  (other than the declaration) is a bug.
#. type: Plain text
#: man-pages/man2/gettimeofday.2:245
msgid ""
"On a non-Linux kernel, with glibc, the I<tz_dsttime> field of I<struct "
"timezone> will be set to a nonzero value by B<gettimeofday>()  if the "
"current timezone has ever had or will have a daylight saving rule applied.  "
"In this sense it exactly mirrors the meaning of B<daylight>(3)  for the "
"current zone.  On Linux, with glibc, the setting of the I<tz_dsttime> field "
"of I<struct timezone> has never been used by B<settimeofday>()  or "
"B<gettimeofday>().  Thus, the following is purely of historical interest."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:255
msgid ""
"On old systems, the field I<tz_dsttime> contains a symbolic constant (values"
" are given below)  that indicates in which part of the year Daylight Saving "
"Time is in force.  (Note: this value is constant throughout the year: it "
"does not indicate that DST is in force, it just selects an algorithm.)  The "
"daylight saving time algorithms defined are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:269
#, no-wrap
msgid ""
"B<DST_NONE>     /* not on DST */\n"
"B<DST_USA>      /* USA style DST */\n"
"B<DST_AUST>     /* Australian style DST */\n"
"B<DST_WET>      /* Western European DST */\n"
"B<DST_MET>      /* Middle European DST */\n"
"B<DST_EET>      /* Eastern European DST */\n"
"B<DST_CAN>      /* Canada */\n"
"B<DST_GB>       /* Great Britain and Eire */\n"
"B<DST_RUM>      /* Romania */\n"
"B<DST_TUR>      /* Turkey */\n"
"B<DST_AUSTALT>  /* Australian style with shift in 1986 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:279
msgid ""
"Of course it turned out that the period in which Daylight Saving Time is in "
"force cannot be given by a simple algorithm, one per country; indeed, this "
"period is determined by unpredictable political decisions.  So this method "
"of representing timezones has been abandoned."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:290
msgid ""
"B<date>(1), B<adjtimex>(2), B<clock_gettime>(2), B<time>(2), B<ctime>(3), "
"B<ftime>(3), B<timeradd>(3), B<capabilities>(7), B<time>(7), B<vdso>(7), "
"B<hwclock>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/getresuid.2:28
#, no-wrap
msgid "GETRESUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:31
msgid "getresuid, getresgid - get real, effective and saved user/group IDs"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:33
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:37
msgid ""
"B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:39
msgid ""
"B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:50
msgid ""
"B<getresuid>()  returns the real UID, the effective UID, and the saved set-"
"user-ID of the calling process, in the arguments I<ruid>, I<euid>, and "
"I<suid>, respectively.  B<getresgid>()  performs the analogous task for the "
"process's group IDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:60
msgid ""
"One of the arguments specified an address outside the calling program's "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:62
msgid "These system calls appeared on Linux starting with kernel 2.1.44."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:67
msgid ""
"The prototypes are given by glibc since version 2.3.2, provided "
"B<_GNU_SOURCE> is defined."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:70
msgid ""
"These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:86
msgid ""
"The original Linux B<getresuid>()  and B<getresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<getresuid32>()  and B<getresgid32>(), supporting 32-bit IDs.  The glibc "
"B<getresuid>()  and B<getresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:91
msgid ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a thread"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<long get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, void *>I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:39
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling thread or of a "
"memory address, depending on the setting of I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:50
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:72
msgid ""
"If I<flags> is specified as 0, then information about the calling thread's "
"default policy (as set by B<set_mempolicy>(2))  is returned, in the buffers "
"pointed to by I<mode> and I<nodemask>.  The value returned in these "
"arguments may be used to restore the thread's policy to its state at the "
"time of the call to B<get_mempolicy>()  using B<set_mempolicy>(2).  When "
"I<flags> is 0, I<addr> must be specified as NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:94
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24),"
" the I<mode> argument is ignored and the set of nodes (memories) that the "
"thread is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  (in the absence of any I<mode flags>)  is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:108
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the"
" policy governing the memory address given in I<addr>.  This policy may be "
"different from the thread's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:129
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the"
" policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned\\ long)*8>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:146
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address"
" I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the thread had performed a read (load) access to that "
"address, and return the ID of the node where that page was allocated."
msgstr ""

#.  Note:  code returns next interleave node via 'mode' argument -Lee
#. Schermerhorn
#. type: Plain text
#: man-pages/man2/get_mempolicy.2:171
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"thread's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  will"
" return in the location pointed to by a non-NULL I<mode> argument, the node "
"ID of the next node that will be used for interleaving of internal kernel "
"pages allocated on behalf of the thread.  These allocations include pages "
"for memory-mapped files in process memory ranges mapped using the B<mmap>(2)"
"  call with the B<MAP_PRIVATE> flag for read accesses, and in memory ranges "
"mapped with the B<MAP_SHARED> flag for all accesses."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:173
msgid "Other flag values are reserved."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:176
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:183
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:191
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:235
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current thread policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> specified"
" B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or B<MPOL_F_NODE>.  (And "
"there are other B<EINVAL> cases.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:239
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version"
" 2.6.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:244
msgid "For information on library support, see B<numa>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:251
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/get_robust_list.2:30
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr ""

#. type: TH
#: man-pages/man2/get_robust_list.2:30
#, no-wrap
msgid "Linux System Calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:33
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:38
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:42
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head **>I<head_ptr>B<,>\n"
"B<                     size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:54
msgid ""
"These system calls deal with per-thread robust futex lists.  These lists are"
" managed in user space: the kernel knows only about the location of the head"
" of the list.  A thread can inform the kernel of the location of its robust "
"futex list using B<set_robust_list>().  The address of a thread's robust "
"futex list can be obtained using B<get_robust_list>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:66
msgid ""
"The purpose of the robust futex list is to ensure that if a thread "
"accidentally fails to unlock a futex before terminating or calling "
"B<execve>(2), another thread that is waiting on that futex is notified that "
"the former owner of the futex has died.  This notification consists of two "
"pieces: the B<FUTEX_OWNER_DIED> bit is set in the futex word, and the kernel"
" performs a B<futex>(2)  B<FUTEX_WAKE> operation on one of the threads "
"waiting on the futex."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:82
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:89
msgid ""
"Permission to employ B<get_robust_list>()  is governed by a ptrace access "
"mode B<PTRACE_MODE_READ_REALCREDS> check; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:101
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head"
" of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be "
"I<sizeof(*head)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:108
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero"
" when the operation is successful, an error code otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:112
msgid ""
"The B<set_robust_list>()  system call can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:117
msgid "I<len> does not equal I<sizeof(struct\\ robust_list_head)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:121
msgid ""
"The B<get_robust_list>()  system call can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:129
msgid ""
"The calling process does not have permission to see the robust futex list of"
" the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:134
msgid "No thread with the thread ID I<pid> could be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:138
msgid ""
"The head of the robust futex list can't be stored at the location I<head>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:140
msgid "These system calls were added in Linux 2.6.17."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:145
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc.  In the unlikely event that you want to call them"
" directly, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:149
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr ""

#.  commit 8141c7f3e7aee618312fa1c15109e1219de784a7
#. type: Plain text
#: man-pages/man2/get_robust_list.2:157
msgid ""
"In the initial implementation, a thread waiting on a futex was notified that"
" the owner had died only if the owner terminated.  Starting with Linux "
"2.6.28, notification was extended to include the case where the owner "
"performs an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:164
msgid ""
"The thread IDs mentioned in the main text are I<kernel> thread IDs of the "
"kind returned by B<clone>(2)  and B<gettid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:167
msgid "B<futex>(2), B<pthread_mutexattr_setrobust>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:171
msgid ""
"I<Documentation/robust-futexes.txt> and I<Documentation/robust-futex-"
"ABI.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man2/getuid.2:26
#, no-wrap
msgid "GETUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:29
msgid "getuid, geteuid - get user identity"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:35
msgid "B<uid_t getuid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:37
msgid "B<uid_t geteuid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:40
msgid "B<getuid>()  returns the real user ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:43
msgid "B<geteuid>()  returns the effective user ID of the calling process."
msgstr ""

#. type: SS
#: man-pages/man2/getuid.2:48
#, no-wrap
msgid "History"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:57
msgid ""
"In UNIX\\ V6 the B<getuid>()  call returned I<(euid E<lt>E<lt> 8) + uid>.  "
"UNIX\\ V7 introduced separate calls B<getuid>()  and B<geteuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:73
msgid ""
"The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
"only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
"B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
"B<geteuid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:89
msgid ""
"On Alpha, instead of a pair of B<getuid>()  and B<geteuid>()  system calls, "
"a single B<getxuid>()  system call is provided, which returns a pair of real"
" and effective UIDs.  The glibc B<getuid>()  and B<geteuid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:93
msgid "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getdomainname.2:29
#, no-wrap
msgid "GETDOMAINNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:32
msgid "getdomainname, setdomainname - get/set NIS domain name"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:36
msgid "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:38
msgid "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:47
msgid "B<getdomainname>(), B<setdomainname>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:60
msgid ""
"These functions are used to access or to change the NIS domain name of the "
"host system."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:71
msgid ""
"B<setdomainname>()  sets the domain name to the value given in the character"
" array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:81
msgid ""
"B<getdomainname>()  returns the null-terminated domain name in the character"
" array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"domain name requires more than I<len> bytes, B<getdomainname>()  returns the"
" first I<len> bytes (glibc) or gives an error (libc)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:89
msgid "B<setdomainname>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:93
msgid "I<name> pointed outside of user address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:97
msgid "I<len> was negative or too large."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:103
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in the user "
"namespace associated with its UTS namespace (see B<namespaces>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:106
msgid "B<getdomainname>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:117
msgid ""
"For B<getdomainname>()  under libc: I<name> is NULL or I<name> is longer "
"than I<len> bytes."
msgstr ""

#.  But they appear on most systems...
#. type: Plain text
#: man-pages/man2/getdomainname.2:120
msgid "POSIX does not specify these calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:124
msgid ""
"Since Linux 1.0, the limit on the length of a domain name, including the "
"terminating null byte, is 64 bytes.  In older kernels, it was 8 bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:134
msgid ""
"On most Linux architectures (including x86), there is no B<getdomainname>()"
"  system call; instead, glibc implements B<getdomainname>()  as a library "
"function that returns a copy of the I<domainname> field returned from a call"
" to B<uname>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:137
msgid "B<gethostname>(2), B<sethostname>(2), B<uname>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/get_kernel_syms.2:10
#, no-wrap
msgid "GET_KERNEL_SYMS"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:13
msgid "get_kernel_syms - retrieve exported kernel and module symbols"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:16
#, no-wrap
msgid "B<#include E<lt>linux/module.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:18
#, no-wrap
msgid "B<int get_kernel_syms(struct kernel_sym *>I<table>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:22
msgid ""
"I<Note>: No declaration of this system call is provided in glibc headers; "
"see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:25
msgid "B<Note>: This system call is present only in kernels before Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:32
msgid ""
"If I<table> is NULL, B<get_kernel_syms>()  returns the number of symbols "
"available for query.  Otherwise, it fills in a table of structures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:39
#, no-wrap
msgid ""
"struct kernel_sym {\n"
"    unsigned long value;\n"
"    char          name[60];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:47
msgid ""
"The symbols are interspersed with magic symbols of the form B<#>I<module-"
"name> with the kernel having an empty name.  The value associated with a "
"symbol of this form is the address at which the module is loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:51
msgid ""
"The symbols exported from each module follow their magic module tag and the "
"modules are returned in the reverse of the order in which they were loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:57
msgid ""
"On success, returns the number of symbols copied to I<table>.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:59
msgid "There is only one possible error return:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:63
msgid "B<get_kernel_syms>()  is not supported in this version of the kernel."
msgstr ""

#.  Removed in Linux 2.5.48
#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:67
msgid ""
"This system call is present on Linux only up until kernel 2.4; it was "
"removed in Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:70
msgid "B<get_kernel_syms>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:78
msgid ""
"This obsolete system call is not supported by glibc.  No declaration is "
"provided in glibc headers, but, through a quirk of history, glibc versions "
"before 2.23 did export an ABI for this system call.  Therefore, in order to "
"employ this system call, it was sufficient to manually declare the interface"
" in your code; alternatively, you could invoke the system call using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:83
msgid ""
"There is no way to indicate the size of the buffer allocated for I<table>.  "
"If symbols have been added to the kernel since the program queried for the "
"symbol table size, memory will be corrupted."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:85
msgid "The length of exported symbol names is limited to 59 characters."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:91
msgid ""
"Because of these limitations, this system call is deprecated in favor of "
"B<query_module>(2)  (which is itself nowadays deprecated in favor of other "
"interfaces described on its manual page)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:95
msgid ""
"B<create_module>(2), B<delete_module>(2), B<init_module>(2), "
"B<query_module>(2)"
msgstr ""

#. type: TH
#: man-pages/man5/group.5:26
#, no-wrap
msgid "GROUP"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:29
msgid "group - user group file"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:34
msgid ""
"The I</etc/group> file is a text file that defines the groups on the system."
"  There is one entry per line, with the following format:"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:38
#, no-wrap
msgid "group_name:password:GID:user_list\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:42
msgid "The fields are as follows:"
msgstr ""

#. type: TP
#: man-pages/man5/group.5:42
#, no-wrap
msgid "I<group_name>"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:45
msgid "the name of the group."
msgstr ""

#. type: TP
#: man-pages/man5/group.5:45
#, no-wrap
msgid "I<password>"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:49
msgid ""
"the (encrypted) group password.  If this field is empty, no password is "
"needed."
msgstr ""

#. type: TP
#: man-pages/man5/group.5:49
#, no-wrap
msgid "I<GID>"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:52
msgid "the numeric group ID."
msgstr ""

#. type: TP
#: man-pages/man5/group.5:52
#, no-wrap
msgid "I<user_list>"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:55
msgid ""
"a list of the usernames that are members of this group, separated by commas."
msgstr ""

#. type: SH
#: man-pages/man5/group.5:55
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:57
msgid "I</etc/group>"
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:63
msgid ""
"As the 4.2BSD B<initgroups>(3)  man page says: no one seems to keep "
"I</etc/group> up-to-date."
msgstr ""

#. type: Plain text
#: man-pages/man5/group.5:74
msgid ""
"B<chgrp>(1), B<gpasswd>(1), B<groups>(1), B<login>(1), B<newgrp>(1), "
"B<sg>(1), B<getgrent>(3), B<getgrnam>(3), B<gshadow>(5), B<passwd>(5), "
"B<vigr>(8)"
msgstr ""

#. type: TH
#: man-pages/man5/gai.conf.5:19
#, no-wrap
msgid "GAI.CONF"
msgstr ""

#. type: TH
#: man-pages/man5/gai.conf.5:19
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:22
msgid "gai.conf - getaddrinfo(3) configuration file"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:36
msgid ""
"A call to B<getaddrinfo>(3)  might return multiple answers.  According to "
"RFC\\ 3484 these answers must be sorted so that the answer with the highest "
"success rate is first in the list.  The RFC provides an algorithm for the "
"sorting.  The static rules are not always adequate, though.  For this "
"reason, the RFC also requires that system administrators should have the "
"possibility to dynamically change the sorting.  For the glibc "
"implementation, this can be achieved with the I</etc/gai.conf> file."
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:40
msgid ""
"Each line in the configuration file consists of a keyword and its "
"parameters.  White spaces in any place are ignored.  Lines starting with "
"\\(aq#\\(aq are comments and are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:42
msgid "The keywords currently recognized are:"
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:42
#, no-wrap
msgid "B<label> I<netmask> I<precedence>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:51
msgid ""
"The value is added to the label table used in the RFC\\ 3484 sorting.  If "
"any B<label> definition is present in the configuration file, the default "
"table is not used.  All the label definitions of the default table which are"
" to be maintained have to be duplicated.  Following the keyword, the line "
"has to contain a network mask and a precedence value."
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:51
#, no-wrap
msgid "B<precedence> I<netmask> I<precedence>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:58
msgid ""
"This keyword is similar to B<label>, but instead the value is added to the "
"precedence table as specified in RFC\\ 3484.  Once again, the presence of a "
"single B<precedence> line in the configuration file causes the default table"
" to not be used."
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:58
#, no-wrap
msgid "B<reload> E<lt>B<yes>|B<no>E<gt>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:67
msgid ""
"This keyword controls whether a process checks whether the configuration "
"file has been changed since the last time it was read.  If the value is "
"\"B<yes>\", the file is reread.  This might cause problems in multithreaded "
"applications and is generally a bad idea.  The default is \"B<no>\"."
msgstr ""

#. type: TP
#: man-pages/man5/gai.conf.5:67
#, no-wrap
msgid "B<scopev4> I<mask> I<value>"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:72
msgid ""
"Add another rule to the RFC\\ 3484 scope table for IPv4 address.  By "
"default, the scope IDs described in section 3.2 in RFC\\ 3438 are used.  "
"Changing these defaults should hardly ever be necessary."
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:74
msgid "I</etc/gai.conf>"
msgstr ""

#.  Added in 2006
#. type: Plain text
#: man-pages/man5/gai.conf.5:79
msgid "The I<gai.conf> file is supported by glibc since version 2.5."
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:82
msgid ""
"The default table according to RFC\\ 3484 would be specified with the "
"following configuration file:"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:95
#, no-wrap
msgid ""
"label  ::1/128       0\n"
"label  ::/0          1\n"
"label  2002::/16     2\n"
"label ::/96          3\n"
"label ::ffff:0:0/96  4\n"
"precedence  ::1/128       50\n"
"precedence  ::/0          40\n"
"precedence  2002::/16     30\n"
"precedence ::/96          20\n"
"precedence ::ffff:0:0/96  10\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/gai.conf.5:102
msgid "B<getaddrinfo>(3), RFC\\ 3484"
msgstr ""

#. type: TH
#: man-pages/man3/gethostbyname.3:38
#, no-wrap
msgid "GETHOSTBYNAME"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:46
msgid ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - get network host entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:50
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:52
#, no-wrap
msgid "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:56
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>       /* for AF_INET */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:58
#, no-wrap
msgid "B<void sethostent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:60
#, no-wrap
msgid "B<void endhostent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:62
#, no-wrap
msgid "B<void herror(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:64
#, no-wrap
msgid "B<const char *hstrerror(int >I<err>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:67
#, no-wrap
msgid ""
"/* System V/POSIX extension */\n"
"B<struct hostent *gethostent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:70
#, no-wrap
msgid ""
"/* GNU extensions */\n"
"B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:74
#, no-wrap
msgid ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:78
#, no-wrap
msgid ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int >I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:82
#, no-wrap
msgid ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:86
#, no-wrap
msgid ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t >I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:100
msgid ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:104 man-pages/man3/gethostbyname.3:117
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:104
#, no-wrap
msgid "Glibc versions up to and including 2.19:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:107 man-pages/man3/gethostbyname.3:120
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:113
msgid "B<herror>(), B<hstrerror>():"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:117
#, no-wrap
msgid "Glibc 2.8 to 2.19:"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:120
#, no-wrap
msgid "Before glibc 2.8:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:123 man-pages/man3/gethostbyname.3:138
msgid "none"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:128
msgid "B<h_errno>:"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:129
#, no-wrap
msgid "Since glibc 2.19"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:132
msgid "_DEFAULT_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:132
#, no-wrap
msgid "Glibc 2.12 to 2.19:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:135
msgid "_BSD_SOURCE || _SVID_SOURCE || _POSIX_C_SOURCE E<lt> 200809L"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:135
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:155
msgid ""
"The B<gethostbyname*>(), B<gethostbyaddr*>(), B<herror>(), and "
"B<hstrerror>()  functions are obsolete.  Applications should use "
"B<getaddrinfo>(3), B<getnameinfo>(3), and B<gai_strerror>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:194
msgid ""
"The B<gethostbyname>()  function returns a structure of type I<hostent> for "
"the given host I<name>.  Here I<name> is either a hostname or an IPv4 "
"address in standard dot notation (as for B<inet_addr>(3)).  If I<name> is an"
" IPv4 address, no lookup is performed and B<gethostbyname>()  simply copies "
"I<name> into the I<h_name> field and its I<struct in_addr> equivalent into "
"the I<h_addr_list[0]> field of the returned I<hostent> structure.  If "
"I<name> doesn't end in a dot and the environment variable B<HOSTALIASES> is "
"set, the alias file pointed to by B<HOSTALIASES> will first be searched for "
"I<name> (see B<hostname>(7)  for the file format).  The current domain and "
"its parents are searched unless I<name> ends in a dot."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:210
msgid ""
"The B<gethostbyaddr>()  function returns a structure of type I<hostent> for "
"the given host address I<addr> of length I<len> and address type I<type>.  "
"Valid address types are B<AF_INET> and B<AF_INET6>.  The host address "
"argument is a pointer to a struct of a type depending on the address type, "
"for example a I<struct in_addr *> (probably obtained via a call to "
"B<inet_addr>(3))  for address type B<AF_INET>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:217
msgid ""
"The B<sethostent>()  function specifies, if I<stayopen> is true (1), that a "
"connected TCP socket should be used for the name server queries and that the"
" connection should remain open during successive queries.  Otherwise, name "
"server queries will use UDP datagrams."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:222
msgid ""
"The B<endhostent>()  function ends the use of a TCP connection for name "
"server queries."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:227
msgid ""
"The (obsolete)  B<herror>()  function prints the error message associated "
"with the current value of I<h_errno> on I<stderr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:232
msgid ""
"The (obsolete)  B<hstrerror>()  function takes an error number (typically "
"I<h_errno>) and returns the corresponding message string."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:246
msgid ""
"The domain name queries carried out by B<gethostbyname>()  and "
"B<gethostbyaddr>()  rely on the Name Service Switch (B<nsswitch.conf>(5))  "
"configured sources or a local name server (B<named>(8)).  The default action"
" is to query the Name Service Switch (B<nsswitch.conf(5))> configured "
"sources, failing that, a local name server (B<named>(8))."
msgstr ""

#. type: SS
#: man-pages/man3/gethostbyname.3:246
#, no-wrap
msgid "Historical"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:250
msgid ""
"The B<nsswitch.conf>(5)  file is the modern way of controlling the order of "
"host lookups."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:256
msgid ""
"In glibc 2.4 and earlier, the I<order> keyword was used to control the order"
" of host lookups as defined in I</etc/host.conf> (B<host.conf>(5))."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:259
msgid ""
"The I<hostent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:270
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* for backward compatibility */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:274
msgid "The members of the I<hostent> structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:274
#, no-wrap
msgid "I<h_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:277
msgid "The official name of the host."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:277
#, no-wrap
msgid "I<h_aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:280
msgid ""
"An array of alternative names for the host, terminated by a null pointer."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:280
#, no-wrap
msgid "I<h_addrtype>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:287
msgid "The type of address; always B<AF_INET> or B<AF_INET6> at present."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:287
#, no-wrap
msgid "I<h_length>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:290
msgid "The length of the address in bytes."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:290
#, no-wrap
msgid "I<h_addr_list>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:294
msgid ""
"An array of pointers to network addresses for the host (in network byte "
"order), terminated by a null pointer."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:294
#, no-wrap
msgid "I<h_addr>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:297
msgid "The first address in I<h_addr_list> for backward compatibility."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:309
msgid ""
"The B<gethostbyname>()  and B<gethostbyaddr>()  functions return the "
"I<hostent> structure or a null pointer if an error occurs.  On error, the "
"I<h_errno> variable holds an error number.  When non-NULL, the return value "
"may point at static data, see the notes below."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:311
msgid "The variable I<h_errno> can have the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:311
#, no-wrap
msgid "B<HOST_NOT_FOUND>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:314
msgid "The specified host is unknown."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:314
#, no-wrap
msgid "B<NO_DATA>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:323
msgid ""
"The requested name is valid but does not have an IP address.  Another type "
"of request to the name server for this domain may return an answer.  The "
"constant B<NO_ADDRESS> is a synonym for B<NO_DATA>."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:323
#, no-wrap
msgid "B<NO_RECOVERY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:326
msgid "A nonrecoverable name server error occurred."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:326
#, no-wrap
msgid "B<TRY_AGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:330
msgid ""
"A temporary error occurred on an authoritative name server.  Try again "
"later."
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:331
#, no-wrap
msgid "I</etc/host.conf>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:334
msgid "resolver configuration file"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:334
#, no-wrap
msgid "I</etc/hosts>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:337
msgid "host database file"
msgstr ""

#. type: TP
#: man-pages/man3/gethostbyname.3:337
#, no-wrap
msgid "I</etc/nsswitch.conf>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:340
msgid "name service switch configuration"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:350
#, no-wrap
msgid "B<gethostbyname>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:352
#, no-wrap
msgid "MT-Unsafe race:hostbyname env\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:352 man-pages/man3/gethostbyname.3:359
#: man-pages/man3/gethostbyname.3:364 man-pages/man3/gethostbyname.3:366
#: man-pages/man3/gethostbyname.3:370 man-pages/man3/gethostbyname.3:375
#: man-pages/man3/gethostbyname.3:382 man-pages/man3/gethostbyname.3:389
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:354 man-pages/man3/gethostbyname.3:361
#: man-pages/man3/gethostbyname.3:372
#, no-wrap
msgid "locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:357
#, no-wrap
msgid "B<gethostbyaddr>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:359
#, no-wrap
msgid "MT-Unsafe race:hostbyaddr env\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:364
#, no-wrap
msgid "B<sethostent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:366
#, no-wrap
msgid "B<endhostent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:368
#, no-wrap
msgid "B<gethostent_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:370
#, no-wrap
msgid "MT-Unsafe race:hostent env\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:375
#, no-wrap
msgid "B<herror>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:377
#, no-wrap
msgid "B<hstrerror>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:380
#, no-wrap
msgid "B<gethostent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:382
#, no-wrap
msgid "MT-Unsafe race:hostent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:384
#, no-wrap
msgid "race:hostentbuf env locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:387
#, no-wrap
msgid "B<gethostbyname2>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:389
#, no-wrap
msgid "MT-Unsafe race:hostbyname2\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:391
#, no-wrap
msgid "env locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:396
#, no-wrap
msgid ""
"B<gethostbyaddr_r>(),\n"
"B<gethostbyname_r>(),\n"
"B<gethostbyname2_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostbyname.3:396
#, no-wrap
msgid "MT-Safe env locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:411
msgid ""
"In the above table, I<hostent> in I<race:hostent> signifies that if any of "
"the functions B<sethostent>(), B<gethostent>(), B<gethostent_r>(), or "
"B<endhostent>()  are used in parallel in different threads of a program, "
"then data races could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:435
msgid ""
"POSIX.1-2001 specifies B<gethostbyname>(), B<gethostbyaddr>(), "
"B<sethostent>(), B<endhostent>(), B<gethostent>(), and I<h_errno>; "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno> are marked "
"obsolescent in that standard.  POSIX.1-2008 removes the specifications of "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno>, recommending the use"
" of B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:445
msgid ""
"The functions B<gethostbyname>()  and B<gethostbyaddr>()  may return "
"pointers to static data, which may be overwritten by later calls.  Copying "
"the I<struct hostent> does not suffice, since it contains pointers; a deep "
"copy is required."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:469
msgid ""
"In the original BSD implementation the I<len> argument of B<gethostbyname>()"
"  was an I<int>.  The SUSv2 standard is buggy and declares the I<len> "
"argument of B<gethostbyaddr>()  to be of type I<size_t>.  (That is wrong, "
"because it has to be I<int>, and I<size_t> is not.  POSIX.1-2001 makes it "
"I<socklen_t>, which is OK.)  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:475
msgid ""
"The BSD prototype for B<gethostbyaddr>()  uses I<const char\\ *> for the "
"first argument."
msgstr ""

#. type: SS
#: man-pages/man3/gethostbyname.3:475
#, no-wrap
msgid "System V/POSIX extension"
msgstr ""

#.  e.g., Linux, FreeBSD, UnixWare, HP-UX
#.  e.g., FreeBSD, AIX
#. type: Plain text
#: man-pages/man3/gethostbyname.3:492
msgid ""
"POSIX requires the B<gethostent>()  call, which should return the next entry"
" in the host data base.  When using DNS/BIND this does not make much sense, "
"but it may be reasonable if the host data base is a file that can be read "
"line by line.  On many systems, a routine of this name reads from the file "
"I</etc/hosts>.  It may be available only when the library was built without "
"DNS support.  The glibc version will ignore ipv6 entries.  This function is "
"not reentrant, and glibc adds a reentrant version B<gethostent_r>()."
msgstr ""

#. type: SS
#: man-pages/man3/gethostbyname.3:492
#, no-wrap
msgid "GNU extensions"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:498
msgid ""
"Glibc2 also has a B<gethostbyname2>()  that works like B<gethostbyname>(), "
"but permits to specify the address family to which the address must belong."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostbyname.3:532
msgid ""
"Glibc2 also has reentrant versions B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>()  and B<gethostbyname2_r>().  The caller supplies a "
"I<hostent> structure I<ret> which will be filled in on success, and a "
"temporary work buffer I<buf> of size I<buflen>.  After the call, I<result> "
"will point to the result on success.  In case of an error or if no entry is "
"found I<result> will be NULL.  The functions return 0 on success and a "
"nonzero error number on failure.  In addition to the errors returned by the "
"nonreentrant versions of these functions, if I<buf> is too small, the "
"functions will return B<ERANGE>, and the call should be retried with a "
"larger buffer.  The global variable I<h_errno> is not modified, but the "
"address of a variable in which to store error numbers is passed in "
"I<h_errnop>."
msgstr ""

#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=482973
#. type: Plain text
#: man-pages/man3/gethostbyname.3:537
msgid ""
"B<gethostbyname>()  does not recognize components of a dotted IPv4 address "
"string that are expressed in hexadecimal."
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: man-pages/man3/gethostbyname.3:549
msgid ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/getpwnam.3:37
#, no-wrap
msgid "GETPWNAM"
msgstr ""

#. type: TH
#: man-pages/man3/getpwnam.3:37
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:40
msgid "getpwnam, getpwnam_r, getpwuid, getpwuid_r - get password file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:44
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:46
#, no-wrap
msgid "B<struct passwd *getpwnam(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:48
#, no-wrap
msgid "B<struct passwd *getpwuid(uid_t >I<uid>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:51
#, no-wrap
msgid ""
"B<int getpwnam_r(const char *>I<name>B<, struct passwd *>I<pwd>B<,>\n"
"B<               char *>I<buf>B<, size_t >I<buflen>B<, struct passwd **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:54
#, no-wrap
msgid ""
"B<int getpwuid_r(uid_t >I<uid>B<, struct passwd *>I<pwd>B<,>\n"
"B<               char *>I<buf>B<, size_t >I<buflen>B<, struct passwd **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:64
msgid "B<getpwnam_r>(), B<getpwuid_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:67
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:79
msgid ""
"The B<getpwnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the password database (e.g., the local "
"password file I</etc/passwd>, NIS, and LDAP)  that matches the username "
"I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:86
msgid ""
"The B<getpwuid>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the password database that matches the "
"user ID I<uid>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:88
msgid "The I<passwd> structure is defined in I<E<lt>pwd.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:100
#, no-wrap
msgid ""
"struct passwd {\n"
"    char   *pw_name;       /* username */\n"
"    char   *pw_passwd;     /* user password */\n"
"    uid_t   pw_uid;        /* user ID */\n"
"    gid_t   pw_gid;        /* group ID */\n"
"    char   *pw_gecos;      /* user information */\n"
"    char   *pw_dir;        /* home directory */\n"
"    char   *pw_shell;      /* shell program */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:106
msgid "See B<passwd>(5)  for more information about these fields."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:128
msgid ""
"The B<getpwnam_r>()  and B<getpwuid_r>()  functions obtain the same "
"information as B<getpwnam>()  and B<getpwuid>(), but store the retrieved "
"I<passwd> structure in the space pointed to by I<pwd>.  The string fields "
"pointed to by the members of the I<passwd> structure are stored in the "
"buffer I<buf> of size I<buflen>.  A pointer to the result (in case of "
"success) or NULL (in case no entry was found or an error occurred) is stored"
" in I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:130
msgid "The call"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:132
#, no-wrap
msgid "    sysconf(_SC_GETPW_R_SIZE_MAX)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:141
msgid ""
"returns either -1, without changing I<errno>, or an initial suggested size "
"for I<buf>.  (If this size is too small, the call fails with B<ERANGE>, in "
"which case the caller can retry with a larger buffer.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:156
msgid ""
"The B<getpwnam>()  and B<getpwuid>()  functions return a pointer to a "
"I<passwd> structure, or NULL if the matching entry is not found or an error "
"occurs.  If an error occurs, I<errno> is set appropriately.  If one wants to"
" check I<errno> after the call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:165
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getpwent>(3), B<getpwnam>(), or B<getpwuid>().  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:179
msgid ""
"On success, B<getpwnam_r>()  and B<getpwuid_r>()  return zero, and set "
"I<*result> to I<pwd>.  If no matching password record was found, these "
"functions return 0 and store NULL in I<*result>.  In case of error, an error"
" number is returned, and NULL is stored in I<*result>."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:180
#, no-wrap
msgid "B<0> or B<ENOENT> or B<ESRCH> or B<EBADF> or B<EPERM> or ... "
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:187
msgid "The given I<name> or I<uid> was not found."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:191
msgid "A signal was caught; see B<signal>(7)."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:191
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:194
msgid "I/O error."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:194
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:197
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:197
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:200
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr ""

#.  not in POSIX
#.  This structure is static, allocated 0 or 1 times. No memory leak. (libc45)
#. type: Plain text
#: man-pages/man3/getpwnam.3:207
msgid "Insufficient memory to allocate I<passwd> structure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:210
msgid "Insufficient buffer space supplied."
msgstr ""

#. type: TP
#: man-pages/man3/getpwnam.3:211
#, no-wrap
msgid "I</etc/passwd>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:214
msgid "local password database file"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwnam.3:224
#, no-wrap
msgid "B<getpwnam>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwnam.3:224
#, no-wrap
msgid "MT-Unsafe race:pwnam locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwnam.3:227
#, no-wrap
msgid "B<getpwuid>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwnam.3:227
#, no-wrap
msgid "MT-Unsafe race:pwuid locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwnam.3:230
#, no-wrap
msgid "B<getpwnam_r>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwnam.3:232
#, no-wrap
msgid "B<getpwuid_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwnam.3:232
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:239
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  The I<pw_gecos> field is not "
"specified in POSIX, but is present on most implementations."
msgstr ""

#.  more precisely:
#.  AIX 5.1 - gives ESRCH
#.  OSF1 4.0g - gives EWOULDBLOCK
#.  libc, glibc up to version 2.6, Irix 6.5 - give ENOENT
#.  glibc since version 2.7 - give 0
#.  FreeBSD 4.8, OpenBSD 3.2, NetBSD 1.6 - give EPERM
#.  SunOS 5.8 - gives EBADF
#.  Tru64 5.1b, HP-UX-11i, SunOS 5.7 - give 0
#. type: Plain text
#: man-pages/man3/getpwnam.3:260
msgid ""
"The formulation given above under \"RETURN VALUE\" is from POSIX.1-2001.  It"
" does not call \"not found\" an error, and hence does not specify what value"
" I<errno> might have in this situation.  But that makes it impossible to "
"recognize errors.  One might argue that according to POSIX I<errno> should "
"be left unchanged if an entry is not found.  Experiments on various UNIX-"
"like systems show that lots of different values occur in this situation: 0, "
"ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM, and probably others."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:278
msgid ""
"The I<pw_dir> field contains the name of the initial working directory of "
"the user.  Login programs use the value of this field to initialize the "
"B<HOME> environment variable for the login shell.  An application that wants"
" to determine its user's home directory should inspect the value of B<HOME> "
"(rather than the value I<getpwuid(getuid())-E<gt>pw_dir>)  since this allows"
" the user to modify their notion of \"the home directory\" during a login "
"session.  To determine the (initial) home directory of another user, it is "
"necessary to use I<getpwnam(\"username\")-E<gt>pw_dir> or similar."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:283
msgid ""
"The program below demonstrates the use of B<getpwnam_r>()  to find the full "
"username and user ID for the username supplied as a command-line argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:290
#, no-wrap
msgid ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:299
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct passwd pwd;\n"
"    struct passwd *result;\n"
"    char *buf;\n"
"    size_t bufsize;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:304
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s username\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:308
#, no-wrap
msgid ""
"    bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n"
"    if (bufsize == -1)          /* Value was indeterminate */\n"
"        bufsize = 16384;        /* Should be more than enough */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:314
#, no-wrap
msgid ""
"    buf = malloc(bufsize);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:325
#, no-wrap
msgid ""
"    s = getpwnam_r(argv[1], &pwd, buf, bufsize, &result);\n"
"    if (result == NULL) {\n"
"        if (s == 0)\n"
"            printf(\"Not found\\en\");\n"
"        else {\n"
"            errno = s;\n"
"            perror(\"getpwnam_r\");\n"
"        }\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:329
#, no-wrap
msgid ""
"    printf(\"Name: %s; UID: %ld\\en\", pwd.pw_gecos, (long) pwd.pw_uid);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwnam.3:339
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getgrnam>(3), B<getpw>(3), "
"B<getpwent>(3), B<getspnam>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getservent_r.3:26
#, no-wrap
msgid "GETSERVENT_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:30
msgid ""
"getservent_r, getservbyname_r, getservbyport_r - get service entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:33
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:36
#, no-wrap
msgid ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:40
#, no-wrap
msgid ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:44
#, no-wrap
msgid ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:59
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:77
msgid ""
"The B<getservent_r>(), B<getservbyname_r>(), and B<getservbyport_r>()  "
"functions are the reentrant equivalents of, respectively, B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  They differ in the way that "
"the I<servent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<servent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getservent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<servent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:108
msgid ""
"If the function call successfully obtains a service record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:111
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in errors."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:119
msgid ""
"On error, record not found (B<getservbyname_r>(), B<getservbyport_r>()), or "
"end of input (B<getservent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:124
msgid "(B<getservent_r>())  No more records in database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:131
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent_r.3:144
#, no-wrap
msgid ""
"B<getservent_r>(),\n"
"B<getservbyname_r>(),\n"
"B<getservbyport_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:151
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:165
msgid ""
"The program below uses B<getservbyport_r>()  to retrieve the service record "
"for the port and protocol named in its first command-line argument.  If a "
"third (integer) command-line argument is supplied, it is used as the initial"
" value for I<buflen>; if B<getservbyport_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:175
#, no-wrap
msgid ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:187
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:189
#, no-wrap
msgid "#define MAX_BUF 10000\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:199
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
"    char **p;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:204
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:208
#, no-wrap
msgid ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"              strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:212
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:217
#, no-wrap
msgid ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:226
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:229
#, no-wrap
msgid ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:231
#, no-wrap
msgid "            buflen++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:238
#, no-wrap
msgid ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:242
#, no-wrap
msgid ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:247
#, no-wrap
msgid ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:254
#, no-wrap
msgid ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent_r.3:260
msgid "B<getservent>(3), B<services>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/gethostid.3:29
#, no-wrap
msgid "GETHOSTID"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:32
msgid ""
"gethostid, sethostid - get or set the unique identifier of the current host"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:36
msgid "B<long gethostid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:38
msgid "B<int sethostid(long >I<hostid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:47
msgid "B<gethostid>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/gethostid.3:50
msgid "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:52
msgid "B<sethostid>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:73
msgid ""
"B<gethostid>()  and B<sethostid>()  respectively get or set a unique 32-bit "
"identifier for the current machine.  The 32-bit identifier is intended to be"
" unique among all UNIX systems in existence.  This normally resembles the "
"Internet address for the local machine, as returned by B<gethostbyname>(3), "
"and thus usually never needs to be set."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:77
msgid "The B<sethostid>()  call is restricted to the superuser."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:81
msgid ""
"B<gethostid>()  returns the 32-bit identifier for the current host as set by"
" B<sethostid>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:87
msgid ""
"On success, B<sethostid>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:90
msgid "B<sethostid>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:94
msgid ""
"The caller did not have permission to write to the file used to store the "
"host ID."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:98
msgid ""
"The calling process's effective user or group ID is not the same as its "
"corresponding real ID."
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostid.3:108
#, no-wrap
msgid "B<gethostid>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostid.3:108
#, no-wrap
msgid "MT-Safe hostid env locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostid.3:111
#, no-wrap
msgid "B<sethostid>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gethostid.3:111
#, no-wrap
msgid "MT-Unsafe const:hostid"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:120
msgid ""
"4.2BSD; these functions were dropped in 4.4BSD.  SVr4 includes "
"B<gethostid>()  but not B<sethostid>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:125
msgid ""
"POSIX.1-2001 and POSIX.1-2008 specify B<gethostid>()  but not "
"B<sethostid>()."
msgstr ""

#.  libc5 used /etc/hostid; libc4 didn't have these functions
#. type: Plain text
#: man-pages/man3/gethostid.3:134
msgid ""
"In the glibc implementation, the I<hostid> is stored in the file "
"I</etc/hostid>.  (In glibc versions before 2.2, the file I</var/adm/hostid> "
"was used.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:145
msgid ""
"In the glibc implementation, if B<gethostid>()  cannot open the file "
"containing the host ID, then it obtains the hostname using "
"B<gethostname>(2), passes that hostname to B<gethostbyname_r>(3)  in order "
"to obtain the host's IPv4 address, and returns a value obtained by bit-"
"twiddling the IPv4 address.  (This value may not be unique.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:147
msgid "It is impossible to ensure that the identifier is globally unique."
msgstr ""

#. type: Plain text
#: man-pages/man3/gethostid.3:149
msgid "B<hostid>(1), B<gethostbyname>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getgrouplist.3:29
#, no-wrap
msgid "GETGROUPLIST"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:32
msgid "getgrouplist - get list of groups to which a user belongs"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:36
msgid "B<int getgrouplist(const char *>I<user>B<, gid_t >I<group>B<,>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:38
msgid "B< gid_t *>I<groups>B<, int *>I<ngroups>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:49
#, no-wrap
msgid ""
"B<getgrouplist>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:61
msgid ""
"The B<getgrouplist>()  function scans the group database (see B<group>(5))  "
"to obtain the list of groups that I<user> belongs to.  Up to I<*ngroups> of "
"these groups are returned in the array I<groups>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:71
msgid ""
"If it was not among the groups defined for I<user> in the group database, "
"then I<group> is included in the list of groups returned by "
"B<getgrouplist>(); typically this argument is specified as the group ID from"
" the password record for I<user>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:81
msgid ""
"The I<ngroups> argument is a value-result argument: on return it always "
"contains the number of groups found for I<user>, including I<group>; this "
"value may be greater than the number of groups stored in I<groups>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:89
msgid ""
"If the number of groups of which I<user> is a member is less than or equal "
"to I<*ngroups>, then the value I<*ngroups> is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:99
msgid ""
"If the user is a member of more than I<*ngroups> groups, then "
"B<getgrouplist>()  returns -1.  In this case, the value returned in "
"I<*ngroups> can be used to resize the buffer passed to a further call "
"B<getgrouplist>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:101
msgid "This function is present since glibc 2.2.4."
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrouplist.3:111
#, no-wrap
msgid "B<getgrouplist>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:115
msgid "This function is nonstandard; it appears on most BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:124
msgid ""
"In glibc versions before 2.3.3, the implementation of this function contains"
" a buffer-overrun bug: it returns the complete list of groups for I<user> in"
" the array I<groups>, even when the number of groups exceeds I<*ngroups>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:133
msgid ""
"The program below displays the group list for the user named in its first "
"command-line argument.  The second command-line argument specifies the "
"I<ngroups> value to be supplied to B<getgrouplist>().  The following shell "
"session shows examples of the use of this program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:143
#, no-wrap
msgid ""
"$B< ./a.out cecilia 0>\n"
"getgrouplist() returned -1; ngroups = 3\n"
"$B< ./a.out cecilia 3>\n"
"ngroups = 3\n"
"16 (dialout)\n"
"33 (video)\n"
"100 (users)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:152
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>grp.hE<gt>\n"
"#include E<lt>pwd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:160
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, ngroups;\n"
"    gid_t *groups;\n"
"    struct passwd *pw;\n"
"    struct group *gr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:165
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>userE<gt> E<lt>ngroupsE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:167
#, no-wrap
msgid "    ngroups = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:173
#, no-wrap
msgid ""
"    groups = malloc(ngroups * sizeof (gid_t));\n"
"    if (groups == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:175
#, no-wrap
msgid "    /* Fetch passwd structure (contains first group ID for user) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:181
#, no-wrap
msgid ""
"    pw = getpwnam(argv[1]);\n"
"    if (pw == NULL) {\n"
"        perror(\"getpwnam\");\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:183
#, no-wrap
msgid "    /* Retrieve group list */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:189
#, no-wrap
msgid ""
"    if (getgrouplist(argv[1], pw-E<gt>pw_gid, groups, &ngroups) == -1) {\n"
"        fprintf(stderr, \"getgrouplist() returned -1; ngroups = %d\\en\",\n"
"                ngroups);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:191
#, no-wrap
msgid "    /* Display list of retrieved groups, along with group names */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:200
#, no-wrap
msgid ""
"    fprintf(stderr, \"ngroups = %d\\en\", ngroups);\n"
"    for (j = 0; j E<lt> ngroups; j++) {\n"
"        printf(\"%d\", groups[j]);\n"
"        gr = getgrgid(groups[j]);\n"
"        if (gr != NULL)\n"
"            printf(\" (%s)\", gr-E<gt>gr_name);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrouplist.3:210
msgid ""
"B<getgroups>(2), B<setgroups>(2), B<getgrent>(3), B<group_member>(3), "
"B<group>(5), B<passwd>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getw.3:25
#, no-wrap
msgid "GETW"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:28
msgid "getw, putw - input and output of words (ints)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:31
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:33
#, no-wrap
msgid "B<int getw(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:35
#, no-wrap
msgid "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:44
msgid "B<getw>(), B<putw>():"
msgstr ""

#. type: TP
#: man-pages/man3/getw.3:47
#, no-wrap
msgid "Since glibc 2.3.3:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:52
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: TP
#: man-pages/man3/getw.3:52
#, no-wrap
msgid "Before glibc 2.3.3:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:55
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:65
msgid ""
"B<getw>()  reads a word (that is, an I<int>) from I<stream>.  It's provided "
"for compatibility with SVr4.  We recommend you use B<fread>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:72
msgid ""
"B<putw>()  writes the word I<w> (that is, an I<int>) to I<stream>.  It is "
"provided for compatibility with SVr4, but we recommend you use B<fwrite>(3)"
"  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:79
msgid ""
"Normally, B<getw>()  returns the word read, and B<putw>()  returns 0.  On "
"error, they return B<EOF>."
msgstr ""

#. type: tbl table
#: man-pages/man3/getw.3:90
#, no-wrap
msgid ""
"B<getw>(),\n"
"B<putw>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:95
msgid "SVr4, SUSv2.  Not present in POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:99
msgid ""
"The value returned on error is also a legitimate data value.  B<ferror>(3)  "
"can be used to distinguish between the two cases."
msgstr ""

#. type: Plain text
#: man-pages/man3/getw.3:104
msgid "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getpwent.3:33
#, no-wrap
msgid "GETPWENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:36
msgid "getpwent, setpwent, endpwent - get password file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:42
#, no-wrap
msgid "B<struct passwd *getpwent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:44
#, no-wrap
msgid "B<void setpwent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:46
#, no-wrap
msgid "B<void endpwent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:57
msgid "B<getpwent>(), B<setpwent>(), B<endpwent>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getpwent.3:62
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:76
msgid ""
"The B<getpwent>()  function returns a pointer to a structure containing the "
"broken-out fields of a record from the password database (e.g., the local "
"password file I</etc/passwd>, NIS, and LDAP).  The first time B<getpwent>()"
"  is called, it returns the first entry; thereafter, it returns successive "
"entries."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:81
msgid ""
"The B<setpwent>()  function rewinds to the beginning of the password "
"database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:86
msgid ""
"The B<endpwent>()  function is used to close the password database after all"
" processing has been performed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:105
msgid ""
"For more information about the fields of this structure, see B<passwd>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:118
msgid ""
"The B<getpwent>()  function returns a pointer to a I<passwd> structure, or "
"NULL if there are no more entries or an error occurred.  If an error occurs,"
" I<errno> is set appropriately.  If one wants to check I<errno> after the "
"call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:127
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getpwent>(), B<getpwnam>(3), or B<getpwuid>(3).  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent.3:165
#, no-wrap
msgid "B<getpwent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent.3:167
#, no-wrap
msgid "MT-Unsafe race:pwent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent.3:169
#, no-wrap
msgid "race:pwentbuf locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent.3:172
#, no-wrap
msgid "B<setpwent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent.3:174
#, no-wrap
msgid "B<endpwent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent.3:174
#, no-wrap
msgid "MT-Unsafe race:pwent locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:188
msgid ""
"In the above table, I<pwent> in I<race:pwent> signifies that if any of the "
"functions B<setpwent>(), B<getpwent>(), or B<endpwent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent.3:200
msgid ""
"B<fgetpwent>(3), B<getpw>(3), B<getpwent_r>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getnameinfo.3:10
#, no-wrap
msgid "GETNAMEINFO"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:13
msgid ""
"getnameinfo - address-to-name translation in protocol-independent manner"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:17
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:21
#, no-wrap
msgid ""
"B<int getnameinfo(const struct sockaddr *>I<addr>B<, socklen_t >I<addrlen>B<,>\n"
"B<                char *>I<host>B<, socklen_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, socklen_t >I<servlen>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:32
#, no-wrap
msgid ""
"B<getnameinfo>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 201112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:48
msgid ""
"The B<getnameinfo>()  function is the inverse of B<getaddrinfo>(3): it "
"converts a socket address to a corresponding host and service, in a "
"protocol-independent manner.  It combines the functionality of "
"B<gethostbyaddr>(3)  and B<getservbyport>(3), but unlike those functions, "
"B<getnameinfo>()  is reentrant and allows programs to eliminate IPv4-versus-"
"IPv6 dependencies."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:71
msgid ""
"The I<addr> argument is a pointer to a generic socket address structure (of "
"type I<sockaddr_in> or I<sockaddr_in6>)  of size I<addrlen> that holds the "
"input IP address and port number.  The arguments I<host> and I<serv> are "
"pointers to caller-allocated buffers (of size I<hostlen> and I<servlen> "
"respectively) into which B<getnameinfo>()  places null-terminated strings "
"containing the host and service names respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:84
msgid ""
"The caller can specify that no hostname (or no service name)  is required by"
" providing a NULL I<host> (or I<serv>)  argument or a zero I<hostlen> (or "
"I<servlen>)  argument.  However, at least one of hostname or service name "
"must be requested."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:90
msgid ""
"The I<flags> argument modifies the behavior of B<getnameinfo>()  as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:90
#, no-wrap
msgid "B<NI_NAMEREQD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:93
msgid ""
"If set, then an error is returned if the hostname cannot be determined."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:93
#, no-wrap
msgid "B<NI_DGRAM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:99
msgid ""
"If set, then the service is datagram (UDP) based rather than stream (TCP) "
"based.  This is required for the few ports (512\\(en514)  that have "
"different services for UDP and TCP."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:99
#, no-wrap
msgid "B<NI_NOFQDN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:103
msgid ""
"If set, return only the hostname part of the fully qualified domain name for"
" local hosts."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:103
#, no-wrap
msgid "B<NI_NUMERICHOST>"
msgstr ""

#.  For example, by calling
#.  .BR inet_ntop ()
#.  instead of
#.  .BR gethostbyaddr ().
#.  POSIX.1-2003 has NI_NUMERICSCOPE, but glibc doesn't have it.
#. type: Plain text
#: man-pages/man3/getnameinfo.3:113
msgid ""
"If set, then the numeric form of the hostname is returned.  (When not set, "
"this will still happen in case the node's name cannot be determined.)"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:113
#, no-wrap
msgid "B<NI_NUMERICSERV>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:118
msgid ""
"If set, then the numeric form of the service address is returned.  (When not"
" set, this will still happen in case the service's name cannot be "
"determined.)"
msgstr ""

#. type: SS
#: man-pages/man3/getnameinfo.3:118
#, no-wrap
msgid "Extensions to getnameinfo() for Internationalized Domain Names"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:127
msgid ""
"Starting with glibc 2.3.4, B<getnameinfo>()  has been extended to "
"selectively allow hostnames to be transparently converted to and from the "
"Internationalized Domain Name (IDN) format (see RFC 3490, "
"I<Internationalizing Domain Names in Applications (IDNA)>).  Three new flags"
" are defined:"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:127
#, no-wrap
msgid "B<NI_IDN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:133
msgid ""
"If this flag is used, then the name found in the lookup process is converted"
" from IDN format to the locale's encoding if necessary.  ASCII-only names "
"are not affected by the conversion, which makes this flag usable in existing"
" programs and environments."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:133
#, no-wrap
msgid "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:140
msgid ""
"Setting these flags will enable the IDNA_ALLOW_UNASSIGNED (allow unassigned "
"Unicode code points) and IDNA_USE_STD3_ASCII_RULES (check output to make "
"sure it is a STD3 conforming hostname)  flags respectively to be used in the"
" IDNA handling."
msgstr ""

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getnameinfo(); they need to
#.  be documented.
#.      #ifdef __USE_GNU
#.      #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.      #define EAI_CANCELED    -101  /* Request canceled.  */
#.      #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.      #define EAI_ALLDONE     -103  /* All requests done.  */
#.      #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.      #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.      #endif
#. type: Plain text
#: man-pages/man3/getnameinfo.3:157
msgid ""
"On success, 0 is returned, and node and service names, if requested, are "
"filled with null-terminated strings, possibly truncated to fit the specified"
" buffer lengths.  On error, one of the following nonzero error codes is "
"returned:"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:157
#, no-wrap
msgid "B<EAI_AGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:161
msgid "The name could not be resolved at this time.  Try again later."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:161
#, no-wrap
msgid "B<EAI_BADFLAGS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:166
msgid "The I<flags> argument has an invalid value."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:166
#, no-wrap
msgid "B<EAI_FAIL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:169
msgid "A nonrecoverable error occurred."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:169
#, no-wrap
msgid "B<EAI_FAMILY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:173
msgid ""
"The address family was not recognized, or the address length was invalid for"
" the specified family."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:173
#, no-wrap
msgid "B<EAI_MEMORY>"
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:176
#, no-wrap
msgid "B<EAI_NONAME>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:182
msgid ""
"The name does not resolve for the supplied arguments.  B<NI_NAMEREQD> is set"
" and the host's name cannot be located, or neither hostname nor service name"
" were requested."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:182
#, no-wrap
msgid "B<EAI_OVERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:189
msgid "The buffer pointed to by I<host> or I<serv> was too small."
msgstr ""

#. type: TP
#: man-pages/man3/getnameinfo.3:189
#, no-wrap
msgid "B<EAI_SYSTEM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:194
msgid "A system error occurred.  The error code can be found in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:199
msgid ""
"The B<gai_strerror>(3)  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:205
msgid "I</etc/resolv.conf>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:208
msgid "B<getnameinfo>()  is provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/getnameinfo.3:218
#, no-wrap
msgid "B<getnameinfo>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:223
msgid "POSIX.1-2001, POSIX.1-2008, RFC\\ 2553."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:228
msgid ""
"In order to assist the programmer in choosing reasonable sizes for the "
"supplied buffers, I<E<lt>netdb.hE<gt>> defines the constants"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:233
#, no-wrap
msgid ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:246
msgid ""
"Since glibc 2.8, these definitions are exposed only if suitable feature test"
" macros are defined, namely: B<_GNU_SOURCE>, B<_DEFAULT_SOURCE> (since glibc"
" 2.19), or (in glibc versions up to and including 2.19)  B<_BSD_SOURCE> or "
"B<_SVID_SOURCE>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:254
msgid ""
"The former is the constant B<MAXDNAME> in recent versions of BIND's "
"I<E<lt>arpa/nameser.hE<gt>> header file.  The latter is a guess based on the"
" services listed in the current Assigned Numbers RFC."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:261
msgid ""
"Before glibc version 2.2, the I<hostlen> and I<servlen> arguments were typed"
" as I<size_t>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:266
msgid ""
"The following code tries to get the numeric hostname and service name, for a"
" given socket address.  Note that there is no hardcoded reference to a "
"particular address family."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:272
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:276
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:281
msgid ""
"The following version checks if the socket address has a reverse address "
"mapping."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:287
#, no-wrap
msgid ""
"struct sockaddr *addr;     /* input */\n"
"socklen_t addrlen;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:293
#, no-wrap
msgid ""
"if (getnameinfo(addr, addrlen, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:300
msgid ""
"An example program using B<getnameinfo>()  can be found in "
"B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:315
msgid ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), "
"B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:319
msgid ""
"R.\\& Gilligan, S.\\& Thomson, J.\\& Bound and W.\\& Stevens, I<Basic Socket"
" Interface Extensions for IPv6>, RFC\\ 2553, March 1999."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:325
msgid ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress E<.UR ftp://ftp.ietf.org"
"\\:/internet-drafts\\:/draft-ietf-ipngwg-scopedaddr-format-02.txt> E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:330
msgid ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnameinfo.3:332
msgid ""
"E<.UR "
"http://www.usenix.org\\:/publications\\:/library\\:/proceedings\\:/usenix2000\\:/freenix\\:/metzprotocol.html>"
" E<.UE .>"
msgstr ""

#. type: TH
#: man-pages/man3/getgrent.3:30
#, no-wrap
msgid "GETGRENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:33
msgid "getgrent, setgrent, endgrent - get group file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>grp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:39
#, no-wrap
msgid "B<struct group *getgrent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:41
#, no-wrap
msgid "B<void setgrent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:43
#, no-wrap
msgid "B<void endgrent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:53
msgid "B<setgrent>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:62
msgid "B<getgrent>(), B<endgrent>():"
msgstr ""

#.         || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getgrent.3:67
#, no-wrap
msgid ""
"Since glibc 2.22:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _DEFAULT_SOURCE\n"
msgstr ""

#.         || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getgrent.3:73
#, no-wrap
msgid ""
"Glibc 2.21 and earlier\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"        || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:88
msgid ""
"The B<getgrent>()  function returns a pointer to a structure containing the "
"broken-out fields of a record in the group database (e.g., the local group "
"file I</etc/group>, NIS, and LDAP).  The first time B<getgrent>()  is "
"called, it returns the first entry; thereafter, it returns successive "
"entries."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:93
msgid ""
"The B<setgrent>()  function rewinds to the beginning of the group database, "
"to allow repeated scans."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:98
msgid ""
"The B<endgrent>()  function is used to close the group database after all "
"processing has been performed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:100
msgid "The I<group> structure is defined in I<E<lt>grp.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:110
#, no-wrap
msgid ""
"struct group {\n"
"    char   *gr_name;        /* group name */\n"
"    char   *gr_passwd;      /* group password */\n"
"    gid_t   gr_gid;         /* group ID */\n"
"    char  **gr_mem;         /* NULL-terminated array of pointers\n"
"                               to names of group members */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:115
msgid ""
"For more information about the fields of this structure, see B<group>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:122
msgid ""
"The B<getgrent>()  function returns a pointer to a I<group> structure, or "
"NULL if there are no more entries or an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:129
msgid ""
"Upon error, I<errno> may be set.  If one wants to check I<errno> after the "
"call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:138
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getgrent>(), B<getgrgid>(3), or B<getgrnam>(3).  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:144
msgid ""
"The service was temporarily unavailable; try again later.  For NSS backends "
"in glibc this indicates a temporary error talking to the backend.  The error"
" may correct itself, retrying later is suggested."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:162
msgid ""
"A necessary input file cannot be found.  For NSS backends in glibc this "
"indicates the backend is not correctly configured."
msgstr ""

#.  not in POSIX
#. type: Plain text
#: man-pages/man3/getgrent.3:168
msgid "Insufficient memory to allocate I<group> structure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:175
msgid "local group database file"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrent.3:185
#, no-wrap
msgid "B<getgrent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrent.3:187
#, no-wrap
msgid "MT-Unsafe race:grent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrent.3:189
#, no-wrap
msgid "race:grentbuf locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrent.3:193
#, no-wrap
msgid ""
"B<setgrent>(),\n"
"B<endgrent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrent.3:193
#, no-wrap
msgid "MT-Unsafe race:grent locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:207
msgid ""
"In the above table, I<grent> in I<race:grent> signifies that if any of the "
"functions B<setgrent>(), B<getgrent>(), or B<endgrent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:209
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent.3:216
msgid ""
"B<fgetgrent>(3), B<getgrent_r>(3), B<getgrgid>(3), B<getgrnam>(3), "
"B<getgrouplist>(3), B<putgrent>(3), B<group>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getauxval.3:27
#, no-wrap
msgid "GETAUXVAL"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:30
msgid "getauxval - retrieve a value from the auxiliary vector"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:33
#, no-wrap
msgid "B<#include E<lt>sys/auxv.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:35
#, no-wrap
msgid "B<unsigned long getauxval(unsigned long >I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:43
msgid ""
"The B<getauxval>()  function retrieves values from the auxiliary vector, a "
"mechanism that the kernel's ELF binary loader uses to pass certain "
"information to user space when a program is executed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:51
msgid ""
"Each entry in the auxiliary vector consists of a pair of values: a type that"
" identifies what this entry represents, and a value for that type.  Given "
"the argument I<type>, B<getauxval>()  returns the corresponding value."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:58
msgid ""
"The value returned for each I<type> is given in the following list.  Not all"
" I<type> values are present on all architectures."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:58
#, no-wrap
msgid "B<AT_BASE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:61
msgid ""
"The base address of the program interpreter (usually, the dynamic linker)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:61
#, no-wrap
msgid "B<AT_BASE_PLATFORM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:66
msgid ""
"A string identifying the real platform; may differ from B<AT_PLATFORM> "
"(PowerPC only)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:66
#, no-wrap
msgid "B<AT_CLKTCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:73
msgid ""
"The frequency with which B<times>(2)  counts.  This value can also be "
"obtained via I<sysconf(_SC_CLK_TCK)>."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:73
#, no-wrap
msgid "B<AT_DCACHEBSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:76
msgid "The data cache block size."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:76
#, no-wrap
msgid "B<AT_EGID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:79
msgid "The effective group ID of the thread."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:79
#, no-wrap
msgid "B<AT_ENTRY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:82
msgid "The entry address of the executable."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:82
#, no-wrap
msgid "B<AT_EUID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:85
msgid "The effective user ID of the thread."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:85
#, no-wrap
msgid "B<AT_EXECFD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:88
msgid "File descriptor of program."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:88
#, no-wrap
msgid "B<AT_EXECFN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:91
msgid "Pathname used to execute program."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:91
#, no-wrap
msgid "B<AT_FLAGS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:94
msgid "Flags (unused)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:94
#, no-wrap
msgid "B<AT_FPUCW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:99
msgid ""
"Used FPU control word (SuperH architecture only).  This gives some "
"information about the FPU initialization performed by the kernel."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:99
#, no-wrap
msgid "B<AT_GID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:102
msgid "The real group ID of the thread."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:102
#, no-wrap
msgid "B<AT_HWCAP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:113
msgid ""
"An architecture and ABI dependent bit-mask whose settings indicate detailed "
"processor capabilities.  The contents of the bit mask are hardware dependent"
" (for example, see the kernel source file "
"I<arch/x86/include/asm/cpufeature.h> for details relating to the Intel x86 "
"architecture; the value returned is the first 32-bit word of the array "
"described there).  A human-readable version of the same information is "
"available via I</proc/cpuinfo>."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:113
#, no-wrap
msgid "B<AT_HWCAP2> (since glibc 2.18)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:116
msgid "Further machine-dependent hints about processor capabilities."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:116
#, no-wrap
msgid "B<AT_ICACHEBSIZE>"
msgstr ""

#.  .TP
#.  .BR AT_IGNORE
#.  .TP
#.  .BR AT_IGNOREPPC
#.  .TP
#.  .BR AT_NOTELF
#. type: Plain text
#: man-pages/man3/getauxval.3:125
msgid "The instruction cache block size."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:125
#, no-wrap
msgid "B<AT_PAGESZ>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:129
msgid ""
"The system page size (the same value returned by I<sysconf(_SC_PAGESIZE)>)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:129
#, no-wrap
msgid "B<AT_PHDR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:132
msgid "The address of the program headers of the executable."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:132
#, no-wrap
msgid "B<AT_PHENT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:135
msgid "The size of program header entry."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:135
#, no-wrap
msgid "B<AT_PHNUM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:138
msgid "The number of program headers."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:138
#, no-wrap
msgid "B<AT_PLATFORM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:145
msgid ""
"A pointer to a string that identifies the hardware platform that the program"
" is running on.  The dynamic linker uses this in the interpretation of "
"I<rpath> values."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:145
#, no-wrap
msgid "B<AT_RANDOM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:148
msgid "The address of sixteen bytes containing a random value."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:148
#, no-wrap
msgid "B<AT_SECURE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:165
msgid ""
"Has a nonzero value if this executable should be treated securely.  Most "
"commonly, a nonzero value indicates that the process is executing a set-"
"user-ID or set-group-ID binary (so that its real and effective UIDs or GIDs "
"differ from one another), or that it gained capabilities by executing a "
"binary file that has capabilities (see B<capabilities>(7)).  Alternatively, "
"a nonzero value may be triggered by a Linux Security Module.  When this "
"value is nonzero, the dynamic linker disables the use of certain environment"
" variables (see B<ld-linux.so>(8))  and glibc changes other aspects of its "
"behavior.  (See also B<secure_getenv>(3).)"
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:165
#, no-wrap
msgid "B<AT_SYSINFO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:169
msgid ""
"The entry point to the system call function in the vDSO.  Not present/needed"
" on all architectures (e.g., absent on x86-64)."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:169
#, no-wrap
msgid "B<AT_SYSINFO_EHDR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:174
msgid ""
"The address of a page containing the virtual Dynamic Shared Object (vDSO)  "
"that the kernel creates in order to provide fast implementations of certain "
"system calls."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:174
#, no-wrap
msgid "B<AT_UCACHEBSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:177
msgid "The unified cache block size."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:177
#, no-wrap
msgid "B<AT_UID>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:180
msgid "The real user ID of the thread."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:188
msgid ""
"On success, B<getauxval>()  returns the value corresponding to I<type>.  If "
"I<type> is not found, 0 is returned."
msgstr ""

#. type: TP
#: man-pages/man3/getauxval.3:189
#, no-wrap
msgid "B<ENOENT> (since glibc 2.19)"
msgstr ""

#.  commit b9ab448f980e296eac21ac65f53783967cc6037b
#. type: Plain text
#: man-pages/man3/getauxval.3:195
msgid ""
"No entry corresponding to I<type> could be found in the auxiliary vector."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:199
msgid "The B<getauxval>()  function was added to glibc in version 2.16."
msgstr ""

#. type: tbl table
#: man-pages/man3/getauxval.3:209
#, no-wrap
msgid "B<getauxval>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:213
msgid "This function is a nonstandard glibc extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:222
msgid ""
"The primary consumer of the information in the auxiliary vector is the "
"dynamic linker B<ld-linux.so>(8).  The auxiliary vector is a convenient and "
"efficient shortcut that allows the kernel to communicate a certain set of "
"standard information that the dynamic linker usually or always needs.  In "
"some cases, the same information could be obtained by system calls, but "
"using the auxiliary vector is cheaper."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:228
msgid ""
"The auxiliary vector resides just above the argument list and environment in"
" the process address space.  The auxiliary vector supplied to a program can "
"be viewed by setting the B<LD_SHOW_AUXV> environment variable when running a"
" program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:232
#, no-wrap
msgid "$ LD_SHOW_AUXV=1 sleep 1\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:241
msgid ""
"The auxiliary vector of any process can (subject to file permissions)  be "
"obtained via I</proc/[pid]/auxv>; see B<proc>(5)  for more information."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:250
msgid ""
"Before the addition of the B<ENOENT> error in glibc 2.19, there was no way "
"to unambiguously distinguish the case where I<type> could not be found from "
"the case where the value corresponding to I<type> was zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/getauxval.3:253
msgid "B<secure_getenv>(3), B<vdso>(7), B<ld-linux.so>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/getpass.3:24
#, no-wrap
msgid "GETPASS"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:27
msgid "getpass - get a password"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:31
msgid "B<char *getpass(const char *>I<prompt>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:38
msgid "B<getpass>():"
msgstr ""

#. type: TP
#: man-pages/man3/getpass.3:41
#, no-wrap
msgid "Since glibc 2.2.2:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:47
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: TP
#: man-pages/man3/getpass.3:48
#, no-wrap
msgid "Before glibc 2.2.2:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:62
msgid ""
"This function is obsolete.  Do not use it.  If you want to read input "
"without terminal echoing enabled, see the description of the I<ECHO> flag in"
" B<termios>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:73
msgid ""
"The B<getpass>()  function opens I</dev/tty> (the controlling terminal of "
"the process), outputs the string I<prompt>, turns off echoing, reads one "
"line (the \"password\"), restores the terminal state and closes I</dev/tty> "
"again."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:84
msgid ""
"The function B<getpass>()  returns a pointer to a static buffer containing "
"(the first B<PASS_MAX> bytes of) the password without the trailing newline, "
"terminated by a null byte (\\(aq\\e0\\(aq).  This buffer may be overwritten "
"by a following call.  On error, the terminal state is restored, I<errno> is "
"set appropriately, and NULL is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:86
msgid "The function may fail if"
msgstr ""

#. type: TP
#: man-pages/man3/getpass.3:86
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:89
msgid "The process does not have a controlling terminal."
msgstr ""

#.  .SH HISTORY
#.  A
#.  .BR getpass ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: man-pages/man3/getpass.3:95
msgid "I</dev/tty>"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpass.3:105
#, no-wrap
msgid "B<getpass>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpass.3:105
#, no-wrap
msgid "MT-Unsafe term"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:110
msgid "Present in SUSv2, but marked LEGACY.  Removed in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:140
msgid ""
"In the GNU C library implementation, if I</dev/tty> cannot be opened, the "
"prompt is written to I<stderr> and the password is read from I<stdin>.  "
"There is no limit on the length of the password.  Line editing is not "
"disabled."
msgstr ""

#.  Libc4 and libc5 have never supported
#.  .B PASS_MAX
#.  or
#.  .BR _SC_PASS_MAX .
#. type: Plain text
#: man-pages/man3/getpass.3:162
msgid ""
"According to SUSv2, the value of B<PASS_MAX> must be defined in "
"I<E<lt>limits.hE<gt>> in case it is smaller than 8, and can in any case be "
"obtained using I<sysconf(_SC_PASS_MAX)>.  However, POSIX.2 withdraws the "
"constants B<PASS_MAX> and B<_SC_PASS_MAX>, and the function B<getpass>().  "
"The glibc version accepts B<_SC_PASS_MAX> and returns B<BUFSIZ> (e.g., "
"8192)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:165
msgid ""
"The calling process should zero the password as soon as possible to avoid "
"leaving the cleartext password visible in the process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpass.3:166
msgid "B<crypt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getpwent_r.3:24
#, no-wrap
msgid "GETPWENT_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:27
msgid "getpwent_r, fgetpwent_r - get passwd file entry reentrantly"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:30
#, no-wrap
msgid "B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:33
#, no-wrap
msgid ""
"B<int getpwent_r(struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\n"
"B<               size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:36
#, no-wrap
msgid ""
"B<int fgetpwent_r(FILE *>I<stream>B<, struct passwd *>I<pwbuf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct passwd **>I<pwbufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:48
#, no-wrap
msgid ""
"B<getpwent_r>(),\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:54
#, no-wrap
msgid ""
"B<fgetpwent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:67
msgid ""
"The functions B<getpwent_r>()  and B<fgetpwent_r>()  are the reentrant "
"versions of B<getpwent>(3)  and B<fgetpwent>(3).  The former reads the next "
"passwd entry from the stream initialized by B<setpwent>(3).  The latter "
"reads the next passwd entry from I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:83
#, no-wrap
msgid ""
"struct passwd {\n"
"    char    *pw_name;      /* username */\n"
"    char    *pw_passwd;    /* user password */\n"
"    uid_t    pw_uid;       /* user ID */\n"
"    gid_t    pw_gid;       /* group ID */\n"
"    char    *pw_gecos;     /* user information */\n"
"    char    *pw_dir;       /* home directory */\n"
"    char    *pw_shell;     /* shell program */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:107
msgid ""
"The nonreentrant functions return a pointer to static storage, where this "
"static storage contains further pointers to user name, password, gecos "
"field, home directory and shell.  The reentrant functions described here "
"return all of that in caller-provided buffers.  First of all there is the "
"buffer I<pwbuf> that can hold a I<struct passwd>.  And next the buffer "
"I<buf> of size I<buflen> that can hold additional strings.  The result of "
"these functions, the I<struct passwd> read from the stream, is stored in the"
" provided buffer I<*pwbuf>, and a pointer to this I<struct passwd> is "
"returned in I<*pwbufp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:114
msgid ""
"On success, these functions return 0 and I<*pwbufp> is a pointer to the "
"I<struct passwd>.  On error, these functions return an error value and "
"I<*pwbufp> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:118
msgid "No more entries."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:122
msgid "Insufficient buffer space supplied.  Try again with larger buffer."
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent_r.3:132
#, no-wrap
msgid "B<getpwent_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getpwent_r.3:135
#, no-wrap
msgid "B<fgetpwent_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:150
msgid ""
"In the above table, I<pwent> in I<race:pwent> signifies that if any of the "
"functions B<setpwent>(), B<getpwent>(), B<endpwent>(), or B<getpwent_r>()  "
"are used in parallel in different threads of a program, then data races "
"could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:155
msgid ""
"These functions are GNU extensions, done in a style resembling the POSIX "
"version of functions like B<getpwnam_r>(3).  Other systems use the prototype"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:160
#, no-wrap
msgid ""
"struct passwd *\n"
"getpwent_r(struct passwd *pwd, char *buf, int buflen);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:164
msgid "or, better,"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:170
#, no-wrap
msgid ""
"int\n"
"getpwent_r(struct passwd *pwd, char *buf, int buflen,\n"
"           FILE **pw_fp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:177
msgid ""
"The function B<getpwent_r>()  is not really reentrant since it shares the "
"reading position in the stream with all other threads."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:183
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#define BUFLEN 4096\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:190
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct passwd pw, *pwp;\n"
"    char buf[BUFLEN];\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:202
#, no-wrap
msgid ""
"    setpwent();\n"
"    while (1) {\n"
"        i = getpwent_r(&pw, buf, BUFLEN, &pwp);\n"
"        if (i)\n"
"            break;\n"
"        printf(\"%s (%d)\\etHOME %s\\etSHELL %s\\en\", pwp-E<gt>pw_name,\n"
"               pwp-E<gt>pw_uid, pwp-E<gt>pw_dir, pwp-E<gt>pw_shell);\n"
"    }\n"
"    endpwent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpwent_r.3:219
msgid ""
"B<fgetpwent>(3), B<getpw>(3), B<getpwent>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<passwd>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getservent.3:34
#, no-wrap
msgid "GETSERVENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:38
msgid ""
"getservent, getservbyname, getservbyport, setservent, endservent - get "
"service entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:43
#, no-wrap
msgid "B<struct servent *getservent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:45
#, no-wrap
msgid ""
"B<struct servent *getservbyname(const char *>I<name>B<, const char "
"*>I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:47
#, no-wrap
msgid ""
"B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:49
#, no-wrap
msgid "B<void setservent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:51
#, no-wrap
msgid "B<void endservent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:62
msgid ""
"The B<getservent>()  function reads the next entry from the services "
"database (see B<services>(5))  and returns a I<servent> structure containing"
" the broken-out fields from the entry.  A connection is opened to the "
"database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:77
msgid ""
"The B<getservbyname>()  function returns a I<servent> structure for the "
"entry from the database that matches the service I<name> using protocol "
"I<proto>.  If I<proto> is NULL, any protocol will be matched.  A connection "
"is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:93
msgid ""
"The B<getservbyport>()  function returns a I<servent> structure for the "
"entry from the database that matches the port I<port> (given in network byte"
" order)  using protocol I<proto>.  If I<proto> is NULL, any protocol will be"
" matched.  A connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:105
msgid ""
"The B<setservent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getserv*>()  functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:109
msgid "The B<endservent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:115
msgid ""
"The I<servent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:124
#, no-wrap
msgid ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:130
msgid "The members of the I<servent> structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:130
#, no-wrap
msgid "I<s_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:133
msgid "The official name of the service."
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:133
#, no-wrap
msgid "I<s_aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:136
msgid "A NULL-terminated list of alternative names for the service."
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:136
#, no-wrap
msgid "I<s_port>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:139
msgid "The port number for the service given in network byte order."
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:139
#, no-wrap
msgid "I<s_proto>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:142
msgid "The name of the protocol to use with this service."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:153
msgid ""
"The B<getservent>(), B<getservbyname>()  and B<getservbyport>()  functions "
"return a pointer to a statically allocated I<servent> structure, or NULL if "
"an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: man-pages/man3/getservent.3:154
#, no-wrap
msgid "I</etc/services>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:157
msgid "services database file"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:167
#, no-wrap
msgid "B<getservent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:169 man-pages/man3/getservent.3:192
#, no-wrap
msgid "MT-Unsafe race:servent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:171
#, no-wrap
msgid "race:serventbuf locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:174
#, no-wrap
msgid "B<getservbyname>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:176
#, no-wrap
msgid "MT-Unsafe race:servbyname\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:181
#, no-wrap
msgid "B<getservbyport>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:183
#, no-wrap
msgid "MT-Unsafe race:servbyport\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:188
#, no-wrap
msgid "B<setservent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getservent.3:190
#, no-wrap
msgid "B<endservent>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:208
msgid ""
"In the above table, I<servent> in I<race:servent> signifies that if any of "
"the functions B<setservent>(), B<getservent>(), or B<endservent>()  are used"
" in parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getservent.3:214
msgid "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getfsent.3:27
#, no-wrap
msgid "GETFSENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:30
msgid ""
"getfsent, getfsspec, getfsfile, setfsent, endfsent - handle fstab entries"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:32
msgid "B<#include E<lt>fstab.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:34
msgid "B<void endfsent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:36
msgid "B<struct fstab *getfsent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:38
msgid "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:40
msgid "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:42
msgid "B<int setfsent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:48
msgid ""
"These functions read from the file I</etc/fstab>.  The I<struct fstab> is "
"defined by:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:60
#, no-wrap
msgid ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:68
msgid ""
"Here the field I<fs_type> contains (on a *BSD system)  one of the five "
"strings \"rw\", \"rq\", \"ro\", \"sw\", \"xx\" (read-write, read-write with "
"quota, read-only, swap, ignore)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:72
msgid ""
"The function B<setfsent>()  opens the file when required and positions it at"
" the first line."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:77
msgid ""
"The function B<getfsent>()  parses the next line from the file.  (After "
"opening it when required.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:81
msgid "The function B<endfsent>()  closes the file when required."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:90
msgid ""
"The function B<getfsspec>()  searches the file from the start and returns "
"the first entry found for which the I<fs_spec> field matches the "
"I<special_file> argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:99
msgid ""
"The function B<getfsfile>()  searches the file from the start and returns "
"the first entry found for which the I<fs_file> field matches the "
"I<mount_point> argument."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR getfsent ()
#.  function appeared in 4.0BSD; the other four functions appeared in 4.3BSD.
#. type: Plain text
#: man-pages/man3/getfsent.3:115
msgid ""
"Upon success, the functions B<getfsent>(), B<getfsfile>(), and "
"B<getfsspec>()  return a pointer to a I<struct fstab>, while B<setfsent>()  "
"returns 1.  Upon failure or end-of-file, these functions return NULL and 0, "
"respectively."
msgstr ""

#. type: tbl table
#: man-pages/man3/getfsent.3:125
#, no-wrap
msgid "B<endfsent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getfsent.3:127
#, no-wrap
msgid "B<setfsent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getfsent.3:127
#, no-wrap
msgid "MT-Unsafe race:fsent"
msgstr ""

#. type: tbl table
#: man-pages/man3/getfsent.3:130
#, no-wrap
msgid "B<getfsent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getfsent.3:132
#, no-wrap
msgid "B<getfsspec>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getfsent.3:134
#, no-wrap
msgid "B<getfsfile>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getfsent.3:134
#, no-wrap
msgid "MT-Unsafe race:fsent locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:148
msgid ""
"These functions are not in POSIX.1.  Several operating systems have them, "
"for example, *BSD, SunOS, Digital UNIX, AIX (which also has a "
"B<getfstype>()).  HP-UX has functions of the same names, that however use a "
"I<struct checklist> instead of a I<struct fstab>, and calls these functions "
"obsolete, superseded by B<getmntent>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:150
msgid "These functions are not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:160
msgid ""
"Since Linux allows mounting a block special device in several places, and "
"since several devices can have the same mount point, where the last device "
"with a given mount point is the interesting one, while B<getfsfile>()  and "
"B<getfsspec>()  only return the first occurrence, these two functions are "
"not suitable for use under Linux."
msgstr ""

#. type: Plain text
#: man-pages/man3/getfsent.3:162
msgid "B<getmntent>(3), B<fstab>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getumask.3:28
#, no-wrap
msgid "GETUMASK"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:31
msgid "getumask - get file creation mask"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:37
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:39
msgid "B<mode_t getumask(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:42
msgid ""
"This function returns the current file creation mask.  It is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:51
#, no-wrap
msgid ""
"mode_t getumask(void)\n"
"{\n"
"    mode_t mask = umask( 0 );\n"
"    umask(mask);\n"
"    return mask;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:58
msgid ""
"except that it is documented to be thread-safe (that is, shares a lock with "
"the B<umask>(2)  library call)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:60
msgid "This is a vaporware GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:66
msgid ""
"This function is documented in the glibc manual, but, as at glibc version "
"2.24, it is not implemented on Linux.  (See B<umask>(2)  for a thread-safe "
"method of discovering a process's umask.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getumask.3:67
msgid "B<umask>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/getdate.3:30
#, no-wrap
msgid "GETDATE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:33
msgid ""
"getdate, getdate_r - convert a date-plus-time string to broken-down time"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:35 man-pages/man3/getdate.3:41
msgid "B<#include E<lt>time.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:37
msgid "B<struct tm *getdate(const char *>I<string>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:39
msgid "B<extern int getdate_err;>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:43
msgid "B<int getdate_r(const char *>I<string>B<, struct tm *>I<res>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:50
msgid "B<getdate>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:57
msgid "B<getdate_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:60
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:78
msgid ""
"The function B<getdate>()  converts a string representation of a date and "
"time, contained in the buffer pointed to by I<string>, into a broken-down "
"time.  The broken-down time is stored in a I<tm> structure, and a pointer to"
" this structure is returned as the function result.  This I<tm> structure is"
" allocated in static storage, and consequently it will be overwritten by "
"further calls to B<getdate>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:90
msgid ""
"In contrast to B<strptime>(3), (which has a I<format> argument), "
"B<getdate>()  uses the formats found in the file whose full pathname is "
"given in the environment variable B<DATEMSK>.  The first line in the file "
"that matches the given input string is used for the conversion."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:94
msgid ""
"The matching is done case insensitively.  Superfluous whitespace, either in "
"the pattern or in the string to be converted, is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:98
msgid ""
"The conversion specifications that a pattern can contain are those given for"
" B<strptime>(3).  One more conversion specification is specified in "
"POSIX.1-2001:"
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:98
#, no-wrap
msgid "B<%Z>"
msgstr ""

#.  FIXME Is it (still) true that %Z is not supported in glibc?
#.  Looking at the glibc 2.21 source code, where the implementation uses
#.  strptime(), suggests that it might be supported.
#. type: Plain text
#: man-pages/man3/getdate.3:105
msgid "Timezone name.  This is not implemented in glibc."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:114
msgid ""
"When B<%Z> is given, the structure containing the broken-down time is "
"initialized with values corresponding to the current time in the given "
"timezone.  Otherwise, the structure is initialized to the broken-down time "
"corresponding to the current local time (as by a call to B<localtime>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:118
msgid ""
"When only the day of the week is given, the day is taken to be the first "
"such day on or after today."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:122
msgid ""
"When only the month is given (and no year), the month is taken to be the "
"first such month equal to or after the current month.  If no day is given, "
"it is the first day of the month."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:125
msgid ""
"When no hour, minute and second are given, the current hour, minute and "
"second are taken."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:128
msgid ""
"If no date is given, but we know the hour, then that hour is taken to be the"
" first such hour equal to or after the current hour."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:138
msgid ""
"B<getdate_r>()  is a GNU extension that provides a reentrant version of "
"B<getdate>().  Rather than using a global variable to report errors and a "
"static buffer to return the broken down time, it returns errors via the "
"function result value, and returns the resulting broken-down time in the "
"caller-allocated buffer pointed to by the argument I<res>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:149
msgid ""
"When successful, B<getdate>()  returns a pointer to a I<struct tm>.  "
"Otherwise, it returns NULL and sets the global variable I<getdate_err> to "
"one of the error numbers shown below.  Changes to I<errno> are unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:154
msgid ""
"On success B<getdate_r>()  returns 0; on error it returns one of the error "
"numbers shown below."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:161
msgid ""
"The following errors are returned via I<getdate_err> (for B<getdate>())  or "
"as the function result (for B<getdate_r>()):"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:166
msgid ""
"The B<DATEMSK> environment variable is not defined, or its value is an empty"
" string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:171
msgid ""
"The template file specified by B<DATEMSK> cannot be opened for reading."
msgstr ""

#.  stat()
#. type: Plain text
#: man-pages/man3/getdate.3:175
msgid "Failed to get file status information."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:175
#, no-wrap
msgid "B<4>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:178
msgid "The template file is not a regular file."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:178
#, no-wrap
msgid "B<5>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:181
msgid "An error was encountered while reading the template file."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:181
#, no-wrap
msgid "B<6>"
msgstr ""

#.  Error 6 doesn't seem to occur in glibc
#. type: Plain text
#: man-pages/man3/getdate.3:185
msgid "Memory allocation failed (not enough memory available)."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:185
#, no-wrap
msgid "B<7>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:188
msgid "There is no line in the file that matches the input."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:188
#, no-wrap
msgid "B<8>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:191
msgid "Invalid input specification."
msgstr ""

#. type: SH
#: man-pages/man3/getdate.3:191
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:192
#, no-wrap
msgid "B<DATEMSK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:195
msgid "File containing format patterns."
msgstr ""

#. type: TP
#: man-pages/man3/getdate.3:195
#, no-wrap
msgid "B<TZ>, B<LC_TIME>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:199
msgid "Variables used by B<strptime>(3)."
msgstr ""

#. type: tbl table
#: man-pages/man3/getdate.3:209
#, no-wrap
msgid "B<getdate>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getdate.3:209
#, no-wrap
msgid "MT-Unsafe race:getdate env locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getdate.3:212
#, no-wrap
msgid "B<getdate_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:216
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:230
msgid ""
"The POSIX.1 specification for B<strptime>(3)  contains conversion "
"specifications using the B<%E> or B<%O> modifier, while such specifications "
"are not given for B<getdate>().  In glibc, B<getdate>()  is implemented "
"using B<strptime>(3), so that precisely the same conversions are supported "
"by both."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:238
msgid ""
"The program below calls B<getdate>()  for each of its command-line "
"arguments, and for each call displays the values in the fields of the "
"returned I<tm> structure.  The following shell session demonstrates the "
"operation of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:279
#, no-wrap
msgid ""
"$B< TFILE=$PWD/tfile>\n"
"$B< echo \\(aq%A\\(aq E<gt> $TFILE >      # Full name of the day of the week\n"
"$B< echo \\(aq%T\\(aq E<gt>E<gt> $TFILE>      # ISO date (YYYY-MM-DD)\n"
"$B< echo \\(aq%F\\(aq E<gt>E<gt> $TFILE>      # Time (HH:MM:SS)\n"
"$B< date>\n"
"$B< export DATEMSK=$TFILE>\n"
"$B< ./a.out Tuesday \\(aq2009-12-28\\(aq \\(aq12:22:33\\(aq>\n"
"Sun Sep  7 06:03:36 CEST 2008\n"
"Call 1 (\"Tuesday\") succeeded:\n"
"    tm_sec   = 36\n"
"    tm_min   = 3\n"
"    tm_hour  = 6\n"
"    tm_mday  = 9\n"
"    tm_mon   = 8\n"
"    tm_year  = 108\n"
"    tm_wday  = 2\n"
"    tm_yday  = 252\n"
"    tm_isdst = 1\n"
"Call 2 (\"2009-12-28\") succeeded:\n"
"    tm_sec   = 36\n"
"    tm_min   = 3\n"
"    tm_hour  = 6\n"
"    tm_mday  = 28\n"
"    tm_mon   = 11\n"
"    tm_year  = 109\n"
"    tm_wday  = 1\n"
"    tm_yday  = 361\n"
"    tm_isdst = 0\n"
"Call 3 (\"12:22:33\") succeeded:\n"
"    tm_sec   = 33\n"
"    tm_min   = 22\n"
"    tm_hour  = 12\n"
"    tm_mday  = 7\n"
"    tm_mon   = 8\n"
"    tm_year  = 108\n"
"    tm_wday  = 0\n"
"    tm_yday  = 250\n"
"    tm_isdst = 1\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:288
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:294
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct tm *tmp;\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:297
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++) {\n"
"        tmp = getdate(argv[j]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:303
#, no-wrap
msgid ""
"        if (tmp == NULL) {\n"
"            printf(\"Call %d failed; getdate_err = %d\\en\",\n"
"                   j, getdate_err);\n"
"            continue;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:315
#, no-wrap
msgid ""
"        printf(\"Call %d (\\e\"%s\\e\") succeeded:\\en\", j, argv[j]);\n"
"        printf(\"    tm_sec   = %d\\en\", tmp-E<gt>tm_sec);\n"
"        printf(\"    tm_min   = %d\\en\", tmp-E<gt>tm_min);\n"
"        printf(\"    tm_hour  = %d\\en\", tmp-E<gt>tm_hour);\n"
"        printf(\"    tm_mday  = %d\\en\", tmp-E<gt>tm_mday);\n"
"        printf(\"    tm_mon   = %d\\en\", tmp-E<gt>tm_mon);\n"
"        printf(\"    tm_year  = %d\\en\", tmp-E<gt>tm_year);\n"
"        printf(\"    tm_wday  = %d\\en\", tmp-E<gt>tm_wday);\n"
"        printf(\"    tm_yday  = %d\\en\", tmp-E<gt>tm_yday);\n"
"        printf(\"    tm_isdst = %d\\en\", tmp-E<gt>tm_isdst);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdate.3:324
msgid ""
"B<time>(2), B<localtime>(3), B<setlocale>(3), B<strftime>(3), B<strptime>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getopt.3:41
#, no-wrap
msgid "GETOPT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:45
msgid ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - "
"Parse command-line options"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:48
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:51
#, no-wrap
msgid ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:54
#, no-wrap
msgid ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:56
#, no-wrap
msgid "B<#include E<lt>getopt.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:60
#, no-wrap
msgid ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:64
#, no-wrap
msgid ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:74
msgid "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:78
msgid "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:99
msgid ""
"The B<getopt>()  function parses the command-line arguments.  Its arguments "
"I<argc> and I<argv> are the argument count and array as passed to the "
"I<main>()  function on program invocation.  An element of I<argv> that "
"starts with \\(aq-\\(aq (and is not exactly \"-\" or \"--\")  is an option "
"element.  The characters of this element (aside from the initial "
"\\(aq-\\(aq) are option characters.  If B<getopt>()  is called repeatedly, "
"it returns successively each of the option characters from each of the "
"option elements."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:108
msgid ""
"The variable I<optind> is the index of the next element to be processed in "
"I<argv>.  The system initializes this value to 1.  The caller can reset it "
"to 1 to restart scanning of the same I<argv>, or when scanning a new "
"argument vector."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:118
msgid ""
"If B<getopt>()  finds another option character, it returns that character, "
"updating the external variable I<optind> and a static variable I<nextchar> "
"so that the next call to B<getopt>()  can resume the scan with the following"
" option character or I<argv>-element."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:124
msgid ""
"If there are no more option characters, B<getopt>()  returns -1.  Then "
"I<optind> is the index in I<argv> of the first I<argv>-element that is not "
"an option."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:151
msgid ""
"I<optstring> is a string containing the legitimate option characters.  If "
"such a character is followed by a colon, the option requires an argument, so"
" B<getopt>()  places a pointer to the following text in the same "
"I<argv>-element, or the text of the following I<argv>-element, in I<optarg>."
"  Two colons mean an option takes an optional arg; if there is text in the "
"current I<argv>-element (i.e., in the same word as the option name itself, "
"for example, \"-oarg\"), then it is returned in I<optarg>, otherwise "
"I<optarg> is set to zero.  This is a GNU extension.  If I<optstring> "
"contains B<W> followed by a semicolon, then B<-W foo> is treated as the long"
" option B<--foo>.  (The B<-W> option is reserved by POSIX.2 for "
"implementation extensions.)  This behavior is a GNU extension, not available"
" with libraries before glibc 2."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:169
msgid ""
"By default, B<getopt>()  permutes the contents of I<argv> as it scans, so "
"that eventually all the nonoptions are at the end.  Two other modes are also"
" implemented.  If the first character of I<optstring> is \\(aq+\\(aq or the "
"environment variable B<POSIXLY_CORRECT> is set, then option processing stops"
" as soon as a nonoption argument is encountered.  If the first character of "
"I<optstring> is \\(aq-\\(aq, then each nonoption I<argv>-element is handled "
"as if it were the argument of an option with character code 1.  (This is "
"used by programs that were written to expect options and other "
"I<argv>-elements in any order and that care about the ordering of the two.)"
"  The special argument \"--\" forces an end of option-scanning regardless of"
" the scanning mode."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:178
msgid ""
"While processing the option list, B<getopt>()  can detect two kinds of "
"errors: (1) an option character that was not specified in I<optstring> and "
"(2) a missing option argument (i.e., an option at the end of the command "
"line without an expected argument).  Such errors are handled and reported as"
" follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:185
msgid ""
"By default, B<getopt>()  prints an error message on standard error, places "
"the erroneous option character in I<optopt>, and returns \\(aq?\\(aq as the "
"function result."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:196
msgid ""
"If the caller has set the global variable I<opterr> to zero, then "
"B<getopt>()  does not print an error message.  The caller can determine that"
" there was an error by testing whether the function return value is "
"\\(aq?\\(aq.  (By default, I<opterr> has a nonzero value.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:207
msgid ""
"If the first character (following any optional \\(aq+\\(aq or \\(aq-\\(aq "
"described above)  of I<optstring> is a colon (\\(aq:\\(aq), then B<getopt>()"
"  likewise does not print an error message.  In addition, it returns "
"\\(aq:\\(aq instead of \\(aq?\\(aq to indicate a missing option argument.  "
"This allows the caller to distinguish the two different types of errors."
msgstr ""

#. type: SS
#: man-pages/man3/getopt.3:207
#, no-wrap
msgid "getopt_long() and getopt_long_only()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:223
msgid ""
"The B<getopt_long>()  function works like B<getopt>()  except that it also "
"accepts long options, started with two dashes.  (If the program accepts only"
" long options, then I<optstring> should be specified as an empty string "
"(\"\"), not NULL.)  Long option names may be abbreviated if the abbreviation"
" is unique or is an exact match for some defined option.  A long option may "
"take a parameter, of the form B<--arg=param> or B<--arg param>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:230
msgid ""
"I<longopts> is a pointer to the first element of an array of I<struct "
"option> declared in I<E<lt>getopt.hE<gt>> as"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:239
#, no-wrap
msgid ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:243
msgid "The meanings of the different fields are:"
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:243
#, no-wrap
msgid "I<name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:246
msgid "is the name of the long option."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:246
#, no-wrap
msgid "I<has_arg>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:252
msgid ""
"is: B<no_argument> (or 0) if the option does not take an argument; "
"B<required_argument> (or 1) if the option requires an argument; or "
"B<optional_argument> (or 2) if the option takes an optional argument."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:252
#, no-wrap
msgid "I<flag>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:266
msgid ""
"specifies how results are returned for a long option.  If I<flag> is NULL, "
"then B<getopt_long>()  returns I<val>.  (For example, the calling program "
"may set I<val> to the equivalent short option character.)  Otherwise, "
"B<getopt_long>()  returns 0, and I<flag> points to a variable which is set "
"to I<val> if the option is found, but left unchanged if the option is not "
"found."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:266
#, no-wrap
msgid "I<val>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:270
msgid ""
"is the value to return, or to load into the variable pointed to by I<flag>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:272
msgid "The last element of the array has to be filled with zeros."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:276
msgid ""
"If I<longindex> is not NULL, it points to a variable which is set to the "
"index of the long option relative to I<longopts>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:285
msgid ""
"B<getopt_long_only>()  is like B<getopt_long>(), but \\(aq-\\(aq as well as "
"\"--\" can indicate a long option.  If an option that starts with "
"\\(aq-\\(aq (not \"--\") doesn't match a long option, but does match a short"
" option, it is parsed as a short option instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:303
msgid ""
"If an option was successfully found, then B<getopt>()  returns the option "
"character.  If all command-line options have been parsed, then B<getopt>()  "
"returns -1.  If B<getopt>()  encounters an option character that was not in "
"I<optstring>, then \\(aq?\\(aq is returned.  If B<getopt>()  encounters an "
"option with a missing argument, then the return value depends on the first "
"character in I<optstring>: if it is \\(aq:\\(aq, then \\(aq:\\(aq is "
"returned; otherwise \\(aq?\\(aq is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:315
msgid ""
"B<getopt_long>()  and B<getopt_long_only>()  also return the option "
"character when a short option is recognized.  For a long option, they return"
" I<val> if I<flag> is NULL, and 0 otherwise.  Error and -1 returns are the "
"same as for B<getopt>(), plus \\(aq?\\(aq for an ambiguous match or an "
"extraneous parameter."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:316
#, no-wrap
msgid "B<POSIXLY_CORRECT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:320
msgid ""
"If this is set, then option processing stops as soon as a nonoption argument"
" is encountered."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:320
#, no-wrap
msgid "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:329
msgid ""
"This variable was used by B<bash>(1)  2.0 to communicate to glibc which "
"arguments are the results of wildcard expansion and so should not be "
"considered as options.  This behavior was removed in B<bash>(1)  version "
"2.01, but the support remains in glibc."
msgstr ""

#. type: tbl table
#: man-pages/man3/getopt.3:341
#, no-wrap
msgid ""
"B<getopt>(),\n"
"B<getopt_long>(),\n"
"B<getopt_long_only>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getopt.3:341
#, no-wrap
msgid "MT-Unsafe race:getopt env"
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:344
#, no-wrap
msgid "B<getopt>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:356
msgid ""
"POSIX.1-2001, POSIX.1-2008, and POSIX.2, provided the environment variable "
"B<POSIXLY_CORRECT> is set.  Otherwise, the elements of I<argv> aren't really"
" I<const>, because we permute them.  We pretend they're I<const> in the "
"prototype to be compatible with other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:360
msgid "The use of \\(aq+\\(aq and \\(aq-\\(aq in I<optstring> is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:374
msgid ""
"On some older implementations, B<getopt>()  was declared in "
"I<E<lt>stdio.hE<gt>>.  SUSv1 permitted the declaration to appear in either "
"I<E<lt>unistd.hE<gt>> or I<E<lt>stdio.hE<gt>>.  POSIX.1-1996 marked the use "
"of I<E<lt>stdio.hE<gt>> for this purpose as LEGACY.  POSIX.1-2001 does not "
"require the declaration to appear in I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: TP
#: man-pages/man3/getopt.3:374
#, no-wrap
msgid "B<getopt_long>() and B<getopt_long_only>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:377
msgid "These functions are GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:396
msgid ""
"A program that scans multiple argument vectors, or rescans the same vector "
"more than once, and wants to make use of GNU extensions such as \\(aq+\\(aq "
"and \\(aq-\\(aq at the start of I<optstring>, or changes the value of "
"B<POSIXLY_CORRECT> between scans, must reinitialize B<getopt>()  by "
"resetting I<optind> to 0, rather than the traditional value of 1.  "
"(Resetting to 0 forces the invocation of an internal initialization routine "
"that rechecks B<POSIXLY_CORRECT> and checks for GNU extensions in "
"I<optstring>.)"
msgstr ""

#. type: SS
#: man-pages/man3/getopt.3:397
#, no-wrap
msgid "getopt()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:405
msgid ""
"The following trivial example program uses B<getopt>()  to handle two "
"program options: I<-n>, with no associated value; and I<-t val>, which "
"expects an associated value."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:410
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:416
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:435
#, no-wrap
msgid ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:438
#, no-wrap
msgid ""
"    printf(\"flags=%d; tfnd=%d; nsecs=%d; optind=%d\\en\",\n"
"            flags, tfnd, nsecs, optind);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:443
#, no-wrap
msgid ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:445
#, no-wrap
msgid "    printf(\"name argument = %s\\en\", argv[optind]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:447
#, no-wrap
msgid "    /* Other code omitted */\n"
msgstr ""

#. type: SS
#: man-pages/man3/getopt.3:451
#, no-wrap
msgid "getopt_long()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:455
msgid ""
"The following example program illustrates the use of B<getopt_long>()  with "
"most of its features."
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:460
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:466
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int c;\n"
"    int digit_optind = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:479
#, no-wrap
msgid ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:484
#, no-wrap
msgid ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:492
#, no-wrap
msgid ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:501
#, no-wrap
msgid ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:505
#, no-wrap
msgid ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:509
#, no-wrap
msgid ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:513
#, no-wrap
msgid ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:517
#, no-wrap
msgid ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:520
#, no-wrap
msgid ""
"        case \\(aq?\\(aq:\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:525
#, no-wrap
msgid ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:532
#, no-wrap
msgid ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getopt.3:538
msgid "B<getopt>(1), B<getsubopt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getnetent_r.3:26
#, no-wrap
msgid "GETNETENT_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:30
msgid ""
"getnetent_r, getnetbyname_r, getnetbyaddr_r - get network entry (reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:37
#, no-wrap
msgid ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:42
#, no-wrap
msgid ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:47
#, no-wrap
msgid ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:62
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:80
msgid ""
"The B<getnetent_r>(), B<getnetbyname_r>(), and B<getnetbyaddr_r>()  "
"functions are the reentrant equivalents of, respectively, B<getnetent>(3), "
"B<getnetbyname>(3), and B<getnetbynumber>(3).  They differ in the way that "
"the I<netent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:86
msgid ""
"Instead of returning a pointer to a statically allocated I<netent> structure"
" as the function result, these functions copy the structure into the "
"location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getnetent_r.3:103
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<netent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:111
msgid ""
"If the function call successfully obtains a network record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#.  getnetent.3 doesn't document any use of h_errno, but nevertheless
#.  the nonreentrant functions no seem to set h_errno.
#. type: Plain text
#: man-pages/man3/getnetent_r.3:119
msgid ""
"The buffer pointed to by I<h_errnop> is used to return the value that would "
"be stored in the global variable I<h_errno> by the nonreentrant versions of "
"these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:122
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:130
msgid ""
"On error, record not found (B<getnetbyname_r>(), B<getnetbyaddr_r>()), or "
"end of input (B<getnetent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:135
msgid "(B<getnetent_r>())  No more records in database."
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent_r.3:155
#, no-wrap
msgid ""
"B<getnetent_r>(),\n"
"B<getnetbyname_r>(),\n"
"B<getnetbyaddr_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent_r.3:164
msgid "B<getnetent>(3), B<networks>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getmntent.3:32
#, no-wrap
msgid "GETMNTENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:36
msgid ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - get "
"filesystem descriptor file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:40
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:42
#, no-wrap
msgid ""
"B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:44
#, no-wrap
msgid "B<struct mntent *getmntent(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:46
#, no-wrap
msgid "B<int addmntent(FILE *>I<stream>B<, const struct mntent *>I<mnt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:48
#, no-wrap
msgid "B<int endmntent(FILE *>I<streamp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:50
#, no-wrap
msgid ""
"B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:53
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:56
#, no-wrap
msgid ""
"B<struct mntent *getmntent_r(FILE *>I<streamp>B<, struct mntent *>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:68
#, no-wrap
msgid ""
"B<getmntent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:73
msgid ""
"These routines are used to access the filesystem description file "
"I</etc/fstab> and the mounted filesystem description file I</etc/mtab>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:91
msgid ""
"The B<setmntent>()  function opens the filesystem description file "
"I<filename> and returns a file pointer which can be used by B<getmntent>()."
"  The argument I<type> is the type of access required and can take the same "
"values as the I<mode> argument of B<fopen>(3).  The returned stream should "
"be closed using B<endmntent>()  rather than B<fclose>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:103
msgid ""
"The B<getmntent>()  function reads the next line of the filesystem "
"description file from I<stream> and returns a pointer to a structure "
"containing the broken out fields from a line in the file.  The pointer "
"points to a static area of memory which is overwritten by subsequent calls "
"to B<getmntent>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:113
msgid ""
"The B<addmntent>()  function adds the I<mntent> structure I<mnt> to the end "
"of the open I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:119
msgid ""
"The B<endmntent>()  function closes the I<stream> associated with the "
"filesystem description file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:136
msgid ""
"The B<hasmntopt>()  function scans the I<mnt_opts> field (see below)  of the"
" I<mntent> structure I<mnt> for a substring that matches I<opt>.  See "
"I<E<lt>mntent.hE<gt>> and B<mount>(8)  for valid mount options."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:150
msgid ""
"The reentrant B<getmntent_r>()  function is similar to B<getmntent>(), but "
"stores the I<struct mount> in the provided I<*mntbuf> and stores the strings"
" pointed to by the entries in that struct in the provided array I<buf> of "
"size I<buflen>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:156
msgid ""
"The I<mntent> structure is defined in I<E<lt>mntent.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:167
#, no-wrap
msgid ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted filesystem */\n"
"    char *mnt_dir;      /* filesystem path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:184
msgid ""
"Since fields in the mtab and fstab files are separated by whitespace, octal "
"escapes are used to represent the characters space (\\e040), tab (\\e011), "
"newline (\\e012), and backslash (\\e\\e) in those files when they occur in "
"one of the four strings in a I<mntent> structure.  The routines "
"B<addmntent>()  and B<getmntent>()  will convert from string representation "
"to escaped representation and back.  When converting from escaped "
"representation, the sequence \\e134 is also converted to a backslash."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:193
msgid ""
"The B<getmntent>()  and B<getmntent_r>()  functions return a pointer to the "
"I<mntent> structure or NULL on failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:197
msgid "The B<addmntent>()  function returns 0 on success and 1 on failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:201
msgid "The B<endmntent>()  function always returns 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:206
msgid ""
"The B<hasmntopt>()  function returns the address of the substring if a match"
" is found and NULL otherwise."
msgstr ""

#. type: TP
#: man-pages/man3/getmntent.3:207
#, no-wrap
msgid "I</etc/fstab>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:210
msgid "filesystem description file"
msgstr ""

#. type: TP
#: man-pages/man3/getmntent.3:210
#, no-wrap
msgid "I</etc/mtab>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:213
msgid "mounted filesystem description file"
msgstr ""

#. type: tbl table
#: man-pages/man3/getmntent.3:226
#, no-wrap
msgid ""
"B<setmntent>(),\n"
"B<endmntent>(),\n"
"B<hasmntopt>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getmntent.3:229
#, no-wrap
msgid "B<getmntent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getmntent.3:229
#, no-wrap
msgid "MT-Unsafe race:mntentbuf locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getmntent.3:232
#, no-wrap
msgid "B<addmntent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getmntent.3:232
#, no-wrap
msgid "MT-Safe race:stream locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getmntent.3:235
#, no-wrap
msgid "B<getmntent_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:244
msgid ""
"The nonreentrant functions are from SunOS 4.1.3.  A routine B<getmntent_r>()"
"  was introduced in HP-UX 10, but it returns an int.  The prototype shown "
"above is glibc-only."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:256
msgid ""
"System V also has a B<getmntent>()  function but the calling sequence "
"differs, and the returned structure is different.  Under System V "
"I</etc/mnttab> is used.  4.4BSD and Digital UNIX have a routine "
"B<getmntinfo>(), a wrapper around the system call B<getfsstat>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getmntent.3:259
msgid "B<fopen>(3), B<fstab>(5), B<mount>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/getprotoent.3:30
#, no-wrap
msgid "GETPROTOENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:34
msgid ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - "
"get protocol entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:39
#, no-wrap
msgid "B<struct protoent *getprotoent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:41
#, no-wrap
msgid "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:43
#, no-wrap
msgid "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:45
#, no-wrap
msgid "B<void setprotoent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:47
#, no-wrap
msgid "B<void endprotoent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:58
msgid ""
"The B<getprotoent>()  function reads the next entry from the protocols "
"database (see B<protocols>(5))  and returns a I<protoent> structure "
"containing the broken-out fields from the entry.  A connection is opened to "
"the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:68
msgid ""
"The B<getprotobyname>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol name I<name>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:78
msgid ""
"The B<getprotobynumber>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol number I<number>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:90
msgid ""
"The B<setprotoent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getproto*>()  functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:94
msgid "The B<endprotoent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:100
msgid ""
"The I<protoent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:108
#, no-wrap
msgid ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:114
msgid "The members of the I<protoent> structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/getprotoent.3:114
#, no-wrap
msgid "I<p_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:117
msgid "The official name of the protocol."
msgstr ""

#. type: TP
#: man-pages/man3/getprotoent.3:117
#, no-wrap
msgid "I<p_aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:120
msgid "A NULL-terminated list of alternative names for the protocol."
msgstr ""

#. type: TP
#: man-pages/man3/getprotoent.3:120
#, no-wrap
msgid "I<p_proto>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:123
msgid "The protocol number."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:134
msgid ""
"The B<getprotoent>(), B<getprotobyname>()  and B<getprotobynumber>()  "
"functions return a pointer to a statically allocated I<protoent> structure, "
"or a null pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: man-pages/man3/getprotoent.3:136
#, no-wrap
msgid "I</etc/protocols>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:139
msgid "protocol database file"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:150
#, no-wrap
msgid "B<getprotoent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:152 man-pages/man3/getprotoent.3:175
#, no-wrap
msgid "MT-Unsafe race:protoent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:154
#, no-wrap
msgid "race:protoentbuf locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:157
#, no-wrap
msgid "B<getprotobyname>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:159
#, no-wrap
msgid "MT-Unsafe race:protobyname\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:164
#, no-wrap
msgid "B<getprotobynumber>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:166
#, no-wrap
msgid "MT-Unsafe race:protobynumber\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:171
#, no-wrap
msgid "B<setprotoent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent.3:173
#, no-wrap
msgid "B<endprotoent>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:191
msgid ""
"In the above table, I<protoent> in I<race:protoent> signifies that if any of"
" the functions B<setprotoent>(), B<getprotoent>(), or B<endprotoent>()  are "
"used in parallel in different threads of a program, then data races could "
"occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent.3:197
msgid ""
"B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getutent.3:31
#, no-wrap
msgid "GETUTENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:35
msgid ""
"getutent, getutid, getutline, pututline, setutent, endutent, utmpname - "
"access utmp file entries"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:37
msgid "B<#include E<lt>utmp.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:39
msgid "B<struct utmp *getutent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:41
msgid "B<struct utmp *getutid(const struct utmp *>I<ut>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:43
msgid "B<struct utmp *getutline(const struct utmp *>I<ut>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:45
msgid "B<struct utmp *pututline(const struct utmp *>I<ut>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:47
msgid "B<void setutent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:49
msgid "B<void endutent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:51
msgid "B<int utmpname(const char *>I<file>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:54
msgid ""
"New applications should use the POSIX.1-specified \"utmpx\" versions of "
"these functions; see CONFORMING TO."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:63
msgid ""
"B<utmpname>()  sets the name of the utmp-format file for the other utmp "
"functions to access.  If B<utmpname>()  is not used to set the filename "
"before the other functions are used, they assume B<_PATH_UTMP>, as defined "
"in I<E<lt>paths.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:68
msgid ""
"B<setutent>()  rewinds the file pointer to the beginning of the utmp file.  "
"It is generally a good idea to call it before any of the other functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:73
msgid ""
"B<endutent>()  closes the utmp file.  It should be called when the user code"
" is done accessing the file with the other functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:80
msgid ""
"B<getutent>()  reads a line from the current file position in the utmp file."
"  It returns a pointer to a structure containing the fields of the line.  "
"The definition of this structure is shown in B<utmp>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:96
msgid ""
"B<getutid>()  searches forward from the current file position in the utmp "
"file based upon I<ut>.  If I<ut-E<gt>ut_type> is one of B<RUN_LVL>, "
"B<BOOT_TIME>, B<NEW_TIME>, or B<OLD_TIME>, B<getutid>()  will find the first"
" entry whose I<ut_type> field matches I<ut-E<gt>ut_type>.  If "
"I<ut-E<gt>ut_type> is one of B<INIT_PROCESS>, B<LOGIN_PROCESS>, "
"B<USER_PROCESS>, or B<DEAD_PROCESS>, B<getutid>()  will find the first entry"
" whose I<ut_id> field matches I<ut-E<gt>ut_id>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:106
msgid ""
"B<getutline>()  searches forward from the current file position in the utmp "
"file.  It scans entries whose I<ut_type> is B<USER_PROCESS> or "
"B<LOGIN_PROCESS> and returns the first one whose I<ut_line> field matches "
"I<ut-E<gt>ut_line>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:118
msgid ""
"B<pututline>()  writes the I<utmp> structure I<ut> into the utmp file.  It "
"uses B<getutid>()  to search for the proper place in the file to insert the "
"new entry.  If it cannot find an appropriate slot for I<ut>, B<pututline>()"
"  will append the new entry to the end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:127
msgid ""
"B<getutent>(), B<getutid>(), and B<getutline>()  return a pointer to a "
"I<struct utmp> on success, and NULL on failure (which includes the \"record "
"not found\" case).  This I<struct utmp> is allocated in static storage, and "
"may be overwritten by subsequent calls."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:133
msgid "On success B<pututline>()  returns I<ut>; on failure, it returns NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:136
msgid ""
"B<utmpname>()  returns 0 if the new name was successfully stored, or -1 on "
"failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:140
msgid ""
"In the event of an error, these functions I<errno> set to indicate the "
"cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:147
msgid "Record not found."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:154
msgid ""
"B<setutent>(), B<pututline>(), and the B<getut*>()  functions can also fail "
"for the reasons described in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man3/getutent.3:155
#, no-wrap
msgid "I</var/run/utmp>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:158
msgid "database of currently logged-in users"
msgstr ""

#. type: TP
#: man-pages/man3/getutent.3:158
#, no-wrap
msgid "I</var/log/wtmp>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:161
msgid "database of past user logins"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:171
#, no-wrap
msgid "B<getutent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:173 man-pages/man3/getutent.3:182
#, no-wrap
msgid "MT-Unsafe init race:utent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:175
#, no-wrap
msgid "race:utentbuf sig:ALRM timer"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:178
#, no-wrap
msgid "B<getutid>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:180
#, no-wrap
msgid "B<getutline>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:184 man-pages/man3/getutent.3:191
#, no-wrap
msgid "sig:ALRM timer"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:187
#, no-wrap
msgid "B<pututline>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:189
#, no-wrap
msgid "MT-Unsafe race:utent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:194
#, no-wrap
msgid "B<setutent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:196
#, no-wrap
msgid "B<endutent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:198
#, no-wrap
msgid "B<utmpname>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getutent.3:198
#, no-wrap
msgid "MT-Unsafe race:utent"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:216
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(), B<getutent>(), B<getutid>(), B<getutline>(), "
"B<pututline>(), B<utmpname>(), or B<endutent>()  are used in parallel in "
"different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:218
msgid "XPG2, SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:227
msgid ""
"In XPG2 and SVID 2 the function B<pututline>()  is documented to return "
"void, and that is what it does on many systems (AIX, HP-UX).  HP-UX "
"introduces a new function B<_pututline>()  with the prototype given above "
"for B<pututline>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:231
msgid ""
"All these functions are obsolete now on non-Linux systems.  POSIX.1-2001 and"
" POSIX.1-2008, following SUSv1, does not have any of these functions, but "
"instead uses"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:235
#, no-wrap
msgid "B<#include E<lt>utmpx.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:242
#, no-wrap
msgid ""
"B<struct utmpx *getutxent(void);>\n"
"B<struct utmpx *getutxid(const struct utmpx *);>\n"
"B<struct utmpx *getutxline(const struct utmpx *);>\n"
"B<struct utmpx *pututxline(const struct utmpx *);>\n"
"B<void setutxent(void);>\n"
"B<void endutxent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:253
msgid ""
"These functions are provided by glibc, and perform the same task as their "
"equivalents without the \"x\", but use I<struct utmpx>, defined on Linux to "
"be the same as I<struct utmp>.  For completeness, glibc also provides "
"B<utmpxname>(), although this function is not specified by POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:261
msgid ""
"On some other systems, the I<utmpx> structure is a superset of the I<utmp> "
"structure, with additional fields, and larger versions of the existing "
"fields, and parallel files are maintained, often I</var/*/utmpx> and "
"I</var/*/wtmpx>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:269
msgid ""
"Linux glibc on the other hand does not use a parallel I<utmpx> file since "
"its I<utmp> structure is already large enough.  The \"x\" functions listed "
"above are just aliases for their counterparts without the \"x\" (e.g., "
"B<getutxent>()  is an alias for B<getutent>())."
msgstr ""

#. type: SS
#: man-pages/man3/getutent.3:270
#, no-wrap
msgid "Glibc notes"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:273
msgid ""
"The above functions are not thread-safe.  Glibc adds reentrant versions"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:277
#, no-wrap
msgid "B<#include E<lt>utmp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:279
#, no-wrap
msgid "B<int getutent_r(struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:282
#, no-wrap
msgid ""
"B<int getutid_r(struct utmp *>I<ut>B<,>\n"
"B<              struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:285
#, no-wrap
msgid ""
"B<int getutline_r(struct utmp *>I<ut>B<,>\n"
"B<                struct utmp *>I<ubuf>B<, struct utmp **>I<ubufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:294
msgid "B<getutent_r>(), B<getutid_r>(), B<getutline_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:298
#, no-wrap
msgid ""
"    _GNU_SOURCE\n"
"    || /* since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* glibc E<lt>= 2.19: */    _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:310
msgid ""
"These functions are GNU extensions, analogs of the functions of the same "
"name without the _r suffix.  The I<ubuf> argument gives these functions a "
"place to store their result.  On success, they return 0, and a pointer to "
"the result is written in I<*ubufp>.  On error, these functions return -1.  "
"There are no utmpx equivalents of the above functions.  (POSIX.1 does not "
"specify such functions.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:318
msgid ""
"The following example adds and removes a utmp record, assuming it is run "
"from within a pseudo terminal.  For usage in a real application, you should "
"check the return values of B<getpwuid>(3)  and B<ttyname>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:325
#, no-wrap
msgid ""
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>utmp.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:330
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct utmp entry;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:332
#, no-wrap
msgid "    system(\"echo before adding entry:;who\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:344
#, no-wrap
msgid ""
"    entry.ut_type = USER_PROCESS;\n"
"    entry.ut_pid = getpid();\n"
"    strcpy(entry.ut_line, ttyname(STDIN_FILENO) + strlen(\"/dev/\"));\n"
"    /* only correct for ptys named /dev/tty[pqr][0-9a-z] */\n"
"    strcpy(entry.ut_id, ttyname(STDIN_FILENO) + strlen(\"/dev/tty\"));\n"
"    time(&entry.ut_time);\n"
"    strcpy(entry.ut_user, getpwuid(getuid())-E<gt>pw_name);\n"
"    memset(entry.ut_host, 0, UT_HOSTSIZE);\n"
"    entry.ut_addr = 0;\n"
"    setutent();\n"
"    pututline(&entry);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:346
#, no-wrap
msgid "    system(\"echo after adding entry:;who\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:353
#, no-wrap
msgid ""
"    entry.ut_type = DEAD_PROCESS;\n"
"    memset(entry.ut_line, 0, UT_LINESIZE);\n"
"    entry.ut_time = 0;\n"
"    memset(entry.ut_user, 0, UT_NAMESIZE);\n"
"    setutent();\n"
"    pututline(&entry);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:355
#, no-wrap
msgid "    system(\"echo after removing entry:;who\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:359
#, no-wrap
msgid ""
"    endutent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutent.3:362
msgid "B<getutmp>(3), B<utmp>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getrpcport.3:8
#, no-wrap
msgid "GETRPCPORT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcport.3:11
msgid "getrpcport - get RPC port number"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcport.3:14
#, no-wrap
msgid "B<#include E<lt>rpc/rpc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcport.3:17
#, no-wrap
msgid ""
"B<int getrpcport(const char *>I<host>B<, unsigned long >I<prognum>B<,>\n"
"B<               unsigned long >I<versnum>B<, unsigned >I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcport.3:38
msgid ""
"B<getrpcport>()  returns the port number for version I<versnum> of the RPC "
"program I<prognum> running on I<host> and using protocol I<proto>.  It "
"returns 0 if it cannot contact the portmapper, or if I<prognum> is not "
"registered.  If I<prognum> is registered but not with version I<versnum>, it"
" will still return a port number (for some version of the program)  "
"indicating that the program is indeed registered.  The version mismatch will"
" be detected upon the first call to the service."
msgstr ""

#. type: tbl table
#: man-pages/man3/getrpcport.3:48
#, no-wrap
msgid "B<getrpcport>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcport.3:53
msgid "Not in POSIX.1.  Present on the BSDs, Solaris, and many other systems."
msgstr ""

#. type: TH
#: man-pages/man3/gcvt.3:30
#, no-wrap
msgid "GCVT"
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:33
msgid "gcvt - convert a floating-point number to a string"
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:36
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:38
#, no-wrap
msgid "B<char *gcvt(double >I<number>B<, int >I<ndigit>B<, char *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:46
msgid "B<gcvt>():"
msgstr ""

#. type: TP
#: man-pages/man3/gcvt.3:49
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:55
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""

#.     || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/gcvt.3:60
msgid "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:71
msgid ""
"The B<gcvt>()  function converts I<number> to a minimal length null-"
"terminated ASCII string and stores the result in I<buf>.  It produces "
"I<ndigit> significant digits in either B<printf>(3)  F format or E format."
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:76
msgid ""
"The B<gcvt>()  function returns the address of the string pointed to by "
"I<buf>."
msgstr ""

#. type: tbl table
#: man-pages/man3/gcvt.3:86
#, no-wrap
msgid "B<gcvt>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:98
msgid ""
"Marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the specification of"
" B<gcvt>(), recommending the use of B<sprintf>(3)  instead (though "
"B<snprintf>(3)  may be preferable)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gcvt.3:101
msgid "B<ecvt>(3), B<fcvt>(3), B<sprintf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getcontext.3:25
#, no-wrap
msgid "GETCONTEXT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:28
msgid "getcontext, setcontext - get or set the user context"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:30
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:32
msgid "B<int getcontext(ucontext_t *>I<ucp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:34
msgid "B<int setcontext(const ucontext_t *>I<ucp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:49
msgid ""
"In a System V-like environment, one has the two types I<mcontext_t> and "
"I<ucontext_t> defined in I<E<lt>ucontext.hE<gt>> and the four functions "
"B<getcontext>(), B<setcontext>(), B<makecontext>(3), and B<swapcontext>(3)  "
"that allow user-level context switching between multiple threads of control "
"within a process."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:57
msgid ""
"The I<mcontext_t> type is machine-dependent and opaque.  The I<ucontext_t> "
"type is a structure that has at least the following fields:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:67
#, no-wrap
msgid ""
"typedef struct ucontext_t {\n"
"    struct ucontext_t *uc_link;\n"
"    sigset_t          uc_sigmask;\n"
"    stack_t           uc_stack;\n"
"    mcontext_t        uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:94
msgid ""
"with I<sigset_t> and I<stack_t> defined in I<E<lt>signal.hE<gt>>.  Here "
"I<uc_link> points to the context that will be resumed when the current "
"context terminates (in case the current context was created using "
"B<makecontext>(3)), I<uc_sigmask> is the set of signals blocked in this "
"context (see B<sigprocmask>(2)), I<uc_stack> is the stack used by this "
"context (see B<sigaltstack>(2)), and I<uc_mcontext> is the machine-specific "
"representation of the saved context, that includes the calling thread's "
"machine registers."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:101
msgid ""
"The function B<getcontext>()  initializes the structure pointed at by I<ucp>"
" to the currently active context."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:114
msgid ""
"The function B<setcontext>()  restores the user context pointed at by "
"I<ucp>.  A successful call does not return.  The context should have been "
"obtained by a call of B<getcontext>(), or B<makecontext>(3), or passed as "
"third argument to a signal handler."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:118
msgid ""
"If the context was obtained by a call of B<getcontext>(), program execution "
"continues as if this call just returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:135
msgid ""
"If the context was obtained by a call of B<makecontext>(3), program "
"execution continues by a call to the function I<func> specified as the "
"second argument of that call to B<makecontext>(3).  When the function "
"I<func> returns, we continue with the I<uc_link> member of the structure "
"I<ucp> specified as the first argument of that call to B<makecontext>(3).  "
"When this member is NULL, the thread exits."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:142
msgid ""
"If the context was obtained by a call to a signal handler, then old standard"
" text says that \"program execution continues with the program instruction "
"following the instruction interrupted by the signal\".  However, this "
"sentence was removed in SUSv2, and the present verdict is \"the result is "
"unspecified\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:151
msgid ""
"When successful, B<getcontext>()  returns 0 and B<setcontext>()  does not "
"return.  On error, both return -1 and set I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:153
msgid "None defined."
msgstr ""

#. type: tbl table
#: man-pages/man3/getcontext.3:164
#, no-wrap
msgid ""
"B<getcontext>(),\n"
"B<setcontext>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getcontext.3:164
#, no-wrap
msgid "MT-Safe race:ucp"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:172
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<getcontext>(), citing portability issues, and recommending that "
"applications be rewritten to use POSIX threads instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:189
msgid ""
"The earliest incarnation of this mechanism was the "
"B<setjmp>(3)/B<longjmp>(3)  mechanism.  Since that does not define the "
"handling of the signal context, the next stage was the "
"B<sigsetjmp>(3)/B<siglongjmp>(3)  pair.  The present mechanism gives much "
"more control.  On the other hand, there is no easy way to detect whether a "
"return from B<getcontext>()  is from the first call, or via a "
"B<setcontext>()  call.  The user has to invent her own bookkeeping device, "
"and a register variable won't do since registers are restored."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:200
msgid ""
"When a signal occurs, the current user context is saved and a new context is"
" created by the kernel for the signal handler.  Do not leave the handler "
"using B<longjmp>(3): it is undefined what would happen with contexts.  Use "
"B<siglongjmp>(3)  or B<setcontext>()  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcontext.3:206
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), "
"B<makecontext>(3), B<sigsetjmp>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/grantpt.3:5
#, no-wrap
msgid "GRANTPT"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:8
msgid "grantpt - grant access to the slave pseudoterminal"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:10
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:12
msgid "B<int grantpt(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:20
msgid "B<grantpt>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:25
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:28
#, no-wrap
msgid ""
"Glibc 2.23 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:40
msgid ""
"The B<grantpt>()  function changes the mode and owner of the slave "
"pseudoterminal device corresponding to the master pseudoterminal referred to"
" by I<fd>.  The user ID of the slave is set to the real UID of the calling "
"process.  The group ID is set to an unspecified value (e.g., I<tty>).  The "
"mode of the slave is set to 0620 (crw--w----)."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:46
msgid ""
"The behavior of B<grantpt>()  is unspecified if a signal handler is "
"installed to catch B<SIGCHLD> signals."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:53
msgid ""
"When successful, B<grantpt>()  returns 0.  Otherwise, it returns -1 and sets"
" I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:57
msgid "The corresponding slave pseudoterminal could not be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:62
msgid "The I<fd> argument is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:67
msgid ""
"The I<fd> argument is valid but not associated with a master pseudoterminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:70
msgid "B<grantpt>()  is provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/grantpt.3:80
#, no-wrap
msgid "B<grantpt>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:88
msgid "This is part of the UNIX 98 pseudoterminal support, see B<pts>(4)."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:100
msgid ""
"Many systems implement this function via a set-user-ID helper binary called "
"\"pt_chown\".  On Linux systems with a devpts filesystem (present since "
"Linux 2.2), the kernel normally sets the correct ownership and permissions "
"for the pseudoterminal slave when the master is opened (B<posix_openpt>(3)),"
" so that nothing must be done by B<grantpt>().  Thus, no such helper binary "
"is required (and indeed it is configured to be absent during the glibc build"
" that is typical on many systems)."
msgstr ""

#. type: Plain text
#: man-pages/man3/grantpt.3:106
msgid ""
"B<open>(2), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), B<pts>(4), "
"B<pty>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/getusershell.3:30
#, no-wrap
msgid "GETUSERSHELL"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:33
msgid "getusershell, setusershell, endusershell - get permitted user shells"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:38
#, no-wrap
msgid "B<char *getusershell(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:40
#, no-wrap
msgid "B<void setusershell(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:42
#, no-wrap
msgid "B<void endusershell(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:53
msgid "B<getusershell>(), B<setusershell>(), B<endusershell>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:81
msgid ""
"The B<getusershell>()  function returns the next line from the file "
"I</etc/shells>, opening the file if necessary.  The line should contain the "
"pathname of a valid user shell.  If I</etc/shells> does not exist or is "
"unreadable, B<getusershell>()  behaves as if I</bin/sh> and I</bin/csh> were"
" listed in the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:86
msgid "The B<setusershell>()  function rewinds I</etc/shells>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:91
msgid "The B<endusershell>()  function closes I</etc/shells>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:95
msgid "The B<getusershell>()  function returns NULL on end-of-file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:98
#, no-wrap
msgid "/etc/shells\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getusershell.3:110
#, no-wrap
msgid ""
"B<getusershell>(),\n"
"B<setusershell>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getusershell.3:112
#, no-wrap
msgid "B<endusershell>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getusershell.3:112
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:116
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/getusershell.3:117
msgid "B<shells>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/gsignal.3:27
#, no-wrap
msgid "GSIGNAL"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:30
msgid "gsignal, ssignal - software signal facility"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:33
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:35
#, no-wrap
msgid "B<typedef void (*sighandler_t)(int);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:37
#, no-wrap
msgid "B<int gsignal(int >I<signum>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:39
#, no-wrap
msgid "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:52
#, no-wrap
msgid ""
"B<gsignal>(),\n"
"B<ssignal>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:60
msgid ""
"Don't use these functions under Linux.  Due to a historical mistake, under "
"Linux these functions are aliases for B<raise>(3)  and B<signal>(2), "
"respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:98
msgid ""
"Elsewhere, on System V-like systems, these functions implement software "
"signaling, entirely independent of the classical B<signal>(2)  and "
"B<kill>(2)  functions.  The function B<ssignal>()  defines the action to "
"take when the software signal with number I<signum> is raised using the "
"function B<gsignal>(), and returns the previous such action or B<SIG_DFL>.  "
"The function B<gsignal>()  does the following: if no action (or the action "
"B<SIG_DFL>)  was specified for I<signum>, then it does nothing and returns "
"0.  If the action B<SIG_IGN> was specified for I<signum>, then it does "
"nothing and returns 1.  Otherwise, it resets the action to B<SIG_DFL> and "
"calls the action function with argument I<signum>, and returns the value "
"returned by that function.  The range of possible values I<signum> varies "
"(often 1\\(en15 or 1\\(en17)."
msgstr ""

#. type: tbl table
#: man-pages/man3/gsignal.3:108
#, no-wrap
msgid "B<gsignal>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gsignal.3:111
#, no-wrap
msgid "B<ssignal>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gsignal.3:111
#, no-wrap
msgid "MT-Safe sigintr"
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:122
msgid ""
"These functions are available under AIX, DG/UX, HP-UX, SCO, Solaris, Tru64."
"  They are called obsolete under most of these systems, and are broken under"
" Linux libc and glibc.  Some systems also have B<gsignal_r>()  and "
"B<ssignal_r>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/gsignal.3:125
msgid "B<kill>(2), B<signal>(2), B<raise>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getlogin.3:28
#, no-wrap
msgid "GETLOGIN"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:31
msgid "getlogin, getlogin_r, cuserid - get username"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:35
msgid "B<char *getlogin(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:37
msgid "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:39
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:41
msgid "B<char *cuserid(char *>I<string>B<);>"
msgstr ""

#.  Deprecated: _REENTRANT ||
#. type: Plain text
#: man-pages/man3/getlogin.3:50
msgid "B<getlogin_r>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:52
msgid "B<cuserid>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:58
#, no-wrap
msgid ""
"    Since glibc 2.24:\n"
"        (_XOPEN_SOURCE && ! (_POSIX_C_SOURCE E<gt>= 200112L)\n"
"        || _GNU_SOURCE\n"
"    Up to and including glibc 2.23:\n"
"        _XOPEN_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:68
msgid ""
"B<getlogin>()  returns a pointer to a string containing the name of the user"
" logged in on the controlling terminal of the process, or a null pointer if "
"this information cannot be determined.  The string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<cuserid>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:74
msgid ""
"B<getlogin_r>()  returns this same username in the array I<buf> of size "
"I<bufsize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:86
msgid ""
"B<cuserid>()  returns a pointer to a string containing a username associated"
" with the effective user ID of the process.  If I<string> is not a null "
"pointer, it should be an array that can hold at least B<L_cuserid> "
"characters; the string is returned in this array.  Otherwise, a pointer to a"
" string in a static area is returned.  This string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<getlogin>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:90
msgid ""
"The macro B<L_cuserid> is an integer constant that indicates how long an "
"array you might need to store a username.  B<L_cuserid> is declared in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:97
msgid ""
"These functions let your program identify positively the user who is running"
" (B<cuserid>())  or the user who logged in this session (B<getlogin>()).  "
"(These can differ when set-user-ID programs are involved.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:102
msgid ""
"For most purposes, it is more useful to use the environment variable "
"B<LOGNAME> to find out who the user is.  This is more flexible precisely "
"because the user can set B<LOGNAME> arbitrarily."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:110
msgid ""
"B<getlogin>()  returns a pointer to the username when successful, and NULL "
"on failure, with I<errno> set to indicate the cause of the error.  "
"B<getlogin_r>()  returns 0 when successful, and nonzero on failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:112
msgid "POSIX specifies"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:121
msgid "The calling process has no controlling terminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:127
msgid ""
"(getlogin_r)  The length of the username, including the terminating null "
"byte (\\(aq\\e0\\(aq), is larger than I<bufsize>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:129
msgid "Linux/glibc also has"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:132
msgid "There was no corresponding entry in the utmp-file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:135
msgid "Insufficient memory to allocate passwd structure."
msgstr ""

#. type: TP
#: man-pages/man3/getlogin.3:135
#, no-wrap
msgid "B<ENOTTY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:139
msgid "Standard input didn't refer to a terminal.  (See BUGS.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:143
msgid "password database file"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:147
msgid "(traditionally I</etc/utmp>; some libc versions used I</var/adm/utmp>)"
msgstr ""

#. type: tbl table
#: man-pages/man3/getlogin.3:157
#, no-wrap
msgid "B<getlogin>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getlogin.3:159
#, no-wrap
msgid "MT-Unsafe race:getlogin race:utent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getlogin.3:161
#, no-wrap
msgid "sig:ALRM timer locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getlogin.3:164
#, no-wrap
msgid "B<getlogin_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getlogin.3:166
#, no-wrap
msgid "MT-Unsafe race:utent sig:ALRM timer\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getlogin.3:171
#, no-wrap
msgid "B<cuserid>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getlogin.3:171
#, no-wrap
msgid "MT-Unsafe race:cuserid/!string locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:190
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<getlogin>()  and B<getlogin_r>()  call those functions, so we use "
"race:utent to remind users."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:195
msgid "B<getlogin>()  and B<getlogin_r>(): POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:206
msgid ""
"System V has a B<cuserid>()  function which uses the real user ID rather "
"than the effective user ID.  The B<cuserid>()  function was included in the "
"1988 version of POSIX, but removed from the 1990 version.  It was present in"
" SUSv2, but removed in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:213
msgid ""
"OpenBSD has B<getlogin>()  and B<setlogin>(), and a username associated with"
" a session, even if it has no controlling terminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:225
msgid ""
"Unfortunately, it is often rather easy to fool B<getlogin>().  Sometimes it "
"does not work at all, because some program messed up the utmp file.  Often, "
"it gives only the first 8 characters of the login name.  The user currently "
"logged in on the controlling terminal of our program need not be the user "
"who started it.  Avoid B<getlogin>()  for security-related purposes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:235
msgid ""
"Note that glibc does not follow the POSIX specification and uses I<stdin> "
"instead of I</dev/tty>.  A bug.  (Other recent systems, like SunOS 5.8 and "
"HP-UX 11.11 and FreeBSD 4.8 all return the login name also when I<stdin> is "
"redirected.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:245
msgid ""
"Nobody knows precisely what B<cuserid>()  does; avoid it in portable "
"programs.  Or avoid it altogether: use I<getpwuid(geteuid())> instead, if "
"that is what you meant.  B<Do not use> B<cuserid>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getlogin.3:249
msgid "B<logname>(1), B<geteuid>(2), B<getuid>(2), B<utmp>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getutmp.3:26
#, no-wrap
msgid "GETUTMP"
msgstr ""

#. type: TH
#: man-pages/man3/getutmp.3:26
#, no-wrap
msgid "2015-03-02"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:29
msgid "getutmp, getutmpx - copy utmp structure to utmpx, and vice versa"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>utmpx.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:36
#, no-wrap
msgid ""
"B< void getutmp(const struct utmpx *>I<ux>B<, struct utmp *>I<u>B<);>\n"
"B< void getutmpx(const struct utmp *>I<u>B<, struct utmpx *>I<ux>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:51
msgid ""
"The B<getutmp>()  function copies the fields of the I<utmpx> structure "
"pointed to by I<ux> to the corresponding fields of the I<utmp> structure "
"pointed to by I<u>.  The B<getutmpx>()  function performs the converse "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:53
msgid "These functions do not return a value."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:55
msgid "These functions first appeared in glibc in version 2.1.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/getutmp.3:66
#, no-wrap
msgid ""
"B<getutmp>(),\n"
"B<getutmpx>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:71
msgid ""
"These functions are nonstandard, but appear on a few other systems, such as "
"Solaris and NetBSD."
msgstr ""

#.  e.g., on Solaris, the utmpx structure is rather larger than utmp.
#. type: Plain text
#: man-pages/man3/getutmp.3:82
msgid ""
"These functions exist primarily for compatibility with other systems where "
"the I<utmp> and I<utmpx> structures contain different fields, or the size of"
" corresponding fields differs.  On Linux, the two structures contain the "
"same fields, and the fields have the same sizes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getutmp.3:85
msgid "B<utmpdump>(1), B<getutent>(3), B<utmp>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/gnu_get_libc_version.3:26
#, no-wrap
msgid "GNU_GET_LIBC_VERSION"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:29
msgid ""
"gnu_get_libc_version, gnu_get_libc_release - get glibc version and release"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:32
#, no-wrap
msgid "B<#include E<lt>gnu/libc-version.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:35
#, no-wrap
msgid ""
"B<const char *gnu_get_libc_version(void);>\n"
"B<const char *gnu_get_libc_release(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:40
msgid ""
"The function B<gnu_get_libc_version>()  returns a string that identifies the"
" glibc version available on the system."
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:47
msgid ""
"The function B<gnu_get_libc_release>()  returns a string indicates the "
"release status of the glibc version available on the system.  This will be a"
" string such as I<stable>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:49
msgid "These functions first appeared in glibc in version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/gnu_get_libc_version.3:60
#, no-wrap
msgid ""
"B<gnu_get_libc_version>(),\n"
"B<gnu_get_libc_release>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:64
msgid "These functions are glibc-specific."
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:66
msgid "When run, the program below will produce output such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:72
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"GNU libc version: 2.8\n"
"GNU libc release: stable\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:80
#, no-wrap
msgid ""
"#include E<lt>gnu/libc-version.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:88
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"GNU libc version: %s\\en\", gnu_get_libc_version());\n"
"    printf(\"GNU libc release: %s\\en\", gnu_get_libc_release());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gnu_get_libc_version.3:90
msgid "B<confstr>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getttyent.3:7
#, no-wrap
msgid "GETTTYENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:10
msgid "getttyent, getttynam, setttyent, endttyent - get ttys file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:12
msgid "B<#include E<lt>ttyent.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:14
msgid "B<struct ttyent *getttyent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:16
msgid "B<struct ttyent *getttynam(const char *>I<name>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:18
msgid "B<int setttyent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:20
msgid "B<int endttyent(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:25
msgid ""
"These functions provide an interface to the file B<_PATH_TTYS> (e.g., "
"I</etc/ttys>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:29
msgid ""
"The function B<setttyent>()  opens the file or rewinds it if already open."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:33
msgid "The function B<endttyent>()  closes the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:40
msgid ""
"The function B<getttynam>()  searches for a given terminal name in the file."
"  It returns a pointer to a I<ttyent> structure (description below)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:50
msgid ""
"The function B<getttyent>()  opens the file B<_PATH_TTYS> (if necessary) and"
" returns the first entry.  If the file is already open, the next entry.  The"
" I<ttyent> structure has the form:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:61
#, no-wrap
msgid ""
"struct ttyent {\n"
"    char *ty_name;     /* terminal device name */\n"
"    char *ty_getty;    /* command to execute, usually getty */\n"
"    char *ty_type;     /* terminal type for termcap */\n"
"    int   ty_status;   /* status flags */\n"
"    char *ty_window;   /* command to start up window manager */\n"
"    char *ty_comment;  /* comment field */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:66
msgid "I<ty_status> can be:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:71
#, no-wrap
msgid ""
"#define TTY_ON     0x01  /* enable logins (start ty_getty program) */\n"
"#define TTY_SECURE 0x02  /* allow UID 0 to login */\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getttyent.3:86
#, no-wrap
msgid ""
"B<getttyent>(),\n"
"B<setttyent>(),\n"
"B<endttyent>(),\n"
"B<getttynam>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getttyent.3:86
#, no-wrap
msgid "MT-Unsafe race:ttyent"
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:91
msgid "Not in POSIX.1.  Present on the BSDs, and perhaps other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:95
msgid ""
"Under Linux, the file I</etc/ttys>, and the functions described above, are "
"not used."
msgstr ""

#. type: Plain text
#: man-pages/man3/getttyent.3:97
msgid "B<ttyname>(3), B<ttyslot>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/group_member.3:25
#, no-wrap
msgid "GROUP_MEMBER"
msgstr ""

#. type: TH
#: man-pages/man3/group_member.3:25
#, no-wrap
msgid "2014-03-30"
msgstr ""

#. type: Plain text
#: man-pages/man3/group_member.3:28
msgid "group_member - test whether a process is in a group"
msgstr ""

#. type: Plain text
#: man-pages/man3/group_member.3:32
msgid "B<int group_member(gid_t >I<gid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/group_member.3:40
msgid "B<group_member>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/group_member.3:48
msgid ""
"The B<group_member>()  function tests whether any of the caller's "
"supplementary group IDs (as returned by B<getgroups>(2))  matches I<gid>."
msgstr ""

#. type: Plain text
#: man-pages/man3/group_member.3:55
msgid ""
"The B<group_member>()  function returns nonzero if any of the caller's "
"supplementary group IDs matches I<gid>, and zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/group_member.3:57
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/group_member.3:61
msgid "B<getgid>(2), B<getgroups>(2), B<getgrouplist>(3), B<group>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getrpcent.3:8
#, no-wrap
msgid "GETRPCENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:12
msgid ""
"getrpcent, getrpcbyname, getrpcbynumber, setrpcent, endrpcent - get RPC "
"entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:17
#, no-wrap
msgid "B<struct rpcent *getrpcent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:19
#, no-wrap
msgid "B<struct rpcent *getrpcbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:21
#, no-wrap
msgid "B<struct rpcent *getrpcbynumber(int >I<number>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:23
#, no-wrap
msgid "B<void setrpcent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:25
#, no-wrap
msgid "B<void endrpcent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:36
msgid ""
"The B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  functions "
"each return a pointer to an object with the following structure containing "
"the broken-out fields of an entry in the RPC program number data base."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:44
#, no-wrap
msgid ""
"struct rpcent {\n"
"    char  *r_name;     /* name of server for this RPC program */\n"
"    char **r_aliases;  /* alias list */\n"
"    long   r_number;   /* RPC program number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:48
msgid "The members of this structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:49
#, no-wrap
msgid "I<r_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:52
msgid "The name of the server for this RPC program."
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:52
#, no-wrap
msgid "I<r_aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:55
msgid "A NULL-terminated list of alternate names for the RPC program."
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:55
#, no-wrap
msgid "I<r_number>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:58
msgid "The RPC program number for this service."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:64
msgid ""
"The B<getrpcent>()  function reads the next entry from the database.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:76
msgid ""
"The B<setrpcent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getrpc*>()  functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:80
msgid "The B<endrpcent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:88
msgid ""
"The B<getrpcbyname>()  and B<getrpcbynumber>()  functions sequentially "
"search from the beginning of the file until a matching RPC program name or "
"program number is found, or until end-of-file is encountered."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:98
msgid ""
"On success, B<getrpcent>(), B<getrpcbyname>(), and B<getrpcbynumber>()  "
"return a pointer to a statically allocated I<rpcent> structure.  NULL is "
"returned on EOF or error."
msgstr ""

#. type: TP
#: man-pages/man3/getrpcent.3:99
#, no-wrap
msgid "I</etc/rpc>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:102
msgid "RPC program number database."
msgstr ""

#. type: tbl table
#: man-pages/man3/getrpcent.3:113
#, no-wrap
msgid ""
"B<getrpcent>(),\n"
"B<getrpcbyname>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getrpcent.3:115
#, no-wrap
msgid "B<getrpcbynumber>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getrpcent.3:119
#, no-wrap
msgid ""
"B<setrpcent>(),\n"
"B<endrpcent>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:130
msgid ""
"All information is contained in a static area so it must be copied if it is "
"to be saved."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent.3:134
msgid "B<getrpcent_r>(3), B<rpc>(5), B<rpcinfo>(8), B<ypserv>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/get_nprocs_conf.3:26
#, no-wrap
msgid "GET_NPROCS"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:29
msgid "get_nprocs, get_nprocs_conf - get number of processors"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:31
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:33
msgid "B<int get_nprocs(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:35
msgid "B<int get_nprocs_conf(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:39
msgid ""
"The function B<get_nprocs_conf>()  returns the number of processors "
"configured by the operating system."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:46
msgid ""
"The function B<get_nprocs>()  returns the number of processors currently "
"available in the system.  This may be less than the number returned by "
"B<get_nprocs_conf>()  because processors may be offline (e.g., on "
"hotpluggable systems)."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:48
msgid "As given in DESCRIPTION."
msgstr ""

#. type: tbl table
#: man-pages/man3/get_nprocs_conf.3:58
#, no-wrap
msgid "B<get_nprocs>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/get_nprocs_conf.3:60
#, no-wrap
msgid "B<get_nprocs_conf>()"
msgstr ""

#.  glibc 2.15
#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:72
msgid ""
"The current implementation of these functions is rather expensive, since "
"they open and parse files in the I</sys> filesystem each time they are "
"called."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:77
msgid ""
"The following B<sysconf>(3)  calls make use of the functions documented on "
"this page to return the same information."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:82
#, no-wrap
msgid ""
"np = sysconf(_SC_NPROCESSORS_CONF);     /* processors configured */\n"
"np = sysconf(_SC_NPROCESSORS_ONLN);     /* processors available */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:90
msgid ""
"The following example shows how B<get_nprocs>()  and B<get_nprocs_conf>()  "
"can be used."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:95
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %d processors configured and \"\n"
"            \"%d processors available.\\en\",\n"
"            get_nprocs_conf(), get_nprocs());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_nprocs_conf.3:106
msgid "B<nproc>(1)"
msgstr ""

#. type: TH
#: man-pages/man3/getifaddrs.3:36
#, no-wrap
msgid "GETIFADDRS"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:39
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:45
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:47
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:58
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing"
" the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:77
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:84
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr ""

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: man-pages/man3/getifaddrs.3:91
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:100
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:109
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)  This field may contain a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:116
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family.  This "
"field may contain a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:131
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:136
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:142
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be"
" freed using B<freeifaddrs>()  when no longer needed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:149
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:162
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), B<malloc>(3), or B<realloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:170
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation supported only IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is "
"available only on kernels that support netlink."
msgstr ""

#. type: tbl table
#: man-pages/man3/getifaddrs.3:181
#, no-wrap
msgid ""
"B<getifaddrs>(),\n"
"B<freeifaddrs>()"
msgstr ""

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: man-pages/man3/getifaddrs.3:204
msgid ""
"Not in POSIX.1.  This function first appeared in BSDi and is present on the "
"BSD systems, but with slightly different semantics documented\\(emreturning "
"one entry per interface, not per address.  This means I<ifa_addr> and other "
"fields can actually be NULL if the interface has no address, and no link-"
"level address is returned if the interface has an IP address assigned.  "
"Also, the way of choosing either I<ifa_broadaddr> or I<ifa_dstaddr> differs "
"on various systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:221
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"rtnl_link_stats>, defined in I<E<lt>linux/if_link.hE<gt>> (in Linux 2.4 and "
"earlier, I<struct net_device_stats>, defined in "
"I<E<lt>linux/netdevice.hE<gt>>), which contains various interface attributes"
" and statistics."
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:228
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(),"
" and B<getnameinfo>(3).  Here is what we see when running this program on "
"one system:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:249
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo       AF_PACKET (17)\n"
"                tx_packets =        524; rx_packets =        524\n"
"                tx_bytes   =      38788; rx_bytes   =      38788\n"
"wlp3s0   AF_PACKET (17)\n"
"                tx_packets =     108391; rx_packets =     130245\n"
"                tx_bytes   =   30420659; rx_bytes   =   94230014\n"
"em1      AF_PACKET (17)\n"
"                tx_packets =          0; rx_packets =          0\n"
"                tx_bytes   =          0; rx_bytes   =          0\n"
"lo       AF_INET (2)\n"
"                address: E<lt>127.0.0.1E<gt>\n"
"wlp3s0   AF_INET (2)\n"
"                address: E<lt>192.168.235.137E<gt>\n"
"lo       AF_INET6 (10)\n"
"                address: E<lt>::1E<gt>\n"
"wlp3s0   AF_INET6 (10)\n"
"                address: E<lt>fe80::7ee9:d3ff:fef5:1a91%wlp3s0E<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:263
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get defns of NI_MAXSERV and NI_MAXHOST */\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/if_link.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:269
#, no-wrap
msgid ""
"int main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr, *ifa;\n"
"    int family, s, n;\n"
"    char host[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:274
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:277
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:281
#, no-wrap
msgid ""
"    for (ifa = ifaddr, n = 0; ifa != NULL; ifa = ifa-E<gt>ifa_next, n++) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:283
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:286
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:293
#, no-wrap
msgid ""
"        printf(\"%-8s %s (%d)\\en\",\n"
"               ifa-E<gt>ifa_name,\n"
"               (family == AF_PACKET) ? \"AF_PACKET\" :\n"
"               (family == AF_INET) ? \"AF_INET\" :\n"
"               (family == AF_INET6) ? \"AF_INET6\" : \"???\",\n"
"               family);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:295
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:306
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST,\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:308
#, no-wrap
msgid "            printf(\"\\et\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:311
#, no-wrap
msgid ""
"        } else if (family == AF_PACKET && ifa-E<gt>ifa_data != NULL) {\n"
"            struct rtnl_link_stats *stats = ifa-E<gt>ifa_data;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:318
#, no-wrap
msgid ""
"            printf(\"\\et\\ettx_packets = %10u; rx_packets = %10u\\en\"\n"
"                   \"\\et\\ettx_bytes   = %10u; rx_bytes   = %10u\\en\",\n"
"                   stats-E<gt>tx_packets, stats-E<gt>rx_packets,\n"
"                   stats-E<gt>tx_bytes, stats-E<gt>rx_bytes);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:322
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getifaddrs.3:328
msgid ""
"B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: man-pages/man3/getline.3:26
#, no-wrap
msgid "GETLINE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:29
msgid "getline, getdelim - delimited string input"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:34
#, no-wrap
msgid ""
"B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:37
#, no-wrap
msgid ""
"B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, "
"FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:47
msgid "B<getline>(), B<getdelim>():"
msgstr ""

#. type: TP
#: man-pages/man3/getline.3:49
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:52
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: man-pages/man3/getline.3:52
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:65
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is null-"
"terminated and includes the newline character, if one was found."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:77
msgid ""
"If I<*lineptr> is set to NULL and I<*n> is set 0 before the call, then "
"B<getline>()  will allocate a buffer for storing the line.  This buffer "
"should be freed by the user program even if B<getline>()  failed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:95
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:101
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:112
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:121
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters"
" read, including the delimiter character, but not including the terminating "
"null byte (\\(aq\\e0\\(aq).  This value can be used to handle embedded null "
"bytes in the line read."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:127
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition).  In the event of an error, I<errno> is set to indicate the "
"cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:137
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:140
msgid "Allocation or reallocation of the line buffer failed."
msgstr ""

#. type: tbl table
#: man-pages/man3/getline.3:151
#, no-wrap
msgid ""
"B<getline>(),\n"
"B<getdelim>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:161
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:166
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:174
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *stream;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t nread;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:179
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:185
#, no-wrap
msgid ""
"    stream = fopen(argv[1], \"r\");\n"
"    if (stream == NULL) {\n"
"        perror(\"fopen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:190
#, no-wrap
msgid ""
"    while ((nread = getline(&line, &len, stream)) != -1) {\n"
"        printf(\"Retrieved line of length %zu:\\en\", nread);\n"
"        fwrite(line, nread, 1, stdout);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:195
#, no-wrap
msgid ""
"    free(line);\n"
"    fclose(stream);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getline.3:201
msgid "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<scanf>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:37
msgid ""
"glob, globfree - find pathnames matching a pattern, free memory from glob()"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:40
#, no-wrap
msgid "B<#include E<lt>glob.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:45
#, no-wrap
msgid ""
"B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"
"B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int >I<eerrno>B<),>\n"
"B<         glob_t *>I<pglob>B<);>\n"
"B<void globfree(glob_t *>I<pglob>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:56
msgid ""
"The B<glob>()  function searches for all the pathnames matching I<pattern> "
"according to the rules used by the shell (see B<glob>(7)).  No tilde "
"expansion or parameter substitution is done; if you want these, use "
"B<wordexp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:62
msgid ""
"The B<globfree>()  function frees the dynamically allocated storage from an "
"earlier call to B<glob>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:73
msgid ""
"The results of a B<glob>()  call are stored in the structure pointed to by "
"I<pglob>.  This structure is of type I<glob_t> (declared in "
"I<E<lt>glob.hE<gt>>)  and includes the following elements defined by POSIX.2"
" (more may be present as an extension):"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:81
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t   gl_pathc;    /* Count of paths matched so far  */\n"
"    char   **gl_pathv;    /* List of matched pathnames.  */\n"
"    size_t   gl_offs;     /* Slots to reserve in I<gl_pathv>.  */\n"
"} glob_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:85
msgid "Results are stored in dynamically allocated storage."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:91
msgid ""
"The argument I<flags> is made up of the bitwise OR of zero or more the "
"following symbolic constants, which modify the behavior of B<glob>():"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:91
#, no-wrap
msgid "B<GLOB_ERR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:99
msgid ""
"Return upon a read error (because a directory does not have read permission,"
" for example).  By default, B<glob>()  attempts carry on despite errors, "
"reading all of the directories that it can."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:99
#, no-wrap
msgid "B<GLOB_MARK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:102
msgid "Append a slash to each path which corresponds to a directory."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:102
#, no-wrap
msgid "B<GLOB_NOSORT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:107
msgid ""
"Don't sort the returned pathnames.  The only reason to do this is to save "
"processing time.  By default, the returned pathnames are sorted."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:107
#, no-wrap
msgid "B<GLOB_DOOFFS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:114
msgid ""
"Reserve I<pglob-E<gt>gl_offs> slots at the beginning of the list of strings "
"in I<pglob-E<gt>pathv>.  The reserved slots contain null pointers."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:114
#, no-wrap
msgid "B<GLOB_NOCHECK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:122
msgid ""
"If no pattern matches, return the original pattern.  By default, B<glob>()  "
"returns B<GLOB_NOMATCH> if there are no matches."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:122
#, no-wrap
msgid "B<GLOB_APPEND>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:129
msgid ""
"Append the results of this call to the vector of results returned by a "
"previous call to B<glob>().  Do not set this flag on the first invocation of"
" B<glob>()."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:129
#, no-wrap
msgid "B<GLOB_NOESCAPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:136
msgid ""
"Don't allow backslash (\\(aq\\e\\(aq) to be used as an escape character.  "
"Normally, a backslash can be used to quote the following character, "
"providing a mechanism to turn off the special meaning metacharacters."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:140
msgid ""
"I<flags> may also include any of the following, which are GNU extensions and"
" not defined by POSIX.2:"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:140
#, no-wrap
msgid "B<GLOB_PERIOD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:144
msgid ""
"Allow a leading period to be matched by metacharacters.  By default, "
"metacharacters can't match a leading period."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:144
#, no-wrap
msgid "B<GLOB_ALTDIRFUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:154
msgid ""
"Use alternative functions I<pglob-E<gt>gl_closedir>, "
"I<pglob-E<gt>gl_readdir>, I<pglob-E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat>, "
"and I<pglob-E<gt>gl_stat> for filesystem access instead of the normal "
"library functions."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:154
#, no-wrap
msgid "B<GLOB_BRACE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:170
msgid ""
"Expand B<csh>(1)  style brace expressions of the form B<{a,b}>.  Brace "
"expressions can be nested.  Thus, for example, specifying the pattern "
"\"{foo/{,cat,dog},bar}\" would return the same results as four separate "
"B<glob>()  calls using the strings: \"foo/\", \"foo/cat\", \"foo/dog\", and "
"\"bar\"."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:170
#, no-wrap
msgid "B<GLOB_NOMAGIC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:175
msgid ""
"If the pattern contains no metacharacters, then it should be returned as the"
" sole matching word, even if there is no file with that name."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:175
#, no-wrap
msgid "B<GLOB_TILDE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:187
msgid ""
"Carry out tilde expansion.  If a tilde (\\(aq~\\(aq) is the only character "
"in the pattern, or an initial tilde is followed immediately by a slash "
"(\\(aq/\\(aq), then the home directory of the caller is substituted for the "
"tilde.  If an initial tilde is followed by a username (e.g., "
"\"~andrea/bin\"), then the tilde and username are substituted by the home "
"directory of that user.  If the username is invalid, or the home directory "
"cannot be determined, then no substitution is performed."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:187
#, no-wrap
msgid "B<GLOB_TILDE_CHECK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:198
msgid ""
"This provides behavior similar to that of B<GLOB_TILDE>.  The difference is "
"that if the username is invalid, or the home directory cannot be determined,"
" then instead of using the pattern itself as the name, B<glob>()  returns "
"B<GLOB_NOMATCH> to indicate an error."
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:198
#, no-wrap
msgid "B<GLOB_ONLYDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:211
msgid ""
"This is a I<hint> to B<glob>()  that the caller is interested only in "
"directories that match the pattern.  If the implementation can easily "
"determine file-type information, then nondirectory files are not returned to"
" the caller.  However, the caller must still check that returned files are "
"directories.  (The purpose of this flag is merely to optimize performance "
"when the caller is interested only in directories.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:234
msgid ""
"If I<errfunc> is not NULL, it will be called in case of an error with the "
"arguments I<epath>, a pointer to the path which failed, and I<eerrno>, the "
"value of I<errno> as returned from one of the calls to B<opendir>(3), "
"B<readdir>(3), or B<stat>(2).  If I<errfunc> returns nonzero, or if "
"B<GLOB_ERR> is set, B<glob>()  will terminate after the call to I<errfunc>."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:241
msgid ""
"Upon successful return, I<pglob-E<gt>gl_pathc> contains the number of "
"matched pathnames and I<pglob-E<gt>gl_pathv> contains a pointer to the list "
"of pointers to matched pathnames.  The list of pointers is terminated by a "
"null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:250
msgid ""
"It is possible to call B<glob>()  several times.  In that case, the "
"B<GLOB_APPEND> flag has to be set in I<flags> on the second and later "
"invocations."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:258
msgid ""
"As a GNU extension, I<pglob-E<gt>gl_flags> is set to the flags specified, "
"B<or>ed with B<GLOB_MAGCHAR> if any metacharacters were found."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:263
msgid ""
"On successful completion, B<glob>()  returns zero.  Other possible returns "
"are:"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:263
#, no-wrap
msgid "B<GLOB_NOSPACE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:266
msgid "for running out of memory,"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:266
#, no-wrap
msgid "B<GLOB_ABORTED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:269
msgid "for a read error, and"
msgstr ""

#. type: TP
#: man-pages/man3/glob.3:269
#, no-wrap
msgid "B<GLOB_NOMATCH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:272
msgid "for no found matches."
msgstr ""

#. type: tbl table
#: man-pages/man3/glob.3:282
#, no-wrap
msgid "B<glob>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/glob.3:284
#, no-wrap
msgid "MT-Unsafe race:utent env\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/glob.3:289
#, no-wrap
msgid "B<globfree>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:306
msgid ""
"In the above table, I<utent> in I<race:utent> signifies that if any of the "
"functions B<setutent>(3), B<getutent>(3), or B<endutent>(3)  are used in "
"parallel in different threads of a program, then data races could occur.  "
"B<glob>()  calls those functions, so we use race:utent to remind users."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:308
msgid "POSIX.1-2001, POSIX.1-2008, POSIX.2."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:319
msgid ""
"The structure elements I<gl_pathc> and I<gl_offs> are declared as I<size_t> "
"in glibc 2.1, as they should be according to POSIX.2, but are declared as "
"I<int> in glibc 2.0."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:328
msgid ""
"The B<glob>()  function may fail due to failure of underlying function "
"calls, such as B<malloc>(3)  or B<opendir>(3).  These will store their error"
" code in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:330
msgid "One example of use is the following code, which simulates typing"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:334
#, no-wrap
msgid "ls -l *.c ../*.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:338
msgid "in the shell:"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:342
#, no-wrap
msgid "glob_t globbuf;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:349
#, no-wrap
msgid ""
"globbuf.gl_offs = 2;\n"
"glob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\n"
"glob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\n"
"globbuf.gl_pathv[0] = \"ls\";\n"
"globbuf.gl_pathv[1] = \"-l\";\n"
"execvp(\"ls\", &globbuf.gl_pathv[0]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/glob.3:361
msgid ""
"B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/getaddrinfo_a.3:30
#, no-wrap
msgid "GETADDRINFO_A"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:34
msgid ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - asynchronous network "
"address and service translation"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:38
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:41
#, no-wrap
msgid ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:44
#, no-wrap
msgid ""
"B<int gai_suspend(const struct gaicb * const >I<list[]>B<, int >I<nitems>B<,>\n"
"B<                const struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:46
#, no-wrap
msgid "B<int gai_error(struct gaicb *>I<req>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:48
#, no-wrap
msgid "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:50
#, no-wrap
msgid "Link with I<-lanl>.\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:58
msgid ""
"The B<getaddrinfo_a>()  function performs the same task as "
"B<getaddrinfo>(3), but allows multiple name look-ups to be performed "
"asynchronously, with optional notification on completion of look-up "
"operations."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:62
msgid "The I<mode> argument has one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:62
#, no-wrap
msgid "B<GAI_WAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:66
msgid ""
"Perform the look-ups synchronously.  The call blocks until the look-ups have"
" completed."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:66
#, no-wrap
msgid "B<GAI_NOWAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:74
msgid ""
"Perform the look-ups asynchronously.  The call returns immediately, and the "
"requests are resolved in the background.  See the discussion of the I<sevp> "
"argument below."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:89
msgid ""
"The array I<list> specifies the look-up requests to process.  The I<nitems> "
"argument specifies the number of elements in I<list>.  The requested look-up"
" operations are started in parallel.  NULL elements in I<list> are ignored."
"  Each request is described by a I<gaicb> structure, defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:98
#, no-wrap
msgid ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:129
msgid ""
"The elements of this structure correspond to the arguments of "
"B<getaddrinfo>(3).  Thus, I<ar_name> corresponds to the I<node> argument and"
" I<ar_service> to the I<service> argument, identifying an Internet host and "
"a service.  The I<ar_request> element corresponds to the I<hints> argument, "
"specifying the criteria for selecting the returned socket address "
"structures.  Finally, I<ar_result> corresponds to the I<res> argument; you "
"do not need to initialize this element, it will be automatically set when "
"the request is resolved.  The I<addrinfo> structure referenced by the last "
"two elements is described in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:145
msgid ""
"When I<mode> is specified as B<GAI_NOWAIT>, notifications about resolved "
"requests can be obtained by employing the I<sigevent> structure pointed to "
"by the I<sevp> argument.  For the definition and general details of this "
"structure, see B<sigevent>(7).  The I<sevp-E<gt>sigev_notify> field can have"
" the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:145
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:148
msgid "Don't provide any notification."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:148
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr ""

#.  si_pid and si_uid are also set, to the values of the calling process,
#.  which doesn't provide useful information, so we'll skip mentioning it.
#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:164
msgid ""
"When a look-up completes, generate the signal I<sigev_signo> for the "
"process.  See B<sigevent>(7)  for general details.  The I<si_code> field of "
"the I<siginfo_t> structure will be set to B<SI_ASYNCNL>."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:164
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:172
msgid ""
"When a look-up completes, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:181
msgid ""
"For B<SIGEV_SIGNAL> and B<SIGEV_THREAD>, it may be useful to point "
"I<sevp-E<gt>sigev_value.sival_ptr> to I<list>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:192
msgid ""
"The B<gai_suspend>()  function suspends execution of the calling thread, "
"waiting for the completion of one or more requests in the array I<list>.  "
"The I<nitems> argument specifies the size of the array I<list>.  The call "
"blocks until one of the following occurs:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:196
msgid "One or more of the operations in I<list> completes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:198
msgid "The call is interrupted by a signal that is caught."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:211
msgid ""
"The time interval specified in I<timeout> elapses.  This argument specifies "
"a timeout in seconds plus nanoseconds (see B<nanosleep>(2)  for details of "
"the I<timespec> structure).  If I<timeout> is NULL, then the call blocks "
"indefinitely (until one of the events above occurs)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:216
msgid ""
"No explicit indication of which request was completed is given; you must "
"determine which request(s) have completed by iterating with B<gai_error>()  "
"over the list of requests."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:226
msgid ""
"The B<gai_error>()  function returns the status of the request I<req>: "
"either B<EAI_INPROGRESS> if the request was not completed yet, 0 if it was "
"handled successfully, or an error code if the request could not be resolved."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:243
msgid ""
"The B<gai_cancel>()  function cancels the request I<req>.  If the request "
"has been canceled successfully, the error status of the request will be set "
"to B<EAI_CANCELED> and normal asynchronous notification will be performed.  "
"The request cannot be canceled if it is currently being processed; in that "
"case, it will be handled as if B<gai_cancel>()  has never been called.  If "
"I<req> is NULL, an attempt is made to cancel all outstanding requests that "
"the process has made."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:248
msgid ""
"The B<getaddrinfo_a>()  function returns 0 if all of the requests have been "
"enqueued successfully, or one of the following nonzero error codes:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:253
msgid ""
"The resources necessary to enqueue the look-up requests were not available."
"  The application may check the error status of each request to determine "
"which ones failed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:260
msgid "I<mode> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:265
msgid ""
"The B<gai_suspend>()  function returns 0 if at least one of the listed "
"requests has been completed.  Otherwise, it returns one of the following "
"nonzero error codes:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:268
msgid ""
"The given timeout expired before any of the requests could be completed."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:268 man-pages/man3/getaddrinfo_a.3:298
#, no-wrap
msgid "B<EAI_ALLDONE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:271
msgid "There were no actual requests given to the function."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:271
#, no-wrap
msgid "B<EAI_INTR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:276
msgid ""
"A signal has interrupted the function.  Note that this interruption might "
"have been caused by signal notification of some completed look-up request."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:288
msgid ""
"The B<gai_error>()  function can return B<EAI_INPROGRESS> for an unfinished "
"look-up request, 0 for a successfully completed look-up (as described "
"above), one of the error codes that could be returned by B<getaddrinfo>(3), "
"or the error code B<EAI_CANCELED> if the request has been canceled "
"explicitly before it could be finished."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:292
msgid "The B<gai_cancel>()  function can return one of these values:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:292
#, no-wrap
msgid "B<EAI_CANCELED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:295
msgid "The request has been canceled successfully."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo_a.3:295
#, no-wrap
msgid "B<EAI_NOTCANCELED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:298
msgid "The request has not been canceled."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:301
msgid "The request has already completed."
msgstr ""

#. type: tbl table
#: man-pages/man3/getaddrinfo_a.3:319
#, no-wrap
msgid ""
"B<getaddrinfo_a>(),\n"
"B<gai_suspend>(),\n"
"B<gai_error>(),\n"
"B<gai_cancel>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:325
msgid ""
"These functions are GNU extensions; they first appeared in glibc in version "
"2.2.3."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:331
msgid ""
"The interface of B<getaddrinfo_a>()  was modeled after the B<lio_listio>(3)"
"  interface."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:335
msgid ""
"Two examples are provided: a simple example that resolves several requests "
"in parallel synchronously, and a complex example showing some of the "
"asynchronous capabilities."
msgstr ""

#. type: SS
#: man-pages/man3/getaddrinfo_a.3:335
#, no-wrap
msgid "Synchronous example"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:340
msgid ""
"The program below simply resolves several hostnames in parallel, giving a "
"speed-up compared to resolving the hostnames sequentially using "
"B<getaddrinfo>(3).  The program might be used like this:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:347
#, no-wrap
msgid ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:351
msgid "Here is the program source code"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:358 man-pages/man3/getaddrinfo_a.3:447
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:366
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:371
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:381
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:388
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:394
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:404
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:411
#, no-wrap
msgid ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SS
#: man-pages/man3/getaddrinfo_a.3:412
#, no-wrap
msgid "Asynchronous example"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:417
msgid ""
"This example shows a simple interactive B<getaddrinfo_a>()  front-end.  The "
"notification facility is not demonstrated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:419
msgid "An example session might look like this:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:436
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:440
msgid "The program source is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:450
#, no-wrap
msgid ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:455
#, no-wrap
msgid ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:459
#, no-wrap
msgid ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:462
#, no-wrap
msgid ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:465
#, no-wrap
msgid ""
"    return buf;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:473
#, no-wrap
msgid ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:477
#, no-wrap
msgid ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:481
#, no-wrap
msgid ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:483
#, no-wrap
msgid "    /* Queue nreqs_base..nreqs requests. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:492
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:501
#, no-wrap
msgid ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int i, ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:504 man-pages/man3/getaddrinfo_a.3:541
#, no-wrap
msgid ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:509 man-pages/man3/getaddrinfo_a.3:546
#, no-wrap
msgid ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:512
#, no-wrap
msgid ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:518
#, no-wrap
msgid ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:522
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:526
#, no-wrap
msgid ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:531
#, no-wrap
msgid ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:538
#, no-wrap
msgid ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:552
#, no-wrap
msgid ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:560
#, no-wrap
msgid ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int i, ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:564
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:567
#, no-wrap
msgid ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:582
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:588
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:591
#, no-wrap
msgid ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:616
#, no-wrap
msgid ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo_a.3:623
msgid ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/getnetent.3:30
#, no-wrap
msgid "GETNETENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:34
msgid ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - get network "
"entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:39
#, no-wrap
msgid "B<struct netent *getnetent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:41
#, no-wrap
msgid "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:43
#, no-wrap
msgid "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:45
#, no-wrap
msgid "B<void setnetent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:47
#, no-wrap
msgid "B<void endnetent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:57
msgid ""
"The B<getnetent>()  function reads the next entry from the networks database"
" and returns a I<netent> structure containing the broken-out fields from the"
" entry.  A connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:66
msgid ""
"The B<getnetbyname>()  function returns a I<netent> structure for the entry "
"from the database that matches the network I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:80
msgid ""
"The B<getnetbyaddr>()  function returns a I<netent> structure for the entry "
"from the database that matches the network number I<net> of type I<type>.  "
"The I<net> argument must be in host byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:92
msgid ""
"The B<setnetent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getnet*>()  functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:96
msgid "The B<endnetent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:102
msgid "The I<netent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:111
#, no-wrap
msgid ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:117
msgid "The members of the I<netent> structure are:"
msgstr ""

#. type: TP
#: man-pages/man3/getnetent.3:117
#, no-wrap
msgid "I<n_name>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:120
msgid "The official name of the network."
msgstr ""

#. type: TP
#: man-pages/man3/getnetent.3:120
#, no-wrap
msgid "I<n_aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:123
msgid "A NULL-terminated list of alternative names for the network."
msgstr ""

#. type: TP
#: man-pages/man3/getnetent.3:123
#, no-wrap
msgid "I<n_addrtype>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:127
msgid "The type of the network number; always B<AF_INET>."
msgstr ""

#. type: TP
#: man-pages/man3/getnetent.3:127
#, no-wrap
msgid "I<n_net>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:130
msgid "The network number in host byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:141
msgid ""
"The B<getnetent>(), B<getnetbyname>()  and B<getnetbyaddr>()  functions "
"return a pointer to a statically allocated I<netent> structure, or a null "
"pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: man-pages/man3/getnetent.3:142
#, no-wrap
msgid "I</etc/networks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:145
msgid "networks database file"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:155
#, no-wrap
msgid "B<getnetent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:157
#, no-wrap
msgid "MT-Unsafe race:netent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:159
#, no-wrap
msgid "race:netentbuf env locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:162
#, no-wrap
msgid "B<getnetbyname>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:164
#, no-wrap
msgid "MT-Unsafe race:netbyname\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:169
#, no-wrap
msgid "B<getnetbyaddr>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:171
#, no-wrap
msgid "MT-Unsafe race:netbyaddr\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:176
#, no-wrap
msgid "B<setnetent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:178
#, no-wrap
msgid "B<endnetent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getnetent.3:180
#, no-wrap
msgid "MT-Unsafe race:netent env\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:196
msgid ""
"In the above table, I<netent> in I<race:netent> signifies that if any of the"
" functions B<setnetent>(), B<getnetent>(), or B<endnetent>()  are used in "
"parallel in different threads of a program, then data races could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:205
msgid ""
"In glibc versions before 2.2, the I<net> argument of B<getnetbyaddr>()  was "
"of type I<long>."
msgstr ""

#.  .BR networks (5)
#. type: Plain text
#: man-pages/man3/getnetent.3:210
msgid "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getnetent.3:211
msgid "RFC\\ 1101"
msgstr ""

#. type: TH
#: man-pages/man3/getgrent_r.3:24
#, no-wrap
msgid "GETGRENT_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:27
msgid "getgrent_r, fgetgrent_r - get group file entry reentrantly"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:30
#, no-wrap
msgid "B<#include E<lt>grp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:33
#, no-wrap
msgid ""
"B<int getgrent_r(struct group *>I<gbuf>B<, char *>I<buf>B<,>\n"
"B<               size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:36
#, no-wrap
msgid ""
"B<int fgetgrent_r(FILE *>I<stream>B<, struct group *>I<gbuf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct group **>I<gbufp>B<);>\n"
msgstr ""

#.  FIXME . The FTM requirements seem inconsistent here.  File a glibc bug?
#. type: Plain text
#: man-pages/man3/getgrent_r.3:46
msgid "B<getgrent_r>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:52
#, no-wrap
msgid ""
"B<fgetgrent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:65
msgid ""
"The functions B<getgrent_r>()  and B<fgetgrent_r>()  are the reentrant "
"versions of B<getgrent>(3)  and B<fgetgrent>(3).  The former reads the next "
"group entry from the stream initialized by B<setgrent>(3).  The latter reads"
" the next group entry from I<stream>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:103
msgid ""
"The nonreentrant functions return a pointer to static storage, where this "
"static storage contains further pointers to group name, password and "
"members.  The reentrant functions described here return all of that in "
"caller-provided buffers.  First of all there is the buffer I<gbuf> that can "
"hold a I<struct group>.  And next the buffer I<buf> of size I<buflen> that "
"can hold additional strings.  The result of these functions, the I<struct "
"group> read from the stream, is stored in the provided buffer I<*gbuf>, and "
"a pointer to this I<struct group> is returned in I<*gbufp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:110
msgid ""
"On success, these functions return 0 and I<*gbufp> is a pointer to the "
"I<struct group>.  On error, these functions return an error value and "
"I<*gbufp> is NULL."
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrent_r.3:128
#, no-wrap
msgid "B<getgrent_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrent_r.3:131
#, no-wrap
msgid "B<fgetgrent_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:146
msgid ""
"In the above table, I<grent> in I<race:grent> signifies that if any of the "
"functions B<setgrent>(), B<getgrent>(), B<endgrent>(), or B<getgrent_r>()  "
"are used in parallel in different threads of a program, then data races "
"could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:156
#, no-wrap
msgid ""
"struct group *getgrent_r(struct group *grp, char *buf,\n"
"                         int buflen);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:165
#, no-wrap
msgid ""
"int getgrent_r(struct group *grp, char *buf, int buflen,\n"
"               FILE **gr_fp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:172
msgid ""
"The function B<getgrent_r>()  is not really reentrant since it shares the "
"reading position in the stream with all other threads."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:179
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>grp.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#define BUFLEN 4096\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:186
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct group grp, *grpp;\n"
"    char buf[BUFLEN];\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:203
#, no-wrap
msgid ""
"    setgrent();\n"
"    while (1) {\n"
"        i = getgrent_r(&grp, buf, BUFLEN, &grpp);\n"
"        if (i)\n"
"            break;\n"
"        printf(\"%s (%d):\", grpp-E<gt>gr_name, grpp-E<gt>gr_gid);\n"
"        for (i = 0; ; i++) {\n"
"            if (grpp-E<gt>gr_mem[i] == NULL)\n"
"                break;\n"
"            printf(\" %s\", grpp-E<gt>gr_mem[i]);\n"
"        }\n"
"        printf(\"\\en\");\n"
"    }\n"
"    endgrent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrent_r.3:219
msgid ""
"B<fgetgrent>(3), B<getgrent>(3), B<getgrgid>(3), B<getgrnam>(3), "
"B<putgrent>(3), B<group>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getspnam.3:8
#, no-wrap
msgid "GETSPNAM"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:13
msgid ""
"getspnam, getspnam_r, getspent, getspent_r, setspent, endspent, fgetspent, "
"fgetspent_r, sgetspent, sgetspent_r, putspent, lckpwdf, ulckpwdf - get "
"shadow password file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:17
#, no-wrap
msgid ""
"/* General shadow password file API */\n"
"B<#include E<lt>shadow.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:19
#, no-wrap
msgid "B<struct spwd *getspnam(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:21
#, no-wrap
msgid "B<struct spwd *getspent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:23
#, no-wrap
msgid "B<void setspent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:25
#, no-wrap
msgid "B<void endspent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:27
#, no-wrap
msgid "B<struct spwd *fgetspent(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:29
#, no-wrap
msgid "B<struct spwd *sgetspent(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:31
#, no-wrap
msgid "B<int putspent(const struct spwd *>I<p>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:33
#, no-wrap
msgid "B<int lckpwdf(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:35
#, no-wrap
msgid "B<int ulckpwdf(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:38
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>shadow.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:41
#, no-wrap
msgid ""
"B<int getspent_r(struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:44
#, no-wrap
msgid ""
"B<int getspnam_r(const char *>I<name>B<, struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:47
#, no-wrap
msgid ""
"B<int fgetspent_r(FILE *>I<stream>B<, struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:50
#, no-wrap
msgid ""
"B<int sgetspent_r(const char *>I<s>B<, struct spwd *>I<spbuf>B<,>\n"
"B<        char *>I<buf>B<, size_t >I<buflen>B<, struct spwd **>I<spbufp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:66
#, no-wrap
msgid ""
"B<getspent_r>(),\n"
"B<getspnam_r>(),\n"
"B<fgetspent_r>(),\n"
"B<sgetspent_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:79
msgid ""
"Long ago it was considered safe to have encrypted passwords openly visible "
"in the password file.  When computers got faster and people got more "
"security-conscious, this was no longer acceptable.  Julianne Frances Haugh "
"implemented the shadow password suite that keeps the encrypted passwords in "
"the shadow password database (e.g., the local shadow password file "
"I</etc/shadow>, NIS, and LDAP), readable only by root."
msgstr ""

#.  FIXME . I've commented out the following for the
#.  moment.  The relationship between PAM and nsswitch.conf needs
#.  to be clearly documented in one place, which is pointed to by
#.  the pages for the user, group, and shadow password functions.
#.  (Jul 2005, mtk)
#.  This shadow password setup has been superseded by PAM
#.  (pluggable authentication modules), and the file
#.  .I /etc/nsswitch.conf
#.  now describes the sources to be used.
#. type: Plain text
#: man-pages/man3/getspnam.3:96
msgid ""
"The functions described below resemble those for the traditional password "
"database (e.g., see B<getpwnam>(3)  and B<getpwent>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:103
msgid ""
"The B<getspnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the shadow password database that matches"
" the username I<name>."
msgstr ""

#.  some systems require a call of setspent() before the first getspent()
#.  glibc does not
#. type: Plain text
#: man-pages/man3/getspnam.3:115
msgid ""
"The B<getspent>()  function returns a pointer to the next entry in the "
"shadow password database.  The position in the input stream is initialized "
"by B<setspent>().  When done reading, the program may call B<endspent>()  so"
" that resources can be deallocated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:122
msgid ""
"The B<fgetspent>()  function is similar to B<getspent>()  but uses the "
"supplied stream instead of the one implicitly opened by B<setspent>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:129
msgid ""
"The B<sgetspent>()  function parses the supplied string I<s> into a struct "
"I<spwd>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:139
msgid ""
"The B<putspent>()  function writes the contents of the supplied struct "
"I<spwd> I<*p> as a text line in the shadow password file format to "
"I<stream>.  String entries with value NULL and numerical entries with value "
"-1 are written as an empty string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:154
msgid ""
"The B<lckpwdf>()  function is intended to protect against multiple "
"simultaneous accesses of the shadow password database.  It tries to acquire "
"a lock, and returns 0 on success, or -1 on failure (lock not obtained within"
" 15 seconds).  The B<ulckpwdf>()  function releases the lock again.  Note "
"that there is no protection against direct access of the shadow password "
"file.  Only programs that use B<lckpwdf>()  will notice the lock."
msgstr ""

#.  Also in libc5
#.  SUN doesn't have sgetspent()
#. type: Plain text
#: man-pages/man3/getspnam.3:159
msgid ""
"These were the functions that formed the original shadow API.  They are "
"widely available."
msgstr ""

#. type: SS
#: man-pages/man3/getspnam.3:159
#, no-wrap
msgid "Reentrant versions"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:176
msgid ""
"Analogous to the reentrant functions for the password database, glibc also "
"has reentrant functions for the shadow password database.  The "
"B<getspnam_r>()  function is like B<getspnam>()  but stores the retrieved "
"shadow password structure in the space pointed to by I<spbuf>.  This shadow "
"password structure contains pointers to strings, and these strings are "
"stored in the buffer I<buf> of size I<buflen>.  A pointer to the result (in "
"case of success) or NULL (in case no entry was found or an error occurred) "
"is stored in I<*spbufp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:183
msgid ""
"The functions B<getspent_r>(), B<fgetspent_r>(), and B<sgetspent_r>()  are "
"similarly analogous to their nonreentrant counterparts."
msgstr ""

#.  SUN doesn't have sgetspent_r()
#. type: Plain text
#: man-pages/man3/getspnam.3:187
msgid ""
"Some non-glibc systems also have functions with these names, often with "
"different prototypes."
msgstr ""

#. type: SS
#: man-pages/man3/getspnam.3:187
#, no-wrap
msgid "Structure"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:189
msgid ""
"The shadow password structure is defined in I<E<lt>shadow.hE<gt>> as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:209
#, no-wrap
msgid ""
"struct spwd {\n"
"    char *sp_namp;     /* Login name */\n"
"    char *sp_pwdp;     /* Encrypted password */\n"
"    long  sp_lstchg;   /* Date of last change\n"
"                          (measured in days since\n"
"                          1970-01-01 00:00:00 +0000 (UTC)) */\n"
"    long  sp_min;      /* Min # of days between changes */\n"
"    long  sp_max;      /* Max # of days between changes */\n"
"    long  sp_warn;     /* # of days before password expires\n"
"                          to warn user to change it */\n"
"    long  sp_inact;    /* # of days after password expires\n"
"                          until account is disabled */\n"
"    long  sp_expire;   /* Date when account expires\n"
"                          (measured in days since\n"
"                          1970-01-01 00:00:00 +0000 (UTC)) */\n"
"    unsigned long sp_flag;  /* Reserved */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:218
msgid ""
"The functions that return a pointer return NULL if no more entries are "
"available or if an error occurs during processing.  The functions which have"
" I<int> as the return value return 0 for success and -1 for failure, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:221
msgid ""
"For the nonreentrant functions, the return value may point to static area, "
"and may be overwritten by subsequent calls to these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:224
msgid ""
"The reentrant functions return zero on success.  In case of error, an error "
"number is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:228
msgid ""
"The caller does not have permission to access the shadow password file."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:231
msgid "Supplied buffer is too small."
msgstr ""

#. type: TP
#: man-pages/man3/getspnam.3:232
#, no-wrap
msgid "I</etc/shadow>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:235
msgid "local shadow password database file"
msgstr ""

#. type: TP
#: man-pages/man3/getspnam.3:235
#, no-wrap
msgid "I</etc/.pwd.lock>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:238
msgid "lock file"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:244
msgid ""
"The include file I<E<lt>paths.hE<gt>> defines the constant B<_PATH_SHADOW> "
"to the pathname of the shadow password file."
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:254
#, no-wrap
msgid "B<getspnam>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:256
#, no-wrap
msgid "MT-Unsafe race:getspnam locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:259
#, no-wrap
msgid "B<getspent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:261
#, no-wrap
msgid "MT-Unsafe race:getspent\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:263
#, no-wrap
msgid "race:spentbuf locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:266
#, no-wrap
msgid "B<setspent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:268
#, no-wrap
msgid "B<endspent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:270
#, no-wrap
msgid "B<getspent_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:272
#, no-wrap
msgid "MT-Unsafe race:getspent locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:275
#, no-wrap
msgid "B<fgetspent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:275
#, no-wrap
msgid "MT-Unsafe race:fgetspent"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:278
#, no-wrap
msgid "B<sgetspent>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:278
#, no-wrap
msgid "MT-Unsafe race:sgetspent"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:281
#, no-wrap
msgid "B<putspent>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:283
#, no-wrap
msgid "B<getspnam_r>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:285
#, no-wrap
msgid "B<sgetspent_r>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:288
#, no-wrap
msgid "B<lckpwdf>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:290
#, no-wrap
msgid "B<ulckpwdf>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getspnam.3:292
#, no-wrap
msgid "B<fgetspent_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:307
msgid ""
"In the above table, I<getspent> in I<race:getspent> signifies that if any of"
" the functions B<setspent>(), B<getspent>(), B<getspent_r>(), or "
"B<endspent>()  are used in parallel in different threads of a program, then "
"data races could occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:311
msgid ""
"The shadow password database and its associated API are not specified in "
"POSIX.1.  However, many other systems provide a similar API."
msgstr ""

#. type: Plain text
#: man-pages/man3/getspnam.3:315
msgid "B<getgrnam>(3), B<getpwnam>(3), B<getpwnam_r>(3), B<shadow>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getaddrinfo.3:44
#, no-wrap
msgid "GETADDRINFO"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:48
msgid ""
"getaddrinfo, freeaddrinfo, gai_strerror - network address and service "
"translation"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:53
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:57
#, no-wrap
msgid ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:59
#, no-wrap
msgid "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:61
#, no-wrap
msgid "B<const char *gai_strerror(int >I<errcode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:74
#, no-wrap
msgid ""
"B<getaddrinfo>(),\n"
"B<freeaddrinfo>(),\n"
"B<gai_strerror>():\n"
"    Since glibc 2.22: _POSIX_C_SOURCE E<gt>= 200112L\n"
"    Glibc 2.21 and earlier: _POSIX_C_SOURCE\n"
msgstr ""

#.  .BR getipnodebyname (3),
#.  .BR getipnodebyaddr (3),
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:100
msgid ""
"Given I<node> and I<service>, which identify an Internet host and a service,"
" B<getaddrinfo>()  returns one or more I<addrinfo> structures, each of which"
" contains an Internet address that can be specified in a call to B<bind>(2)"
"  or B<connect>(2).  The B<getaddrinfo>()  function combines the "
"functionality provided by the B<gethostbyname>(3)  and B<getservbyname>(3)  "
"functions into a single interface, but unlike the latter functions, "
"B<getaddrinfo>()  is reentrant and allows programs to eliminate IPv4-versus-"
"IPv6 dependencies."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:106
msgid ""
"The I<addrinfo> structure used by B<getaddrinfo>()  contains the following "
"fields:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:119
#, no-wrap
msgid ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:141
msgid ""
"The I<hints> argument points to an I<addrinfo> structure that specifies "
"criteria for selecting the socket address structures returned in the list "
"pointed to by I<res>.  If I<hints> is not NULL it points to an I<addrinfo> "
"structure whose I<ai_family>, I<ai_socktype>, and I<ai_protocol> specify "
"criteria that limit the set of socket addresses returned by "
"B<getaddrinfo>(), as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:141
#, no-wrap
msgid "I<ai_family>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:157
msgid ""
"This field specifies the desired address family for the returned addresses."
"  Valid values for this field include B<AF_INET> and B<AF_INET6>.  The value"
" B<AF_UNSPEC> indicates that B<getaddrinfo>()  should return socket "
"addresses for any address family (either IPv4 or IPv6, for example) that can"
" be used with I<node> and I<service>."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:157
#, no-wrap
msgid "I<ai_socktype>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:166
msgid ""
"This field specifies the preferred socket type, for example B<SOCK_STREAM> "
"or B<SOCK_DGRAM>.  Specifying 0 in this field indicates that socket "
"addresses of any type can be returned by B<getaddrinfo>()."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:166
#, no-wrap
msgid "I<ai_protocol>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:172
msgid ""
"This field specifies the protocol for the returned socket addresses.  "
"Specifying 0 in this field indicates that socket addresses with any protocol"
" can be returned by B<getaddrinfo>()."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:172
#, no-wrap
msgid "I<ai_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:176
msgid ""
"This field specifies additional options, described below.  Multiple flags "
"are specified by bitwise OR-ing them together."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:180
msgid ""
"All the other fields in the structure pointed to by I<hints> must contain "
"either 0 or a null pointer, as appropriate."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:215
msgid ""
"Specifying I<hints> as NULL is equivalent to setting I<ai_socktype> and "
"I<ai_protocol> to 0; I<ai_family> to B<AF_UNSPEC>; and I<ai_flags> to "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>.  (POSIX specifies different defaults "
"for I<ai_flags>; see NOTES.)  I<node> specifies either a numerical network "
"address (for IPv4, numbers-and-dots notation as supported by "
"B<inet_aton>(3); for IPv6, hexadecimal string format as supported by "
"B<inet_pton>(3)), or a network hostname, whose network addresses are looked "
"up and resolved.  If I<hints.ai_flags> contains the B<AI_NUMERICHOST> flag, "
"then I<node> must be a numerical network address.  The B<AI_NUMERICHOST> "
"flag suppresses any potentially lengthy network host address lookups."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:240
msgid ""
"If the B<AI_PASSIVE> flag is specified in I<hints.ai_flags>, and I<node> is "
"NULL, then the returned socket addresses will be suitable for B<bind>(2)ing "
"a socket that will B<accept>(2)  connections.  The returned socket address "
"will contain the \"wildcard address\" (B<INADDR_ANY> for IPv4 addresses, "
"B<IN6ADDR_ANY_INIT> for IPv6 address).  The wildcard address is used by "
"applications (typically servers)  that intend to accept connections on any "
"of the host's network addresses.  If I<node> is not NULL, then the "
"B<AI_PASSIVE> flag is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:260
msgid ""
"If the B<AI_PASSIVE> flag is not set in I<hints.ai_flags>, then the returned"
" socket addresses will be suitable for use with B<connect>(2), B<sendto>(2),"
" or B<sendmsg>(2).  If I<node> is NULL, then the network address will be set"
" to the loopback interface address (B<INADDR_LOOPBACK> for IPv4 addresses, "
"B<IN6ADDR_LOOPBACK_INIT> for IPv6 address); this is used by applications "
"that intend to communicate with peers running on the same host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:283
msgid ""
"I<service> sets the port in each returned address structure.  If this "
"argument is a service name (see B<services>(5)), it is translated to the "
"corresponding port number.  This argument can also be specified as a decimal"
" number, which is simply converted to binary.  If I<service> is NULL, then "
"the port number of the returned socket addresses will be left uninitialized."
"  If B<AI_NUMERICSERV> is specified in I<hints.ai_flags> and I<service> is "
"not NULL, then I<service> must point to a string containing a numeric port "
"number.  This flag is used to inhibit the invocation of a name resolution "
"service in cases where it is known not to be required."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:289
msgid "Either I<node> or I<service>, but not both, may be NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:305
msgid ""
"The B<getaddrinfo>()  function allocates and initializes a linked list of "
"I<addrinfo> structures, one for each network address that matches I<node> "
"and I<service>, subject to any restrictions imposed by I<hints>, and returns"
" a pointer to the start of the list in I<res>.  The items in the linked list"
" are linked by the I<ai_next> field."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:327
msgid ""
"There are several reasons why the linked list may have more than one "
"I<addrinfo> structure, including: the network host is multihomed, accessible"
" over multiple protocols (e.g., both B<AF_INET> and B<AF_INET6>); or the "
"same service is available from multiple socket types (one B<SOCK_STREAM> "
"address and another B<SOCK_DGRAM> address, for example).  Normally, the "
"application should try using the addresses in the order in which they are "
"returned.  The sorting function used within B<getaddrinfo>()  is defined in "
"RFC\\ 3484; the order can be tweaked for a particular system by editing "
"I</etc/gai.conf> (available since glibc 2.5)."
msgstr ""

#.  In glibc prior to 2.3.4, the ai_canonname of each addrinfo
#.  structure was set pointing to the canonical name; that was
#.  more than POSIX.1-2001 specified, or other implementations provided.
#.  MTK, Aug 05
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:342
msgid ""
"If I<hints.ai_flags> includes the B<AI_CANONNAME> flag, then the "
"I<ai_canonname> field of the first of the I<addrinfo> structures in the "
"returned list is set to point to the official name of the host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:346
msgid ""
"The remaining fields of each returned I<addrinfo> structure are initialized "
"as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:369
msgid ""
"The I<ai_family>, I<ai_socktype>, and I<ai_protocol> fields return the "
"socket creation parameters (i.e., these fields have the same meaning as the "
"corresponding arguments of B<socket>(2)).  For example, I<ai_family> might "
"return B<AF_INET> or B<AF_INET6>; I<ai_socktype> might return B<SOCK_DGRAM> "
"or B<SOCK_STREAM>; and I<ai_protocol> returns the protocol for the socket."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:376
msgid ""
"A pointer to the socket address is placed in the I<ai_addr> field, and the "
"length of the socket address, in bytes, is placed in the I<ai_addrlen> "
"field."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:395
msgid ""
"If I<hints.ai_flags> includes the B<AI_ADDRCONFIG> flag, then IPv4 addresses"
" are returned in the list pointed to by I<res> only if the local system has "
"at least one IPv4 address configured, and IPv6 addresses are returned only "
"if the local system has at least one IPv6 address configured.  The loopback "
"address is not considered for this case as valid as a configured address.  "
"This flag is useful on, for example, IPv4-only systems, to ensure that "
"B<getaddrinfo>()  does not return IPv6 socket addresses that would always "
"fail in B<connect>(2)  or B<bind>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:420
msgid ""
"If I<hints.ai_flags> specifies the B<AI_V4MAPPED> flag, and "
"I<hints.ai_family> was specified as B<AF_INET6>, and no matching IPv6 "
"addresses could be found, then return IPv4-mapped IPv6 addresses in the list"
" pointed to by I<res>.  If both B<AI_V4MAPPED> and B<AI_ALL> are specified "
"in I<hints.ai_flags>, then return both IPv6 and IPv4-mapped IPv6 addresses "
"in the list pointed to by I<res>.  B<AI_ALL> is ignored if B<AI_V4MAPPED> is"
" not also specified."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:426
msgid ""
"The B<freeaddrinfo>()  function frees the memory that was allocated for the "
"dynamically allocated linked list I<res>."
msgstr ""

#. type: SS
#: man-pages/man3/getaddrinfo.3:426
#, no-wrap
msgid "Extensions to getaddrinfo() for Internationalized Domain Names"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:435
msgid ""
"Starting with glibc 2.3.4, B<getaddrinfo>()  has been extended to "
"selectively allow the incoming and outgoing hostnames to be transparently "
"converted to and from the Internationalized Domain Name (IDN) format (see "
"RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>).  Four "
"new flags are defined:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:435
#, no-wrap
msgid "B<AI_IDN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:441
msgid ""
"If this flag is specified, then the node name given in I<node> is converted "
"to IDN format if necessary.  The source encoding is that of the current "
"locale."
msgstr ""

#.  Implementation Detail:
#.  To minimize effects on system performance the implementation might
#.  want to check whether the input string contains any non-ASCII
#.  characters.  If there are none the IDN step can be skipped completely.
#.  On systems which allow not-ASCII safe encodings for a locale this
#.  might be a problem.
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:453
msgid ""
"If the input name contains non-ASCII characters, then the IDN encoding is "
"used.  Those parts of the node name (delimited by dots) that contain non-"
"ASCII characters are encoded using ASCII Compatible Encoding (ACE)  before "
"being passed to the name resolution functions."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:453
#, no-wrap
msgid "B<AI_CANONIDN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:465
msgid ""
"After a successful name lookup, and if the B<AI_CANONNAME> flag was "
"specified, B<getaddrinfo>()  will return the canonical name of the node "
"corresponding to the I<addrinfo> structure value passed back.  The return "
"value is an exact copy of the value returned by the name resolution "
"function."
msgstr ""

#. Implementation Detail:
#. If no component of the returned name starts with xn\-\- the IDN
#. step can be skipped, therefore avoiding unnecessary slowdowns.
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:478
msgid ""
"If the name is encoded using ACE, then it will contain the I<xn--> prefix "
"for one or more components of the name.  To convert these components into a "
"readable form the B<AI_CANONIDN> flag can be passed in addition to "
"B<AI_CANONNAME>.  The resulting string is encoded using the current locale's"
" encoding."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:478
#, no-wrap
msgid "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"
msgstr ""

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getaddrinfo(); they need to
#.  be documented.
#.     #ifdef __USE_GNU
#.     #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.     #define EAI_CANCELED    -101  /* Request canceled.  */
#.     #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.     #define EAI_ALLDONE     -103  /* All requests done.  */
#.     #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.     #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.     #endif
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:499
msgid ""
"B<getaddrinfo>()  returns 0 if it succeeds, or one of the following nonzero "
"error codes:"
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:499
#, no-wrap
msgid "B<EAI_ADDRFAMILY>"
msgstr ""

#.  Not in SUSv3
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:504
msgid ""
"The specified network host does not have any network addresses in the "
"requested address family."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:508
msgid ""
"The name server returned a temporary failure indication.  Try again later."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:518
msgid ""
"I<hints.ai_flags> contains invalid flags; or, I<hints.ai_flags> included "
"B<AI_CANONNAME> and I<name> was NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:521
msgid "The name server returned a permanent failure indication."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:524
msgid "The requested address family is not supported."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:527
#, no-wrap
msgid "B<EAI_NODATA>"
msgstr ""

#.  Not in SUSv3
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:532
msgid ""
"The specified network host exists, but does not have any network addresses "
"defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:549
msgid ""
"The I<node> or I<service> is not known; or both I<node> and I<service> are "
"NULL; or B<AI_NUMERICSERV> was specified in I<hints.ai_flags> and I<service>"
" was not a numeric port-number string."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:549
#, no-wrap
msgid "B<EAI_SERVICE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:570
msgid ""
"The requested service is not available for the requested socket type.  It "
"may be available through another socket type.  For example, this error could"
" occur if I<service> was \"shell\" (a service available only on stream "
"sockets), and either I<hints.ai_protocol> was B<IPPROTO_UDP>, or "
"I<hints.ai_socktype> was B<SOCK_DGRAM>; or the error could occur if "
"I<service> was not NULL, and I<hints.ai_socktype> was B<SOCK_RAW> (a socket "
"type that does not support the concept of services)."
msgstr ""

#. type: TP
#: man-pages/man3/getaddrinfo.3:570
#, no-wrap
msgid "B<EAI_SOCKTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:582
msgid ""
"The requested socket type is not supported.  This could occur, for example, "
"if I<hints.ai_socktype> and I<hints.ai_protocol> are inconsistent (e.g., "
"B<SOCK_DGRAM> and B<IPPROTO_TCP>, respectively)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:587
msgid "Other system error, check I<errno> for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:592
msgid ""
"The B<gai_strerror>()  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""

#. type: tbl table
#: man-pages/man3/getaddrinfo.3:604
#, no-wrap
msgid "B<getaddrinfo>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getaddrinfo.3:608
#, no-wrap
msgid ""
"B<freeaddrinfo>(),\n"
"B<gai_strerror>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:616
msgid ""
"POSIX.1-2001, POSIX.1-2008.  The B<getaddrinfo>()  function is documented in"
" RFC\\ 2553."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:621
msgid ""
"B<getaddrinfo>()  supports the I<address>B<%>I<scope-id> notation for "
"specifying the IPv6 scope-ID."
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:629
msgid ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, and B<AI_V4MAPPED> are available since glibc "
"2.3.3.  B<AI_NUMERICSERV> is available since glibc 2.3.4."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:640
msgid ""
"According to POSIX.1, specifying I<hints> as NULL should cause I<ai_flags> "
"to be assumed as 0.  The GNU C library instead assumes a value of "
"B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> for this case, since this value is "
"considered an improvement on the specification."
msgstr ""

#.  getnameinfo.3 refers to this example
#.  socket.2 refers to this example
#.  bind.2 refers to this example
#.  connect.2 refers to this example
#.  recvfrom.2 refers to this example
#.  sendto.2 refers to this example
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:654
msgid ""
"The following programs demonstrate the use of B<getaddrinfo>(), "
"B<gai_strerror>(), B<freeaddrinfo>(), and B<getnameinfo>(3).  The programs "
"are an echo server and client for UDP datagrams."
msgstr ""

#. type: SS
#: man-pages/man3/getaddrinfo.3:654
#, no-wrap
msgid "Server program"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:664
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:666 man-pages/man3/getaddrinfo.3:761
#, no-wrap
msgid "#define BUF_SIZE 500\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:677
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:682
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:691
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:697
#, no-wrap
msgid ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:702
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:708
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:711
#, no-wrap
msgid ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:714 man-pages/man3/getaddrinfo.3:807
#, no-wrap
msgid ""
"        close(sfd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:719
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:721 man-pages/man3/getaddrinfo.3:814
#, no-wrap
msgid "    freeaddrinfo(result);           /* No longer needed */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:723
#, no-wrap
msgid "    /* Read datagrams and echo them back to sender */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:730
#, no-wrap
msgid ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(struct sockaddr_storage);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:732
#, no-wrap
msgid "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:741
#, no-wrap
msgid ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"        if (s == 0)\n"
"            printf(\"Received %zd bytes from %s:%s\\en\",\n"
"                    nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:748
#, no-wrap
msgid ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: SS
#: man-pages/man3/getaddrinfo.3:749
#, no-wrap
msgid "Client program"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:759
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:771
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s, j;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:776
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:778
#, no-wrap
msgid "    /* Obtain address(es) matching host/port */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:784
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:790
#, no-wrap
msgid ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:795
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:801
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:804
#, no-wrap
msgid ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:812
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:817
#, no-wrap
msgid ""
"    /* Send remaining command-line arguments as separate\n"
"       datagrams, and read responses from server */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:821
#, no-wrap
msgid ""
"    for (j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:827
#, no-wrap
msgid ""
"        if (len E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:832
#, no-wrap
msgid ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:838
#, no-wrap
msgid ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getaddrinfo.3:841
#, no-wrap
msgid ""
"        printf(\"Received %zd bytes: %s\\en\", nread, buf);\n"
"    }\n"
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: man-pages/man3/getaddrinfo.3:854
msgid ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<gai.conf>(5), B<hostname>(7), B<ip>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/getsubopt.3:25
#, no-wrap
msgid "GETSUBOPT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:28
msgid "getsubopt - parse suboption arguments from a string"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:33
msgid ""
"B<int getsubopt(char **>I<optionp>B<, char * const *>I<tokens>B<, char "
"**>I<valuep>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:40
msgid "B<getsubopt>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/getsubopt.3:45
msgid "_XOPEN_SOURCE\\ E<gt>= 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:64
msgid ""
"B<getsubopt>()  parses the list of comma-separated suboptions provided in "
"I<optionp>.  (Such a suboption list is typically produced when B<getopt>(3)"
"  is used to parse a command line; see for example the I<-o> option of "
"B<mount>(8).)  Each suboption may include an associated value, which is "
"separated from the suboption name by an equal sign.  The following is an "
"example of the kind of string that might be passed in I<optionp>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:68
#, no-wrap
msgid "B<ro,name=xyz>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:79
msgid ""
"The I<tokens> argument is a pointer to a NULL-terminated array of pointers "
"to the tokens that B<getsubopt>()  will look for in I<optionp>.  The tokens "
"should be distinct, null-terminated strings containing at least one "
"character, with no embedded equal signs or commas."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:100
msgid ""
"Each call to B<getsubopt>()  returns information about the next unprocessed "
"suboption in I<optionp>.  The first equal sign in a suboption (if any) is "
"interpreted as a separator between the name and the value of that suboption."
"  The value extends to the next comma, or (for the last suboption) to the "
"end of the string.  If the name of the suboption matches a known name from "
"I<tokens>, and a value string was found, B<getsubopt>()  sets I<*valuep> to "
"the address of that string.  The first comma in I<optionp> is overwritten "
"with a null byte, so I<*valuep> is precisely the \"value string\" for that "
"suboption."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:104
msgid ""
"If the suboption is recognized, but no value string was found, I<*valuep> is"
" set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:112
msgid ""
"When B<getsubopt>()  returns, I<optionp> points to the next suboption, or to"
" the null byte (\\(aq\\e0\\(aq) at the end of the string if the last "
"suboption was just processed."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:124
msgid ""
"If the first suboption in I<optionp> is recognized, B<getsubopt>()  returns "
"the index of the matching suboption element in I<tokens>.  Otherwise, -1 is "
"returned and I<*valuep> is the entire I<name>B<[=>I<value>B<]> string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:131
msgid ""
"Since I<*optionp> is changed, the first suboption before the call to "
"B<getsubopt>()  is not (necessarily) the same as the first suboption after "
"B<getsubopt>()."
msgstr ""

#. type: tbl table
#: man-pages/man3/getsubopt.3:141
#, no-wrap
msgid "B<getsubopt>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:152
msgid ""
"Since B<getsubopt>()  overwrites any commas it finds in the string "
"I<*optionp>, that string must be writable; it cannot be a string constant."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:154
msgid "The following program expects suboptions following a \"-o\" option."
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:160
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:178
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    enum {\n"
"        RO_OPT = 0,\n"
"        RW_OPT,\n"
"        NAME_OPT\n"
"    };\n"
"    char *const token[] = {\n"
"        [RO_OPT]   = \"ro\",\n"
"        [RW_OPT]   = \"rw\",\n"
"        [NAME_OPT] = \"name\",\n"
"        NULL\n"
"    };\n"
"    char *subopts;\n"
"    char *value;\n"
"    int opt;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:183
#, no-wrap
msgid ""
"    int readonly = 0;\n"
"    int readwrite = 0;\n"
"    char *name = NULL;\n"
"    int errfnd = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:189
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"o:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqo\\(aq:\n"
"            subopts = optarg;\n"
"            while (*subopts != \\(aq\\e0\\(aq && !errfnd) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:194
#, no-wrap
msgid ""
"            switch (getsubopt(&subopts, token, &value)) {\n"
"            case RO_OPT:\n"
"                readonly = 1;\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:198
#, no-wrap
msgid ""
"            case RW_OPT:\n"
"                readwrite = 1;\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:206
#, no-wrap
msgid ""
"            case NAME_OPT:\n"
"                if (value == NULL) {\n"
"                    fprintf(stderr, \"Missing value for \"\n"
"                            \"suboption \\(aq%s\\(aq\\en\", token[NAME_OPT]);\n"
"                    errfnd = 1;\n"
"                    continue;\n"
"                }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:209
#, no-wrap
msgid ""
"                name = value;\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:223
#, no-wrap
msgid ""
"            default:\n"
"                fprintf(stderr, \"No match found \"\n"
"                        \"for token: /%s/\\en\", value);\n"
"                errfnd = 1;\n"
"                break;\n"
"            }\n"
"        }\n"
"        if (readwrite && readonly) {\n"
"            fprintf(stderr, \"Only one of \\(aq%s\\(aq and \\(aq%s\\(aq can be \"\n"
"                    \"specified\\en\", token[RO_OPT], token[RW_OPT]);\n"
"            errfnd = 1;\n"
"        }\n"
"        break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:228
#, no-wrap
msgid ""
"        default:\n"
"            errfnd = 1;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:235
#, no-wrap
msgid ""
"    if (errfnd || argc == 1) {\n"
"        fprintf(stderr, \"\\enUsage: %s -o E<lt>suboptstringE<gt>\\en\", argv[0]);\n"
"        fprintf(stderr, \"suboptions are \\(aqro\\(aq, \\(aqrw\\(aq, \"\n"
"                \"and \\(aqname=E<lt>valueE<gt>\\(aq\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:237
#, no-wrap
msgid "    /* Remainder of program... */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getsubopt.3:242
msgid "B<getopt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getrpcent_r.3:26
#, no-wrap
msgid "GETRPCENT_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:30
msgid ""
"getrpcent_r, getrpcbyname_r, getrpcbynumber_r - get RPC entry (reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:36
#, no-wrap
msgid ""
"B<int getrpcent_r(struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:40
#, no-wrap
msgid ""
"B<int getrpcbyname_r(const char *>I<name>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:44
#, no-wrap
msgid ""
"B<int getrpcbynumber_r(int >I<number>B<,>\n"
"B<                struct rpcent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct rpcent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:59
#, no-wrap
msgid ""
"B<getrpcent_r>(),\n"
"B<getrpcbyname_r>(),\n"
"B<getrpcbynumber_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:77
msgid ""
"The B<getrpcent_r>(), B<getrpcbyname_r>(), and B<getrpcbynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getrpcent>(3), "
"B<getrpcbyname>(3), and B<getrpcbynumber>(3).  They differ in the way that "
"the I<rpcent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<rpcent> structure"
" as the function result, these functions copy the structure into the "
"location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: man-pages/man3/getrpcent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<rpcent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:108
msgid ""
"If the function call successfully obtains an RPC record, then I<*result> is "
"set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:119
msgid ""
"On error, record not found (B<getrpcbyname_r>(), B<getrpcbynumber_r>()), or "
"end of input (B<getrpcent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:124
msgid "(B<getrpcent_r>())  No more records in database."
msgstr ""

#. type: tbl table
#: man-pages/man3/getrpcent_r.3:144
#, no-wrap
msgid ""
"B<getrpcent_r>(),\n"
"B<getrpcbyname_r>(),\n"
"B<getrpcbynumber_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getrpcent_r.3:153
msgid "B<getrpcent>(3), B<rpc>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getdtablesize.3:27
#, no-wrap
msgid "GETDTABLESIZE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:30
msgid "getdtablesize - get file descriptor table size"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:34
msgid "B<int getdtablesize(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:41
msgid "B<getdtablesize>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:50
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
"    || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:62
msgid ""
"B<getdtablesize>()  returns the maximum number of files a process can have "
"open, one more than the largest possible value for a file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:64
msgid "The current limit on the number of open files per process."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:70
msgid ""
"On Linux, B<getdtablesize>()  can return any of the errors described for "
"B<getrlimit>(2); see NOTES below."
msgstr ""

#. type: tbl table
#: man-pages/man3/getdtablesize.3:80
#, no-wrap
msgid "B<getdtablesize>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:90
msgid ""
"SVr4, 4.4BSD (the B<getdtablesize>()  function first appeared in 4.2BSD).  "
"It is not specified in POSIX.1; portable applications should employ "
"I<sysconf(_SC_OPEN_MAX)> instead of this call."
msgstr ""

#.  The libc4 and libc5 versions return
#.  .B OPEN_MAX
#.  (set to 256 since Linux 0.98.4).
#. type: Plain text
#: man-pages/man3/getdtablesize.3:103
msgid ""
"B<getdtablesize>()  is implemented as a libc library function.  The glibc "
"version calls B<getrlimit>(2)  and returns the current B<RLIMIT_NOFILE> "
"limit, or B<OPEN_MAX> when that fails."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdtablesize.3:107
msgid "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/getcwd.3:32
#, no-wrap
msgid "GETCWD"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:35
msgid "getcwd, getwd, get_current_dir_name - get current working directory"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:40
#, no-wrap
msgid "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:42
#, no-wrap
msgid "B<char *getwd(char *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:44
#, no-wrap
msgid "B<char *get_current_dir_name(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:52
msgid "B<get_current_dir_name>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:57
msgid "B<getwd>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:66
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:81
msgid ""
"These functions return a null-terminated string containing an absolute "
"pathname that is the current working directory of the calling process.  The "
"pathname is returned as the function result and via the argument I<buf>, if "
"present."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:89
msgid ""
"The B<getcwd>()  function copies an absolute pathname of the current working"
" directory to the array pointed to by I<buf>, which is of length I<size>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:99
msgid ""
"If the length of the absolute pathname of the current working directory, "
"including the terminating null byte, exceeds I<size> bytes, NULL is "
"returned, and I<errno> is set to B<ERANGE>; an application should check for "
"this error, and allocate a larger buffer if necessary."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:117
msgid ""
"As an extension to the POSIX.1-2001 standard, glibc's B<getcwd>()  allocates"
" the buffer dynamically using B<malloc>(3)  if I<buf> is NULL.  In this "
"case, the allocated buffer has the length I<size> unless I<size> is zero, "
"when I<buf> is allocated as big as necessary.  The caller should B<free>(3)"
"  the returned buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:130
msgid ""
"B<get_current_dir_name>()  will B<malloc>(3)  an array big enough to hold "
"the absolute pathname of the current working directory.  If the environment "
"variable B<PWD> is set, and its value is correct, then that value will be "
"returned.  The caller should B<free>(3)  the returned buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:155
msgid ""
"B<getwd>()  does not B<malloc>(3)  any memory.  The I<buf> argument should "
"be a pointer to an array at least B<PATH_MAX> bytes long.  If the length of "
"the absolute pathname of the current working directory, including the "
"terminating null byte, exceeds B<PATH_MAX> bytes, NULL is returned, and "
"I<errno> is set to B<ENAMETOOLONG>.  (Note that on some systems, B<PATH_MAX>"
" may not be a compile-time constant; furthermore, its value may depend on "
"the filesystem, see B<pathconf>(3).)  For portability and security reasons, "
"use of B<getwd>()  is deprecated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:164
msgid ""
"On success, these functions return a pointer to a string containing the "
"pathname of the current working directory.  In the case B<getcwd>()  and "
"B<getwd>()  this is the same value as I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:171
msgid ""
"On failure, these functions return NULL, and I<errno> is set to indicate the"
" error.  The contents of the array pointed to by I<buf> are undefined on "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:175
msgid "Permission to read or search a component of the filename was denied."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:179
msgid "I<buf> points to a bad address."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:186
msgid "The I<size> argument is zero and I<buf> is not a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:191
msgid "B<getwd>(): I<buf> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:197
msgid ""
"B<getwd>(): The size of the null-terminated absolute pathname string exceeds"
" B<PATH_MAX> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:200
msgid "The current working directory has been unlinked."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:210
msgid ""
"The I<size> argument is less than the length of the absolute pathname of the"
" working directory, including the terminating null byte.  You need to "
"allocate a bigger array and try again."
msgstr ""

#. type: tbl table
#: man-pages/man3/getcwd.3:221
#, no-wrap
msgid ""
"B<getcwd>(),\n"
"B<getwd>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getcwd.3:224
#, no-wrap
msgid "B<get_current_dir_name>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getcwd.3:224
#, no-wrap
msgid "MT-Safe env"
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:234
msgid ""
"B<getcwd>()  conforms to POSIX.1-2001.  Note however that POSIX.1-2001 "
"leaves the behavior of B<getcwd>()  unspecified if I<buf> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:245
msgid ""
"B<getwd>()  is present in POSIX.1-2001, but marked LEGACY.  POSIX.1-2008 "
"removes the specification of B<getwd>().  Use B<getcwd>()  instead.  "
"POSIX.1-2001 does not define any errors for B<getwd>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:248
msgid "B<get_current_dir_name>()  is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:259
msgid ""
"Under Linux, these functions make use of the B<getcwd>()  system call "
"(available since Linux 2.1.92).  On older systems they would query "
"I</proc/self/cwd>.  If both system call and proc filesystem are missing, a "
"generic implementation is called.  Only in that case can these calls fail "
"under Linux with B<EACCES>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:268
msgid ""
"These functions are often used to save the location of the current working "
"directory for the purpose of returning to it later.  Opening the current "
"directory (\".\") and calling B<fchdir>(2)  to return is usually a faster "
"and more reliable alternative when sufficiently many file descriptors are "
"available, especially on platforms other than Linux."
msgstr ""

#.  commit 3272c544da48f8915a0e34189182aed029bd0f2b
#. type: Plain text
#: man-pages/man3/getcwd.3:288
msgid ""
"On Linux, the kernel provides a B<getcwd>()  system call, which the "
"functions described in this page will use if possible.  The system call "
"takes the same arguments as the library function of the same name, but is "
"limited to returning at most B<PATH_MAX> bytes.  (Before Linux 3.12, the "
"limit on the size of the returned pathname was the system page size.  On "
"many architectures, B<PATH_MAX> and the system page size are both 4096 "
"bytes, but a few architectures have a larger page size.)  If the length of "
"the pathname of the current working directory exceeds this limit, then the "
"system call fails with the error B<ENAMETOOLONG>.  In this case, the library"
" functions fall back to a (slower) alternative implementation that returns "
"the full pathname."
msgstr ""

#.  commit 8df9d1a4142311c084ffeeacb67cd34d190eff74
#. type: Plain text
#: man-pages/man3/getcwd.3:305
msgid ""
"Following a change in Linux 2.6.36, the pathname returned by the B<getcwd>()"
"  system call will be prefixed with the string \"(unreachable)\" if the "
"current directory is not below the root directory of the current process "
"(e.g., because the process set a new filesystem root using B<chroot>(2)  "
"without changing its current directory into the new root).  Such behavior "
"can also be caused by an unprivileged user by changing the current directory"
" into another mount namespace.  When dealing with pathname from untrusted "
"sources, callers of the functions described in this page should consider "
"checking whether the returned pathname starts with '/' or '(' to avoid "
"misinterpreting an unreachable path as a relative pathname."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:316
msgid ""
"Since the Linux 2.6.36 change that added \"(unreachable)\" in the "
"circumstances described above, the glibc implementation of B<getcwd>()  has "
"failed to conform to POSIX and returned a relative pathname when the API "
"contract requires an absolute pathname.  With glibc 2.27 onwards this is "
"corrected; calling B<getcwd>()  from such a pathname will now result in "
"failure with B<ENOENT>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getcwd.3:323
msgid ""
"B<pwd>(1), B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), "
"B<malloc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/get_phys_pages.3:25
#, no-wrap
msgid "GET_PHYS_PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:29
msgid ""
"get_phys_pages, get_avphys_pages - get total and available physical page "
"counts"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:32
#, no-wrap
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:35
#, no-wrap
msgid ""
"B<long int get_phys_pages(void);>\n"
"B<long int get_avphys_pages(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:40
msgid ""
"The function B<get_phys_pages>()  returns the total number of physical pages"
" of memory available on the system."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:45
msgid ""
"The function B<get_avphys_pages>()  returns the number of currently "
"available physical pages of memory on the system."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:51
msgid ""
"On success, these functions return a nonnegative value as given in "
"DESCRIPTION.  On failure, they return -1 and set I<errno> to indicate the "
"cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:58
msgid ""
"The system could not provide the required information (possibly because the "
"I</proc> filesystem was not mounted)."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:67
msgid ""
"These functions obtain the required information by scanning the I<MemTotal> "
"and I<MemFree> fields of I</proc/meminfo>."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:72
msgid ""
"The following B<sysconf>(3)  calls provide a portable means of obtaining the"
" same information as the functions described on this page."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:77
#, no-wrap
msgid ""
"total_pages = sysconf(_SC_PHYS_PAGES);    /* total pages */\n"
"avl_pages = sysconf(_SC_AVPHYS_PAGES);    /* available pages */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:85
msgid ""
"The following example shows how B<get_phys_pages>()  and "
"B<get_avphys_pages>()  can be used."
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:90
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:99
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %ld pages of physical memory and \"\n"
"            \"%ld pages of physical memory available.\\en\",\n"
"            get_phys_pages(), get_avphys_pages());\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/get_phys_pages.3:101
msgid "B<sysconf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getpt.3:7
#, no-wrap
msgid "GETPT"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:10
msgid "getpt - open the pseudoterminal master (PTM)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:14
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:16
#, no-wrap
msgid "B<int getpt(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:21
msgid ""
"B<getpt>()  opens a pseudoterminal master and returns its file descriptor.  "
"It is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:25
#, no-wrap
msgid "open(/dev/ptmx, O_RDWR | O_NOCTTY);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:30
msgid ""
"on Linux systems, though the pseudoterminal master is located elsewhere on "
"some systems that use GNU Libc."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:37
msgid ""
"B<getpt>()  returns an open file descriptor upon successful completion.  "
"Otherwise, it returns -1 and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:41
msgid "B<getpt>()  can fail with various errors described in B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:44
msgid "B<getpt>()  is provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/getpt.3:54
#, no-wrap
msgid "B<getpt>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:62
msgid "B<getpt>()  is glibc-specific; use B<posix_openpt>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpt.3:68
msgid ""
"B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<unlockpt>(3), "
"B<ptmx>(4), B<pty>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/getloadavg.3:34
#, no-wrap
msgid "GETLOADAVG"
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:37
msgid "getloadavg - get system load averages"
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:42
#, no-wrap
msgid "B<int getloadavg(double >I<loadavg[]>B<, int >I<nelem>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:50
msgid "B<getloadavg>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:55
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:67
msgid ""
"The B<getloadavg>()  function returns the number of processes in the system "
"run queue averaged over various periods of time.  Up to I<nelem> samples are"
" retrieved and assigned to successive elements of I<loadavg>[].  The system "
"imposes a maximum of 3 samples, representing averages over the last 1, 5, "
"and 15 minutes, respectively."
msgstr ""

#.  .SH HISTORY
#.  The
#.  BR getloadavg ()
#.  function appeared in
#.  4.3BSD Reno .
#. type: Plain text
#: man-pages/man3/getloadavg.3:75
msgid ""
"If the load average was unobtainable, -1 is returned; otherwise, the number "
"of samples actually retrieved is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:77
msgid "This function is available in glibc since version 2.2."
msgstr ""

#. type: tbl table
#: man-pages/man3/getloadavg.3:87
#, no-wrap
msgid "B<getloadavg>()"
msgstr ""

#.  mdoc seems to have a bug - there must be no newline here
#. type: Plain text
#: man-pages/man3/getloadavg.3:93
msgid "Not in POSIX.1.  Present on the BSDs and Solaris."
msgstr ""

#. type: Plain text
#: man-pages/man3/getloadavg.3:95
msgid "B<uptime>(1), B<proc>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getprotoent_r.3:26
#, no-wrap
msgid "GETPROTOENT_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:30
msgid ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - get protocol entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:36
#, no-wrap
msgid ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:40
#, no-wrap
msgid ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:44
#, no-wrap
msgid ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:59
#, no-wrap
msgid ""
"B<getprotoent_r>(),\n"
"B<getprotobyname_r>(),\n"
"B<getprotobynumber_r>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:77
msgid ""
"The B<getprotoent_r>(), B<getprotobyname_r>(), and B<getprotobynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getprotoent>(3),"
" B<getprotobyname>(3), and B<getprotobynumber>(3).  They differ in the way "
"that the I<protoent> structure is returned, and in the function calling "
"signature and return value.  This manual page describes just the differences"
" from the nonreentrant functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<protoent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer.
#.  The 1024 byte value is also what the Solaris man page suggests. -- mtk
#. type: Plain text
#: man-pages/man3/getprotoent_r.3:101
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<protoent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>,"
" and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:109
msgid ""
"If the function call successfully obtains a protocol record, then I<*result>"
" is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:120
msgid ""
"On error, record not found (B<getprotobyname_r>(), B<getprotobynumber_r>()),"
" or end of input (B<getprotoent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:125
msgid "(B<getprotoent_r>())  No more records in database."
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent_r.3:142
#, no-wrap
msgid "B<getprotoent_r>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent_r.3:144
#, no-wrap
msgid "B<getprotobyname_r>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getprotoent_r.3:146
#, no-wrap
msgid "B<getprotobynumber_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:167
msgid ""
"The program below uses B<getprotobyname_r>()  to retrieve the protocol "
"record for the protocol named in its first command-line argument.  If a "
"second (integer) command-line argument is supplied, it is used as the "
"initial value for I<buflen>; if B<getprotobyname_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:178
#, no-wrap
msgid ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:201
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
"    char **p;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:206
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:210
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:224
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:240
#, no-wrap
msgid ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:251
#, no-wrap
msgid ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getprotoent_r.3:257
msgid "B<getprotoent>(3), B<protocols>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getenv.3:33
#, no-wrap
msgid "GETENV"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:36
msgid "getenv, secure_getenv - get an environment variable"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:41
#, no-wrap
msgid "B<char *getenv(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:43
#, no-wrap
msgid "B<char *secure_getenv(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:52
msgid "B<secure_getenv>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:61
msgid ""
"The B<getenv>()  function searches the environment list to find the "
"environment variable I<name>, and returns a pointer to the corresponding "
"I<value> string."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:69
msgid ""
"The GNU-specific B<secure_getenv>()  function is just like B<getenv>()  "
"except that it returns NULL in cases where \"secure execution\" is required."
"  Secure execution is required if one of the following conditions was true "
"when the program run by the calling process was loaded:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:74
msgid ""
"the process's effective user ID did not match its real user ID or the "
"process's effective group ID did not match its real group ID (typically this"
" is the result of executing a set-user-ID or set-group-ID program);"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:76
msgid "the effective capability bit was set on the executable file; or"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:78
msgid "the process has a nonempty permitted capability set."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:81
msgid ""
"Secure execution may also be required if triggered by some Linux security "
"modules."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:88
msgid ""
"The B<secure_getenv>()  function is intended for use in general-purpose "
"libraries to avoid vulnerabilities that could occur if set-user-ID or set-"
"group-ID programs accidentally trusted the environment."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:93
msgid ""
"The B<getenv>()  function returns a pointer to the value in the environment,"
" or NULL if there is no match."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:96
msgid "B<secure_getenv>()  first appeared in glibc 2.17."
msgstr ""

#. type: tbl table
#: man-pages/man3/getenv.3:107
#, no-wrap
msgid ""
"B<getenv>(),\n"
"B<secure_getenv>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:112
msgid "B<getenv>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:115
msgid "B<secure_getenv>()  is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:117
msgid "The strings in the environment list are of the form I<name=value>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:123
msgid ""
"As typically implemented, B<getenv>()  returns a pointer to a string within "
"the environment list.  The caller must take care not to modify this string, "
"since that would change the environment of the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:136
msgid ""
"The implementation of B<getenv>()  is not required to be reentrant.  The "
"string pointed to by the return value of B<getenv>()  may be statically "
"allocated, and can be modified by a subsequent call to B<getenv>(), "
"B<putenv>(3), B<setenv>(3), or B<unsetenv>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:142
msgid ""
"The \"secure execution\" mode of B<secure_getenv>()  is controlled by the "
"B<AT_SECURE> flag contained in the auxiliary vector passed from the kernel "
"to user space."
msgstr ""

#. type: Plain text
#: man-pages/man3/getenv.3:149
msgid ""
"B<clearenv>(3), B<getauxval>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3),"
" B<capabilities>(7), B<environ>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/getpw.3:32
#, no-wrap
msgid "GETPW"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:35
msgid "getpw - reconstruct password line entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:40
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>pwd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:42
#, no-wrap
msgid "B<int getpw(uid_t >I<uid>B<, char *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:49
msgid ""
"The B<getpw>()  function reconstructs the password line entry for the given "
"user ID I<uid> in the buffer I<buf>.  The returned buffer contains a line of"
" format"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:53
#, no-wrap
msgid "B<name:passwd:uid:gid:gecos:dir:shell>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:80
msgid ""
"The B<getpw>()  function returns 0 on success; on error, it returns -1, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:90
msgid ""
"If I<uid> is not found in the password database, B<getpw>()  returns -1, "
"sets I<errno> to 0, and leaves I<buf> unchanged."
msgstr ""

#. type: TP
#: man-pages/man3/getpw.3:91
#, no-wrap
msgid "B<0> or B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:95
msgid "No user corresponding to I<uid>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:99
msgid "I<buf> is NULL."
msgstr ""

#. type: tbl table
#: man-pages/man3/getpw.3:118
#, no-wrap
msgid "B<getpw>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:123
msgid "SVr2."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:130
msgid ""
"The B<getpw>()  function is dangerous as it may overflow the provided buffer"
" I<buf>.  It is obsoleted by B<getpwuid>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getpw.3:138
msgid ""
"B<endpwent>(3), B<fgetpwent>(3), B<getpwent>(3), B<getpwnam>(3), "
"B<getpwuid>(3), B<putpwent>(3), B<setpwent>(3), B<passwd>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/getipnodebyname.3:26
#, no-wrap
msgid "GETIPNODEBYNAME"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:30
msgid ""
"getipnodebyname, getipnodebyaddr, freehostent - get network hostnames and "
"addresses"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:38
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:41
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:43
#, no-wrap
msgid "B<void freehostent(struct hostent *>I<ip>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:51
msgid ""
"These functions are deprecated (and unavailable in glibc).  Use "
"B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:59
msgid ""
"The B<getipnodebyname>()  and B<getipnodebyaddr>()  functions return the "
"names and addresses of a network host.  These functions return a pointer to "
"the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:69
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:82
msgid ""
"These functions replace the B<gethostbyname>(3)  and B<gethostbyaddr>(3)  "
"functions, which could access only the IPv4 network address family.  The "
"B<getipnodebyname>()  and B<getipnodebyaddr>()  functions can access "
"multiple network address families."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:93
msgid ""
"Unlike the B<gethostby> functions, these functions return pointers to "
"dynamically allocated memory.  The B<freehostent>()  function is used to "
"release the dynamically allocated memory after the caller no longer needs "
"the I<hostent> structure."
msgstr ""

#. type: SS
#: man-pages/man3/getipnodebyname.3:93
#, no-wrap
msgid "getipnodebyname() arguments"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:104
msgid ""
"The B<getipnodebyname>()  function looks up network addresses for the host "
"specified by the I<name> argument.  The I<af> argument specifies one of the "
"following values:"
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:104 man-pages/man3/getipnodebyname.3:166
#, no-wrap
msgid "B<AF_INET>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:110
msgid ""
"The I<name> argument points to a dotted-quad IPv4 address or a name of an "
"IPv4 network host."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:110 man-pages/man3/getipnodebyname.3:176
#, no-wrap
msgid "B<AF_INET6>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:116
msgid ""
"The I<name> argument points to a hexadecimal IPv6 address or a name of an "
"IPv6 network host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:125
msgid ""
"The I<flags> argument specifies additional options.  More than one option "
"can be specified by bitwise OR-ing them together.  I<flags> should be set to"
" 0 if no options are desired."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:125
#, no-wrap
msgid "B<AI_V4MAPPED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:132
msgid ""
"This flag is used with B<AF_INET6> to request a query for IPv4 addresses "
"instead of IPv6 addresses; the IPv4 addresses will be mapped to IPv6 "
"addresses."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:132
#, no-wrap
msgid "B<AI_ALL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:138
msgid ""
"This flag is used with B<AI_V4MAPPED> to request a query for both IPv4 and "
"IPv6 addresses.  Any IPv4 address found will be mapped to an IPv6 address."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:138
#, no-wrap
msgid "B<AI_ADDRCONFIG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:150
msgid ""
"This flag is used with B<AF_INET6> to further request that queries for IPv6 "
"addresses should not be made unless the system has at least one IPv6 address"
" assigned to a network interface, and that queries for IPv4 addresses should"
" not be made unless the system has at least one IPv4 address assigned to a "
"network interface.  This flag may be used by itself or with the "
"B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:150
#, no-wrap
msgid "B<AI_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:154
msgid "This flag is equivalent to B<(AI_ADDRCONFIG | AI_V4MAPPED)>."
msgstr ""

#. type: SS
#: man-pages/man3/getipnodebyname.3:154
#, no-wrap
msgid "getipnodebyaddr() arguments"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:166
msgid ""
"The B<getipnodebyaddr>()  function looks up the name of the host whose "
"network address is specified by the I<addr> argument.  The I<af> argument "
"specifies one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:176
msgid ""
"The I<addr> argument points to a I<struct in_addr> and I<len> must be set to"
" I<sizeof(struct in_addr)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:186
msgid ""
"The I<addr> argument points to a I<struct in6_addr> and I<len> must be set "
"to I<sizeof(struct in6_addr)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:190
msgid ""
"NULL is returned if an error occurred, and I<error_num> will contain an "
"error code from the following list:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:193
msgid "The hostname or network address was not found."
msgstr ""

#. type: TP
#: man-pages/man3/getipnodebyname.3:193
#, no-wrap
msgid "B<NO_ADDRESS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:199
msgid ""
"The domain name server recognized the network address or name, but no answer"
" was returned.  This can happen if the network host has only IPv4 addresses "
"and a request has been made for IPv6 information only, or vice versa."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:202
msgid "The domain name server returned a permanent failure response."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:206
msgid ""
"The domain name server returned a temporary failure response.  You might "
"have better luck next time."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:210
msgid ""
"A successful query returns a pointer to a I<hostent> structure that contains"
" the following fields:"
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:213
msgid "This is the official name of this network host."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:217
msgid ""
"This is an array of pointers to unofficial aliases for the same host.  The "
"array is terminated by a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:239
msgid ""
"This is a copy of the I<af> argument to B<getipnodebyname>()  or "
"B<getipnodebyaddr>().  I<h_addrtype> will always be B<AF_INET> if the I<af> "
"argument was B<AF_INET>.  I<h_addrtype> will always be B<AF_INET6> if the "
"I<af> argument was B<AF_INET6>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:253
msgid ""
"This field will be set to I<sizeof(struct in_addr)> if I<h_addrtype> is "
"B<AF_INET>, and to I<sizeof(struct in6_addr)> if I<h_addrtype> is "
"B<AF_INET6>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:258
msgid ""
"This is an array of one or more pointers to network address structures for "
"the network host.  The array is terminated by a null pointer."
msgstr ""

#.  Not in POSIX.1-2001.
#. type: Plain text
#: man-pages/man3/getipnodebyname.3:261
msgid "RFC\\ 2553."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:266
msgid ""
"These functions were present in glibc 2.1.91-95, but were removed again.  "
"Several UNIX-like systems support them, but all call them deprecated."
msgstr ""

#. type: Plain text
#: man-pages/man3/getipnodebyname.3:270
msgid "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getgrnam.3:33
#, no-wrap
msgid "GETGRNAM"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:36
msgid "getgrnam, getgrnam_r, getgrgid, getgrgid_r - get group file entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:42
#, no-wrap
msgid "B<struct group *getgrnam(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:44
#, no-wrap
msgid "B<struct group *getgrgid(gid_t >I<gid>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:47
#, no-wrap
msgid ""
"B<int getgrnam_r(const char *>I<name>B<, struct group *>I<grp>B<,>\n"
"B<          char *>I<buf>B<, size_t >I<buflen>B<, struct group **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:50
#, no-wrap
msgid ""
"B<int getgrgid_r(gid_t >I<gid>B<, struct group *>I<grp>B<,>\n"
"B<          char *>I<buf>B<, size_t >I<buflen>B<, struct group **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:60
msgid "B<getgrnam_r>(), B<getgrgid_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:75
msgid ""
"The B<getgrnam>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the group database (e.g., the local group"
" file I</etc/group>, NIS, and LDAP)  that matches the group name I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:82
msgid ""
"The B<getgrgid>()  function returns a pointer to a structure containing the "
"broken-out fields of the record in the group database that matches the group"
" ID I<gid>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:122
msgid ""
"The B<getgrnam_r>()  and B<getgrgid_r>()  functions obtain the same "
"information as B<getgrnam>()  and B<getgrgid>(), but store the retrieved "
"I<group> structure in the space pointed to by I<grp>.  The string fields "
"pointed to by the members of the I<group> structure are stored in the buffer"
" I<buf> of size I<buflen>.  A pointer to the result (in case of success) or "
"NULL (in case no entry was found or an error occurred) is stored in "
"I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:126
#, no-wrap
msgid "    sysconf(_SC_GETGR_R_SIZE_MAX)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:150
msgid ""
"The B<getgrnam>()  and B<getgrgid>()  functions return a pointer to a "
"I<group> structure, or NULL if the matching entry is not found or an error "
"occurs.  If an error occurs, I<errno> is set appropriately.  If one wants to"
" check I<errno> after the call, it should be set to zero before the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:159
msgid ""
"The return value may point to a static area, and may be overwritten by "
"subsequent calls to B<getgrent>(3), B<getgrgid>(), or B<getgrnam>().  (Do "
"not pass the returned pointer to B<free>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:173
msgid ""
"On success, B<getgrnam_r>()  and B<getgrgid_r>()  return zero, and set "
"I<*result> to I<grp>.  If no matching group record was found, these "
"functions return 0 and store NULL in I<*result>.  In case of error, an error"
" number is returned, and NULL is stored in I<*result>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:181
msgid "The given I<name> or I<gid> was not found."
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrnam.3:218
#, no-wrap
msgid "B<getgrnam>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrnam.3:218
#, no-wrap
msgid "MT-Unsafe race:grnam locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrnam.3:221
#, no-wrap
msgid "B<getgrgid>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrnam.3:221
#, no-wrap
msgid "MT-Unsafe race:grgid locale"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrnam.3:224
#, no-wrap
msgid "B<getgrnam_r>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/getgrnam.3:226
#, no-wrap
msgid "B<getgrgid_r>()"
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#.  more precisely:
#.  AIX 5.1 - gives ESRCH
#.  OSF1 4.0g - gives EWOULDBLOCK
#.  libc, glibc up to version 2.6, Irix 6.5 - give ENOENT
#.  glibc since version 2.7 - give 0
#.  FreeBSD 4.8, OpenBSD 3.2, NetBSD 1.6 - give EPERM
#.  SunOS 5.8 - gives EBADF
#.  Tru64 5.1b, HP-UX-11i, SunOS 5.7 - give 0
#. type: Plain text
#: man-pages/man3/getgrnam.3:252
msgid ""
"The formulation given above under \"RETURN VALUE\" is from POSIX.1.  It does"
" not call \"not found\" an error, hence does not specify what value I<errno>"
" might have in this situation.  But that makes it impossible to recognize "
"errors.  One might argue that according to POSIX I<errno> should be left "
"unchanged if an entry is not found.  Experiments on various UNIX-like "
"systems show that lots of different values occur in this situation: 0, "
"ENOENT, EBADF, ESRCH, EWOULDBLOCK, EPERM, and probably others."
msgstr ""

#. type: Plain text
#: man-pages/man3/getgrnam.3:258
msgid ""
"B<endgrent>(3), B<fgetgrent>(3), B<getgrent>(3), B<getpwnam>(3), "
"B<setgrent>(3), B<group>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/gamma.3:9
#, no-wrap
msgid "GAMMA"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:12
msgid "gamma, gammaf, gammal - (logarithm of the) gamma function"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:14
msgid "B<#include E<lt>math.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:16
msgid "B<double gamma(double >I<x>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:18
msgid "B<float gammaf(float >I<x>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:20
msgid "B<long double gammal(long double >I<x>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:22
msgid "Link with I<-lm>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:30
msgid "B<gamma>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:34
#, no-wrap
msgid ""
"_XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:37
msgid "B<gammaf>(), B<gammal>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:41
#, no-wrap
msgid ""
"_XOPEN_SOURCE E<gt>= 600 || (_XOPEN_SOURCE && _ISOC99_SOURCE)\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:49
msgid ""
"These functions are deprecated: instead, use either the B<tgamma>(3)  or the"
" B<lgamma>(3)  functions, as appropriate."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:52
msgid "For the definition of the Gamma function, see B<tgamma>(3)."
msgstr ""

#. type: SS
#: man-pages/man3/gamma.3:52
#, no-wrap
msgid "*BSD version"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:56
msgid ""
"The libm in 4.4BSD and some versions of FreeBSD had a B<gamma>()  function "
"that computes the Gamma function, as one would expect."
msgstr ""

#. type: SS
#: man-pages/man3/gamma.3:56
#, no-wrap
msgid "glibc version"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:62
msgid ""
"Glibc has a B<gamma>()  function that is equivalent to B<lgamma>(3)  and "
"computes the natural logarithm of the Gamma function."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:65 man-pages/man3/gamma.3:68
msgid "See B<lgamma>(3)."
msgstr ""

#. type: tbl table
#: man-pages/man3/gamma.3:80
#, no-wrap
msgid ""
"B<gamma>(),\n"
"B<gammaf>(),\n"
"B<gammal>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/gamma.3:80
#, no-wrap
msgid "MT-Unsafe race:signgam"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:86
msgid ""
"Because of historical variations in behavior across systems, this function "
"is not specified in any recent standard.  It was documented in SVID 2."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:99
msgid ""
"4.2BSD had a B<gamma>()  that computed ln(|Gamma(|I<x>|)|), leaving the sign"
" of Gamma(|I<x>|)  in the external integer I<signgam>.  In 4.3BSD the name "
"was changed to B<lgamma>(3), and the man page promises"
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:103
msgid ""
"At some time in the future the name gamma will be rehabilitated and used for"
" the Gamma function"
msgstr ""

#.  The FreeBSD man page says about gamma() that it is like lgamma()
#.  except that is does not set signgam.
#.  Also, that 4.4BSD has a gamma() that computes the true gamma function.
#. type: Plain text
#: man-pages/man3/gamma.3:115
msgid ""
"This did indeed happen in 4.4BSD, where B<gamma>()  computes the Gamma "
"function (with no effect on I<signgam>).  However, this came too late, and "
"we now have B<tgamma>(3), the \"true gamma\" function."
msgstr ""

#. type: Plain text
#: man-pages/man3/gamma.3:118
msgid "B<lgamma>(3), B<signgam>(3), B<tgamma>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getwchar.3:17
#, no-wrap
msgid "GETWCHAR"
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:20
msgid "getwchar - read a wide character from standard input"
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:23
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:25
#, no-wrap
msgid "B<wint_t getwchar(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:46
msgid ""
"The B<getwchar>()  function is the wide-character equivalent of the "
"B<getchar>(3)  function.  It reads a wide character from I<stdin> and "
"returns it.  If the end of stream is reached, or if I<ferror(stdin)> becomes"
" true, it returns B<WEOF>.  If a wide-character conversion error occurs, it "
"sets I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:49
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:55
msgid ""
"The B<getwchar>()  function returns the next wide-character from standard "
"input, or B<WEOF>."
msgstr ""

#. type: tbl table
#: man-pages/man3/getwchar.3:65
#, no-wrap
msgid "B<getwchar>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:70
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:77
msgid ""
"The behavior of B<getwchar>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:83
msgid ""
"It is reasonable to expect that B<getwchar>()  will actually read a "
"multibyte sequence from standard input and then convert it to a wide "
"character."
msgstr ""

#. type: Plain text
#: man-pages/man3/getwchar.3:85
msgid "B<fgetwc>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/getentropy.3:25
#, no-wrap
msgid "GETENTROPY"
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:28
msgid "getentropy - fill a buffer with random bytes"
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:32
msgid "B<int getentropy(void *>I<buffer>B<, size_t >I<length>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:39
msgid "B<getentropy>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:56
msgid ""
"The B<getentropy>()  function writes I<length> bytes of high-quality random "
"data to the buffer starting at the location pointed to by I<buffer>.  The "
"maximum permitted value for the I<length> argument is 256."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:60
msgid ""
"A successful call to B<getentropy>()  always provides the requested number "
"of bytes of entropy."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:65
msgid ""
"On success, this function returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:73
msgid ""
"Part or all of the buffer specified by I<buffer> and I<length> is not in "
"valid addressable memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:77
msgid "I<length> is greater than 256."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:82
msgid ""
"An unspecified error occurred while trying to overwrite I<buffer> with "
"random data."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:87
msgid ""
"This kernel version does not implement the B<getrandom>(2)  system call "
"required to implement this function."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:91
msgid "The B<getentropy>()  function first appeared in glibc 2.25."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:94
msgid "This function is nonstandard.  It is also present on OpenBSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:99
msgid "The B<getentropy>()  function is implemented using B<getrandom>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:105
msgid ""
"Whereas the glibc wrapper makes B<getrandom>(2)  a cancellation point, "
"B<getentropy>()  is not a cancellation point."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:111
msgid ""
"B<getentropy>()  is also declared in B<E<lt>sys/random.hE<gt>>.  (No feature"
" test macro need be defined to obtain the declaration from that header "
"file.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:120
msgid ""
"A call to B<getentropy>()  may block if the system has just booted and the "
"kernel has not yet collected enough randomness to initialize the entropy "
"pool.  In this case, B<getentropy>()  will keep blocking even if a signal is"
" handled, and will return only once the entropy pool has been initialized."
msgstr ""

#. type: Plain text
#: man-pages/man3/getentropy.3:123
msgid "B<getrandom>(2), B<urandom>(4), B<random>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/getdirentries.3:27
#, no-wrap
msgid "GETDIRENTRIES"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:30
msgid ""
"getdirentries - get directory entries in a filesystem-independent format"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:32
msgid "B<#include E<lt>dirent.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:35
msgid ""
"B<ssize_t getdirentries(int >I<fd>B<, char *>I<buf>B<, size_t >I<nbytes> B<,"
" off_t *>I<basep>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:46
#, no-wrap
msgid ""
"B<getdirentries>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:59
msgid ""
"Read directory entries from the directory specified by I<fd> into I<buf>.  "
"At most I<nbytes> are read.  Reading starts at offset I<*basep>, and "
"I<*basep> is updated with the new position after reading."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:65
msgid ""
"B<getdirentries>()  returns the number of bytes read or zero when at the end"
" of the directory.  If an error occurs, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:67
msgid "See the Linux library source code for details."
msgstr ""

#. type: tbl table
#: man-pages/man3/getdirentries.3:77
#, no-wrap
msgid "B<getdirentries>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:87
msgid ""
"Not in POSIX.1.  Present on the BSDs, and a few other systems.  Use "
"B<opendir>(3)  and B<readdir>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/getdirentries.3:89
msgid "B<lseek>(2), B<open>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/gets.3:29
#, no-wrap
msgid "GETS"
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:32
msgid "gets - get a string from standard input (DEPRECATED)"
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:37
#, no-wrap
msgid "B<char *gets(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:40
msgid "I<Never use this function>."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:50
msgid ""
"B<gets>()  reads a line from I<stdin> into the buffer pointed to by I<s> "
"until either a terminating newline or B<EOF>, which it replaces with a null "
"byte (\\(aq\\e0\\(aq).  No check for buffer overrun is performed (see BUGS "
"below)."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:58
msgid ""
"B<gets>()  returns I<s> on success, and NULL on error or when end of file "
"occurs while no characters have been read.  However, given the lack of "
"buffer overrun checking, there can be no guarantees that the function will "
"even return."
msgstr ""

#. type: tbl table
#: man-pages/man3/gets.3:68
#, no-wrap
msgid "B<gets>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:73
msgid "C89, C99, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:85
msgid ""
"LSB deprecates B<gets>().  POSIX.1-2008 marks B<gets>()  obsolescent.  ISO "
"C11 removes the specification of B<gets>()  from the C language, and since "
"version 2.16, glibc header files don't expose the function declaration if "
"the B<_ISOC11_SOURCE> feature test macro is defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:99
msgid ""
"Never use B<gets>().  Because it is impossible to tell without knowing the "
"data in advance how many characters B<gets>()  will read, and because "
"B<gets>()  will continue to store characters past the end of the buffer, it "
"is extremely dangerous to use.  It has been used to break computer security."
"  Use B<fgets>()  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:103
msgid ""
"For more information, see CWE-242 (aka \"Use of Inherently Dangerous "
"Function\") at http://cwe.mitre.org/data/definitions/242.html"
msgstr ""

#. type: Plain text
#: man-pages/man3/gets.3:120
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetc>(3), B<fgets>(3), "
"B<fgetwc>(3), B<fgetws>(3), B<fopen>(3), B<fread>(3), B<fseek>(3), "
"B<getline>(3), B<getwchar>(3), B<puts>(3), B<scanf>(3), B<ungetwc>(3), "
"B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""
