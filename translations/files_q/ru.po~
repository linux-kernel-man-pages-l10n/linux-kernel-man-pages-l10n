# Copyright (C) 2014 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Artyom Kunyov <artkun@guitarplayer.ru>, 2012.
# Konstantin Shvaykovskiy <kot.shv@gmail.com>, 2012.
# Yuri Kozlov <yuray@komyakino.ru>, 2012-2014.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2014-06-08 18:49+0400\n"
"PO-Revision-Date: 2014-06-08 21:58+0400\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<"
"=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#. type: TH
#: man-pages/man2/query_module.2:10
#, no-wrap
msgid "QUERY_MODULE"
msgstr "QUERY_MODULE"

#. type: TH
#: man-pages/man2/query_module.2:10
#, no-wrap
msgid "2014-05-10"
msgstr "2014-05-10"

#. type: TH
#: man-pages/man2/query_module.2:10
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man2/query_module.2:10
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man2/query_module.2:11
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man2/query_module.2:13
msgid "query_module - query the kernel for various bits pertaining to modules"
msgstr ""
"query_module - запросить ядро о различных параметрах, касающихся модулей"

#. type: SH
#: man-pages/man2/query_module.2:13
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man2/query_module.2:16
#, no-wrap
msgid "B<#include E<lt>linux/module.hE<gt>>\n"
msgstr "B<#include E<lt>linux/module.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/query_module.2:19
#, no-wrap
msgid ""
"B<int query_module(const char *>I<name>B<, int >I<which>B<, void *>I<buf>B<,>"
"\n"
"B<                 size_t >I<bufsize>B<, size_t *>I<ret>B<);>\n"
msgstr ""
"B<int query_module(const char *>I<name>B<, int >I<which>B<, void *>I<buf>B<,>"
"\nB<                 size_t >I<bufsize>B<, size_t *>I<ret>B<);>\n"

#. type: Plain text
#: man-pages/man2/query_module.2:23
msgid ""
"I<Note>: No declaration of this function is provided in glibc headers; see "
"NOTES."
msgstr ""
"I<Замечание>: В заголовочных файлах glibc эта функция отсутствует; смотрите "
"ЗАМЕЧАНИЯ."

#. type: SH
#: man-pages/man2/query_module.2:23
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man2/query_module.2:26
msgid "I<Note>: This system call is present only in kernels before Linux 2.6."
msgstr ""
"I<Замечание>: Данный системный вызов доступен только в ядрах до Linux 2.6."

#. type: Plain text
#: man-pages/man2/query_module.2:43
msgid ""
"B<query_module>()  requests information from the kernel about loadable "
"modules.  The returned information is placed in the buffer pointed to by "
"I<buf>.  The caller must specify the size of I<buf> in I<bufsize>.  The "
"precise nature and format of the returned information depend on the "
"operation specified by I<which>.  Some operations require I<name> to "
"identify a currently loaded module, some allow I<name> to be NULL, "
"indicating the kernel proper."
msgstr ""
"B<query_module>() запрашивает информацию у ядра о загружаемых модулях. "
"Возвращаемая информация помещается в буфер, указанный в I<buf>. Вызывающий "
"должен указать размер I<buf> в I<bufsize>. Смысл и формат возвращаемой "
"информации зависит от операции, задаваемой в I<which>. Для некоторых операций "
"требуется заполнить I<name> для указания на уже загруженный модуль, для "
"некоторых в I<name> можно указать NULL, что указывает на получения свойства "
"ядра."

#. type: Plain text
#: man-pages/man2/query_module.2:46
msgid "The following values can be specified for I<which>:"
msgstr "В I<which> можно указать следующие значения:"

#. type: TP
#: man-pages/man2/query_module.2:46
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: man-pages/man2/query_module.2:51
msgid ""
"Returns success, if the kernel supports B<query_module>().  Used to probe "
"for availability of the system call."
msgstr ""
"Завершается успешно, если ядро поддерживает B<query_module>(). Используется "
"для проверки доступности системного вызова."

#. type: TP
#: man-pages/man2/query_module.2:51
#, no-wrap
msgid "B<QM_MODULES>"
msgstr "B<QM_MODULES>"

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:59
msgid ""
"Returns the names of all loaded modules.  The returned buffer consists of a "
"sequence of null-terminated strings; I<ret> is set to the number of modules."
msgstr ""
"Возвращает имена всех загруженных модулей. Возвращаемый буфер содержит "
"последовательность строк, оканчивающихся null; в I<ret> указано количество "
"модулей."

#. type: TP
#: man-pages/man2/query_module.2:59
#, no-wrap
msgid "B<QM_DEPS>"
msgstr "B<QM_DEPS>"

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:66
msgid ""
"Returns the names of all modules used by the indicated module.  The returned"
" buffer consists of a sequence of null-terminated strings; I<ret> is set to "
"the number of modules."
msgstr ""
"Возвращает имена всех модулей, используемых указанным модулем. Возвращаемый "
"буфер содержит последовательность строк, оканчивающихся null; в I<ret> "
"указано количество модулей."

#. type: TP
#: man-pages/man2/query_module.2:66
#, no-wrap
msgid "B<QM_REFS>"
msgstr "B<QM_REFS>"

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:75
msgid ""
"Returns the names of all modules using the indicated module.  This is the "
"inverse of B<QM_DEPS>.  The returned buffer consists of a sequence of null-"
"terminated strings; I<ret> is set to the number of modules."
msgstr ""
"Возвращает имена всех модулей, использующих указанный модуль. Это обратная по "
"отношению к B<QM_DEPS> операция. Возвращаемый буфер содержит "
"последовательность строк, оканчивающихся null; в I<ret> указано количество "
"модулей."

#. type: TP
#: man-pages/man2/query_module.2:75
#, no-wrap
msgid "B<QM_SYMBOLS>"
msgstr "B<QM_SYMBOLS>"

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:81
msgid ""
"Returns the symbols and values exported by the kernel or the indicated "
"module.  The returned buffer is an array of structures of the following form"
msgstr ""
"Возвращает символы и значения, экспортируемые ядром или указанным модулем. "
"Возвращаемый буфер содержит массив структур следующего формата:"

#. type: Plain text
#: man-pages/man2/query_module.2:88
#, no-wrap
msgid ""
"struct module_symbol {\n"
"    unsigned long value;\n"
"    unsigned long name;\n"
"};\n"
msgstr ""
"struct module_symbol {\n    unsigned long value;\n    unsigned long "
"name;\n};\n"

#. type: Plain text
#: man-pages/man2/query_module.2:98
msgid ""
"followed by null-terminated strings.  The value of I<name> is the character "
"offset of the string relative to the start of I<buf>; I<ret> is set to the "
"number of symbols."
msgstr ""
"завершаемого строками, оканчивающимися null. Значение I<name> содержит "
"смещение строки в знаках относительно начала I<buf>; в I<ret> указано "
"количество символов."

#. type: TP
#: man-pages/man2/query_module.2:98
#, no-wrap
msgid "B<QM_INFO>"
msgstr "B<QM_INFO>"

#. type: Plain text
#: man-pages/man2/query_module.2:102
msgid ""
"Returns miscellaneous information about the indicated module.  The output "
"buffer format is:"
msgstr ""
"Возвращает различную информацию об указанном модуле. Формат результата в "
"буфере:"

#. type: Plain text
#: man-pages/man2/query_module.2:110
#, no-wrap
msgid ""
"struct module_info {\n"
"    unsigned long address;\n"
"    unsigned long size;\n"
"    unsigned long flags;\n"
"};\n"
msgstr ""
"struct module_info {\n    unsigned long address;\n    unsigned long size;\n   "
" unsigned long flags;\n};\n"

#. type: Plain text
#: man-pages/man2/query_module.2:129
msgid ""
"where I<address> is the kernel address at which the module resides, I<size> "
"is the size of the module in bytes, and I<flags> is a mask of "
"B<MOD_RUNNING>, B<MOD_AUTOCLEAN>, and so on, that indicates the current "
"status of the module (see the Linux kernel source file "
"I<include/linux/module.h>).  I<ret> is set to the size of the I<module_info>"
" structure."
msgstr ""
"где I<address> — это адрес ядра, где располагается модуль, I<size> — размер "
"модуля в байтах, I<flags> — маска B<MOD_RUNNING>, B<MOD_AUTOCLEAN> и т. п., "
"показывающая текущее состояние модуля (смотрите файл исходного кода ядра "
"Linux I<include/linux/module.h>). В I<ret> указан размер структуры I<"
"module_info>."

#. type: SH
#: man-pages/man2/query_module.2:129
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/query_module.2:134
msgid ""
"On success, zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается ноль. В случае ошибки возвращается -1, а "
"I<errno> устанавливается в соответствующее значение."

#. type: SH
#: man-pages/man2/query_module.2:134
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man2/query_module.2:135
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/query_module.2:143
msgid ""
"At least one of I<name>, I<buf>, or I<ret> was outside the program's "
"accessible address space."
msgstr ""
"Одно из значений в I<name>, I<buf> или I<ret> находится вне доступного "
"программного адресного пространства."

#. type: TP
#: man-pages/man2/query_module.2:143
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#.  Not permitted with QM_DEPS, QM_REFS, or QM_INFO.
#. type: Plain text
#: man-pages/man2/query_module.2:153
msgid ""
"Invalid I<which>; or I<name> is NULL (indicating \"the kernel\"), but this "
"is not permitted with the specified value of I<which>."
msgstr ""
"Неправильное значение I<which>; I<name> равно NULL (указывающее \"параметры "
"ядра\"), но оно не разрешено для указанного значения I<which>."

#. type: TP
#: man-pages/man2/query_module.2:153
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/query_module.2:158
msgid "No module by that I<name> exists."
msgstr "Модуль с именем, указанным в I<name>, не существует."

#. type: TP
#: man-pages/man2/query_module.2:158
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/query_module.2:163
msgid ""
"The buffer size provided was too small.  I<ret> is set to the minimum size "
"needed."
msgstr ""
"Указанный размер буфера слишком мал. В I<ret> возвращается минимальный "
"необходимый размер."

#. type: TP
#: man-pages/man2/query_module.2:163
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/query_module.2:168
msgid ""
"B<query_module>()  is not supported in this version of the kernel (e.g., the"
" kernel is version 2.6 or later)."
msgstr ""
"B<query_module>() не поддерживается в этой версии ядра (например, в 2.6 или "
"более поздних)."

#. type: SH
#: man-pages/man2/query_module.2:168
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#.  Removed in Linux 2.5.48
#. type: Plain text
#: man-pages/man2/query_module.2:172
msgid ""
"This system call is present on Linux only up until kernel 2.4; it was "
"removed in Linux 2.6."
msgstr ""
"Данный системный вызов есть только в Linux до версии 2.4; он был удалён в "
"Linux 2.6."

#. type: SH
#: man-pages/man2/query_module.2:172
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man2/query_module.2:175
msgid "B<query_module>()  is Linux-specific."
msgstr "B<query_module>() есть только в Linux."

#. type: SH
#: man-pages/man2/query_module.2:175
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man2/query_module.2:183
msgid ""
"Some of the information that was formerly available via B<query_module>()  "
"can be obtained from I</proc/modules>, I</proc/kallsyms>, and the files "
"under the directory I</sys/module>."
msgstr ""
"Некоторую информацию, которая была ранее доступна через B<query_module>(), "
"можно получить из I</proc/modules>, I</proc/kallsyms> и файлов из каталога I<"
"/sys/modules>."

#. type: Plain text
#: man-pages/man2/query_module.2:193
msgid ""
"The B<query_module>()  system call is not supported by glibc.  No "
"declaration is provided in glibc headers, but, through a quirk of history, "
"glibc does export an ABI for this system call.  Therefore, in order to "
"employ this system call, it is sufficient to manually declare the interface "
"in your code; alternatively, you can invoke the system call using "
"B<syscall>(2)."
msgstr ""
"Системный вызов B<query_module>() не поддерживается glibc. В заголовочных "
"файлах glibc он не объявлен, но в недавнем прошлом glibc экспортировал ABI "
"для этого системного вызова. Поэтому чтобы получить данный системный вызов "
"достаточно вручную объявить интерфейс в своём коде; или же вы можете вызвать "
"его через B<syscall>(2)."

#. type: SH
#: man-pages/man2/query_module.2:193
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man2/query_module.2:199
msgid ""
"B<create_module>(2), B<delete_module>(2), B<get_kernel_syms>(2), "
"B<init_module>(2), B<lsmod>(8), B<modinfo>(8)"
msgstr ""
"B<create_module>(2), B<delete_module>(2), B<get_kernel_syms>(2), B<"
"init_module>(2), B<lsmod>(8), B<modinfo>(8)"

#. type: TH
#: man-pages/man2/quotactl.2:27
#, no-wrap
msgid "QUOTACTL"
msgstr "QUOTACTL"

#. type: TH
#: man-pages/man2/quotactl.2:27
#, no-wrap
msgid "2010-06-16"
msgstr "2010-06-16"

#. type: Plain text
#: man-pages/man2/quotactl.2:30
msgid "quotactl - manipulate disk quotas"
msgstr "quotactl - управление дисковыми квотами"

#. type: Plain text
#: man-pages/man2/quotactl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt>>\n"
msgstr "B<#include E<lt>sys/quota.hE<gt>>\nB<#include E<lt>xfs/xqm.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:37
#, no-wrap
msgid ""
"B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, "
"caddr_t >I<addr>B<);>\n"
msgstr ""
"B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, "
"caddr_t >I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:49
msgid ""
"The quota system can be used to set per-user and per-group limits on the "
"amount of disk space used on a filesystem.  For each user and/or group, a "
"soft limit and a hard limit can be set for each filesystem.  The hard limit "
"can't be exceeded.  The soft limit can be exceeded, but warnings will ensue."
"  Moreover, the user can't exceed the soft limit for more than one week (by "
"default) at a time; after this time, the soft limit counts as a hard limit."
msgstr ""
"С помощью системы квот можно задать каждому пользователю или группе лимит "
"использования дискового пространства. Для пользователя или группы в каждой "
"файловой системе можно указать необязательный (soft) и обязательный (hard) "
"лимиты. Обязательный лимит не может быть превышен. Необязательный лимит "
"превышать можно, но будет выдано соответствующее предостережение. Более того, "
"пользователь не может превышать необязательный лимит более одной недели (по "
"умолчанию): по истечении этого времени необязательный лимит будет считаться "
"обязательным."

#. type: Plain text
#: man-pages/man2/quotactl.2:74
msgid ""
"The B<quotactl>()  call manipulates disk quotas.  The I<cmd> argument "
"indicates a command to be applied to the user or group ID specified in "
"I<id>.  To initialize the I<cmd> argument, use the I<QCMD(subcmd, type)> "
"macro.  The I<type> value is either B<USRQUOTA>, for user quotas, or "
"B<GRPQUOTA>, for group quotas.  The I<subcmd> value is described below."
msgstr ""
"Управление квотами выполняется с помощью вызова B<quotactl>(). В аргументе I<"
"cmd> задаётся команда, которая должна быть применена для пользовательского "
"или группового идентификатора, указанного в I<id>. Для инициализации значения "
"аргумента I<cmd> используйте макрос I<QCMD(subcmd, type)>. Значение I<type> "
"может быть B<USRQUOTA> (для пользовательских квот) или B<GRPQUOTA> (для "
"групповых квот). Значение I<subcmd> описано ниже."

#. type: Plain text
#: man-pages/man2/quotactl.2:79
msgid ""
"The I<special> argument is a pointer to a null-terminated string containing "
"the pathname of the (mounted) block special device for the filesystem being "
"manipulated."
msgstr ""
"Аргумент I<special> представляет собой указатель на строку, завершающуюся "
"null и содержащую путь к блочному устройству (смонтированному) с файловой "
"системой, на которую накладывается квота."

#. type: Plain text
#: man-pages/man2/quotactl.2:87
msgid ""
"The I<addr> argument is the address of an optional, command-specific, data "
"structure that is copied in or out of the system.  The interpretation of "
"I<addr> is given with each command below."
msgstr ""
"Аргумент I<addr> представляет собой адрес необязательной, зависящей от "
"команды, структуры данных, которые копируются в или из системы. Интерпретация "
"I<addr> указана ниже (для каждой команды)."

#. type: Plain text
#: man-pages/man2/quotactl.2:91
msgid "The I<subcmd> value is one of the following:"
msgstr "Значением I<subcmd> может быть одно из:"

#. type: TP
#: man-pages/man2/quotactl.2:91
#, no-wrap
msgid "B<Q_QUOTAON>"
msgstr "B<Q_QUOTAON>"

#. type: Plain text
#: man-pages/man2/quotactl.2:98
msgid ""
"Turn on quotas for a filesystem.  The I<id> argument is the identification "
"number of the quota format to be used.  Currently, there are three supported"
" quota formats:"
msgstr ""
"Включает учёт квот в файловой системе. В аргументе I<id> задаётся "
"используемый идентификационный номер формата квот. В настоящее время "
"поддерживается три формата квот:"

#. type: TP
#: man-pages/man2/quotactl.2:99
#, no-wrap
msgid "B<QFMT_VFS_OLD>"
msgstr "B<QFMT_VFS_OLD>"

#. type: Plain text
#: man-pages/man2/quotactl.2:102
msgid "The original quota format."
msgstr "Самая первая версия формата квот."

#. type: TP
#: man-pages/man2/quotactl.2:102
#, no-wrap
msgid "B<QFMT_VFS_V0>"
msgstr "B<QFMT_VFS_V0>"

#. type: Plain text
#: man-pages/man2/quotactl.2:106
msgid ""
"The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and "
"quota limits up to 2^42 bytes and 2^32 inodes."
msgstr ""
"Стандартный формат квот VFS v0, позволяет работать с  32-битными UID и GID и "
"ограничениями по квотам до 2^42 байт и 2^32 inode."

#. type: TP
#: man-pages/man2/quotactl.2:106
#, no-wrap
msgid "B<QFMT_VFS_V1>"
msgstr "B<QFMT_VFS_V1>"

#. type: Plain text
#: man-pages/man2/quotactl.2:110
msgid ""
"A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64"
" bytes and 2^64 inodes."
msgstr ""
"Данный формат квот позволяет работать с 32-битными UID и GID и ограничениями "
"по квотам до 2^64 байт и 2^64 inode."

#. type: Plain text
#: man-pages/man2/quotactl.2:121
msgid ""
"The I<addr> argument points to the pathname of a file containing the quotas "
"for the filesystem.  The quota file must exist; it is normally created with "
"the B<quotacheck>(8)  program.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""
"Аргумент I<addr> представляет собой указатель на путь к файлу, в котором "
"содержатся квоты файловой системы. Файл квот должен существовать; обычно он "
"создаётся с помощью программы B<quotacheck>(8). Данная операция требует "
"дополнительных прав (B<CAP_SYS_ADMIN>)."

#. type: TP
#: man-pages/man2/quotactl.2:121
#, no-wrap
msgid "B<Q_QUOTAOFF>"
msgstr "B<Q_QUOTAOFF>"

#. type: Plain text
#: man-pages/man2/quotactl.2:131
msgid ""
"Turn off quotas for a filesystem.  The I<addr> and I<id> arguments are "
"ignored.  This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""
"Выключает учёт квот в файловой системе. Аргументы I<addr> и I<id> "
"игнорируются. Данная операция требует дополнительных прав (B<CAP_SYS_ADMIN>)."

#. type: TP
#: man-pages/man2/quotactl.2:131
#, no-wrap
msgid "B<Q_GETQUOTA>"
msgstr "B<Q_GETQUOTA>"

#. type: Plain text
#: man-pages/man2/quotactl.2:142
msgid ""
"Get disk quota limits and current usage for user or group I<id>.  The "
"I<addr> argument is a pointer to a I<dqblk> structure defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""
"Возвращает данные по лимитам и текущее значение использованного пространства "
"для пользователя или группы с заданным I<id>. Аргумент I<addr> является "
"указателем на структуру I<dqblk>, определённую в I<E<lt>sys/quota.hE<gt>> "
"следующим образом:"

#. type: Plain text
#: man-pages/man2/quotactl.2:147 man-pages/man2/quotactl.2:234
#, no-wrap
msgid ""
"/* uint64_t is an unsigned 64-bit integer;\n"
"   uint32_t is an unsigned 32-bit integer */\n"
msgstr ""
"/* uint64_t имеет тип unsigned 64-bit integer;\n   uint32_t имеет тип "
"unsigned 32-bit integer */\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:167
#, no-wrap
msgid ""
"struct dqblk {          /* Definition since Linux 2.4.22 */\n"
"    uint64_t dqb_bhardlimit;   /* absolute limit on disk\n"
"                                  quota blocks alloc */\n"
"    uint64_t dqb_bsoftlimit;   /* preferred limit on\n"
"                                  disk quota blocks */\n"
"    uint64_t dqb_curspace;     /* current quota block\n"
"                                  count */\n"
"    uint64_t dqb_ihardlimit;   /* maximum number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_isoftlimit;   /* preferred inode limit */\n"
"    uint64_t dqb_curinodes;    /* current number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_btime;        /* time limit for excessive\n"
"                                  disk use */\n"
"    uint64_t dqb_itime;        /* time limit for excessive\n"
"                                  files */\n"
"    uint32_t dqb_valid;        /* bit mask of QIF_*\n"
"                                  constants */\n"
"};\n"
msgstr ""
"struct dqblk {          /* Определение, действующее с Linux 2.4.22 */\n    "
"uint64_t dqb_bhardlimit;   /* абсолютный лимит на выделяемые\n                "
"                  блоки дисковых квот */\n    uint64_t dqb_bsoftlimit;   /* "
"предпочтительный лимит на выделяемые\n                                  блоки "
"дисковых квот */\n    uint64_t dqb_curspace;     /* текущее количество блоков "
"квот */\n    uint64_t dqb_ihardlimit;   /* максимальное количество \n         "
"                         выделенных inode */\n    uint64_t dqb_isoftlimit;   "
"/* предпочтительных лимит по inode */\n    uint64_t dqb_curinodes;    /* "
"текущее количество\n                                  выделенных inode */\n   "
" uint64_t dqb_btime;        /* временной лимит по превышению\n                "
"                  использования диска */\n    uint64_t dqb_itime;        /* "
"временной лимит по превышению\n                                  файлов */\n  "
"  uint32_t dqb_valid;        /* битовая маска констант QIF_* */\n};\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:170
#, no-wrap
msgid ""
"/* Flags in dqb_valid that indicate which fields in\n"
"   dqblk structure are valid. */\n"
msgstr ""
"/* Флаги в dqb_valid указывают, какие поля в\n   структуре dqblk являются "
"рабочими. */\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:181
#, no-wrap
msgid ""
"#define QIF_BLIMITS   1\n"
"#define QIF_SPACE     2\n"
"#define QIF_ILIMITS   4\n"
"#define QIF_INODES    8\n"
"#define QIF_BTIME     16\n"
"#define QIF_ITIME     32\n"
"#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n"
"#define QIF_USAGE     (QIF_SPACE | QIF_INODES)\n"
"#define QIF_TIMES     (QIF_BTIME | QIF_ITIME)\n"
"#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"
msgstr ""
"#define QIF_BLIMITS   1\n#define QIF_SPACE     2\n#define QIF_ILIMITS   "
"4\n#define QIF_INODES    8\n#define QIF_BTIME     16\n#define QIF_ITIME     "
"32\n#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n#define QIF_USAGE     "
"(QIF_SPACE | QIF_INODES)\n#define QIF_TIMES     (QIF_BTIME | "
"QIF_ITIME)\n#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:198
msgid ""
"The I<dqb_valid> field is a bit mask that is set to indicate the entries in "
"the I<dqblk> structure that are valid.  Currently, the kernel fills in all "
"entries of the I<dqblk> structure and marks them as valid in the "
"I<dqb_valid> field.  Unprivileged users may retrieve only their own quotas; "
"a privileged user (B<CAP_SYS_ADMIN>)  can retrieve the quotas of any user."
msgstr ""
"Поле I<dqb_valid> представляет собой битовую маску, показывающую какие поля в "
"структуре I<dqblk> являются рабочими. В настоящее время ядро заполняется все "
"поля структуры I<dqblk> и маркирует их как рабочие в поле I<dqb_valid>. "
"Непривилегированные пользователи могут получить данные только по своим "
"квотам; привилегированный пользователь (имеющий мандат B<CAP_SYS_ADMIN>) "
"может получить данные по квотам любого пользователя."

#. type: TP
#: man-pages/man2/quotactl.2:198
#, no-wrap
msgid "B<Q_SETQUOTA>"
msgstr "B<Q_SETQUOTA>"

#. type: Plain text
#: man-pages/man2/quotactl.2:218
msgid ""
"Set quota information for user or group I<id>, using the information "
"supplied in the I<dqblk> structure pointed to by I<addr>.  The I<dqb_valid> "
"field of the I<dqblk> structure indicates which entries in the structure "
"have been set by the caller.  This operation supersedes the B<Q_SETQLIM> and"
" B<Q_SETUSE> operations in the previous quota interfaces.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""
"Устанавливает квоты для пользователя или группы с указанным I<id>, используя "
"информацию из структуры I<dqblk>, на которую указывает I<addr>. Полем I<"
"dqb_valid> в структуре I<dqblk> определяется какие элементы структуры "
"установлены вызывающим. Эта операция заменяет предоставляемые прежде операции "
"работы с квотами B<Q_SETQLIM> и B<Q_SETUSE>. Эта операция требует "
"дополнительных прав (B<CAP_SYS_ADMIN>)."

#. type: TP
#: man-pages/man2/quotactl.2:218
#, no-wrap
msgid "B<Q_GETINFO>"
msgstr "B<Q_GETINFO>"

#. type: Plain text
#: man-pages/man2/quotactl.2:229
msgid ""
"Get information (like grace times) about quotafile.  The I<addr> argument "
"should be a pointer to a I<dqinfo> structure.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""
"Возвращает информацию (например, льготное время (grace times)) о quotafile. "
"Аргумент I<addr> должен содержать указатель на структуру I<dqinfo>. Эта "
"структура определена в I<E<lt>sys/quota.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/quotactl.2:238
#, no-wrap
msgid ""
"struct dqinfo {         /* Defined since kernel 2.4.22 */\n"
"    uint64_t dqi_bgrace;    /* Time before block soft limit\n"
"                               becomes hard limit */\n"
msgstr ""
"struct dqinfo {         /* начиная с ядра 2.4.22 */\n    uint64_t dqi_bgrace; "
"   /* время, перед тем как необязательный предел\n                            "
"   для блока станет обязательным */\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:245
#, no-wrap
msgid ""
"    uint64_t dqi_igrace;    /* Time before inode soft limit\n"
"                               becomes hard limit */\n"
"    uint32_t dqi_flags;     /* Flags for quotafile\n"
"                               (DQF_*) */\n"
"    uint32_t dqi_valid;\n"
"};\n"
msgstr ""
"    uint64_t dqi_igrace;    /* время, перед тем как необязательный предел\n   "
"                            для inode станет обязательным */\n    uint32_t "
"dqi_flags;     /* флаги quotafile\n                               (DQF_*) "
"*/\n    uint32_t dqi_valid;\n};\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:247
#, no-wrap
msgid "/* Bits for dqi_flags */\n"
msgstr "/* биты из dqi_flags */\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:249
#, no-wrap
msgid "/* Quota format QFMT_VFS_OLD */\n"
msgstr "/* формат квот QFMT_VFS_OLD */\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:251
#, no-wrap
msgid "#define V1_DQF_RSQUASH\t1   /* Root squash enabled */\n"
msgstr ""
"#define V1_DQF_RSQUASH\t1   /* включён режим сброса прав root (root squash) "
"*/\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:253
#, no-wrap
msgid "/* Other quota formats have no dqi_flags bits defined */\n"
msgstr "/* в других форматах квот биты dqi_flags не определены */\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:256
#, no-wrap
msgid ""
"/* Flags in dqi_valid that indicate which fields in\n"
"   dqinfo structure are valid. */\n"
msgstr ""
"/* флаги в dqi_valid, которые показывают какие поля в\n   структуре dqinfo "
"рабочие. */\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:261
#, no-wrap
msgid ""
"# define IIF_BGRACE\t1\n"
"# define IIF_IGRACE\t2\n"
"# define IIF_FLAGS\t4\n"
"# define IIF_ALL        (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"
msgstr ""
"# define IIF_BGRACE\t1\n# define IIF_IGRACE\t2\n# define IIF_FLAGS\t4\n# "
"define IIF_ALL        (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"

#. type: Plain text
#: man-pages/man2/quotactl.2:277
msgid ""
"The I<dqi_valid> field in the I<dqinfo> structure indicates the entries in "
"the structure that are valid.  Currently, the kernel fills in all entries of"
" the I<dqinfo> structure and marks them all as valid in the I<dqi_valid> "
"field.  The I<id> argument is ignored."
msgstr ""
"Значение поля I<dqi_valid> в структуре I<dqinfo> указывает на рабочие "
"элементы. В настоящее время ядро заполняет все элементы структуры I<dqinfo> и "
"помечает их как рабочие в поле I<dqi_valid>. Аргумент I<id> игнорируется."

#. type: TP
#: man-pages/man2/quotactl.2:277
#, no-wrap
msgid "B<Q_SETINFO>"
msgstr "B<Q_SETINFO>"

#. type: Plain text
#: man-pages/man2/quotactl.2:301
msgid ""
"Set information about quotafile.  The I<addr> argument should be a pointer "
"to a I<dqinfo> structure.  The I<dqi_valid> field of the I<dqinfo> structure"
" indicates the entries in the structure that have been set by the caller.  "
"This operation supersedes the B<Q_SETGRACE> and B<Q_SETFLAGS> operations in "
"the previous quota interfaces.  The I<id> argument is ignored.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""
"Задаёт информацию о quotafile. Значение аргумента I<addr> должно быть "
"указателем на структуру I<dqinfo>. Полем I<dqi_valid> в структуре I<dqinfo> "
"определяется, какие элементы структуры установлены вызывающим. Эта операция "
"заменяет операции B<Q_SETGRACE> и B<Q_SETFLAGS> из предоставляемых прежде "
"операций работы с квотами. Аргумент I<id> игнорируется. Эта операция требует "
"дополнительных прав (B<CAP_SYS_ADMIN>)."

#. type: TP
#: man-pages/man2/quotactl.2:301
#, no-wrap
msgid "B<Q_GETFMT>"
msgstr "B<Q_GETFMT>"

#. type: Plain text
#: man-pages/man2/quotactl.2:308
msgid ""
"Get quota format used on the specified filesystem.  The I<addr> argument "
"should be a pointer to a 4-byte buffer where the format number will be "
"stored."
msgstr ""
"Возвращает формат квоты, используемый в указанной файловой системе. В "
"аргументе I<addr> должен содержаться указатель на 4-байтовый буфер, в который "
"будет записан номер формата."

#. type: TP
#: man-pages/man2/quotactl.2:308
#, no-wrap
msgid "B<Q_SYNC>"
msgstr "B<Q_SYNC>"

#. type: Plain text
#: man-pages/man2/quotactl.2:319
msgid ""
"Update the on-disk copy of quota usages for a filesystem.  If I<special> is "
"NULL, then all filesystems with active quotas are sync'ed.  The I<addr> and "
"I<id> arguments are ignored."
msgstr ""
"Обновляет дисковую копию используемых квот в файловой системе. Если значение "
"I<special> равно NULL, то действующие квоты будут синхронизированы на всех "
"файловых системах. Аргументы I<addr> и I<id> игнорируются."

#. type: TP
#: man-pages/man2/quotactl.2:319
#, no-wrap
msgid "B<Q_GETSTATS>"
msgstr "B<Q_GETSTATS>"

#.  Q_GETSTATS was removed in kernel 2.4.22.
#. type: Plain text
#: man-pages/man2/quotactl.2:339
msgid ""
"Get statistics and other generic information about the quota subsystem.  The"
" I<addr> argument should be a pointer to a I<dqstats> structure in which "
"data should be stored.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>>.  The I<special> and I<id> arguments are ignored.  "
"This operation is obsolete and not supported by recent kernels.  Files in "
"I</proc/sys/fs/quota/> carry the information instead."
msgstr ""
"Возвращает статистику и другую общую информацию о подсистеме квот. Аргумент "
"I<addr> должен содержать указатель на структуру I<dqstats>, в которую нужно "
"сохранить данные. Эта структура определена в I<E<lt>sys/quota.hE<gt>>. "
"Аргументы I<special> и I<id> игнорируются. Эта операция устарела и не "
"поддерживается новыми ядрами. Информацию можно получить из файлов в I<"
"/proc/sys/fs/quota/>."

#. type: Plain text
#: man-pages/man2/quotactl.2:342
msgid ""
"For XFS filesystems making use of the XFS Quota Manager (XQM), the above "
"commands are bypassed and the following commands are used:"
msgstr ""
"Для файловых систем XFS, использующих XFS Quota Manager (XQM), приведённые "
"выше команды не выполняются, а используются следующие команды:"

#. type: TP
#: man-pages/man2/quotactl.2:342
#, no-wrap
msgid "B<Q_XQUOTAON>"
msgstr "B<Q_XQUOTAON>"

#. type: Plain text
#: man-pages/man2/quotactl.2:363
msgid ""
"Turn on quotas for an XFS filesystem.  XFS provides the ability to turn "
"on/off quota limit enforcement with quota accounting.  Therefore, XFS "
"expects I<addr> to be a pointer to an I<unsigned int> that contains either "
"the flags B<XFS_QUOTA_UDQ_ACCT> and/or B<XFS_QUOTA_UDQ_ENFD> (for user "
"quota), or B<XFS_QUOTA_GDQ_ACCT> and/or B<XFS_QUOTA_GDQ_ENFD> (for group "
"quota), as defined in I<E<lt>xfs/xqm.hE<gt>>.  This operation requires "
"privilege (B<CAP_SYS_ADMIN>)."
msgstr ""
"Включает квоты для файловой системы XFS. XFS позволяет включать/выключать "
"применение квот с ведением учёта. Поэтому для XFS в I<addr> ожидается "
"указатель на I<unsigned int>, который представляет собой или флаги B<"
"XFS_QUOTA_UDQ_ACCT> и/или B<XFS_QUOTA_UDQ_ENFD> (для пользовательской квоты), "
"или B<XFS_QUOTA_GDQ_ACCT> и/или B<XFS_QUOTA_GDQ_ENFD> (для квот на группу), "
"определённые в I<E<lt>xfs/xqm.hE<gt>>. Эта операция требует дополнительных "
"прав (B<CAP_SYS_ADMIN>)."

#. type: TP
#: man-pages/man2/quotactl.2:363
#, no-wrap
msgid "B<Q_XQUOTAOFF>"
msgstr "B<Q_XQUOTAOFF>"

#. type: Plain text
#: man-pages/man2/quotactl.2:374
msgid ""
"Turn off quotas for an XFS filesystem.  As with B<Q_QUOTAON>, XFS "
"filesystems expect a pointer to an I<unsigned int> that specifies whether "
"quota accounting and/or limit enforcement need to be turned off.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""
"Выключает квоты для файловой системы XFS. Как в B<Q_QUOTAON>, для файловых "
"систем XFS ожидается указатель на I<unsigned int>, в котором задаётся что "
"нужно отключить: учёт или применение квот. Эта операция требует "
"дополнительных прав (B<CAP_SYS_ADMIN>)."

#. type: TP
#: man-pages/man2/quotactl.2:374
#, no-wrap
msgid "B<Q_XGETQUOTA>"
msgstr "B<Q_XGETQUOTA>"

#. type: Plain text
#: man-pages/man2/quotactl.2:388
msgid ""
"Get disk quota limits and current usage for user I<id>.  The I<addr> "
"argument is a pointer to an I<fs_disk_quota> structure (defined in "
"I<E<lt>xfs/xqm.hE<gt>>).  Unprivileged users may retrieve only their own "
"quotas; a privileged user (B<CAP_SYS_ADMIN>)  may retrieve the quotas of any"
" user."
msgstr ""
"Возвращает дисковые квоты и текущее использование для пользователя с "
"указанным I<id>. В I<addr> содержится указатель на структуру I<fs_disk_quota> "
"(определена в I<E<lt>xfs/xqm.hE<gt>>). Непривилегированные пользователи могут "
"получить данные только по своим квотам; привилегированный пользователь (с B<"
"CAP_SYS_ADMIN>) может получить информацию о квотах любого пользователя."

#. type: TP
#: man-pages/man2/quotactl.2:388
#, no-wrap
msgid "B<Q_XSETQLIM>"
msgstr "B<Q_XSETQLIM>"

#. type: Plain text
#: man-pages/man2/quotactl.2:400
msgid ""
"Set disk quota limits for user I<id>.  The I<addr> argument is a pointer to "
"an I<fs_disk_quota> structure (defined in I<E<lt>xfs/xqm.hE<gt>>).  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""
"Устанавливает дисковую квоту для пользователя с указанным I<id>. В аргументе "
"I<addr> задаётся указатель на структуру I<fs_disk_quota> (определена в I<E<lt>"
"xfs/xqm.hE<gt>>). Эта операция требует дополнительных прав (B<CAP_SYS_ADMIN>)."

#. type: TP
#: man-pages/man2/quotactl.2:400
#, no-wrap
msgid "B<Q_XGETQSTAT>"
msgstr "B<Q_XGETQSTAT>"

#. type: Plain text
#: man-pages/man2/quotactl.2:408
msgid ""
"Returns an I<fs_quota_stat> structure containing XFS filesystem-specific "
"quota information.  This is useful for finding out how much space is used to"
" store quota information, and also to get quotaon/off status of a given "
"local XFS filesystem."
msgstr ""
"Возвращает структуру I<fs_quota_stat>, в которой содержится информация о "
"квотах, которая доступна только для файловой системы XFS. Она полезна для "
"определения пространства, использованного для хранения информации о квотах, а "
"также для получения состояния включённых/отключённых квот в заданной "
"локальной файловой системе XFS."

#. type: TP
#: man-pages/man2/quotactl.2:408
#, no-wrap
msgid "B<Q_XQUOTARM>"
msgstr "B<Q_XQUOTARM>"

#. type: Plain text
#: man-pages/man2/quotactl.2:412
msgid ""
"Free the disk space taken by disk quotas.  Quotas must have already been "
"turned off."
msgstr ""
"Освобождает дисковое пространство, занятое под квоты. Квоты должны быть "
"выключены."

#. type: Plain text
#: man-pages/man2/quotactl.2:419
msgid ""
"There is no command equivalent to B<Q_SYNC> for XFS since B<sync>(1)  writes"
" quota information to disk (in addition to the other filesystem metadata "
"that it writes out)."
msgstr ""
"Для XFS нет эквивалента команде B<Q_SYNC>, так как B<sync>(1) записывает "
"информацию о квотах на диск (вместе с другими метаданными файловой системы)."

#. type: Plain text
#: man-pages/man2/quotactl.2:427
msgid ""
"On success, B<quotactl>()  returns 0; on error -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"При успешном выполнении B<quotactl>() возвращается 0; при ошибке возвращается "
"-1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/quotactl.2:434
msgid "I<addr> or I<special> is invalid."
msgstr "Неверное значение I<addr> или I<special>."

#. type: Plain text
#: man-pages/man2/quotactl.2:440
msgid "I<cmd> or I<type> is invalid."
msgstr "Неверное значение I<cmd> или I<type>."

#. type: Plain text
#: man-pages/man2/quotactl.2:447
msgid "The file specified by I<special> or I<addr> does not exist."
msgstr "Файл, указанный в I<special> или I<addr>, не существует."

#. type: Plain text
#: man-pages/man2/quotactl.2:452
msgid "The kernel has not been compiled with the B<CONFIG_QUOTA> option."
msgstr "Ядро собрано с выключенным параметром B<CONFIG_QUOTA>."

#. type: TP
#: man-pages/man2/quotactl.2:452
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: man-pages/man2/quotactl.2:456
msgid "I<special> is not a block device."
msgstr "Значение I<special> не указывает на блочное устройство."

#. type: TP
#: man-pages/man2/quotactl.2:456
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/quotactl.2:461
msgid ""
"The caller lacked the required privilege (B<CAP_SYS_ADMIN>)  for the "
"specified operation."
msgstr ""
"Вызывающий не имеет необходимых прав (B<CAP_SYS_ADMIN>) для выполнения "
"указанной операции."

#. type: TP
#: man-pages/man2/quotactl.2:461 man-pages/man2/quotactl.2:504
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/quotactl.2:465
msgid ""
"No disk quota is found for the indicated user.  Quotas have not been turned "
"on for this filesystem."
msgstr ""
"Не найдена дисковая квота для заданного пользователя. Квоты выключены в "
"файловой системе."

#. type: Plain text
#: man-pages/man2/quotactl.2:474
msgid "If I<cmd> is B<Q_SETQUOTA>, B<quotactl>()  may also set I<errno> to:"
msgstr ""
"Если значение I<cmd> равно B<Q_SETQUOTA>, то B<quotactl>() также может "
"присвоить I<errno> следующее:"

#. type: TP
#: man-pages/man2/quotactl.2:474
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man2/quotactl.2:477
msgid "Specified limits are out of range allowed by quota format."
msgstr "Заданный лимит вне диапазона допустимого форматом квот."

#. type: Plain text
#: man-pages/man2/quotactl.2:486
msgid "If I<cmd> is B<Q_QUOTAON>, B<quotactl>()  may also set I<errno> to:"
msgstr ""
"Если значение I<cmd> равно B<Q_QUOTAON>, то B<quotactl>() также может "
"присвоить I<errno> следующее:"

#. type: TP
#: man-pages/man2/quotactl.2:486
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/quotactl.2:495
msgid ""
"The quota file pointed to by I<addr> exists, but is not a regular file; or, "
"the quota file pointed to by I<addr> exists, but is not on the filesystem "
"pointed to by I<special>."
msgstr ""
"Файл квот, указанный в I<addr>, существует, но не является обычным файлом; "
"или файл квот, указанный в I<addr>, существует, но находится не на файловой "
"системе, указанной в I<special>."

#. type: TP
#: man-pages/man2/quotactl.2:495
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/quotactl.2:501
msgid ""
"B<Q_QUOTAON> attempted, but another B<Q_QUOTAON> had already been performed."
msgstr ""
"Попытка выполнить B<Q_QUOTAON>, но уже выполняется другой запуск B<Q_QUOTAON>."

#. type: Plain text
#: man-pages/man2/quotactl.2:504
msgid "The quota file is corrupted."
msgstr "Файл квот повреждён."

#. type: Plain text
#: man-pages/man2/quotactl.2:507
msgid "Specified quota format was not found."
msgstr "Заданный формат квот не найден."

#. type: Plain text
#: man-pages/man2/quotactl.2:511
msgid "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"
msgstr "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"

#. type: TH
#: man-pages/man3/qsort.3:37
#, no-wrap
msgid "QSORT"
msgstr "QSORT"

#. type: TH
#: man-pages/man3/qsort.3:37
#, no-wrap
msgid "2012-03-08"
msgstr "2012-03-08"

#. type: Plain text
#: man-pages/man3/qsort.3:40
msgid "qsort, qsort_r - sort an array"
msgstr "qsort, qsort_r - сортировка массива"

#. type: Plain text
#: man-pages/man3/qsort.3:43
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/qsort.3:46
#, no-wrap
msgid ""
"B<void qsort(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void qsort(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\nB<    "
"       int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: man-pages/man3/qsort.3:50
#, no-wrap
msgid ""
"B<void qsort_r(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *, void *),>\n"
"B<           void *>I<arg>B<);>\n"
msgstr ""
"B<void qsort_r(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\nB<  "
"         int (*>I<compar>B<)(const void *, const void *, void *),>\nB<        "
"   void *>I<arg>B<);>\n"

#. type: Plain text
#: man-pages/man3/qsort.3:55
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>"
"(7)):"

#. type: Plain text
#: man-pages/man3/qsort.3:60
msgid "B<qsort_r>(): _GNU_SOURCE"
msgstr "B<qsort_r>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/qsort.3:68
msgid ""
"The B<qsort>()  function sorts an array with I<nmemb> elements of size "
"I<size>.  The I<base> argument points to the start of the array."
msgstr ""
"Функция B<qsort>() сортирует массив из I<nmemb> размером I<size>. Аргумент I<"
"base> указывает на начало массива."

#. type: Plain text
#: man-pages/man3/qsort.3:72
msgid ""
"The contents of the array are sorted in ascending order according to a "
"comparison function pointed to by I<compar>, which is called with two "
"arguments that point to the objects being compared."
msgstr ""
"Содержимое массива сортируется в соответствии с функцией сравнения, на "
"которую ссылается I<compar>, вызываемой вместе с двумя аргументами, которые "
"ссылаются на сравниваемые объекты."

#. type: Plain text
#: man-pages/man3/qsort.3:78
msgid ""
"The comparison function must return an integer less than, equal to, or "
"greater than zero if the first argument is considered to be respectively "
"less than, equal to, or greater than the second.  If two members compare as "
"equal, their order in the sorted array is undefined."
msgstr ""
"Функция сравнения должна вернуть целое, меньшее, равное и большее нуля для "
"случаев, когда первый аргумент меньше, равен или больше второго "
"соответственно. Если оба элемента сравнения равны, порядок их сортировки в "
"массиве не будет определен."

#. type: Plain text
#: man-pages/man3/qsort.3:91
msgid ""
"The B<qsort_r>()  function is identical to B<qsort>()  except that the "
"comparison function I<compar> takes a third argument.  A pointer is passed "
"to the comparison function via I<arg>.  In this way, the comparison function"
" does not need to use global variables to pass through arbitrary arguments, "
"and is therefore reentrant and safe to use in threads."
msgstr ""
"Функция B<qsort_r>() идентична B<qsort>(), за исключением того, что в функцию "
"сравнения I<compar> добавлен третий аргумент. Указатель передаётся в функцию "
"сравнения через аргумент I<arg>. Таким образом, функции сравнения не "
"требуется глобальныепеременные для передачи произвольных аргументов, и "
"поэтому она реентерабельна и её можно безопасно использовать в нитях."

#. type: Plain text
#: man-pages/man3/qsort.3:97
msgid "The B<qsort>()  and B<qsort_r>()  functions return no value."
msgstr "Функции B<qsort>() и B<qsort_r>() ничего не возвращают."

#. type: Plain text
#: man-pages/man3/qsort.3:100
msgid "B<qsort_r>()  was added to glibc in version 2.8."
msgstr "Функция B<qsort_r>() впервые появилась в glibc 2.8."

#. type: Plain text
#: man-pages/man3/qsort.3:104
msgid "The B<qsort>()  function conforms to SVr4, 4.3BSD, C89, C99."
msgstr "Функция B<qsort>() соответствует SVr4, 4.3BSD, C89, C99."

#. type: Plain text
#: man-pages/man3/qsort.3:116
msgid ""
"Library routines suitable for use as the I<compar> argument to B<qsort>()  "
"include B<alphasort>(3)  and B<versionsort>(3).  To compare C strings, the "
"comparison function can call B<strcmp>(3), as shown in the example below."
msgstr ""
"Для использования в параметре I<compar> функции B<qsort>() подходят "
"библиотечные процедуры B<alphasort>(3) и B<versionsort>(3). Для сравнения "
"C-строк в качестве функции сравнения можно использовать B<strcmp>(3), как это "
"указано ниже."

#. type: SH
#: man-pages/man3/qsort.3:116
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man3/qsort.3:119
msgid "For one example of use, see the example under B<bsearch>(3)."
msgstr "Для примера использования смотрите пример, указанный в B<bsearch>(3)."

#. type: Plain text
#: man-pages/man3/qsort.3:122
msgid ""
"Another example is the following program, which sorts the strings given in "
"its command-line arguments:"
msgstr ""
"Еще один пример программы, сортирующей строки, переданные в качестве "
"аргументов через командную строку:"

#. type: Plain text
#: man-pages/man3/qsort.3:127
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>"
"string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/qsort.3:134
#, no-wrap
msgid ""
"static int\n"
"cmpstringp(const void *p1, const void *p2)\n"
"{\n"
"    /* The actual arguments to this function are \"pointers to\n"
"       pointers to char\", but strcmp(3) arguments are \"pointers\n"
"       to char\", hence the following cast plus dereference */\n"
msgstr ""
"static int\ncmpstringp(const void *p1, const void *p2)\n{\n    /* Аргументами "
"данной функции являются \"pointers to\n       pointers to char\", однако "
"аргументами strcmp(3) \n       являются \"pointers to char\", так что здесь "
"происходит\n       преобразование и разыменовывание ссылок */\n"

#. type: Plain text
#: man-pages/man3/qsort.3:137
#, no-wrap
msgid ""
"    return strcmp(* (char * const *) p1, * (char * const *) p2);\n"
"}\n"
msgstr "    return strcmp(* (char * const *) p1, * (char * const *) p2);\n}\n"

#. type: Plain text
#: man-pages/man3/qsort.3:142
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int j;\n"

#. type: Plain text
#: man-pages/man3/qsort.3:147
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n        fprintf(stderr, \"Использование: %s E<lt>"
"stringE<gt>...\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/qsort.3:149
#, no-wrap
msgid "    qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);\n"
msgstr "    qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);\n"

#. type: Plain text
#: man-pages/man3/qsort.3:154
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        puts(argv[j]);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    for (j = 1; j E<lt> argc; j++)\n        puts(argv[j]);\n    "
"exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/qsort.3:159
msgid "B<sort>(1), B<alphasort>(3), B<strcmp>(3), B<versionsort>(3)"
msgstr "B<sort>(1), B<alphasort>(3), B<strcmp>(3), B<versionsort>(3)"

#. type: TH
#: man-pages/man3/queue.3:39
#, no-wrap
msgid "QUEUE"
msgstr "QUEUE"

#. type: TH
#: man-pages/man3/queue.3:39
#, no-wrap
msgid "2007-12-28"
msgstr "2007-12-28"

#. type: Plain text
#: man-pages/man3/queue.3:48
msgid ""
"LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
"LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
"TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
"CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - implementations "
"of lists, tail queues, and circular queues"
msgstr ""
"LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
"LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
"TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
"CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - реализации "
"списков, хвостовых очередей (tail queue) и кольцевых очередей (circular queue)"

#. type: Plain text
#: man-pages/man3/queue.3:51
#, no-wrap
msgid "B<#include E<lt>sys/queue.hE<gt>>\n"
msgstr "B<#include E<lt>sys/queue.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/queue.3:60
#, no-wrap
msgid ""
"B<LIST_ENTRY(>I<TYPE>B<);>\n"
"B<LIST_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<LIST_INIT(LIST_HEAD *>I<head>B<);>\n"
"B<LIST_INSERT_AFTER(LIST_ENTRY *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
"B<LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
"B<LIST_REMOVE(TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""
"B<LIST_ENTRY(>I<TYPE>B<);>\nB<LIST_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\nB<"
"LIST_INIT(LIST_HEAD *>I<head>B<);>\nB<LIST_INSERT_AFTER(LIST_ENTRY *>I<"
"listelm>B<, >\nB<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>"
"\nB<LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, >\nB<                TYPE *>I<elm>"
"B<, LIST_ENTRY >I<NAME>B<);>\nB<LIST_REMOVE(TYPE *>I<elm>B<, LIST_ENTRY >I<"
"NAME>B<);>\n"

#. type: Plain text
#: man-pages/man3/queue.3:71
#, no-wrap
msgid ""
"B<TAILQ_ENTRY(>I<TYPE>B<);>\n"
"B<TAILQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\n"
"B<TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>"
"B<);>\n"
msgstr ""
"B<TAILQ_ENTRY(>I<TYPE>B<);>\nB<TAILQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\nB<"
"TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\nB<TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<"
"head>B<, TYPE *>I<listelm>B<, >\nB<                TYPE *>I<elm>B<, "
"TAILQ_ENTRY >I<NAME>B<);>\nB<TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, >\nB<  "
"              TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\nB<"
"TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, >\nB<                TYPE *>I<elm>"
"B<, TAILQ_ENTRY >I<NAME>B<);>\nB<TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, TYPE *>"
"I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"

#. type: Plain text
#: man-pages/man3/queue.3:85
#, no-wrap
msgid ""
"B<CIRCLEQ_ENTRY(>I<TYPE>B<);>\n"
"B<CIRCLEQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\n"
"B<CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""
"B<CIRCLEQ_ENTRY(>I<TYPE>B<);>\nB<CIRCLEQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>"
"\nB<CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\nB<"
"CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\nB<     "
"           TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\nB<"
"CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\nB<    "
"            TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\nB<"
"CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, >\nB<                TYPE *>I<"
"elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\nB<CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<"
"head>B<, >\nB<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>"
"\nB<CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, >\nB<                TYPE *>I<"
"elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"

#. type: Plain text
#: man-pages/man3/queue.3:90
msgid ""
"These macros define and operate on three types of data structures: lists, "
"tail queues, and circular queues.  All three structures support the "
"following functionality:"
msgstr ""
"Эти макросы определяют и управляют тремя типами структур данных: списками, "
"хвостовыми очередями и кольцевыми очередями. Все три структуры поддерживают "
"следующие возможности:"

#. type: IP
#: man-pages/man3/queue.3:93 man-pages/man3/queue.3:95
#: man-pages/man3/queue.3:97 man-pages/man3/queue.3:99
#: man-pages/man3/queue.3:109 man-pages/man3/queue.3:131
#: man-pages/man3/queue.3:133 man-pages/man3/queue.3:135
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man3/queue.3:95
msgid "Insertion of a new entry at the head of the list."
msgstr "Вставка нового элемента в начало списка."

#. type: Plain text
#: man-pages/man3/queue.3:97
msgid "Insertion of a new entry after any element in the list."
msgstr "Вставка нового элемента после любого элемента списка."

#. type: Plain text
#: man-pages/man3/queue.3:99
msgid "Removal of any entry in the list."
msgstr "Удаление любого элемента списка."

#. type: Plain text
#: man-pages/man3/queue.3:101
msgid "Forward traversal through the list."
msgstr "Прямой обход списка."

#. type: Plain text
#: man-pages/man3/queue.3:106
msgid ""
"Lists are the simplest of the three data structures and support only the "
"above functionality."
msgstr ""
"Списки — самая простая из этих трёх структур данных и поддерживает только "
"указанные выше возможности."

#. type: Plain text
#: man-pages/man3/queue.3:108
msgid "Tail queues add the following functionality:"
msgstr "Хвостовые очереди добавляют следующую возможность:"

#. type: Plain text
#: man-pages/man3/queue.3:111 man-pages/man3/queue.3:133
msgid "Entries can be added at the end of a list."
msgstr "Элементы могут быть добавлены в конец списка."

#. type: Plain text
#: man-pages/man3/queue.3:114 man-pages/man3/queue.3:141
msgid "However:"
msgstr "Однако:"

#. type: IP
#: man-pages/man3/queue.3:117 man-pages/man3/queue.3:144
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man3/queue.3:119 man-pages/man3/queue.3:146
msgid "All list insertions and removals must specify the head of the list."
msgstr "При вставке и удалении элементов нужно указывать начало списка."

#. type: IP
#: man-pages/man3/queue.3:119 man-pages/man3/queue.3:146
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man3/queue.3:121 man-pages/man3/queue.3:148
msgid "Each head entry requires two pointers rather than one."
msgstr "Каждый начальный элемент требует двух указателей вместо одного."

#. type: IP
#: man-pages/man3/queue.3:121 man-pages/man3/queue.3:148
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man3/queue.3:124
msgid ""
"Code size is about 15% greater and operations run about 20% slower than "
"lists."
msgstr "Код примерно на 15% больше и на 20% медленнее, чем в списках."

#. type: Plain text
#: man-pages/man3/queue.3:128
msgid "Circular queues add the following functionality:"
msgstr "Кольцевые очереди добавляют следующие возможности:"

#. type: Plain text
#: man-pages/man3/queue.3:135
msgid "Entries can be added before another entry."
msgstr "Элементы могут добавляться перед другим элементом."

#. type: Plain text
#: man-pages/man3/queue.3:137
msgid "They may be traversed backward, from tail to head."
msgstr "Обход может идти в обратном направлении, от конца к началу."

#. type: Plain text
#: man-pages/man3/queue.3:150
msgid "The termination condition for traversal is more complex."
msgstr "Условие завершения обхода более сложное."

#. type: IP
#: man-pages/man3/queue.3:150
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man3/queue.3:153
msgid ""
"Code size is about 40% greater and operations run about 45% slower than "
"lists."
msgstr "Код примерно на 40% больше и на 45% медленнее, чем в списках."

#. type: Plain text
#: man-pages/man3/queue.3:176
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type B<LIST_ENTRY>, B<TAILQ_ENTRY>, or "
"B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument I<HEADNAME> is the name of a "
"user-defined structure that must be declared using the macros B<LIST_HEAD>, "
"B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See the examples below for further "
"explanation of how these macros are used."
msgstr ""
"В определениях макросов I<TYPE> является именем структуры, определённой "
"пользователем, которая должна содержать поле типа B<LIST_ENTRY>, B<"
"TAILQ_ENTRY> или B<CIRCLEQ_ENTRY>, названное I<NAME>. Аргумент I<HEADNAME> "
"является именем структуры, определённой пользователем, которая должна быть "
"объявлена, используя макрос B<LIST_HEAD>, B<TAILQ_HEAD> или B<CIRCLEQ_HEAD>. "
"Смотрите примеры ниже для дальнейшего объяснения использования этих макросов."

#. type: SS
#: man-pages/man3/queue.3:176
#, no-wrap
msgid "Lists"
msgstr "Списки"

#. type: Plain text
#: man-pages/man3/queue.3:189
msgid ""
"A list is headed by a structure defined by the B<LIST_HEAD> macro.  This "
"structure contains a single pointer to the first element on the list.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the list.  New elements can be added to the list after an"
" existing element or at the head of the list.  A B<LIST_HEAD> structure is "
"declared as follows:"
msgstr ""
"Список начинается структурой, определённой макросом B<LIST_HEAD>. Эта "
"структура содержит единственный указатель на первый элемент списка. Элементы "
"дважды связаны, поэтому произвольный элемент можно удалить без обхода списка. "
"Новые элементы могут быть добавлены в список после существующего элемента или "
"в начало списка. Структура B<LIST_HEAD> объявляется следующим образом:"

#. type: Plain text
#: man-pages/man3/queue.3:193
#, no-wrap
msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr "LIST_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: man-pages/man3/queue.3:202
msgid ""
"where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> is"
" the type of the elements to be linked into the list.  A pointer to the head"
" of the list can later be declared as:"
msgstr ""
"где I<HEADNAME> — имя определяемой структуры, а I<TYPE> — тип связанных "
"элементов в списке. Указатель на начало списка может в дальнейшем быть "
"объявлен, как:"

#. type: Plain text
#: man-pages/man3/queue.3:206 man-pages/man3/queue.3:299
#: man-pages/man3/queue.3:401
#, no-wrap
msgid "struct HEADNAME *headp;\n"
msgstr "struct HEADNAME *headp;\n"

#. type: Plain text
#: man-pages/man3/queue.3:214 man-pages/man3/queue.3:307
#: man-pages/man3/queue.3:409
msgid "(The names I<head> and I<headp> are user selectable.)"
msgstr "(Имена I<head> и I<headp> выбираются пользователем.)"

#. type: Plain text
#: man-pages/man3/queue.3:219
msgid ""
"The macro B<LIST_ENTRY> declares a structure that connects the elements in "
"the list."
msgstr ""
"Макрос B<LIST_ENTRY> объявляет структуру, которая подключает элементы в "
"список."

#. type: Plain text
#: man-pages/man3/queue.3:224
msgid "The macro B<LIST_INIT> initializes the list referenced by I<head>."
msgstr ""
"Макрос B<LIST_INIT> инициализирует список, на который ссылается I<head>."

#. type: Plain text
#: man-pages/man3/queue.3:230
msgid ""
"The macro B<LIST_INSERT_HEAD> inserts the new element I<elm> at the head of "
"the list."
msgstr ""
"Макрос B<LIST_INSERT_HEAD> вставляет новый элемент I<elm> в начало списка."

#. type: Plain text
#: man-pages/man3/queue.3:237
msgid ""
"The macro B<LIST_INSERT_AFTER> inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"Макрос B<LIST_INSERT_AFTER> вставляет новый элемент I<elm> за элементом I<"
"listelm>."

#. type: Plain text
#: man-pages/man3/queue.3:243
msgid "The macro B<LIST_REMOVE> removes the element I<elm> from the list."
msgstr "Макрос B<LIST_REMOVE> удаляет элемент I<elm> из списка."

#. type: SS
#: man-pages/man3/queue.3:243
#, no-wrap
msgid "List example"
msgstr "Пример списка"

#. type: Plain text
#: man-pages/man3/queue.3:252
#, no-wrap
msgid ""
"LIST_HEAD(listhead, entry) head;\n"
"struct listhead *headp;                 /* List head. */\n"
"struct entry {\n"
"    ...\n"
"    LIST_ENTRY(entry) entries;          /* List. */\n"
"    ...\n"
"} *n1, *n2, *np;\n"
msgstr ""
"LIST_HEAD(listhead, entry) head;\nstruct listhead *headp;                 /* "
"начало списка */\nstruct entry {\n    ...\n    LIST_ENTRY(entry) entries;     "
"     /* список */\n    ...\n} *n1, *n2, *np;\n"

#. type: Plain text
#: man-pages/man3/queue.3:254
#, no-wrap
msgid "LIST_INIT(&head);                       /* Initialize the list. */\n"
msgstr "LIST_INIT(&head);                       /* инициализация списка */\n"

#. type: Plain text
#: man-pages/man3/queue.3:257
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* вставка в начало "
"*/\nLIST_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: man-pages/man3/queue.3:263
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"LIST_INSERT_AFTER(n1, n2, entries);\n"
"                                        /* Forward traversal. */\n"
"for (np = head.lh_first; np != NULL; np = np-E<gt>entries.le_next)\n"
"    np-E<gt> ...\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* вставка после "
"*/\nLIST_INSERT_AFTER(n1, n2, entries);\n                                     "
"   /* вперёд до конца */\nfor (np = head.lh_first; np != NULL; np = np-E<gt>"
"entries.le_next)\n    np-E<gt> ...\n"

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=1506
#. type: Plain text
#: man-pages/man3/queue.3:267
#, no-wrap
msgid ""
"while (head.lh_first != NULL)           /* Delete. */\n"
"    LIST_REMOVE(head.lh_first, entries);\n"
msgstr ""
"while (head.lh_first != NULL)           /* удаление */\n    "
"LIST_REMOVE(head.lh_first, entries);\n"

#. type: SS
#: man-pages/man3/queue.3:268
#, no-wrap
msgid "Tail queues"
msgstr "Хвостовые очереди"

#. type: Plain text
#: man-pages/man3/queue.3:282
msgid ""
"A tail queue is headed by a structure defined by the B<TAILQ_HEAD> macro.  "
"This structure contains a pair of pointers, one to the first element in the "
"tail queue and the other to the last element in the tail queue.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the tail queue.  New elements can be added to the tail "
"queue after an existing element, at the head of the tail queue, or at the "
"end of the tail queue.  A B<TAILQ_HEAD> structure is declared as follows:"
msgstr ""
"Хвостовая очередь задается структурой, определяемой макросом B<TAILQ_HEAD>. "
"Эта структура содержит пару указателей, один для первого элемента хвостовой "
"очереди, а другой для последнего элемента хвостовой очереди. Элементы связаны "
"дважды так, что любой элемент может быть удалён без прохождения по всей "
"очереди. Новые элементы могут быть добавлены в хвостовую очередь после "
"существующего элемента, в конец или в начало очереди. Структура B<TAILQ_HEAD> "
"объявляется следующим образом:"

#. type: Plain text
#: man-pages/man3/queue.3:286
#, no-wrap
msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr "TAILQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: man-pages/man3/queue.3:295
msgid ""
"where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> is"
" the type of the elements to be linked into the tail queue.  A pointer to "
"the head of the tail queue can later be declared as:"
msgstr ""
"где I<HEADNAME> — имя определяемой структуры, а I<TYPE> — тип связанных "
"элементов в хвостовой очереди. Указатель на начало хвостовой очереди может в "
"дальнейшем быть объявлен как:"

#. type: Plain text
#: man-pages/man3/queue.3:312
msgid ""
"The macro B<TAILQ_ENTRY> declares a structure that connects the elements in "
"the tail queue."
msgstr ""
"Макрос B<TAILQ_ENTRY> объявляет структуру, которая подключает элементы в "
"хвостовую очередь."

#. type: Plain text
#: man-pages/man3/queue.3:317
msgid ""
"The macro B<TAILQ_INIT> initializes the tail queue referenced by I<head>."
msgstr ""
"Макрос B<TAILQ_INIT> инициализирует хвостовую очередь, на которую ссылается "
"I<head>."

#. type: Plain text
#: man-pages/man3/queue.3:323
msgid ""
"The macro B<TAILQ_INSERT_HEAD> inserts the new element I<elm> at the head of"
" the tail queue."
msgstr ""
"Макрос B<TAILQ_INSERT_HEAD> вставляет новый элемент I<elm> в начало хвостовой "
"очереди."

#. type: Plain text
#: man-pages/man3/queue.3:329
msgid ""
"The macro B<TAILQ_INSERT_TAIL> inserts the new element I<elm> at the end of "
"the tail queue."
msgstr ""
"Макрос B<TAILQ_INSERT_TAIL> вставляет новый элемент I<elm> в конец хвостовой "
"очереди."

#. type: Plain text
#: man-pages/man3/queue.3:336
msgid ""
"The macro B<TAILQ_INSERT_AFTER> inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"Макрос B<TAILQ_INSERT_AFTER> вставляет новый элемент I<elm> за элементом I<"
"listelm>."

#. type: Plain text
#: man-pages/man3/queue.3:342
msgid ""
"The macro B<TAILQ_REMOVE> removes the element I<elm> from the tail queue."
msgstr "Макрос B<TAILQ_REMOVE> удаляет элемент I<elm> из хвостовой очереди."

#. type: SS
#: man-pages/man3/queue.3:342
#, no-wrap
msgid "Tail queue example"
msgstr "Пример хвостовой очереди"

#. type: Plain text
#: man-pages/man3/queue.3:351
#, no-wrap
msgid ""
"TAILQ_HEAD(tailhead, entry) head;\n"
"struct tailhead *headp;                 /* Tail queue head. */\n"
"struct entry {\n"
"    ...\n"
"    TAILQ_ENTRY(entry) entries;         /* Tail queue. */\n"
"    ...\n"
"} *n1, *n2, *np;\n"
msgstr ""
"TAILQ_HEAD(tailhead, entry) head;\nstruct tailhead *headp;                 /* "
"заголовок хвостовой очереди */\nstruct entry {\n    ...\n    "
"TAILQ_ENTRY(entry) entries;         /* хвостовая очередь */\n    ...\n} *n1, "
"*n2, *np;\n"

#. type: Plain text
#: man-pages/man3/queue.3:353
#, no-wrap
msgid "TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgstr "TAILQ_INIT(&head);                      /* инициализация очереди */\n"

#. type: Plain text
#: man-pages/man3/queue.3:356
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* вставка в начало "
"*/\nTAILQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: man-pages/man3/queue.3:359
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
"TAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* вставка в хвост "
"*/\nTAILQ_INSERT_TAIL(&head, n1, entries);\n"

#. type: Plain text
#: man-pages/man3/queue.3:368
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
"                                        /* Forward traversal. */\n"
"for (np = head.tqh_first; np != NULL; np = np-E<gt>entries.tqe_next)\n"
"    np-E<gt> ...\n"
"                                        /* Delete. */\n"
"while (head.tqh_first != NULL)\n"
"    TAILQ_REMOVE(&head, head.tqh_first, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* вставка после "
"*/\nTAILQ_INSERT_AFTER(&head, n1, n2, entries);\n                             "
"           /* вперед по очереди */\nfor (np = head.tqh_first; np != NULL; np "
"= np-E<gt>entries.tqe_next)\n    np-E<gt> ...\n                               "
"         /* удаление */\nwhile (head.tqh_first != NULL)\n    "
"TAILQ_REMOVE(&head, head.tqh_first, entries);\n"

#. type: SS
#: man-pages/man3/queue.3:369
#, no-wrap
msgid "Circular queues"
msgstr "Циклические очереди"

#. type: Plain text
#: man-pages/man3/queue.3:384
msgid ""
"A circular queue is headed by a structure defined by the B<CIRCLEQ_HEAD> "
"macro.  This structure contains a pair of pointers, one to the first element"
" in the circular queue and the other to the last element in the circular "
"queue.  The elements are doubly linked so that an arbitrary element can be "
"removed without traversing the queue.  New elements can be added to the "
"queue after an existing element, before an existing element, at the head of "
"the queue, or at the end of the queue.  A B<CIRCLEQ_HEAD> structure is "
"declared as follows:"
msgstr ""
"Циклическая очередь задается структурой, определяемой макросом B<CIRCLEQ_HEAD>"
". Эта структура содержит пару указателей, один для первого элемента "
"циклической очереди, а другой для последнего элемента циклической очереди. "
"Элементы связаны дважды так, что любой элемент может быть удалён без "
"прохождения по всей очереди. Новые элементы могут быть добавлены в очередь "
"после существующего элемента, перед существующем элементом, в конец или в "
"начало очереди. Структура B<CIRCLEQ_HEAD> объявляется так:"

#. type: Plain text
#: man-pages/man3/queue.3:388
#, no-wrap
msgid "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: man-pages/man3/queue.3:397
msgid ""
"where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> is"
" the type of the elements to be linked into the circular queue.  A pointer "
"to the head of the circular queue can later be declared as:"
msgstr ""
"где I<HEADNAME> — имя определяемой структуры, а I<TYPE> — тип связанных "
"элементов в циклической очереди. Указатель на начало циклической очереди "
"может в дальнейшем быть объявлен как:"

#. type: Plain text
#: man-pages/man3/queue.3:414
msgid ""
"The macro B<CIRCLEQ_ENTRY> declares a structure that connects the elements "
"in the circular queue."
msgstr ""
"Макрос B<CIRCLEQ_ENTRY> объявляет структуру, которая подключает элементы в "
"циклическую очередь."

#. type: Plain text
#: man-pages/man3/queue.3:419
msgid ""
"The macro B<CIRCLEQ_INIT> initializes the circular queue referenced by "
"I<head>."
msgstr ""
"Макрос B<CIRCLEQ_INIT> инициализирует циклическую очередь, на которую "
"ссылается I<head>."

#. type: Plain text
#: man-pages/man3/queue.3:425
msgid ""
"The macro B<CIRCLEQ_INSERT_HEAD> inserts the new element I<elm> at the head "
"of the circular queue."
msgstr ""
"Макрос B<CIRCLEQ_INSERT_HEAD> вставляет новый элемент I<elm> в начало "
"циклической очереди."

#. type: Plain text
#: man-pages/man3/queue.3:431
msgid ""
"The macro B<CIRCLEQ_INSERT_TAIL> inserts the new element I<elm> at the end "
"of the circular queue."
msgstr ""
"Макрос B<CIRCLEQ_INSERT_TAIL> вставляет новый элемент I<elm> в конец "
"циклической очереди."

#. type: Plain text
#: man-pages/man3/queue.3:438
msgid ""
"The macro B<CIRCLEQ_INSERT_AFTER> inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"Макрос B<CIRCLEQ_INSERT_AFTER> вставляет новый элемент I<elm> за элементом I<"
"listelm>."

#. type: Plain text
#: man-pages/man3/queue.3:445
msgid ""
"The macro B<CIRCLEQ_INSERT_BEFORE> inserts the new element I<elm> before the"
" element I<listelm>."
msgstr ""
"Макрос B<CIRCLEQ_INSERT_BEFORE> вставляет новый элемент I<elm> перед "
"элементом I<listelm>."

#. type: Plain text
#: man-pages/man3/queue.3:451
msgid ""
"The macro B<CIRCLEQ_REMOVE> removes the element I<elm> from the circular "
"queue."
msgstr ""
"Макрос B<CIRCLEQ_REMOVE> удаляет элемент I<elm> из циклической очереди."

#. type: SS
#: man-pages/man3/queue.3:451
#, no-wrap
msgid "Circular queue example"
msgstr "Пример циклической очереди"

#. type: Plain text
#: man-pages/man3/queue.3:460
#, no-wrap
msgid ""
"CIRCLEQ_HEAD(circleq, entry) head;\n"
"struct circleq *headp;              /* Circular queue head. */\n"
"struct entry {\n"
"    ...\n"
"    CIRCLEQ_ENTRY(entry) entries;   /* Circular queue. */\n"
"    ...\n"
"} *n1, *n2, *np;\n"
msgstr ""
"CIRCLEQ_HEAD(circleq, entry) head;\nstruct circleq *headp;              /* "
"заголовок циклической очереди */\nstruct entry {\n    ...\n    "
"CIRCLEQ_ENTRY(entry) entries;   /* циклическая очередь */\n    ...\n} *n1, "
"*n2, *np;\n"

#. type: Plain text
#: man-pages/man3/queue.3:462
#, no-wrap
msgid ""
"CIRCLEQ_INIT(&head);                /* Initialize the circular queue. */\n"
msgstr ""
"CIRCLEQ_INIT(&head);                /* инициализация циклической\n            "
"                           очереди */\n"

#. type: Plain text
#: man-pages/man3/queue.3:465
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));  /* Insert at the head. */\n"
"CIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));  /* вставка в начало "
"*/\nCIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: man-pages/man3/queue.3:468
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));  /* Insert at the tail. */\n"
"CIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));  /* вставка в хвост "
"*/\nCIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"

#. type: Plain text
#: man-pages/man3/queue.3:471
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));  /* вставка после "
"*/\nCIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: man-pages/man3/queue.3:484
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));  /* Insert before. */\n"
"CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);\n"
"                                    /* Forward traversal. */\n"
"for (np = head.cqh_first; np != (void *)&head;\n"
"        np = np-E<gt>entries.cqe_next)\n"
"    np-E<gt> ...\n"
"                                    /* Reverse traversal. */\n"
"for (np = head.cqh_last; np != (void *)&head; np = np-E<gt>entries.cqe_prev)\n"
"    np-E<gt> ...\n"
"                                    /* Delete. */\n"
"while (head.cqh_first != (void *)&head)\n"
"    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));  /* вставка перед "
"*/\nCIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);\n                          "
"          /* вперёд по очереди */\nfor (np = head.cqh_first; np != (void "
"*)&head;\n        np = np-E<gt>entries.cqe_next)\n    np-E<gt> ...\n          "
"                          /* назад по очереди */\nfor (np = head.cqh_last; np "
"!= (void *)&head; np = np-E<gt>entries.cqe_prev)\n    np-E<gt> ...\n          "
"                          /* удаление */\nwhile (head.cqh_first != (void "
"*)&head)\n    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);\n"

#. type: Plain text
#: man-pages/man3/queue.3:490
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
"appeared in 4.4BSD."
msgstr ""
"Не является частью POSIX.1-2001. Присутствует в BSD. Впервые появились в "
"4.4BSD."

#. type: TH
#: man-pages/man3/qecvt.3:28
#, no-wrap
msgid "QECVT"
msgstr "QECVT"

#. type: TH
#: man-pages/man3/qecvt.3:28
#, no-wrap
msgid "2014-03-11"
msgstr "2014-03-11"

#. type: TH
#: man-pages/man3/qecvt.3:28
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/qecvt.3:31
msgid "qecvt, qfcvt, qgcvt - convert a floating-point number to a string"
msgstr "qecvt, qfcvt, qgcvt - преобразуют число с плавающей точкой в строку"

#. type: Plain text
#: man-pages/man3/qecvt.3:33
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/qecvt.3:36
msgid ""
"B<char *qecvt(long double >I<number>B<, int >I<ndigits>B<, int "
"*>I<decpt>B<,> B<int *>I<sign>B<);>"
msgstr ""
"B<char *qecvt(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"

#. type: Plain text
#: man-pages/man3/qecvt.3:39
msgid ""
"B<char *qfcvt(long double >I<number>B<, int >I<ndigits>B<, int "
"*>I<decpt>B<,> B<int *>I<sign>B<);>"
msgstr ""
"B<char *qfcvt(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"

#. type: Plain text
#: man-pages/man3/qecvt.3:41
msgid ""
"B<char *qgcvt(long double >I<number>B<, int >I<ndigit>B<, char *>I<buf>B<);>"
msgstr ""
"B<char *qgcvt(long double >I<number>B<, int >I<ndigit>B<, char *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man3/qecvt.3:52
msgid "B<qecvt>(), B<qfcvt>(), B<qgcvt>(): _SVID_SOURCE"
msgstr "B<qecvt>(), B<qfcvt>(), B<qgcvt>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/qecvt.3:85
msgid ""
"The functions B<qecvt>(), B<qfcvt>()  and B<qgcvt>()  are identical to "
"B<ecvt>(3), B<fcvt>(3)  and B<gcvt>(3)  respectively, except that they use a"
" I<long double> argument I<number>.  See B<ecvt>(3)  and B<gcvt>(3)."
msgstr ""
"Функции B<qecvt>(), B<qfcvt>() и B<qgcvt>() идентичны B<ecvt>(3), B<fcvt>(3) "
"и B<gcvt>(3), соответственно, за исключением того, что аргумент I<number> "
"имеет тип I<long double>. Смотрите B<ecvt>(3) и B<gcvt>(3)."

#. type: SH
#: man-pages/man3/qecvt.3:85
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/qecvt.3:86
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/qecvt.3:92
msgid "The B<qecvt>()  and B<qfcvt>()  functions are not thread-safe."
msgstr ""
"Функции B<qecvt>() и B<qfcvt>() нельзя использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/qecvt.3:96
msgid "The B<qgcvt>()  function is thread-safe."
msgstr "Функцию B<qgcvt>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/qecvt.3:102
msgid ""
"SVr4.  Not seen in most common UNIX implementations, but occurs in SunOS.  "
"Not supported by libc4 and libc5.  Supported by glibc."
msgstr ""
"SVr4. Отсутствуют в наиболее распространённых реализаций UNIX, но есть в "
"SunOS. Не поддерживаются в libc4 и libc5. Поддерживаются в glibc."

#. type: Plain text
#: man-pages/man3/qecvt.3:107
msgid "These functions are obsolete.  Instead, B<snprintf>(3)  is recommended."
msgstr ""
"Данные функции устарели. Вместо них рекомендуется использовать B<snprintf>(3)."

#. type: Plain text
#: man-pages/man3/qecvt.3:111
msgid "B<ecvt>(3), B<ecvt_r>(3), B<gcvt>(3), B<sprintf>(3)"
msgstr "B<ecvt>(3), B<ecvt_r>(3), B<gcvt>(3), B<sprintf>(3)"

