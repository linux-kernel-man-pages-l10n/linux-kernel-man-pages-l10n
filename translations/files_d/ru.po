# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Yuri Kozlov <yuray@komyakino.ru>, 2012-2019.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
# Иван Павлов <pavia00@gmail.com>, 2017.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:25+0300\n"
"PO-Revision-Date: 2019-08-29 09:55+0300\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n"
"%100>=11 && n%100<=14)? 2 : 3);\n"
"X-Generator: Lokalize 2.0\n"

#. type: TH
#: man-pages/man4/dsp56k.4:27
#, no-wrap
msgid "DSP56K"
msgstr "DSP56K"

#. type: TH
#: man-pages/man4/dsp56k.4:27
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: man-pages/man4/dsp56k.4:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/dsp56k.4:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/dsp56k.4:28
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/dsp56k.4:30
msgid "dsp56k - DSP56001 interface device"
msgstr "dsp56k - устройство интерфейса DSP56001"

#. type: SH
#: man-pages/man4/dsp56k.4:30
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man4/dsp56k.4:33
#, no-wrap
msgid "#include E<lt>asm/dsp56k.hE<gt>\n"
msgstr "#include E<lt>asm/dsp56k.hE<gt>\n"

#. type: Plain text
#: man-pages/man4/dsp56k.4:36
#, no-wrap
msgid ""
"B<ssize_t read(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"
"B<ssize_t write(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<ssize_t read(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"
"B<ssize_t write(int >I<fd>B<, void *>I<data>B<, size_t >I<length>B<);>\n"

#. type: Plain text
#: man-pages/man4/dsp56k.4:42
#, no-wrap
msgid ""
"B<int ioctl(int >I<fd>B<, DSP56K_UPLOAD, struct dsp56k_upload *>I<program>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_TX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_RX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_FLAGS, struct dsp56k_host_flags *>I<flags>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_CMD, int >I<cmd>B<);>\n"
msgstr ""
"B<int ioctl(int >I<fd>B<, DSP56K_UPLOAD, struct dsp56k_upload *>I<program>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_TX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_SET_RX_WSIZE, int >I<wsize>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_FLAGS, struct dsp56k_host_flags *>I<flags>B<);>\n"
"B<int ioctl(int >I<fd>B<, DSP56K_HOST_CMD, int >I<cmd>B<);>\n"

#. type: SH
#: man-pages/man4/dsp56k.4:43
#, no-wrap
msgid "CONFIGURATION"
msgstr "НАСТРОЙКА"

#. type: Plain text
#: man-pages/man4/dsp56k.4:46
msgid ""
"The dsp56k device is a character device with major number 55 and minor "
"number 0."
msgstr ""
"Устройство dsp56k является символьным устройством с старшим номером 55 и "
"младшим номером 0."

#. type: SH
#: man-pages/man4/dsp56k.4:46
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/dsp56k.4:52
msgid ""
"The Motorola DSP56001 is a fully programmable 24-bit digital signal "
"processor found in Atari Falcon030-compatible computers.  The I<dsp56k> "
"special file is used to control the DSP56001, and to send and receive data "
"using the bidirectional handshaked host port."
msgstr ""
"Motorola DSP56001 \\(em это полностью программируемый 24-битный цифровой "
"сигнальный процессор, используемый в компьютерах Atari Falcon030 и "
"совместимых с ними. Специальный файл I<dsp56k> используется для управления "
"DSP56001 и для посылки и получения данных через выбранный на узле (host) "
"двунаправленный порт."

#. type: Plain text
#: man-pages/man4/dsp56k.4:62
msgid ""
"To send a data stream to the signal processor, use B<write>(2)  to the "
"device, and B<read>(2)  to receive processed data.  The data can be sent or "
"received in 8, 16, 24, or 32-bit quantities on the host side, but will "
"always be seen as 24-bit quantities in the DSP56001."
msgstr ""
"Для отправки потока данных сигнальному процессору, используйте B<write>(2), "
"а для получения обработанных данных \\(em B<read>(2). Данные могут быть "
"посылаться и получаться узлом по 8, 16, 24 или 32 бита, а сигнальный "
"процессор способен обрабатывать только по 24 бита."

#. type: Plain text
#: man-pages/man4/dsp56k.4:67
msgid ""
"The following B<ioctl>(2)  calls are used to control the I<dsp56k> device:"
msgstr ""
"Для управления устройством I<dsp56k> используются следующие вызовы "
"B<ioctl>(2):"

#. type: IP
#: man-pages/man4/dsp56k.4:67
#, no-wrap
msgid "B<DSP56K_UPLOAD>"
msgstr "B<DSP56K_UPLOAD>"

#. type: Plain text
#: man-pages/man4/dsp56k.4:74
msgid ""
"resets the DSP56001 and uploads a program.  The third B<ioctl>(2)  argument "
"must be a pointer to a I<struct dsp56k_binary> with members I<bin> pointing "
"to a DSP56001 binary program, and I<len> set to the length of the program, "
"counted in 24-bit words."
msgstr ""
"Обнуляет DSP56001 и загружает в него программу. Третьим аргументом "
"B<ioctl>(2) должен быть указатель на I<struct dsp56k_binary>, в которое поле "
"I<bin> указывает на двоичную программу DSP56001, а в I<len> задаётся длина "
"программы (значение должно быть кратно 24-битным словам)."

#. type: IP
#: man-pages/man4/dsp56k.4:74
#, no-wrap
msgid "B<DSP56K_SET_TX_WSIZE>"
msgstr "B<DSP56K_SET_TX_WSIZE>"

#. type: Plain text
#: man-pages/man4/dsp56k.4:82
msgid ""
"sets the transmit word size.  Allowed values are in the range 1 to 4, and is "
"the number of bytes that will be sent at a time to the DSP56001.  These data "
"quantities will either be padded with zero bytes, or truncated to fit the "
"native 24-bit data format of the DSP56001."
msgstr ""
"Устанавливает размер передаваемых слов. Допустимое значение находится в "
"пределах от 1 до 4, и является числом байт, посылаемых за один раз в "
"DSP56001. Эти частички информации будут заполнены нулевыми байтами или "
"преобразованы в формат 24-битных данных DSP56001."

#. type: IP
#: man-pages/man4/dsp56k.4:82
#, no-wrap
msgid "B<DSP56K_SET_RX_WSIZE>"
msgstr "B<DSP56K_SET_RX_WSIZE>"

#. type: Plain text
#: man-pages/man4/dsp56k.4:89
msgid ""
"sets the receive word size.  Allowed values are in the range 1 to 4, and is "
"the number of bytes that will be received at a time from the DSP56001.  "
"These data quantities will either truncated, or padded with a null byte "
"(\\(aq\\e0\\(aq) to fit the native 24-bit data format of the DSP56001."
msgstr ""
"Устанавливает размер принимаемых слов. Допустимое значение находится в "
"диапазоне от 1 до 4, и является числом байт, принимаемых за один раз от "
"процессора DSP56001. Эти частички информации будут урезаны или дополнены "
"байтом null (\\(aq\\e0\\(aq), чтобы соответствовать 24-битному формату "
"DSP56001."

#. type: IP
#: man-pages/man4/dsp56k.4:89
#, no-wrap
msgid "B<DSP56K_HOST_FLAGS>"
msgstr "B<DSP56K_HOST_FLAGS>"

#. type: Plain text
#: man-pages/man4/dsp56k.4:96
msgid ""
"read and write the host flags.  The host flags are four general-purpose bits "
"that can be read by both the hosting computer and the DSP56001.  Bits 0 and "
"1 can be written by the host, and bits 2 and 3 can be written by the "
"DSP56001."
msgstr ""
"Считывает и записывает флаги узла. Флаги узла \\(em это четыре бита общего "
"назначения, они могут быть считаны как узлом, так и процессором DSP56001. "
"Нулевой и первый биты могут записываться узлом, а второй и третий пишутся "
"устройством DSP56001."

#. type: Plain text
#: man-pages/man4/dsp56k.4:106
msgid ""
"To access the host flags, the third B<ioctl>(2)  argument must be a pointer "
"to a I<struct dsp56k_host_flags>.  If bit 0 or 1 is set in the I<dir> "
"member, the corresponding bit in I<out> will be written to the host flags.  "
"The state of all host flags will be returned in the lower four bits of the "
"I<status> member."
msgstr ""
"Для получения доступа к флагам узла третий аргумент B<ioctl>(2) должен быть "
"указателем на I<struct dsp56k_host_flags>. Если нулевой и первый поля I<dir> "
"установлены в единичное значение, то соответствующий бит в поле I<out> будет "
"записан в флаг узла. Состояние всех флагов узла будет возвращено в младших "
"четырёх битах поля I<status>."

#. type: IP
#: man-pages/man4/dsp56k.4:106
#, no-wrap
msgid "B<DSP56K_HOST_CMD>"
msgstr "B<DSP56K_HOST_CMD>"

#. type: Plain text
#: man-pages/man4/dsp56k.4:110
msgid ""
"sends a host command.  Allowed values are in the range 0 to 31, and is a "
"user-defined command handled by the program running in the DSP56001."
msgstr ""
"Посылает команды узла. Допустимые величины находятся в диапазоне от 0 до 31, "
"это определяемые пользователем команды, обрабатываемые программой, "
"выполняющейся на DSP56001."

#. type: SH
#: man-pages/man4/dsp56k.4:110
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#.  .SH AUTHORS
#.  Fredrik Noring <noring@nocrew.org>, lars brinkhoff <lars@nocrew.org>,
#.  Tomas Berndtsson <tomas@nocrew.org>.
#. type: Plain text
#: man-pages/man4/dsp56k.4:115
msgid "/dev/dsp56k"
msgstr "/dev/dsp56k"

#. type: SH
#: man-pages/man4/dsp56k.4:115
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/dsp56k.4:120
msgid ""
"I<linux/include/asm-m68k/dsp56k.h>, I<linux/drivers/char/dsp56k.c>, E<.UR "
"http://dsp56k.nocrew.org/> E<.UE ,> DSP56000/DSP56001 Digital Signal "
"Processor User's Manual"
msgstr ""
"I<linux/include/asm-m68k/dsp56k.h>, I<linux/drivers/char/dsp56k.c>, E<.UR "
"http://dsp56k.nocrew.org/> E<.UE ,> DSP56000/DSP56001 Digital Signal "
"Processor User's Manual"

#. type: TH
#: man-pages/man7/ddp.7:12
#, no-wrap
msgid "DDP"
msgstr "DDP"

#. type: TH
#: man-pages/man7/ddp.7:12
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: man-pages/man7/ddp.7:15
msgid "ddp - Linux AppleTalk protocol implementation"
msgstr "ddp - реализация протокола AppleTalk в Linux"

#. type: Plain text
#: man-pages/man7/ddp.7:17
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man7/ddp.7:19
msgid "B<#include E<lt>netatalk/at.hE<gt>>"
msgstr "B<#include E<lt>netatalk/at.hE<gt>>"

#. type: Plain text
#: man-pages/man7/ddp.7:21
msgid "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"
msgstr "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"

#. type: Plain text
#: man-pages/man7/ddp.7:23
msgid "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"
msgstr "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"

#. type: Plain text
#: man-pages/man7/ddp.7:34
msgid ""
"Linux implements the AppleTalk protocols described in I<Inside AppleTalk>.  "
"Only the DDP layer and AARP are present in the kernel.  They are designed to "
"be used via the B<netatalk> protocol libraries.  This page documents the "
"interface for those who wish or need to use the DDP layer directly."
msgstr ""
"В Linux реализованы протоколы AppleTalk, описанные в I<Inside AppleTalk>. В "
"ядре есть лишь уровни DDP и AARP. Они проектировались с учётом того, что ими "
"будут пользоваться через библиотеку протоколов B<netatalk>. В этой странице "
"описан интерфейс для тех, кому требуется использовать уровень DDP напрямую."

#. type: Plain text
#: man-pages/man7/ddp.7:39
msgid ""
"The communication between AppleTalk and the user program works using a BSD-"
"compatible socket interface.  For more information on sockets, see "
"B<socket>(7)."
msgstr ""
"Связь между AppleTalk и пользовательской программой реализована через "
"интерфейс сокетов, совместимых с BSD. Дополнительную информацию о сокетах "
"можно найти в B<socket>(7)."

#. type: Plain text
#: man-pages/man7/ddp.7:60
msgid ""
"An AppleTalk socket is created by calling the B<socket>(2)  function with a "
"B<AF_APPLETALK> socket family argument.  Valid socket types are "
"B<SOCK_DGRAM> to open a B<ddp> socket or B<SOCK_RAW> to open a B<raw> "
"socket.  I<protocol> is the AppleTalk protocol to be received or sent.  For "
"B<SOCK_RAW> you must specify B<ATPROTO_DDP>."
msgstr ""
"Сокет AppleTalk создаётся из вызова B<socket>(2), которому в качестве "
"аргумента семейства указывается значение B<AF_APPLETALK>. Типом сокета может "
"быть B<SOCK_DGRAM> (чтобы открыть сокет B<ddp>) или B<SOCK_RAW> (для "
"открытия сокета B<raw>). Значением I<protocol> устанавливается протокол "
"приема-передачи AppleTalk. При B<SOCK_RAW> необходимо указать значение "
"B<ATPROTO_DDP>."

#. type: Plain text
#: man-pages/man7/ddp.7:65
msgid ""
"Raw sockets may be opened only by a process with effective user ID 0 or when "
"the process has the B<CAP_NET_RAW> capability."
msgstr ""
"Неструктурированные сокеты могут быть открыты только процессом с "
"идентификатором эффективного пользователя, равным нулю, либо процессом, "
"имеющим мандат B<CAP_NET_RAW>."

#. type: SS
#: man-pages/man7/ddp.7:65
#, no-wrap
msgid "Address format"
msgstr "Формат адреса"

#. type: Plain text
#: man-pages/man7/ddp.7:68
msgid ""
"An AppleTalk socket address is defined as a combination of a network number, "
"a node number, and a port number."
msgstr ""
"Адрес сокета AppleTalk определяется как комбинация номера сети, номера узла "
"и номера порта."

#. type: Plain text
#: man-pages/man7/ddp.7:75
#, no-wrap
msgid ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"
msgstr ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"

#. type: Plain text
#: man-pages/man7/ddp.7:81
#, no-wrap
msgid ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* address family */\n"
"    unsigned char  sat_port;      /* port */\n"
"    struct at_addr sat_addr;      /* net/node */\n"
"};\n"
msgstr ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* адресное семейство */\n"
"    unsigned char  sat_port;      /* порт */\n"
"    struct at_addr sat_addr;      /* сеть/узел */\n"
"};\n"

#.  FIXME . this doesn't make sense [johnl]
#. type: Plain text
#: man-pages/man7/ddp.7:120
msgid ""
"I<sat_family> is always set to B<AF_APPLETALK>.  I<sat_port> contains the "
"port.  The port numbers below 129 are known as I<reserved ports>.  Only "
"processes with the effective user ID 0 or the B<CAP_NET_BIND_SERVICE> "
"capability may B<bind>(2)  to these sockets.  I<sat_addr> is the host "
"address.  The I<net> member of I<struct at_addr> contains the host network "
"in network byte order.  The value of B<AT_ANYNET> is a wildcard and also "
"implies \\(lqthis network.\\(rq The I<node> member of I<struct at_addr> "
"contains the host node number.  The value of B<AT_ANYNODE> is a wildcard and "
"also implies \\(lqthis node.\\(rq The value of B<ATADDR_BCAST> is a link "
"local broadcast address."
msgstr ""
"Значение I<sat_family> всегда устанавливается в B<AF_APPLETALK>. В "
"I<sat_port> содержится номер порта. Порты с номерами меньше 129 называются "
"I<зарезервированными портами>. Вызов B<bind>(2) для этих сокетов допустим "
"только для процессов, у которых идентификатор эффективного пользователя "
"равен нулю, либо имеется мандат B<CAP_NET_BIND_SERVICE>. В I<sat_addr> "
"указан адрес машины (host). Поле I<net> структуры I<struct at_addr> содержит "
"адрес сети машины в сетевом порядке расположения байт. Значение B<AT_ANYNET> "
"является шаблоном, включающим в себя и \\(lqэту сеть\\(rq. Поле I<node> "
"структуры I<struct at_addr> содержит номер узла машины. Значение "
"B<AT_ANYNODE> является шаблоном, включающим в себя и \\(lqэтот узел\\(rq. "
"Значение B<ATADDR_BCAST> является ссылкой на локальный широковещательный "
"адрес."

#. type: SS
#: man-pages/man7/ddp.7:120
#, no-wrap
msgid "Socket options"
msgstr "Параметры сокета"

#. type: Plain text
#: man-pages/man7/ddp.7:122
msgid "No protocol-specific socket options are supported."
msgstr "Специальные параметры сокета для протокола не поддерживаются."

#. type: SS
#: man-pages/man7/ddp.7:122
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#. type: Plain text
#: man-pages/man7/ddp.7:128
msgid ""
"IP supports a set of I</proc> interfaces to configure some global AppleTalk "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/atalk/>."
msgstr ""
"IP поддерживает набор интерфейсов I</proc> для настройки некоторых общих "
"параметров Appletalk. Доступ к параметрам можно получить путем чтения или "
"записи файлов в каталоге I</proc/sys/net/atalk/>."

#. type: TP
#: man-pages/man7/ddp.7:128
#, no-wrap
msgid "I<aarp-expiry-time>"
msgstr "I<aarp-expiry-time>"

#. type: Plain text
#: man-pages/man7/ddp.7:131
msgid "The time interval (in seconds) before an AARP cache entry expires."
msgstr ""
"Временной интервал (в секундах) до момента устаревания записи в кэше AARP."

#. type: TP
#: man-pages/man7/ddp.7:131
#, no-wrap
msgid "I<aarp-resolve-time>"
msgstr "I<aarp-resolve-time>"

#. type: Plain text
#: man-pages/man7/ddp.7:134
msgid "The time interval (in seconds) before an AARP cache entry is resolved."
msgstr "Временной интервал (в секундах) до определения записи в кэше AARP."

#. type: TP
#: man-pages/man7/ddp.7:134
#, no-wrap
msgid "I<aarp-retransmit-limit>"
msgstr "I<aarp-retransmit-limit>"

#. type: Plain text
#: man-pages/man7/ddp.7:138
msgid ""
"The number of retransmissions of an AARP query before the node is declared "
"dead."
msgstr ""
"Количество повторных передач запроса AARP до того, как запись будет "
"объявлена недействительной."

#. type: TP
#: man-pages/man7/ddp.7:138
#, no-wrap
msgid "I<aarp-tick-time>"
msgstr "I<aarp-tick-time>"

#. type: Plain text
#: man-pages/man7/ddp.7:141
msgid "The timer rate (in seconds) for the timer driving AARP."
msgstr "Скорость таймера управляющего AARP в секундах."

#. type: Plain text
#: man-pages/man7/ddp.7:144
msgid ""
"The default values match the specification and should never need to be "
"changed."
msgstr ""
"Значения по умолчанию соответствуют спецификации и никогда не должны "
"меняться."

#. type: SS
#: man-pages/man7/ddp.7:144
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#.  FIXME . Add a section about multicasting
#. type: Plain text
#: man-pages/man7/ddp.7:149
msgid "All ioctls described in B<socket>(7)  apply to DDP."
msgstr "Все вызовы ioctl, описанные в B<socket>(7), применимы к DDP."

#. type: SH
#: man-pages/man7/ddp.7:149
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/ddp.7:150
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man7/ddp.7:157
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include sending to a broadcast address without having the broadcast "
"flag set, and trying to bind to a reserved port without effective user ID 0 "
"or B<CAP_NET_BIND_SERVICE>."
msgstr ""
"Пользователь попытался выполнить операцию, не имея на то соответствующих "
"прав. Это относится к передаче информации по широковещательному адресу при "
"сброшенном флаге широковещательной передачи, а также к попытке соединения с "
"зарезервированным портом, когда идентификатор эффективного пользователя "
"отличается от нуля или отсутствует мандат B<CAP_NET_BIND_SERVICE>."

#. type: TP
#: man-pages/man7/ddp.7:157
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: man-pages/man7/ddp.7:160
msgid "Tried to bind to an address already in use."
msgstr "Попытка связать сокет с уже используемым адресом."

#. type: TP
#: man-pages/man7/ddp.7:160
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: man-pages/man7/ddp.7:164
msgid ""
"A nonexistent interface was requested or the requested source address was "
"not local."
msgstr ""
"Был запрошен несуществующий интерфейс или запрошенный исходящий адрес не "
"является локальным."

#. type: TP
#: man-pages/man7/ddp.7:164
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man7/ddp.7:167
msgid "Operation on a nonblocking socket would block."
msgstr "Действие над неблокирующим сокетом привело бы к его блокировке."

#. type: TP
#: man-pages/man7/ddp.7:167
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: man-pages/man7/ddp.7:170
msgid "A connection operation on a nonblocking socket is already in progress."
msgstr ""
"Операция соединения на неблокирующем сокете уже находится в процессе "
"выполнения."

#. type: TP
#: man-pages/man7/ddp.7:170
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: man-pages/man7/ddp.7:174
msgid "A connection was closed during an B<accept>(2)."
msgstr "Соединение закрыто во время B<accept>(2)."

#. type: TP
#: man-pages/man7/ddp.7:174
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr "B<EHOSTUNREACH>"

#. type: Plain text
#: man-pages/man7/ddp.7:177
msgid "No routing table entry matches the destination address."
msgstr "Нет записи в таблице маршрутизации, указывающей на адрес назначения."

#. type: TP
#: man-pages/man7/ddp.7:177
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/ddp.7:180
msgid "Invalid argument passed."
msgstr "Передан неверный аргумент."

#. type: TP
#: man-pages/man7/ddp.7:180
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: man-pages/man7/ddp.7:184
msgid "B<connect>(2)  was called on an already connected socket."
msgstr "Вызов B<connect>(2) запущен для сокета, уже установившего соединение."

#. type: TP
#: man-pages/man7/ddp.7:184
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man7/ddp.7:187
msgid "Datagram is bigger than the DDP MTU."
msgstr "Размер датаграммы больше размера DDP MTU."

#. type: TP
#: man-pages/man7/ddp.7:187
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man7/ddp.7:190
msgid "Network device not available or not capable of sending IP."
msgstr "Сетевое устройство недоступно или неспособно посылать IP."

#. type: TP
#: man-pages/man7/ddp.7:190
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man7/ddp.7:194
msgid "B<SIOCGSTAMP> was called on a socket where no packet arrived."
msgstr ""
"Операция B<SIOCGSTAMP> вызвана для сокета, который ещё не получил ни одного "
"пакета."

#. type: TP
#: man-pages/man7/ddp.7:194
#, no-wrap
msgid "B<ENOMEM> and B<ENOBUFS>"
msgstr "B<ENOMEM> и B<ENOBUFS>"

#. type: Plain text
#: man-pages/man7/ddp.7:197
msgid "Not enough memory available."
msgstr "Недостаточно памяти."

#. type: TP
#: man-pages/man7/ddp.7:197
#, no-wrap
msgid "B<ENOPKG>"
msgstr "B<ENOPKG>"

#. type: Plain text
#: man-pages/man7/ddp.7:200
msgid "A kernel subsystem was not configured."
msgstr "Не настроена подсистема ядра."

#. type: TP
#: man-pages/man7/ddp.7:200
#, no-wrap
msgid "B<ENOPROTOOPT> and B<EOPNOTSUPP>"
msgstr "B<ENOPROTOOPT> и B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man7/ddp.7:203
msgid "Invalid socket option passed."
msgstr "Передан недопустимый параметр сокета."

#. type: TP
#: man-pages/man7/ddp.7:203
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man7/ddp.7:207
msgid ""
"The operation is defined only on a connected socket, but the socket wasn't "
"connected."
msgstr ""
"Операция определена только для сокета, установившего соединение, а этот "
"сокет не соединён."

#. type: TP
#: man-pages/man7/ddp.7:207
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man7/ddp.7:212
msgid ""
"User doesn't have permission to set high priority, make a configuration "
"change, or send signals to the requested process or group."
msgstr ""
"У пользователя нет достаточных полномочий, чтобы повысить приоритет, "
"изменить настройку или послать сигнал запрашиваемому процессу или группе "
"процессов."

#. type: TP
#: man-pages/man7/ddp.7:212
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: man-pages/man7/ddp.7:215
msgid "The connection was unexpectedly closed or shut down by the other end."
msgstr ""
"Соединение неожиданно закрылось или завершено (shut down) другой стороной."

#. type: TP
#: man-pages/man7/ddp.7:215
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: man-pages/man7/ddp.7:218
msgid "The socket was unconfigured, or an unknown socket type was requested."
msgstr "Сокет не настроен или запрошен неизвестный тип сокета."

#. type: SH
#: man-pages/man7/ddp.7:218
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/ddp.7:223
msgid ""
"AppleTalk is supported by Linux 2.0 or higher.  The I</proc> interfaces "
"exist since Linux 2.2."
msgstr ""
"AppleTalk поддерживается в Linux версии 2.0 и более поздних. Интерфейс I</"
"proc> появился в Linux 2.2."

#. type: SH
#: man-pages/man7/ddp.7:223
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man7/ddp.7:229
msgid ""
"Be very careful with the B<SO_BROADCAST> option; it is not privileged in "
"Linux.  It is easy to overload the network with careless sending to "
"broadcast addresses."
msgstr ""
"Будьте очень осторожны при работе с параметром B<SO_BROADCAST>: в Linux он "
"не относится к привилегированным. Масштабная рассылка сообщений по "
"широковещательному адресу может легко перегрузить сеть."

#. type: SS
#: man-pages/man7/ddp.7:229
#, no-wrap
msgid "Compatibility"
msgstr "Совместимость"

#. type: Plain text
#: man-pages/man7/ddp.7:236
msgid ""
"The basic AppleTalk socket interface is compatible with B<netatalk> on BSD-"
"derived systems.  Many BSD systems fail to check B<SO_BROADCAST> when "
"sending broadcast frames; this can lead to compatibility problems."
msgstr ""
"Базовый интерфейс сокетов Appletalk совместим с B<netatalk> в BSD-подобных "
"системах. Многие системы BSD не проверяют B<SO_BROADCAST> при посылке "
"широковещательных кадров: это может привести к проблемам совместимости."

#. type: Plain text
#: man-pages/man7/ddp.7:241
msgid ""
"The raw socket mode is unique to Linux and exists to support the alternative "
"CAP package and AppleTalk monitoring tools more easily."
msgstr ""
"Режим неструктурированных сокетов поддерживается только в Linux и "
"предназначен для облегчения поддержки альтернатив пакета CAP и утилит "
"мониторинга AppleTalk."

#. type: SH
#: man-pages/man7/ddp.7:241
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man7/ddp.7:243
msgid "There are too many inconsistent error values."
msgstr "Слишком много противоречий в значениях ошибок."

#. type: Plain text
#: man-pages/man7/ddp.7:246
msgid ""
"The ioctls used to configure routing tables, devices, AARP tables, and other "
"devices are not yet described."
msgstr ""
"Вызовы ioctl для настройки таблиц маршрутизации, устройств, таблиц AARP и "
"других устройств пока что не описаны."

#. type: Plain text
#: man-pages/man7/ddp.7:250
msgid "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"
msgstr "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"

#. type: TH
#: man-pages/man2/dup.2:37
#, no-wrap
msgid "DUP"
msgstr "DUP"

#. type: Plain text
#: man-pages/man2/dup.2:40
msgid "dup, dup2, dup3 - duplicate a file descriptor"
msgstr "dup, dup2, dup3 - создать дубликат файлового дескриптора"

#. type: Plain text
#: man-pages/man2/dup.2:43
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/dup.2:46
#, no-wrap
msgid ""
"B<int dup(int >I<oldfd>B<);>\n"
"B<int dup2(int >I<oldfd>B<, int >I<newfd>B<);>\n"
msgstr ""
"B<int dup(int >I<oldfd>B<);>\n"
"B<int dup2(int >I<oldfd>B<, int >I<newfd>B<);>\n"

#. type: Plain text
#: man-pages/man2/dup.2:50
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Определение констант O_* */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/dup.2:52
#, no-wrap
msgid "B<int dup3(int >I<oldfd>B<, int >I<newfd>B<, int >I<flags>B<);>\n"
msgstr "B<int dup3(int >I<oldfd>B<, int >I<newfd>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/dup.2:59
msgid ""
"The B<dup>()  system call creates a copy of the file descriptor I<oldfd>, "
"using the lowest-numbered unused file descriptor for the new descriptor."
msgstr ""
"Системный вызов B<dup>() создаёт копию файлового дескриптора I<oldfd>, "
"используя для нового дескриптора самый маленький свободный номер файлового "
"дескриптора."

#. type: Plain text
#: man-pages/man2/dup.2:68
msgid ""
"After a successful return, the old and new file descriptors may be used "
"interchangeably.  They refer to the same open file description (see "
"B<open>(2))  and thus share file offset and file status flags; for example, "
"if the file offset is modified by using B<lseek>(2)  on one of the file "
"descriptors, the offset is also changed for the other."
msgstr ""
"После успешного выполнения старый и новый файловые дескрипторы являются "
"взаимозаменяемыми. Они указывают на одно и то же открытое файловое описание "
"(смотрите B<open>(2)) и поэтому имеют общее файловое смещение и флаги "
"состояния файла; например, если файловое смещение изменить с помощью "
"B<lseek>(2) через один из файловых дескрипторов, то смещение изменится и для "
"другого."

#. type: Plain text
#: man-pages/man2/dup.2:77
msgid ""
"The two file descriptors do not share file descriptor flags (the close-on-"
"exec flag).  The close-on-exec flag (B<FD_CLOEXEC>; see B<fcntl>(2))  for "
"the duplicate descriptor is off."
msgstr ""
"Эти два файловых дескриптора имеют различные флаги дескриптора файла (флаг "
"close-on-exec). Флаг close-on-exec (B<FD_CLOEXEC>; см. B<fcntl>(2)) у копии "
"дескриптора сбрасывается."

#. type: SS
#: man-pages/man2/dup.2:77
#, no-wrap
msgid "dup2()"
msgstr "dup2()"

#. type: Plain text
#: man-pages/man2/dup.2:88
msgid ""
"The B<dup2>()  system call performs the same task as B<dup>(), but instead "
"of using the lowest-numbered unused file descriptor, it uses the file "
"descriptor number specified in I<newfd>.  If the file descriptor I<newfd> "
"was previously open, it is silently closed before being reused."
msgstr ""
"Системный вызов B<dup2>() выполняет ту же задачу, что и B<dup>(), но вместо "
"использования самого маленького неиспользуемого номера файлового "
"дескриптора, он использует номер файлового дескриптора, указанного в "
"I<newfd>. Если файловый дескриптор I<newfd> уже открыт, то он закрывается "
"перед повторным использованием."

#. type: Plain text
#: man-pages/man2/dup.2:104
msgid ""
"The steps of closing and reusing the file descriptor I<newfd> are performed "
"I<atomically>.  This is important, because trying to implement equivalent "
"functionality using B<close>(2)  and B<dup>()  would be subject to race "
"conditions, whereby I<newfd> might be reused between the two steps.  Such "
"reuse could happen because the main program is interrupted by a signal "
"handler that allocates a file descriptor, or because a parallel thread "
"allocates a file descriptor."
msgstr ""
"Шаги по закрытию и повторному использованию файлового дескриптора I<newfd> "
"выполняются I<атомарно>. Это важно, так как попытка реализовать подобное с "
"помощью B<close>(2) и B<dup>() привело бы к состязательности, в силу чего "
"I<newfd> мог быть задействован повторно между этими двумя шагами. Такое "
"повторное использование может произойти, из-за прерывания основной программы "
"обработчиком сигналов, который выделяет файловый дескриптор, или из-за "
"параллельной нити, выделяющей файловый дескриптор."

#. type: Plain text
#: man-pages/man2/dup.2:106
msgid "Note the following points:"
msgstr "Также заметим следующее:"

#. type: IP
#: man-pages/man2/dup.2:106 man-pages/man2/dup.2:112 man-pages/man2/dup.2:129
#: man-pages/man2/dup.2:138
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man2/dup.2:112
msgid ""
"If I<oldfd> is not a valid file descriptor, then the call fails, and "
"I<newfd> is not closed."
msgstr ""
"Если I<oldfd> является некорректным файловым дескриптором, то вызов "
"завершается с ошибкой, а I<newfd> не закрывается."

#. type: Plain text
#: man-pages/man2/dup.2:124
msgid ""
"If I<oldfd> is a valid file descriptor, and I<newfd> has the same value as "
"I<oldfd>, then B<dup2>()  does nothing, and returns I<newfd>."
msgstr ""
"Если I<oldfd> является корректным файловым дескриптором, а номер I<newfd> "
"совпадает с I<oldfd>, то B<dup2>() не делает ничего и возвращает значение "
"I<newfd>."

#. type: SS
#: man-pages/man2/dup.2:124
#, no-wrap
msgid "dup3()"
msgstr "dup3()"

#. type: Plain text
#: man-pages/man2/dup.2:129
msgid "B<dup3>()  is the same as B<dup2>(), except that:"
msgstr "B<dup3>() похож на B<dup2>(). Отличия заключаются в следующем:"

#. type: Plain text
#: man-pages/man2/dup.2:138
msgid ""
"The caller can force the close-on-exec flag to be set for the new file "
"descriptor by specifying B<O_CLOEXEC> in I<flags>.  See the description of "
"the same flag in B<open>(2)  for reasons why this may be useful."
msgstr ""
"Вызывающий может принудительно установить флаг close-on-exec flag у нового "
"файлового дескриптора, указав B<O_CLOEXEC> в I<flags>. Зачем это может быть "
"нужно смотрите в B<open>(2)."

#.  Ulrich Drepper, LKML, 2008-10-09:
#. 	We deliberately decided on this change.  Otherwise, what is the
#. 	result of dup3(fd, fd, O_CLOEXEC)?
#. type: Plain text
#: man-pages/man2/dup.2:150
msgid ""
"If I<oldfd> equals I<newfd>, then B<dup3>()  fails with the error B<EINVAL>."
msgstr "Если I<oldfd> равно I<newfd>, то B<dup3>() выдает ошибку B<EINVAL>."

#. type: SH
#: man-pages/man2/dup.2:150
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/dup.2:156
msgid ""
"On success, these system calls return the new file descriptor.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"В случае успеха данные системные вызовы возвращают новый файловый дескриптор "
"или -1, если произошла ошибка (в этом случае I<errno> устанавливается "
"должным образом)."

#. type: TP
#: man-pages/man2/dup.2:157 man-pages/man2/dup.2:161
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/dup.2:161
msgid "I<oldfd> isn't an open file descriptor."
msgstr "Значение I<oldfd> не является открытым файловым дескриптором."

#. type: Plain text
#: man-pages/man2/dup.2:168
msgid ""
"I<newfd> is out of the allowed range for file descriptors (see the "
"discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"Значение I<newfd> находится вне допустимого диапазона файловых дескрипторов "
"(смотрите описание B<RLIMIT_NOFILE> в B<getrlimit>(2))."

#. type: TP
#: man-pages/man2/dup.2:168
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/dup.2:178
msgid ""
"(Linux only) This may be returned by B<dup2>()  or B<dup3>()  during a race "
"condition with B<open>(2)  and B<dup>()."
msgstr ""
"(только в Linux) Может случиться в B<dup2>() или B<dup3>() при возникновении "
"состязательности вызовов B<open>(2) и B<dup>()."

#. type: TP
#: man-pages/man2/dup.2:178
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/dup.2:186
msgid ""
"The B<dup2>()  or B<dup3>()  call was interrupted by a signal; see "
"B<signal>(7)."
msgstr ""
"Вызов B<dup2>() или B<dup3>() был прерван каким-либо сигналом. Смотрите "
"B<signal>(7)."

#. type: Plain text
#: man-pages/man2/dup.2:191
msgid "(B<dup3>())  I<flags> contain an invalid value."
msgstr "(B<dup3>()) I<flags> содержит некорректное значение."

#. type: Plain text
#: man-pages/man2/dup.2:197
msgid "(B<dup3>())  I<oldfd> was equal to I<newfd>."
msgstr "(B<dup3>()) I<oldfd> было равно I<newfd>."

#. type: TP
#: man-pages/man2/dup.2:197
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/dup.2:204
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"Было достигнуто ограничение по количеству открытых файловых дескрипторов на "
"процесс (смотрите описание B<RLIMIT_NOFILE> в B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man2/dup.2:209
msgid ""
"B<dup3>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""
"Вызов B<dup3>() был добавлен в Linux версии 2.6.27; поддержка в glibc "
"доступна с версии 2.9."

#. type: SH
#: man-pages/man2/dup.2:209
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man2/dup.2:213
msgid "B<dup>(), B<dup2>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "B<dup>(), B<dup2>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#.  SVr4 documents additional
#.  EINTR and ENOLINK error conditions.  POSIX.1 adds EINTR.
#.  The EBUSY return is Linux-specific.
#. type: Plain text
#: man-pages/man2/dup.2:219
msgid "B<dup3>()  is Linux-specific."
msgstr "B<dup3>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/dup.2:233
msgid ""
"The error returned by B<dup2>()  is different from that returned by "
"B<fcntl(>..., B<F_DUPFD>, ...B<)> when I<newfd> is out of range.  On some "
"systems, B<dup2>()  also sometimes returns B<EINVAL> like B<F_DUPFD>."
msgstr ""
"Ошибка, которую возвращает B<dup2>(), отличается от той, что возвращает "
"B<fcntl(>…, B<F_DUPFD>, …B<)>, когда I<newfd> находится вне допустимых "
"пределов. На некоторых системах B<dup2>() также иногда возвращает B<EINVAL> "
"— как B<F_DUPFD>."

#. type: Plain text
#: man-pages/man2/dup.2:249
msgid ""
"If I<newfd> was open, any errors that would have been reported at "
"B<close>(2)  time are lost.  If this is of concern, then\\(emunless the "
"program is single-threaded and does not allocate file descriptors in signal "
"handlers\\(emthe correct approach is I<not> to close I<newfd> before calling "
"B<dup2>(), because of the race condition described above.  Instead, code "
"something like the following could be used:"
msgstr ""
"Если был открыт I<newfd>, то любые ошибки, о которых было бы сообщено "
"B<close>(2), теряются. Если это важно, то (если программа однонитевая и не "
"выделяет файловые дескрипторы в обработчиках сигналов) правильней будет "
"I<не> закрывать I<newfd> перед вызовом B<dup2>(), из-за состязательности, "
"описанной выше. Вместо этого можно использовать, например, такой код:"

#. type: Plain text
#: man-pages/man2/dup.2:254
#, no-wrap
msgid ""
"    /* Obtain a duplicate of 'newfd' that can subsequently\n"
"       be used to check for close() errors; an EBADF error\n"
"       means that 'newfd' was not open. */\n"
msgstr ""
"    /* Получить копию «newfd», которую затем можно\n"
"       использовать для проверки ошибок close(); ошибка EBADF\n"
"       означает, что «newfd» не открыт. */\n"

#. type: Plain text
#: man-pages/man2/dup.2:259
#, no-wrap
msgid ""
"    tmpfd = dup(newfd);\n"
"    if (tmpfd == -1 && errno != EBADF) {\n"
"        /* Handle unexpected dup() error */\n"
"    }\n"
msgstr ""
"    tmpfd = dup(newfd);\n"
"    if (tmpfd == -1 && errno != EBADF) {\n"
"        /* обработка неожидаемой ошибки dup() */\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/dup.2:261
#, no-wrap
msgid "    /* Atomically duplicate 'oldfd' on 'newfd' */\n"
msgstr "    /* атомарное копирование «oldfd» в «newfd» */\n"

#. type: Plain text
#: man-pages/man2/dup.2:265
#, no-wrap
msgid ""
"    if (dup2(oldfd, newfd) == -1) {\n"
"        /* Handle dup2() error */\n"
"    }\n"
msgstr ""
"    if (dup2(oldfd, newfd) == -1) {\n"
"        /* обработка ошибки dup2() */\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/dup.2:268
#, no-wrap
msgid ""
"    /* Now check for close() errors on the file originally\n"
"       referred to by 'newfd' */\n"
msgstr ""
"    /* теперь проверим ошибки close() у файла, на который изначально\n"
"       ссылался «newfd» */\n"

#. type: Plain text
#: man-pages/man2/dup.2:274
#, no-wrap
msgid ""
"    if (tmpfd != -1) {\n"
"        if (close(tmpfd) == -1) {\n"
"            /* Handle errors from close */\n"
"        }\n"
"    }\n"
msgstr ""
"    if (tmpfd != -1) {\n"
"        if (close(tmpfd) == -1) {\n"
"            /* обработка ошибок закрытия */\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/dup.2:278
msgid "B<close>(2), B<fcntl>(2), B<open>(2)"
msgstr "B<close>(2), B<fcntl>(2), B<open>(2)"

#. type: TH
#: man-pages/man2/delete_module.2:25
#, no-wrap
msgid "DELETE_MODULE"
msgstr "DELETE_MODULE"

#. type: Plain text
#: man-pages/man2/delete_module.2:28
msgid "delete_module - unload a kernel module"
msgstr "delete_module - выгружает модуль ядра"

#. type: Plain text
#: man-pages/man2/delete_module.2:31
#, no-wrap
msgid "B<int delete_module(const char *>I<name>B<, int >I<flags>B<);>\n"
msgstr "B<int delete_module(const char *>I<name>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/delete_module.2:35
msgid ""
"I<Note>: No declaration of this system call is provided in glibc headers; "
"see NOTES."
msgstr ""
"I<Замечание>: В заголовочных файлах glibc этой системный вызов отсутствует; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/delete_module.2:49
msgid ""
"The B<delete_module>()  system call attempts to remove the unused loadable "
"module entry identified by I<name>.  If the module has an I<exit> function, "
"then that function is executed before unloading the module.  The I<flags> "
"argument is used to modify the behavior of the system call, as described "
"below.  This system call requires privilege."
msgstr ""
"Вызов B<delete_module>() пытается удалить неиспользуемый загруженный модуль "
"с именем I<name>. Если у модуля есть функция I<exit>, то она выполняется "
"перед выгрузкой. Аргумент I<flags> используется для изменения поведения "
"системного вызова — это описано далее. Данный системный вызов требует особых "
"прав."

#. type: Plain text
#: man-pages/man2/delete_module.2:51
msgid "Module removal is attempted according to the following rules:"
msgstr "Удаление модуля выполняется по следующим правилам:"

#. type: IP
#: man-pages/man2/delete_module.2:51
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man2/delete_module.2:55
msgid ""
"If there are other loaded modules that depend on (i.e., refer to symbols "
"defined in) this module, then the call fails."
msgstr ""
"Если какой-то другой модуль зависит от выгружаемого (т.е., использует его "
"символы), то вызов завершается с ошибкой."

#. type: IP
#: man-pages/man2/delete_module.2:55
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man2/delete_module.2:59
msgid ""
"Otherwise, if the reference count for the module (i.e., the number of "
"processes currently using the module)  is zero, then the module is "
"immediately unloaded."
msgstr ""
"В противном случае, если счётчик ссылок на модуль (т.е. количество "
"процессов, использующих модуль в данный момент) равно нулю, то модуль "
"немедленно выгружается."

#. type: IP
#: man-pages/man2/delete_module.2:59
#, no-wrap
msgid "3."
msgstr "3."

#.   	O_TRUNC == KMOD_REMOVE_FORCE in kmod library
#.   	O_NONBLOCK == KMOD_REMOVE_NOWAIT in kmod library
#. type: Plain text
#: man-pages/man2/delete_module.2:70
msgid ""
"If a module has a nonzero reference count, then the behavior depends on the "
"bits set in I<flags>.  In normal usage (see NOTES), the B<O_NONBLOCK> flag "
"is always specified, and the B<O_TRUNC> flag may additionally be specified."
msgstr ""
"Если у модуля ненулевой счётчик ссылок, то поведение зависит от битов, "
"установленных в I<flags>. Обычно (смотрите ЗАМЕЧАНИЯ) всегда указывается "
"флаг B<O_NONBLOCK>, а иногда добавляется B<O_TRUNC>."

#. type: Plain text
#: man-pages/man2/delete_module.2:74
msgid "The various combinations for I<flags> have the following effect:"
msgstr "Различные комбинации значений в I<flags> дают разный эффект:"

#. type: TP
#: man-pages/man2/delete_module.2:75
#, no-wrap
msgid "B<flags == O_NONBLOCK>"
msgstr "B<flags == O_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/delete_module.2:78
msgid "The call returns immediately, with an error."
msgstr "Вызов сразу завершается с ошибкой."

#. type: TP
#: man-pages/man2/delete_module.2:78
#, no-wrap
msgid "B<flags == (O_NONBLOCK | O_TRUNC)>"
msgstr "B<flags == (O_NONBLOCK | O_TRUNC)>"

#. type: Plain text
#: man-pages/man2/delete_module.2:82
msgid ""
"The module is unloaded immediately, regardless of whether it has a nonzero "
"reference count."
msgstr ""
"Модуль немедленно выгружается, независимо от того, равен счётчик ссылок 0 "
"или нет."

#. type: TP
#: man-pages/man2/delete_module.2:82
#, no-wrap
msgid "B<(flags & O_NONBLOCK) == 0>"
msgstr "B<(flags & O_NONBLOCK) == 0>"

#. type: Plain text
#: man-pages/man2/delete_module.2:89
msgid "If I<flags> does not specify B<O_NONBLOCK>, the following steps occur:"
msgstr ""
"Если в I<flags> не указан B<O_NONBLOCK>, то выполняются следующие шаги:"

#. type: Plain text
#: man-pages/man2/delete_module.2:92
msgid "The module is marked so that no new references are permitted."
msgstr "Модуль помечается, что больше ссылаться на него запрещается."

#. type: Plain text
#: man-pages/man2/delete_module.2:97
msgid ""
"If the module's reference count is nonzero, the caller is placed in an "
"uninterruptible sleep state (B<TASK_UNINTERRUPTIBLE>)  until the reference "
"count is zero, at which point the call unblocks."
msgstr ""
"Если счётчик ссылок модуля не равен нулю, то вызывающий переходит в "
"непрерываемое состояние сна (B<TASK_UNINTERRUPTIBLE>) до тех пор, пока "
"счётчик ссылок не станет равным 0 — в этот момент вызов разблокируется."

#. type: Plain text
#: man-pages/man2/delete_module.2:99
msgid "The module is unloaded in the usual way."
msgstr "Модуль выгружается как обычно."

#. type: Plain text
#: man-pages/man2/delete_module.2:113
msgid ""
"The B<O_TRUNC> flag has one further effect on the rules described above.  By "
"default, if a module has an I<init> function but no I<exit> function, then "
"an attempt to remove the module fails.  However, if B<O_TRUNC> was "
"specified, this requirement is bypassed."
msgstr ""
"Флаг B<O_TRUNC> имеет ещё один эффект на правила, описанные выше. По "
"умолчанию, если модуль имеет функцию I<init>, но не имеет функции I<exit>, "
"то попытка удаления модуля завершается с ошибкой. Однако, если указан "
"B<O_TRUNC>, то это требование не учитывается."

#. type: Plain text
#: man-pages/man2/delete_module.2:124
msgid ""
"Using the B<O_TRUNC> flag is dangerous! If the kernel was not built with "
"B<CONFIG_MODULE_FORCE_UNLOAD>, this flag is silently ignored.  (Normally, "
"B<CONFIG_MODULE_FORCE_UNLOAD> is enabled.)  Using this flag taints the "
"kernel (TAINT_FORCED_RMMOD)."
msgstr ""
"Использовать флаг B<O_TRUNC> опасно! Если ядро не собрано с параметром "
"B<CONFIG_MODULE_FORCE_UNLOAD>, то этот флаг просто игнорируется (обычно "
"параметр B<CONFIG_MODULE_FORCE_UNLOAD> включают). Использование этого флага "
"приводит к примешиванию (taints) в ядре (TAINT_FORCED_RMMOD)."

#. type: Plain text
#: man-pages/man2/delete_module.2:129
msgid ""
"On success, zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается ноль. В случае ошибки возвращается -1, "
"а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/delete_module.2:143
msgid ""
"The module is not \"live\" (i.e., it is still being initialized or is "
"already marked for removal); or, the module has an I<init> function but has "
"no I<exit> function, and B<O_TRUNC> was not specified in I<flags>."
msgstr ""
"Модуль не «живой» (т.е., он всё ещё инициализируется или уже помечен для "
"удаления); или модуль имеет функцию I<init>, но не имеет функции I<exit> и в "
"I<flags> не указан флаг B<O_TRUNC>."

#. type: TP
#: man-pages/man2/delete_module.2:143
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/delete_module.2:147
msgid ""
"I<name> refers to a location outside the process's accessible address space."
msgstr ""
"Значение I<name> указывает на расположение вне доступного адресного "
"пространства процесса."

#. type: Plain text
#: man-pages/man2/delete_module.2:150
msgid "No module by that name exists."
msgstr "Модуль с таким именем не существует."

#. type: Plain text
#: man-pages/man2/delete_module.2:161
msgid ""
"The caller was not privileged (did not have the B<CAP_SYS_MODULE> "
"capability), or module unloading is disabled (see I</proc/sys/kernel/"
"modules_disabled> in B<proc>(5))."
msgstr ""
"Вызывающий не имеет прав (не имеет мандата B<CAP_SYS_MODULE>), или отключена "
"выгрузка модулей (смотрите I</proc/sys/kernel/modules_disabled> в "
"B<proc>(5))."

#. type: TP
#: man-pages/man2/delete_module.2:161
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: man-pages/man2/delete_module.2:172
msgid ""
"Other modules depend on this module; or, B<O_NONBLOCK> was specified in "
"I<flags>, but the reference count of this module is nonzero and B<O_TRUNC> "
"was not specified in I<flags>."
msgstr ""
"Другие модули зависят от этого модуля; или в I<flags> указан флаг  "
"B<O_NONBLOCK>, но счётчик ссылок модуля не равен 0 и в I<flags> не указан "
"флаг B<O_TRUNC>."

#. type: Plain text
#: man-pages/man2/delete_module.2:175
msgid "B<delete_module>()  is Linux-specific."
msgstr "Вызов B<delete_module>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/delete_module.2:186
msgid ""
"The B<delete_module>()  system call is not supported by glibc.  No "
"declaration is provided in glibc headers, but, through a quirk of history, "
"glibc versions before 2.23 did export an ABI for this system call.  "
"Therefore, in order to employ this system call, it is (before glibc 2.23) "
"sufficient to manually declare the interface in your code; alternatively, "
"you can invoke the system call using B<syscall>(2)."
msgstr ""
"Системный вызов B<delete_module>() не поддерживается glibc. В заголовочных "
"файлах glibc он не объявлен, но в недавнем прошлом glibc до версии 2.23 "
"экспортировал ABI для этого системного вызова. Поэтому чтобы получить данный "
"системный вызов достаточно вручную объявить интерфейс в своём коде; или же "
"вы можете вызвать его через B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/delete_module.2:196
msgid ""
"The uninterruptible sleep that may occur if B<O_NONBLOCK> is omitted from "
"I<flags> is considered undesirable, because the sleeping process is left in "
"an unkillable state.  As at Linux 3.7, specifying B<O_NONBLOCK> is optional, "
"but in future kernels it is likely to become mandatory."
msgstr ""
"Непрерываемый сон, который может начаться, если в I<flags> не указан флаг "
"B<O_NONBLOCK>, считается нежелательным, так как спящий процесс находится в "
"неубиваемом состоянии. В Linux 3.7 указание B<O_NONBLOCK> необязательно, но "
"в будущих ядрах, он, вероятно, станет обязательным."

#. type: SS
#: man-pages/man2/delete_module.2:196
#, no-wrap
msgid "Linux 2.4 and earlier"
msgstr "Linux версии 2.4 и более ранние"

#. type: Plain text
#: man-pages/man2/delete_module.2:198
msgid "In Linux 2.4 and earlier, the system call took only one argument:"
msgstr ""
"В Linux версии 2.4 и более ранних системный вызов принимал один аргумент:"

#. type: Plain text
#: man-pages/man2/delete_module.2:200
msgid "B< int delete_module(const char *>I<name>B<);>"
msgstr "B< int delete_module(const char *>I<name>B<);>"

#. type: Plain text
#: man-pages/man2/delete_module.2:204
msgid "If I<name> is NULL, all unused modules marked auto-clean are removed."
msgstr ""
"Если значение I<name> равно NULL, то все неиспользуемые модули, помеченные "
"для автоматической вычистки, удаляются."

#. type: Plain text
#: man-pages/man2/delete_module.2:210
msgid ""
"Some further details of differences in the behavior of B<delete_module>()  "
"in Linux 2.4 and earlier are I<not> currently explained in this manual page."
msgstr ""
"Есть и некоторые другие отличия в поведении B<delete_module>() в Linux 2.4 и "
"более ранних, I<но> они пока не описаны в этой справочной странице."

#. type: Plain text
#: man-pages/man2/delete_module.2:216
msgid ""
"B<create_module>(2), B<init_module>(2), B<query_module>(2), B<lsmod>(8), "
"B<modprobe>(8), B<rmmod>(8)"
msgstr ""
"B<create_module>(2), B<init_module>(2), B<query_module>(2), B<lsmod>(8), "
"B<modprobe>(8), B<rmmod>(8)"

#. type: TH
#: man-pages/man5/dir_colors.5:12
#, no-wrap
msgid "DIR_COLORS"
msgstr "DIR_COLORS"

#. type: TH
#: man-pages/man5/dir_colors.5:12
#, no-wrap
msgid "2013-08-09"
msgstr "2013-08-09"

#. type: TH
#: man-pages/man5/dir_colors.5:12
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: man-pages/man5/dir_colors.5:12
#, no-wrap
msgid "Linux User Manual"
msgstr "Руководство пользователя Linux"

#. type: Plain text
#: man-pages/man5/dir_colors.5:15
msgid "dir_colors - configuration file for dircolors(1)"
msgstr "dir_colors - файл настроек для утилиты dircolors(1)"

#. type: Plain text
#: man-pages/man5/dir_colors.5:22
msgid ""
"The program B<ls>(1)  uses the environment variable B<LS_COLORS> to "
"determine the colors in which the filenames are to be displayed.  This "
"environment variable is usually set by a command like"
msgstr ""
"Программа B<ls>(1) использует переменную окружения B<LS_COLORS> для "
"определения цветов, которыми должны отображаться имена файлов. Эта "
"переменная окружения обычно устанавливается командой типа:"

#. type: Plain text
#: man-pages/man5/dir_colors.5:25
msgid "eval \\`dircolors some_path/dir_colors\\`"
msgstr "eval \\`dircolors некий_путь/dir_colors\\`"

#. type: Plain text
#: man-pages/man5/dir_colors.5:38
msgid ""
"found in a system default shell initialization file, like I</etc/profile> or "
"I</etc/csh.cshrc>.  (See also B<dircolors>(1).)  Usually, the file used here "
"is I</etc/DIR_COLORS> and can be overridden by a I<.dir_colors> file in "
"one's home directory."
msgstr ""
"Эта команда обычно находится в стандартном файле начальных настроек оболочки "
"командной строки, например в I</etc/profile> или I</etc/csh.cshrc>. "
"(Смотрите также B<dircolors>(1).) Обычно здесь используется файл I</etc/"
"DIR_COLORS>, и его настройки могут быть изменены файлом I<.dir_colors> из "
"каталога пользователя."

#. type: Plain text
#: man-pages/man5/dir_colors.5:44
msgid ""
"This configuration file consists of several statements, one per line.  "
"Anything right of a hash mark (#) is treated as a comment, if the hash mark "
"is at the beginning of a line or is preceded by at least one whitespace.  "
"Blank lines are ignored."
msgstr ""
"Данный файл настройки состоит из нескольких операторов, по одному в строке. "
"Всё, что находится после символа решётки (#), считается комментарием (если "
"этот символ находится в начале строки или перед ним находится как минимум "
"один пробел). Пустые строки игнорируются."

#. type: Plain text
#: man-pages/man5/dir_colors.5:62
msgid ""
"The I<global> section of the file consists of any statement before the first "
"B<TERM> statement.  Any statement in the global section of the file is "
"considered valid for all terminal types.  Following the global section is "
"one or more I<terminal-specific> sections, preceded by one or more B<TERM> "
"statements which specify the terminal types (as given by the B<TERM> "
"environment variable) the following declarations apply to.  It is always "
"possible to override a global declaration by a subsequent terminal-specific "
"one."
msgstr ""
"Все операторы, появившиеся до первого оператора B<TERM>, составляют "
"I<глобальный> раздел. Они действуют для всех типов терминалов. После "
"глобального раздела находится один или более разделов, описывающих "
"определённые I<терминалы>. Он начинается с одного или более операторов "
"B<TERM>, который задаёт тип терминала (то же имя, что указывается в "
"переменной окружения B<TERM>). Для любого терминала глобальные настройки "
"всегда можно перекрыть терминал-специфичными."

#. type: Plain text
#: man-pages/man5/dir_colors.5:64
msgid "The following statements are recognized; case is insignificant:"
msgstr "Распознаются следующие операторы (регистр букв неважен):"

#. type: TP
#: man-pages/man5/dir_colors.5:64
#, no-wrap
msgid "B<TERM >I<terminal-type>"
msgstr "B<TERM >I<тип_терминала>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:72
msgid ""
"Starts a terminal-specific section and specifies which terminal it applies "
"to.  Multiple B<TERM> statements can be used to create a section which "
"applies for several terminal types."
msgstr ""
"Начинает раздел, специфичный для терминала, и указывает, к какому типу "
"терминала он применим. Можно указывать несколько операторов B<TERM>, чтобы "
"создать раздел, применимый к нескольким типам терминалов."

#. type: TP
#: man-pages/man5/dir_colors.5:72
#, no-wrap
msgid "B<COLOR yes|all|no|none|tty>"
msgstr "B<COLOR yes|all|no|none|tty>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:80
msgid ""
"(Slackware only; ignored by GNU B<dircolors>(1).)  Specifies that "
"colorization should always be enabled (I<yes> or I<all>), never enabled "
"(I<no> or I<none>), or enabled only if the output is a terminal (I<tty>).  "
"The default is I<no>."
msgstr ""
"(Только для Slackware; игнорируется GNU B<dircolors>(1).) Указывает, что "
"расцветка должна быть всегда разрешена (I<yes> или I<all>), никогда не "
"разрешена (I<no> или I<none>), или разрешена, только если вывод происходит "
"на терминальное устройство (I<tty>). По умолчанию I<no>."

#. type: TP
#: man-pages/man5/dir_colors.5:80
#, no-wrap
msgid "B<EIGHTBIT yes|no>"
msgstr "B<EIGHTBIT yes|no>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:89
msgid ""
"(Slackware only; ignored by GNU B<dircolors>(1).)  Specifies that eight-bit "
"ISO 8859 characters should be enabled by default.  For compatibility "
"reasons, this can also be specified as 1 for I<yes> or 0 for I<no>.  The "
"default is I<no>."
msgstr ""
"(Только для Slackware; игнорируется GNU B<dircolors>(1).) Указывает, "
"разрешены ли по умолчанию восьмибитные символы ISO 8859. Из соображений "
"совместимости можно также указывать 1 вместо I<yes> или 0 вместо I<no>. По "
"умолчанию I<no>."

#. type: TP
#: man-pages/man5/dir_colors.5:89
#, no-wrap
msgid "B<OPTIONS >I<options>"
msgstr "B<OPTIONS >I<параметры>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:102
msgid ""
"(Slackware only; ignored by GNU B<dircolors>(1).)  Adds command-line options "
"to the default B<ls> command line.  The options can be any valid B<ls> "
"command-line options, and should include the leading minus sign.  Note that "
"B<dircolors> does not verify the validity of these options."
msgstr ""
"(Только для Slackware; игнорируется GNU B<dircolors>(1).) Добавляет "
"параметры по умолчанию к командной строке B<ls>. Здесь можно указать любой "
"разрешённый параметр команды B<ls>, причем нужно указывать начальный знак "
"минус. Заметьте, что B<dircolors> не проверяет, допустимы ли эти параметры."

#. type: TP
#: man-pages/man5/dir_colors.5:102
#, no-wrap
msgid "B<NORMAL >I<color-sequence>"
msgstr "B<NORMAL >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:105
msgid "Specifies the color used for normal (nonfilename) text."
msgstr "Задаёт цвет, используемый для нормального (не имя файла) текста."

#. type: Plain text
#: man-pages/man5/dir_colors.5:108
msgid "Synonym: B<NORM>."
msgstr "Синоним B<NORM>."

#. type: TP
#: man-pages/man5/dir_colors.5:108
#, no-wrap
msgid "B<FILE >I<color-sequence>"
msgstr "B<FILE >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:111
msgid "Specifies the color used for a regular file."
msgstr "Задаёт цвет, используемый для обычных файлов."

#. type: TP
#: man-pages/man5/dir_colors.5:111
#, no-wrap
msgid "B<DIR >I<color-sequence>"
msgstr "B<DIR >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:114
msgid "Specifies the color used for directories."
msgstr "Задаёт цвет, используемый для каталогов."

#. type: TP
#: man-pages/man5/dir_colors.5:114
#, no-wrap
msgid "B<LINK >I<color-sequence>"
msgstr "B<LINK >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:117
msgid "Specifies the color used for a symbolic link."
msgstr "Задаёт цвет, используемый для символьных ссылок."

#. type: Plain text
#: man-pages/man5/dir_colors.5:121
msgid "Synonyms: B<LNK>, B<SYMLINK>."
msgstr "Синонимы: B<LNK>, B<SYMLINK>."

#. type: TP
#: man-pages/man5/dir_colors.5:121
#, no-wrap
msgid "B<ORPHAN >I<color-sequence>"
msgstr "B<ORPHAN >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:130
msgid ""
"Specifies the color used for an orphaned symbolic link (one which points to "
"a nonexistent file).  If this is unspecified, B<ls> will use the B<LINK> "
"color instead."
msgstr ""
"Задаёт цвет, используемый для нерабочих символьных ссылок (указывающих на "
"несуществующие файлы). Если этот цвет не задан, то B<ls> будет использовать "
"вместо него цвет B<LINK>."

#. type: TP
#: man-pages/man5/dir_colors.5:130
#, no-wrap
msgid "B<MISSING >I<color-sequence>"
msgstr "B<MISSING >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:139
msgid ""
"Specifies the color used for a missing file (a nonexistent file which "
"nevertheless has a symbolic link pointing to it).  If this is unspecified, "
"B<ls> will use the B<FILE> color instead."
msgstr ""
"Задаёт цвет, используемый для отсутствующих файлов (несуществующих файлов, "
"на которые указывают символьные ссылки). Если этот цвет не задан, то B<ls> "
"будет использовать вместо него цвет B<FILE>."

#. type: TP
#: man-pages/man5/dir_colors.5:139
#, no-wrap
msgid "B<FIFO >I<color-sequence>"
msgstr "B<FIFO >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:142
msgid "Specifies the color used for a FIFO (named pipe)."
msgstr "Задаёт цвет, используемый для FIFO (именованных каналов)."

#. type: Plain text
#: man-pages/man5/dir_colors.5:145
msgid "Synonym: B<PIPE>."
msgstr "Синоним B<PIPE>."

#. type: TP
#: man-pages/man5/dir_colors.5:145
#, no-wrap
msgid "B<SOCK >I<color-sequence>"
msgstr "B<SOCK >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:148
msgid "Specifies the color used for a socket."
msgstr "Задаёт цвет, используемый для сокетов."

#. type: TP
#: man-pages/man5/dir_colors.5:148
#, no-wrap
msgid "B<DOOR >I<color-sequence>"
msgstr "B<DOOR >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:152
msgid ""
"(Supported since fileutils 4.1)  Specifies the color used for a door "
"(Solaris 2.5 and later)."
msgstr ""
"(Поддерживается, начиная с fileutils 4.1) Задаёт цвет, используемый для "
"файлов типа door (Solaris 2.5 и выше)."

#. type: TP
#: man-pages/man5/dir_colors.5:152
#, no-wrap
msgid "B<BLK >I<color-sequence>"
msgstr "B<BLK >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:155
msgid "Specifies the color used for a block device special file."
msgstr "Задаёт цвет, используемый для специальных файлов блочных устройств."

#. type: Plain text
#: man-pages/man5/dir_colors.5:158
msgid "Synonym: B<BLOCK>."
msgstr "Синоним B<BLOCK>."

#. type: TP
#: man-pages/man5/dir_colors.5:158
#, no-wrap
msgid "B<CHR >I<color-sequence>"
msgstr "B<CHR >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:161
msgid "Specifies the color used for a character device special file."
msgstr "Задаёт цвет, используемый для специальных файлов символьных устройств."

#. type: Plain text
#: man-pages/man5/dir_colors.5:164
msgid "Synonym: B<CHAR>."
msgstr "Синоним B<CHAR>."

#. type: TP
#: man-pages/man5/dir_colors.5:164
#, no-wrap
msgid "B<EXEC >I<color-sequence>"
msgstr "B<EXEC >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:167
msgid "Specifies the color used for a file with the executable attribute set."
msgstr ""
"Задаёт цвет, используемый для файлов с установленным атрибутом выполнения."

#. type: TP
#: man-pages/man5/dir_colors.5:167
#, no-wrap
msgid "B<SUID >I<color-sequence>"
msgstr "B<SUID >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:170
msgid "Specifies the color used for a file with the set-user-ID attribute set."
msgstr ""
"Задаёт цвет, используемый для файлов с установленным битом set-user-ID."

#. type: Plain text
#: man-pages/man5/dir_colors.5:173
msgid "Synonym: B<SETUID>."
msgstr "Синоним B<SETUID>."

#. type: TP
#: man-pages/man5/dir_colors.5:173
#, no-wrap
msgid "B<SGID >I<color-sequence>"
msgstr "B<SGID >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:176
msgid ""
"Specifies the color used for a file with the set-group-ID attribute set."
msgstr ""
"Задаёт цвет, используемый для файлов с установленным битом set-group-ID."

#. type: Plain text
#: man-pages/man5/dir_colors.5:179
msgid "Synonym: B<SETGID>."
msgstr "Синоним B<SETGID>."

#. type: TP
#: man-pages/man5/dir_colors.5:179
#, no-wrap
msgid "B<STICKY >I<color-sequence>"
msgstr "B<STICKY >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:182
msgid "Specifies the color used for a directory with the sticky attribute set."
msgstr ""
"Задаёт цвет, используемый для файлов с установленным закрепляющим (sticky) "
"битом."

#. type: TP
#: man-pages/man5/dir_colors.5:182
#, no-wrap
msgid "B<STICKY_OTHER_WRITABLE >I<color-sequence>"
msgstr "B<STICKY_OTHER_WRITABLE >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:185
msgid ""
"Specifies the color used for an other-writable directory with the executable "
"attribute set."
msgstr ""
"Задаёт цвет, используемый для каталогов с установленным атрибутом выполнения "
"и доступный на запись другим."

#. type: Plain text
#: man-pages/man5/dir_colors.5:188
msgid "Synonym: B<OWT>."
msgstr "Синоним B<OWT>."

#. type: TP
#: man-pages/man5/dir_colors.5:188
#, no-wrap
msgid "B<OTHER_WRITABLE >I<color-sequence>"
msgstr "B<OTHER_WRITABLE >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:191
msgid ""
"Specifies the color used for an other-writable directory without the "
"executable attribute set."
msgstr ""
"Задаёт цвет, используемый для каталогов без установленного атрибута "
"выполнения и доступный на запись другим."

#. type: Plain text
#: man-pages/man5/dir_colors.5:194
msgid "Synonym: B<OWR>."
msgstr "Синоним B<OWR>."

#. type: TP
#: man-pages/man5/dir_colors.5:194
#, no-wrap
msgid "B<LEFTCODE >I<color-sequence>"
msgstr "B<LEFTCODE >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:199
msgid "Specifies the I<left code> for non-ISO\\ 6429 terminals (see below)."
msgstr "Задаёт I<левый код> для не-ISO\\ 6429 терминалов (см. ниже)."

#. type: Plain text
#: man-pages/man5/dir_colors.5:202
msgid "Synonym: B<LEFT>."
msgstr "Синоним B<LEFT>."

#. type: TP
#: man-pages/man5/dir_colors.5:202
#, no-wrap
msgid "B<RIGHTCODE >I<color-sequence>"
msgstr "B<RIGHTCODE >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:207
msgid "Specifies the I<right code> for non-ISO\\ 6429 terminals (see below)."
msgstr "Задаёт I<правый код> для не-ISO\\ 6429 терминалов (см. ниже)."

#. type: Plain text
#: man-pages/man5/dir_colors.5:210
msgid "Synonym: B<RIGHT>."
msgstr "Синоним B<RIGHT>."

#. type: TP
#: man-pages/man5/dir_colors.5:210
#, no-wrap
msgid "B<ENDCODE >I<color-sequence>"
msgstr "B<ENDCODE >I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:215
msgid "Specifies the I<end code> for non-ISO\\ 6429 terminals (see below)."
msgstr "Задаёт I<конечный код> для не-ISO\\ 6429 терминалов (см. ниже)."

#. type: Plain text
#: man-pages/man5/dir_colors.5:218
msgid "Synonym: B<END>."
msgstr "Синоним B<END>."

#. type: TP
#: man-pages/man5/dir_colors.5:218
#, no-wrap
msgid "B<*>I<extension> I<color-sequence>"
msgstr "B<*>I<расширение> I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:221
msgid "Specifies the color used for any file that ends in I<extension>."
msgstr ""
"Задаёт цвет, используемый для файлов, чьи имена заканчиваются на заданное "
"I<расширение>."

#. type: TP
#: man-pages/man5/dir_colors.5:221
#, no-wrap
msgid " B<.>I<extension> I<color-sequence>"
msgstr " B<.>I<расширение> I<цвет>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:234
msgid ""
"Same as B<*>.I<extension>.  Specifies the color used for any file that ends "
"in .I<extension>.  Note that the period is included in the extension, which "
"makes it impossible to specify an extension not starting with a period, such "
"as B<~> for B<emacs> backup files.  This form should be considered obsolete."
msgstr ""
"То же самое, что и B<*>.I<расширение>. Задаёт цвет, используемый для файлов, "
"чьи имена заканчиваются указанным .I<расширением>. Заметьте, что точка "
"входит в состав расширения, и из-за этого невозможно указать расширение, не "
"начинающееся с точки, например B<~> для резервных копий редактора B<emacs>. "
"Эта форма записи считается устаревшей."

#. type: SS
#: man-pages/man5/dir_colors.5:234
#, no-wrap
msgid "ISO 6429 (ANSI) color sequences"
msgstr "Цветовые последовательности ISO 6429 (ANSI)"

#. type: Plain text
#: man-pages/man5/dir_colors.5:242
msgid ""
"Most color-capable ASCII terminals today use ISO 6429 (ANSI) color "
"sequences, and many common terminals without color capability, including "
"B<xterm> and the widely used and cloned DEC VT100, will recognize ISO 6429 "
"color codes and harmlessly eliminate them from the output or emulate them.  "
"B<ls> uses ISO 6429 codes by default, assuming colorization is enabled."
msgstr ""
"Большинство цветных ASCII-терминалов в настоящее время используют цветовые "
"последовательности ISO 6429 (ANSI), а многие распространённые терминалы, не "
"поддерживающие цвет, включая B<xterm> и широко используемый и клонируемый "
"DEC VT100, распознают цветовые коды ISO 6429 и без последствий удаляют их из "
"выходного потока или же эмулируют их. B<ls> по умолчанию использует коды ISO "
"6429, если включена расцветка."

#. type: Plain text
#: man-pages/man5/dir_colors.5:246
msgid ""
"ISO 6429 color sequences are composed of sequences of numbers separated by "
"semicolons.  The most common codes are:"
msgstr ""
"Цветовые последовательности ISO 6429 представляют собой последовательность "
"чисел, разделённых точками с запятой. Самые распространенные коды:"

#. type: tbl table
#: man-pages/man5/dir_colors.5:249
#, no-wrap
msgid " 0"
msgstr " 0"

#. type: tbl table
#: man-pages/man5/dir_colors.5:249
#, no-wrap
msgid "to restore default color"
msgstr "восстановить цвет по умолчанию"

#. type: tbl table
#: man-pages/man5/dir_colors.5:250
#, no-wrap
msgid " 1"
msgstr " 1"

#. type: tbl table
#: man-pages/man5/dir_colors.5:250
#, no-wrap
msgid "for brighter colors"
msgstr "яркие цвета"

#. type: tbl table
#: man-pages/man5/dir_colors.5:251
#, no-wrap
msgid " 4"
msgstr " 4"

#. type: tbl table
#: man-pages/man5/dir_colors.5:251
#, no-wrap
msgid "for underlined text"
msgstr "подчёркнутый текст"

#. type: tbl table
#: man-pages/man5/dir_colors.5:252
#, no-wrap
msgid " 5"
msgstr " 5"

#. type: tbl table
#: man-pages/man5/dir_colors.5:252
#, no-wrap
msgid "for flashing text"
msgstr "мигающий текст"

#. type: tbl table
#: man-pages/man5/dir_colors.5:253
#, no-wrap
msgid "30"
msgstr "30"

#. type: tbl table
#: man-pages/man5/dir_colors.5:253
#, no-wrap
msgid "for black foreground"
msgstr "чёрные символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:254
#, no-wrap
msgid "31"
msgstr "31"

#. type: tbl table
#: man-pages/man5/dir_colors.5:254
#, no-wrap
msgid "for red foreground"
msgstr "красные символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:255
#, no-wrap
msgid "32"
msgstr "32"

#. type: tbl table
#: man-pages/man5/dir_colors.5:255
#, no-wrap
msgid "for green foreground"
msgstr "зелёные символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:256
#, no-wrap
msgid "33"
msgstr "33"

#. type: tbl table
#: man-pages/man5/dir_colors.5:256
#, no-wrap
msgid "for yellow (or brown) foreground"
msgstr "жёлтые (или коричневые) символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:257
#, no-wrap
msgid "34"
msgstr "34"

#. type: tbl table
#: man-pages/man5/dir_colors.5:257
#, no-wrap
msgid "for blue foreground"
msgstr "синие символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:258
#, no-wrap
msgid "35"
msgstr "35"

#. type: tbl table
#: man-pages/man5/dir_colors.5:258
#, no-wrap
msgid "for purple foreground"
msgstr "пурпурные символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:259
#, no-wrap
msgid "36"
msgstr "36"

#. type: tbl table
#: man-pages/man5/dir_colors.5:259
#, no-wrap
msgid "for cyan foreground"
msgstr "бирюзовые символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:260
#, no-wrap
msgid "37"
msgstr "37"

#. type: tbl table
#: man-pages/man5/dir_colors.5:260
#, no-wrap
msgid "for white (or gray) foreground"
msgstr "белые (или серые) символы"

#. type: tbl table
#: man-pages/man5/dir_colors.5:261
#, no-wrap
msgid "40"
msgstr "40"

#. type: tbl table
#: man-pages/man5/dir_colors.5:261
#, no-wrap
msgid "for black background"
msgstr "чёрный фон"

#. type: tbl table
#: man-pages/man5/dir_colors.5:262
#, no-wrap
msgid "41"
msgstr "41"

#. type: tbl table
#: man-pages/man5/dir_colors.5:262
#, no-wrap
msgid "for red background"
msgstr "красный фон"

#. type: tbl table
#: man-pages/man5/dir_colors.5:263
#, no-wrap
msgid "42"
msgstr "42"

#. type: tbl table
#: man-pages/man5/dir_colors.5:263
#, no-wrap
msgid "for green background"
msgstr "зелёный фон"

#. type: tbl table
#: man-pages/man5/dir_colors.5:264
#, no-wrap
msgid "43"
msgstr "43"

#. type: tbl table
#: man-pages/man5/dir_colors.5:264
#, no-wrap
msgid "for yellow (or brown) background"
msgstr "жёлтый (или коричневый) фон"

#. type: tbl table
#: man-pages/man5/dir_colors.5:265
#, no-wrap
msgid "44"
msgstr "44"

#. type: tbl table
#: man-pages/man5/dir_colors.5:265
#, no-wrap
msgid "for blue background"
msgstr "синий фон"

#. type: tbl table
#: man-pages/man5/dir_colors.5:266
#, no-wrap
msgid "45"
msgstr "45"

#. type: tbl table
#: man-pages/man5/dir_colors.5:266
#, no-wrap
msgid "for purple background"
msgstr "пурпурный фон"

#. type: tbl table
#: man-pages/man5/dir_colors.5:267
#, no-wrap
msgid "46"
msgstr "46"

#. type: tbl table
#: man-pages/man5/dir_colors.5:267
#, no-wrap
msgid "for cyan background"
msgstr "бирюзовый фон"

#. type: tbl table
#: man-pages/man5/dir_colors.5:268
#, no-wrap
msgid "47"
msgstr "47"

#. type: tbl table
#: man-pages/man5/dir_colors.5:268
#, no-wrap
msgid "for white (or gray) background"
msgstr "белый (или серый) фон"

#. type: Plain text
#: man-pages/man5/dir_colors.5:273
msgid "Not all commands will work on all systems or display devices."
msgstr ""
"Не все команды будут работать на любой системе или устройстве отображения."

#. type: Plain text
#: man-pages/man5/dir_colors.5:276
msgid "B<ls> uses the following defaults:"
msgstr "B<ls> использует следующие значения по умолчанию:"

#. type: tbl table
#: man-pages/man5/dir_colors.5:278
#, no-wrap
msgid "NORMAL"
msgstr "NORMAL"

#. type: tbl table
#: man-pages/man5/dir_colors.5:278 man-pages/man5/dir_colors.5:279
#, no-wrap
msgid "0       "
msgstr "0       "

#. type: tbl table
#: man-pages/man5/dir_colors.5:278
#, no-wrap
msgid "Normal (nonfilename) text"
msgstr "обычный (не имя файла) текст"

#. type: tbl table
#: man-pages/man5/dir_colors.5:279
#, no-wrap
msgid "FILE"
msgstr "FILE"

#. type: tbl table
#: man-pages/man5/dir_colors.5:279
#, no-wrap
msgid "Regular file"
msgstr "обычный файл"

#. type: tbl table
#: man-pages/man5/dir_colors.5:280
#, no-wrap
msgid "DIR"
msgstr "DIR"

#. type: tbl table
#: man-pages/man5/dir_colors.5:280
#, no-wrap
msgid "32      "
msgstr "32      "

#. type: tbl table
#: man-pages/man5/dir_colors.5:280
#, no-wrap
msgid "Directory"
msgstr "каталог"

#. type: tbl table
#: man-pages/man5/dir_colors.5:281
#, no-wrap
msgid "LINK"
msgstr "LINK"

#. type: tbl table
#: man-pages/man5/dir_colors.5:281
#, no-wrap
msgid "36      "
msgstr "36      "

#. type: tbl table
#: man-pages/man5/dir_colors.5:281
#, no-wrap
msgid "Symbolic link"
msgstr "символьная ссылка"

#. type: tbl table
#: man-pages/man5/dir_colors.5:282
#, no-wrap
msgid "ORPHAN"
msgstr "ORPHAN"

#. type: tbl table
#: man-pages/man5/dir_colors.5:282 man-pages/man5/dir_colors.5:283
#, no-wrap
msgid "undefined"
msgstr "не определено"

#. type: tbl table
#: man-pages/man5/dir_colors.5:282
#, no-wrap
msgid "Orphaned symbolic link"
msgstr "сломанная символьная ссылка"

#. type: tbl table
#: man-pages/man5/dir_colors.5:283
#, no-wrap
msgid "MISSING"
msgstr "MISSING"

#. type: tbl table
#: man-pages/man5/dir_colors.5:283
#, no-wrap
msgid "Missing file"
msgstr "отсутствующий файл"

#. type: tbl table
#: man-pages/man5/dir_colors.5:284
#, no-wrap
msgid "FIFO"
msgstr "FIFO"

#. type: tbl table
#: man-pages/man5/dir_colors.5:284
#, no-wrap
msgid "31      "
msgstr "31      "

#. type: tbl table
#: man-pages/man5/dir_colors.5:284
#, no-wrap
msgid "Named pipe (FIFO)"
msgstr "именованный канал (FIFO)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:285
#, no-wrap
msgid "SOCK"
msgstr "SOCK"

#. type: tbl table
#: man-pages/man5/dir_colors.5:285
#, no-wrap
msgid "33      "
msgstr "33      "

#. type: tbl table
#: man-pages/man5/dir_colors.5:285
#, no-wrap
msgid "Socket"
msgstr "сокет"

#. type: tbl table
#: man-pages/man5/dir_colors.5:286
#, no-wrap
msgid "BLK"
msgstr "BLK"

#. type: tbl table
#: man-pages/man5/dir_colors.5:286 man-pages/man5/dir_colors.5:287
#, no-wrap
msgid "44;37   "
msgstr "44;37   "

#. type: tbl table
#: man-pages/man5/dir_colors.5:286
#, no-wrap
msgid "Block device"
msgstr "блочное устройство"

#. type: tbl table
#: man-pages/man5/dir_colors.5:287
#, no-wrap
msgid "CHR"
msgstr "CHR"

#. type: tbl table
#: man-pages/man5/dir_colors.5:287
#, no-wrap
msgid "Character device"
msgstr "символьное устройство"

#. type: tbl table
#: man-pages/man5/dir_colors.5:288
#, no-wrap
msgid "EXEC"
msgstr "EXEC"

#. type: tbl table
#: man-pages/man5/dir_colors.5:288
#, no-wrap
msgid "35      "
msgstr "35      "

#. type: tbl table
#: man-pages/man5/dir_colors.5:288
#, no-wrap
msgid "Executable file"
msgstr "исполняемый файл"

#. type: Plain text
#: man-pages/man5/dir_colors.5:300
msgid ""
"A few terminal programs do not recognize the default properly.  If all text "
"gets colorized after you do a directory listing, change the B<NORMAL> and "
"B<FILE> codes to the numerical codes for your normal foreground and "
"background colors."
msgstr ""
"Некоторые терминальные программы неправильно распознают настройки цвета по "
"умолчанию. Если весь текст становится расцвеченным после того, как вы "
"просматриваете листинг каталога, измените коды B<NORMAL> и B<FILE> на "
"цифровые коды для нормального цвета текста и фона."

#. type: SS
#: man-pages/man5/dir_colors.5:300
#, no-wrap
msgid "Other terminal types (advanced configuration)"
msgstr "Другие типы терминалов (расширенная настройка)"

#. type: Plain text
#: man-pages/man5/dir_colors.5:310
msgid ""
"If you have a color-capable (or otherwise highlighting) terminal (or "
"printer!) which uses a different set of codes, you can still generate a "
"suitable setup.  To do so, you will have to use the B<LEFTCODE>, "
"B<RIGHTCODE>, and B<ENDCODE> definitions."
msgstr ""
"Если у вас есть терминал (или принтер!) с поддержкой цвета (или другими "
"возможностями выделения), который использует другой набор кодов, вы всё "
"равно сможете создать подходящие настройки. Для этого нужно использовать "
"операторы B<LEFTCODE>, B<RIGHTCODE> и B<ENDCODE>."

#. type: Plain text
#: man-pages/man5/dir_colors.5:333
msgid ""
"When writing out a filename, B<ls> generates the following output sequence: "
"B<LEFTCODE> I<typecode> B<RIGHTCODE> I<filename> B<ENDCODE>, where the "
"I<typecode> is the color sequence that depends on the type or name of file.  "
"If the B<ENDCODE> is undefined, the sequence B<LEFTCODE NORMAL RIGHTCODE> "
"will be used instead.  The purpose of the left- and rightcodes is merely to "
"reduce the amount of typing necessary (and to hide ugly escape codes away "
"from the user).  If they are not appropriate for your terminal, you can "
"eliminate them by specifying the respective keyword on a line by itself."
msgstr ""
"При выводе имени файла B<ls> генерирует такую последовательность: "
"B<LEFTCODE> I<кода_типа> B<RIGHTCODE> I<имя_файла> B<ENDCODE>, где "
"I<код_типа> \\(em цветовая последовательность, зависящая от типа или имени "
"файла. Если B<ENDCODE> не определён, то вместо него будет использоваться "
"последовательность B<LEFTCODE NORMAL RIGHTCODE>. Предназначением левого "
"(LEFTCODE) и правого (RIGHTCODE) кодов является сокращение количества "
"информации, которую нужно набирать (а также спрятать уродливые escape-"
"последовательности от пользователя). Если они не подходят для вашего "
"терминала, их можно выключить, поместив соответствующее ключевое слово на "
"отдельной строке."

#. type: Plain text
#: man-pages/man5/dir_colors.5:346
msgid ""
"B<NOTE:> If the B<ENDCODE> is defined in the global section of the setup "
"file, it I<cannot> be undefined in a terminal-specific section of the file.  "
"This means any B<NORMAL> definition will have no effect.  A different "
"B<ENDCODE> can, however, be specified, which would have the same effect."
msgstr ""
"B<ЗАМЕЧАНИЕ:> Если B<ENDCODE> определён в глобальном разделе файла настроек, "
"то его I<нельзя> переопределить в разделе определённого терминала. Это "
"означает, что все определения B<NORMAL> не приведут ни к какому результату. "
"Однако, можно использовать различные B<ENDCODE>, что и приведёт к нужному "
"результату."

#. type: SS
#: man-pages/man5/dir_colors.5:346
#, no-wrap
msgid "Escape sequences"
msgstr "Экранированные последовательности"

#. type: Plain text
#: man-pages/man5/dir_colors.5:353
msgid ""
"To specify control- or blank characters in the color sequences or filename "
"extensions, either C-style \\e-escaped notation or B<stty>-style ^-notation "
"can be used.  The C-style notation includes the following characters:"
msgstr ""
"Для того, чтобы указать в цветовых последовательностях или расширениях имён "
"файлов управляющие символы или пробелы, можно использовать либо нотацию в "
"стиле языка C с помощью обратной косой черты, либо нотацию в стиле программы "
"B<stty> с помощью символа ^. Нотация в стиле языка C включает в себя такие "
"символы:"

#. type: tbl table
#: man-pages/man5/dir_colors.5:356
#, no-wrap
msgid "\\ea"
msgstr "\\ea"

#. type: tbl table
#: man-pages/man5/dir_colors.5:356
#, no-wrap
msgid "Bell (ASCII 7)"
msgstr "Звуковой сигнал (ASCII 7)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:357
#, no-wrap
msgid "\\eb"
msgstr "\\eb"

#. type: tbl table
#: man-pages/man5/dir_colors.5:357
#, no-wrap
msgid "Backspace (ASCII 8)"
msgstr "Забой (ASCII 8)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:358
#, no-wrap
msgid "\\ee"
msgstr "\\ee"

#. type: tbl table
#: man-pages/man5/dir_colors.5:358
#, no-wrap
msgid "Escape (ASCII 27)"
msgstr "Экранирующий символ (ASCII 27)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:359
#, no-wrap
msgid "\\ef"
msgstr "\\ef"

#. type: tbl table
#: man-pages/man5/dir_colors.5:359
#, no-wrap
msgid "Form feed (ASCII 12)"
msgstr "Прогон страницы (ASCII 12)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:360
#, no-wrap
msgid "\\en"
msgstr "\\en"

#. type: tbl table
#: man-pages/man5/dir_colors.5:360
#, no-wrap
msgid "Newline (ASCII 10)"
msgstr "Перевод строки (ASCII 10)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:361
#, no-wrap
msgid "\\er"
msgstr "\\er"

#. type: tbl table
#: man-pages/man5/dir_colors.5:361
#, no-wrap
msgid "Carriage Return (ASCII 13)"
msgstr "Возврат каретки (ASCII 13)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:362
#, no-wrap
msgid "\\et"
msgstr "\\et"

#. type: tbl table
#: man-pages/man5/dir_colors.5:362
#, no-wrap
msgid "Tab (ASCII 9)"
msgstr "Табуляция (ASCII 9)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:363
#, no-wrap
msgid "\\ev"
msgstr "\\ev"

#. type: tbl table
#: man-pages/man5/dir_colors.5:363
#, no-wrap
msgid "Vertical Tab (ASCII 11)"
msgstr "Вертикальная табуляция (ASCII 11)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:364
#, no-wrap
msgid "\\e?"
msgstr "\\e?"

#. type: tbl table
#: man-pages/man5/dir_colors.5:364
#, no-wrap
msgid "Delete (ASCII 127)"
msgstr "Удаление (ASCII 127)"

#. type: tbl table
#: man-pages/man5/dir_colors.5:365
#, no-wrap
msgid "\\eI<nnn>"
msgstr "\\eI<nnn>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:365
#, no-wrap
msgid "I<Any character (octal notation)>"
msgstr "I<Любой символ (восьмеричная запись)>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:366
#, no-wrap
msgid "I<\\exnnn>"
msgstr "I<\\exnnn>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:366
#, no-wrap
msgid "I<Any character (hexadecimal notation)>"
msgstr "I<Любой символ (шестнадцатеричная запись)>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:367
#, no-wrap
msgid "I<\\e_>"
msgstr "I<\\e_>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:367
#, no-wrap
msgid "I<Space>"
msgstr "I<Пробел>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:368
#, no-wrap
msgid "I<\\e\\e>"
msgstr "I<\\e\\e>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:368
#, no-wrap
msgid "I<Backslash (\\e)>"
msgstr "I<Обратная косая черта (\\e)>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:369
#, no-wrap
msgid "I<\\e^>"
msgstr "I<\\e^>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:369
#, no-wrap
msgid "I<Caret (^)>"
msgstr "I<Крышка (^)>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:370
#, no-wrap
msgid "I<\\e#>"
msgstr "I<\\e#>"

#. type: tbl table
#: man-pages/man5/dir_colors.5:370
#, no-wrap
msgid "I<Hash mark (#)>"
msgstr "I<Знак решетки (#)>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:377
msgid ""
"Note that escapes are necessary to enter a space, backslash, caret, or any "
"control character anywhere in the string, as well as a hash mark as the "
"first character."
msgstr ""
"Заметьте, что экранирование необходимо, чтобы использовать пробел, обратную "
"косую черту, крышку или управляющие символы в любом месте строки, а также "
"символ решётки в качестве первого символа в строке."

#. type: TP
#: man-pages/man5/dir_colors.5:378
#, no-wrap
msgid "I</etc/DIR_COLORS>"
msgstr "I</etc/DIR_COLORS>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:381
msgid "System-wide configuration file."
msgstr "Общесистемный файл настройки"

#. type: TP
#: man-pages/man5/dir_colors.5:381
#, no-wrap
msgid "I<~/.dir_colors>"
msgstr "I<~/.dir_colors>"

#. type: Plain text
#: man-pages/man5/dir_colors.5:384
msgid "Per-user configuration file."
msgstr "Пользовательский файл настройки"

#. type: Plain text
#: man-pages/man5/dir_colors.5:389
msgid ""
"This page describes the B<dir_colors> file format as used in the "
"fileutils-4.1 package; other versions may differ slightly."
msgstr ""
"Эта страница описывает формат файла B<dir_colors>, который можно найти в "
"пакете fileutils-4.1; другие версии могут немного отличаться."

#. type: Plain text
#: man-pages/man5/dir_colors.5:395
msgid ""
"The default B<LEFTCODE> and B<RIGHTCODE> definitions, which are used by ISO "
"6429 terminals are:"
msgstr ""
"Значение B<LEFTCODE> и B<RIGHTCODE>, используемые по умолчанию терминалами "
"ISO 6429:"

#. type: tbl table
#: man-pages/man5/dir_colors.5:398
#, no-wrap
msgid "LEFTCODE"
msgstr "LEFTCODE"

#. type: tbl table
#: man-pages/man5/dir_colors.5:398
#, no-wrap
msgid "\\ee["
msgstr "\\ee["

#. type: tbl table
#: man-pages/man5/dir_colors.5:399
#, no-wrap
msgid "RIGHTCODE"
msgstr "RIGHTCODE"

#. type: tbl table
#: man-pages/man5/dir_colors.5:399
#, no-wrap
msgid "m"
msgstr "m"

#. type: Plain text
#: man-pages/man5/dir_colors.5:406
msgid "The default B<ENDCODE> is undefined."
msgstr "По умолчанию значение B<ENDCODE> не определено."

#. type: Plain text
#: man-pages/man5/dir_colors.5:410
msgid "B<dircolors>(1), B<ls>(1), B<stty>(1), B<xterm>(1)"
msgstr "B<dircolors>(1), B<ls>(1), B<stty>(1), B<xterm>(1)"

#. type: TH
#: man-pages/man3/des_crypt.3:14
#, no-wrap
msgid "DES_CRYPT"
msgstr "DES_CRYPT"

#. type: Plain text
#: man-pages/man3/des_crypt.3:18
msgid ""
"des_crypt, ecb_crypt, cbc_crypt, des_setparity, DES_FAILED - fast DES "
"encryption"
msgstr ""
"des_crypt, ecb_crypt, cbc_crypt, des_setparity, DES_FAILED - быстрое "
"шифрование DES"

#.  Sun version
#.  .B #include <des_crypt.h>
#. type: Plain text
#: man-pages/man3/des_crypt.3:23
#, no-wrap
msgid "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/des_crypt.3:26
#, no-wrap
msgid ""
"B<int ecb_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<);>\n"
msgstr ""
"B<int ecb_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/des_crypt.3:29
#, no-wrap
msgid ""
"B<int cbc_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<, char *>I<ivec>B<);>\n"
msgstr ""
"B<int cbc_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<, char *>I<ivec>B<);>\n"

#. type: Plain text
#: man-pages/man3/des_crypt.3:31
#, no-wrap
msgid "B<void des_setparity(char *>I<key>B<);>\n"
msgstr "B<void des_setparity(char *>I<key>B<);>\n"

#. type: Plain text
#: man-pages/man3/des_crypt.3:33
#, no-wrap
msgid "B<int DES_FAILED(int >I<status>B<);>\n"
msgstr "B<int DES_FAILED(int >I<status>B<);>\n"

#. type: Plain text
#: man-pages/man3/des_crypt.3:63
msgid ""
"B<ecb_crypt>()  and B<cbc_crypt>()  implement the NBS DES (Data Encryption "
"Standard).  These routines are faster and more general purpose than "
"B<crypt>(3).  They also are able to utilize DES hardware if it is "
"available.  B<ecb_crypt>()  encrypts in ECB (Electronic Code Book)  mode, "
"which encrypts blocks of data independently.  B<cbc_crypt>()  encrypts in "
"CBC (Cipher Block Chaining)  mode, which chains together successive blocks.  "
"CBC mode protects against insertions, deletions and substitutions of "
"blocks.  Also, regularities in the clear text will not appear in the cipher "
"text."
msgstr ""
"В функциях B<ecb_crypt>() и B<cbc_crypt>() реализован стандарт шифрования "
"данных NBS DES (Data Encryption Standard). Они более быстры и имеют более "
"широкое предназначение, чем B<crypt>(3). Также они могут использовать (при "
"наличии) оборудование DES. Функция B<ecb_crypt>() шифрует данные в режиме "
"ECB (Electronic Code Book), при котором блоки данных шифруются независимо "
"друг от друга. Функция B<cbc_crypt>() шифрует данные в режиме CBC (Cipher "
"Block Chaining), при котором вместе связываются рядом стоящие блоки. Режим "
"CBC защищает от вставки, удаления или подмены блоков. Также повторяющиеся "
"отрезки простого текста не появятся в зашифрованном в таком режиме коде."

#. type: Plain text
#: man-pages/man3/des_crypt.3:106
msgid ""
"Here is how to use these routines.  The first argument, I<key>, is the 8-"
"byte encryption key with parity.  To set the key's parity, which for DES is "
"in the low bit of each byte, use B<des_setparity>().  The second argument, "
"I<data>, contains the data to be encrypted or decrypted.  The third "
"argument, I<datalen>, is the length in bytes of I<data>, which must be a "
"multiple of 8.  The fourth argument, I<mode>, is formed by ORing together "
"some things.  For the encryption direction OR in either B<DES_ENCRYPT> or "
"B<DES_DECRYPT>.  For software versus hardware encryption, OR in either "
"B<DES_HW> or B<DES_SW>.  If B<DES_HW> is specified, and there is no "
"hardware, then the encryption is performed in software and the routine "
"returns B<DESERR_NOHWDEVICE>.  For B<cbc_crypt>(), the argument I<ivec> is "
"the 8-byte initialization vector for the chaining.  It is updated to the "
"next initialization vector upon return."
msgstr ""
"Рассмотрим применение этих функций. Первый параметр, I<key>, является 8-"
"байтным ключом шифрования с чётностью. Для установки чётности ключа, которая "
"для DES находится в младшем бите каждого байта, используйте "
"B<des_setparity>. Второй параметр, I<data>, содержит данные для шифрования "
"или расшифровки. Третий параметр, I<datalen>, задаёт длину блока данных "
"I<data> в байтах, длина должна быть кратна 8. Четвертый параметр, I<mode>, "
"формируется через логическое сложение (OR) нескольких вещей. Чтобы указать "
"тип операции добавляется либо B<DES_ENCRYPT>, либо B<DES_DECRYPT>. Чтобы "
"применить программное шифрование или использовать специальное оборудование, "
"добавляется либо B<DES_HW>, либо B<DES_SW>. Если указано B<DES_HW> и "
"оборудование не обнаружено, то шифрование выполняется в программном режиме, "
"а функция возвращает B<DESERR_NOHWDEVICE>. В B<cbc_crypt>() параметр I<ivec> "
"используется как 8-байтовый вектор инициализации для шифрования цепочек. Он "
"обновляется на следующий вектор инициализации при возврате."

#. type: TP
#: man-pages/man3/des_crypt.3:108
#, no-wrap
msgid "B<DESERR_NONE>"
msgstr "B<DESERR_NONE>"

#. type: Plain text
#: man-pages/man3/des_crypt.3:111
msgid "No error."
msgstr "Нет ошибок."

#. type: TP
#: man-pages/man3/des_crypt.3:111
#, no-wrap
msgid "B<DESERR_NOHWDEVICE>"
msgstr "B<DESERR_NOHWDEVICE>"

#. type: Plain text
#: man-pages/man3/des_crypt.3:114
msgid ""
"Encryption succeeded, but done in software instead of the requested hardware."
msgstr ""
"Шифрование выполнено, но использовался программный метод, так как не было "
"обнаружено запрошенное оборудование шифрования."

#. type: TP
#: man-pages/man3/des_crypt.3:114
#, no-wrap
msgid "B<DESERR_HWERROR>"
msgstr "B<DESERR_HWERROR>"

#. type: Plain text
#: man-pages/man3/des_crypt.3:117
msgid "An error occurred in the hardware or driver."
msgstr "Ошибка в оборудовании или драйвере."

#. type: TP
#: man-pages/man3/des_crypt.3:117
#, no-wrap
msgid "B<DESERR_BADPARAM>"
msgstr "B<DESERR_BADPARAM>"

#. type: Plain text
#: man-pages/man3/des_crypt.3:120
msgid "Bad argument to routine."
msgstr "Некорректный параметр функции."

#.  .BR DES_FAILED\c
#.  .BR ( stat )
#.  So far the Sun page
#.  Some additions - aeb
#. type: Plain text
#: man-pages/man3/des_crypt.3:131
msgid ""
"Given a result status I<stat>, the macro B<DES_FAILED(>I<stat>B<)> is false "
"only for the first two statuses."
msgstr ""
"Указывая итоговое состояние I<stat>, значение макроса "
"B<DES_FAILED(>I<stat>B<)> будет ложно только для первых двух состояний."

#. type: Plain text
#: man-pages/man3/des_crypt.3:134
msgid "These functions are present in glibc 2.1 and later."
msgstr "Эти функции присутствуют в glibc 2.1 и более новых."

#. type: Plain text
#: man-pages/man3/des_crypt.3:145
msgid ""
"Because they employ the DES block cipher, which is no longer considered "
"secure, B<ecb_crypt>(), B<ecb_crypt>(), B<crypt_r>(), and "
"B<des_setparity>()  were removed in glibc 2.28.  Applications should switch "
"to a modern cryptography library, such as B<libgcrypt>."
msgstr ""
"Функции B<ecb_crypt>(), B<ecb_crypt>(), B<crypt_r>() и B<des_setparity>() "
"удалены из glibc 2.28, так как они используют блочный шифр DES, который "
"теперь считается небезопасным. В приложениях следует использовать "
"современную библиотеку шифрования, например B<libgcrypt>."

#. type: SH
#: man-pages/man3/des_crypt.3:145
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man3/des_crypt.3:148
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man3/des_crypt.3:152
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man3/des_crypt.3:152
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man3/des_crypt.3:152
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man3/des_crypt.3:157
#, no-wrap
msgid ""
"B<ecb_crypt>(),\n"
"B<cbc_crypt>(),\n"
"B<des_setparity>()"
msgstr ""
"B<ecb_crypt>(),\n"
"B<cbc_crypt>(),\n"
"B<des_setparity>()"

#. type: tbl table
#: man-pages/man3/des_crypt.3:157
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man3/des_crypt.3:157
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: man-pages/man3/des_crypt.3:162
msgid "4.3BSD.  Not in POSIX.1."
msgstr "4.3BSD. Отсутствует в POSIX-1."

#. type: Plain text
#: man-pages/man3/des_crypt.3:165
msgid "B<des>(1), B<crypt>(3), B<xcrypt>(3)"
msgstr "B<des>(1), B<crypt>(3), B<xcrypt>(3)"

#. type: TH
#: man-pages/man3/drand48_r.3:27
#, no-wrap
msgid "DRAND48_R"
msgstr "DRAND48_R"

#. type: Plain text
#: man-pages/man3/drand48_r.3:32
msgid ""
"drand48_r, erand48_r, lrand48_r, nrand48_r, mrand48_r, jrand48_r, srand48_r, "
"seed48_r, lcong48_r - generate uniformly distributed pseudo-random numbers "
"reentrantly"
msgstr ""
"drand48_r, erand48_r, lrand48_r, nrand48_r, mrand48_r, jrand48_r, srand48_r, "
"seed48_r, lcong48_r - генерация равномерно распределённых псевдослучайных "
"чисел реентерабельным способом"

#. type: Plain text
#: man-pages/man3/drand48_r.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:37
#, no-wrap
msgid "B<int drand48_r(struct drand48_data *>I<buffer>B<, double *>I<result>B<);>\n"
msgstr "B<int drand48_r(struct drand48_data *>I<buffer>B<, double *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:40
#, no-wrap
msgid ""
"B<int erand48_r(unsigned short >I<xsubi>B<[3]>I<,>\n"
"B<              struct drand48_data *>I<buffer>B<, double *>I<result>B<);>\n"
msgstr ""
"B<int erand48_r(unsigned short >I<xsubi>B<[3]>I<,>\n"
"B<              struct drand48_data *>I<buffer>B<, double *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:42
#, no-wrap
msgid "B<int lrand48_r(struct drand48_data *>I<buffer>B<, long int *>I<result>B<);>\n"
msgstr "B<int lrand48_r(struct drand48_data *>I<buffer>B<, long int *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:45
#, no-wrap
msgid ""
"B<int nrand48_r(unsigned short int >I<xsubi[3]>B<,>\n"
"B<              struct drand48_data *>I<buffer>B<, long int *>I<result>B<);>\n"
msgstr ""
"B<int nrand48_r(unsigned short int >I<xsubi[3]>B<,>\n"
"B<              struct drand48_data *>I<buffer>B<, long int *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:47
#, no-wrap
msgid "B<int mrand48_r(struct drand48_data *>I<buffer>B<,long int *>I<result>B<);>\n"
msgstr "B<int mrand48_r(struct drand48_data *>I<buffer>B<,long int *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:50
#, no-wrap
msgid ""
"B<int jrand48_r(unsigned short int >I<xsubi[3]>B<,>\n"
"B<              struct drand48_data *>I<buffer>B<, long int *>I<result>B<);>\n"
msgstr ""
"B<int jrand48_r(unsigned short int >I<xsubi[3]>B<,>\n"
"B<              struct drand48_data *>I<buffer>B<, long int *>I<result>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:52
#, no-wrap
msgid "B<int srand48_r(long int >I<seedval>B<, struct drand48_data *>I<buffer>B<);>\n"
msgstr "B<int srand48_r(long int >I<seedval>B<, struct drand48_data *>I<buffer>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:55
#, no-wrap
msgid ""
"B<int seed48_r(unsigned short int >I<seed16v[3]>B<,>\n"
"B<             struct drand48_data *>I<buffer>B<);>\n"
msgstr ""
"B<int seed48_r(unsigned short int >I<seed16v[3]>B<,>\n"
"B<             struct drand48_data *>I<buffer>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:58
#, no-wrap
msgid ""
"B<int lcong48_r(unsigned short int >I<param[7]>B<,>\n"
"B<              struct drand48_data *>I<buffer>B<);>\n"
msgstr ""
"B<int lcong48_r(unsigned short int >I<param[7]>B<,>\n"
"B<              struct drand48_data *>I<buffer>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:63
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. "
"B<feature_test_macros>(7)):"

#.  .BR drand48_r (),
#.  .BR erand48_r (),
#.  .BR lrand48_r (),
#.  .BR nrand48_r (),
#.  .BR mrand48_r (),
#.  .BR jrand48_r (),
#.  .BR srand48_r (),
#.  .BR seed48_r (),
#.  .BR lcong48_r ():
#. type: Plain text
#: man-pages/man3/drand48_r.3:78
#, no-wrap
msgid ""
"All functions shown above:\n"
"    /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"        || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"Для всех вышеуказанных функций:\n"
"    /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"        || /* в версии glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/drand48_r.3:85
msgid ""
"These functions are the reentrant analogs of the functions described in "
"B<drand48>(3).  Instead of modifying the global random generator state, they "
"use the supplied data I<buffer>."
msgstr ""
"Данные функции являются реентерабельными аналогами функций, описанных в "
"B<drand48>(3). Вместо изменения состояния глобального генератора "
"произвольных чисел, в них используется передаваемый буфер данных I<buffer>."

#. type: Plain text
#: man-pages/man3/drand48_r.3:92
msgid ""
"Before the first use, this struct must be initialized, for example, by "
"filling it with zeros, or by calling one of the functions B<srand48_r>(), "
"B<seed48_r>(), or B<lcong48_r>()."
msgstr ""
"Перед первым использованием эта структура должна быть инициализирована, "
"например, заполнена нулями или посредством вызова функции B<srand48_r>(), "
"B<seed48_r>() или B<lcong48_r>()."

#. type: Plain text
#: man-pages/man3/drand48_r.3:94
msgid "The return value is 0."
msgstr "Возвращаемое значение равно 0."

#. type: tbl table
#: man-pages/man3/drand48_r.3:113
#, no-wrap
msgid ""
"B<drand48_r>(),\n"
"B<erand48_r>(),\n"
"B<lrand48_r>(),\n"
"B<nrand48_r>(),\n"
"B<mrand48_r>(),\n"
"B<jrand48_r>(),\n"
"B<srand48_r>(),\n"
"B<seed48_r>(),\n"
"B<lcong48_r>()"
msgstr ""
"B<drand48_r>(),\n"
"B<erand48_r>(),\n"
"B<lrand48_r>(),\n"
"B<nrand48_r>(),\n"
"B<mrand48_r>(),\n"
"B<jrand48_r>(),\n"
"B<srand48_r>(),\n"
"B<seed48_r>(),\n"
"B<lcong48_r>()"

#. type: tbl table
#: man-pages/man3/drand48_r.3:113
#, no-wrap
msgid "MT-Safe race:buffer"
msgstr "MT-Safe race:buffer"

#. type: Plain text
#: man-pages/man3/drand48_r.3:118
msgid "These functions are GNU extensions and are not portable."
msgstr "Эти функции являются расширениями GNU и не переносимы."

#. type: Plain text
#: man-pages/man3/drand48_r.3:121
msgid "B<drand48>(3), B<rand>(3), B<random>(3)"
msgstr "B<drand48>(3), B<rand>(3), B<random>(3)"

#. type: TH
#: man-pages/man3/daemon.3:36
#, no-wrap
msgid "DAEMON"
msgstr "DAEMON"

#. type: TH
#: man-pages/man3/daemon.3:36
#, no-wrap
msgid "2017-11-26"
msgstr "2017-11-26"

#. type: Plain text
#: man-pages/man3/daemon.3:39
msgid "daemon - run in the background"
msgstr "daemon - выполнение в фоновом режиме"

#. type: Plain text
#: man-pages/man3/daemon.3:41
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man3/daemon.3:43
msgid "B<int daemon(int >I<nochdir>B<, int >I<noclose>B<);>"
msgstr "B<int daemon(int >I<nochdir>B<, int >I<noclose>B<);>"

#. type: Plain text
#: man-pages/man3/daemon.3:50
msgid "B<daemon>():"
msgstr "B<daemon>():"

#.              commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: man-pages/man3/daemon.3:58
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""
"    начиная с glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    до glibc 2.19, включительно:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"

#. type: Plain text
#: man-pages/man3/daemon.3:64
msgid ""
"The B<daemon>()  function is for programs wishing to detach themselves from "
"the controlling terminal and run in the background as system daemons."
msgstr ""
"Функция B<daemon>() необходима для того, чтобы отключить программу от "
"управляющего терминала и запустить её в фоновом режиме подобно тому, как "
"выполняются системные службы."

#. type: Plain text
#: man-pages/man3/daemon.3:72
msgid ""
"If I<nochdir> is zero, B<daemon>()  changes the process's current working "
"directory to the root directory (\"/\"); otherwise, the current working "
"directory is left unchanged."
msgstr ""
"Если аргумент I<nochdir> равен нулю, то B<daemon>() изменяет текущий рабочий "
"каталог процесса на корневой («/»); в противном случае текущий рабочий "
"каталог не изменяется."

#. type: Plain text
#: man-pages/man3/daemon.3:81
msgid ""
"If I<noclose> is zero, B<daemon>()  redirects standard input, standard "
"output and standard error to I</dev/null>; otherwise, no changes are made to "
"these file descriptors."
msgstr ""
"Если аргумент I<noclose> равен нулю, то B<daemon>() перенаправляет "
"стандартный поток ввода, вывода и ошибок в I</dev/null>;  в противном случае "
"данные файловые дескрипторы не изменяется."

#.  not .IR in order not to underline _
#. type: Plain text
#: man-pages/man3/daemon.3:99
msgid ""
"(This function forks, and if the B<fork>(2)  succeeds, the parent calls "
"B<_exit>(2), so that further errors are seen by the child only.)  On success "
"B<daemon>()  returns zero.  If an error occurs, B<daemon>()  returns -1 and "
"sets I<errno> to any of the errors specified for the B<fork>(2)  and "
"B<setsid>(2)."
msgstr ""
"Эта функция порождает новый процесс и, если B<fork>(2) завершается без "
"ошибок, родительский процесс вызывает B<_exit>(2), чтобы дальнейшие ошибки "
"воспринимались только дочерним процессом. В случае успешного выполнения "
"B<daemon>() возвращается ноль. Если возникла ошибка, то B<daemon>() "
"возвращает -1 и присваивает глобальной переменной I<errno> одно из значений, "
"указанных для B<fork>(2) и B<setsid>(2)."

#. type: tbl table
#: man-pages/man3/daemon.3:109
#, no-wrap
msgid "B<daemon>()"
msgstr "B<daemon>()"

#. type: Plain text
#: man-pages/man3/daemon.3:117
msgid ""
"Not in POSIX.1.  A similar function appears on the BSDs.  The B<daemon>()  "
"function first appeared in 4.4BSD."
msgstr ""
"Отсутствует в POSIX.1. Подобная функция есть в BSD. Впервые функция "
"B<daemon>() появилась в 4.4BSD."

#. type: Plain text
#: man-pages/man3/daemon.3:125
msgid ""
"The glibc implementation can also return -1 when I</dev/null> exists but is "
"not a character device with the expected major and minor numbers.  In this "
"case, I<errno> need not be set."
msgstr ""
"Реализация в glibc может также возвращать -1 в случаях, когда I</dev/null> "
"существует, но не является файлом символьного устройства с ожидаемыми "
"основным и вспомогательным номерами. В этом случае нет необходимости "
"устанавливать I<errno>."

#.  FIXME . https://sourceware.org/bugzilla/show_bug.cgi?id=19144
#.  Tested using a program that uses daemon() and then opens an
#.  otherwise unused console device (/dev/ttyN) that does not
#.  have an associated getty process.
#. type: Plain text
#: man-pages/man3/daemon.3:145
msgid ""
"The GNU C library implementation of this function was taken from BSD, and "
"does not employ the double-fork technique (i.e., B<fork>(2), B<setsid>(2), "
"B<fork>(2))  that is necessary to ensure that the resulting daemon process "
"is not a session leader.  Instead, the resulting daemon I<is> a session "
"leader.  On systems that follow System V semantics (e.g., Linux), this means "
"that if the daemon opens a terminal that is not already a controlling "
"terminal for another session, then that terminal will inadvertently become "
"the controlling terminal for the daemon."
msgstr ""
"Для библиотеки GNU C реализация этой функции была взята из BSD, и в ней не "
"применяется техника двойного fork (т. е., B<fork>(2), B<setsid>(2), "
"B<fork>(2)), поэтому необходимо проверить, что полученный процесс службы не "
"является лидером сеанса. Вместо этого полученная служба I<является> лидером "
"сеанса. В системах, следующих семантике System V (например, Linux), это "
"означает, что если служба открывает терминал, которой пока не является "
"управляющим для другого сеанса, то этот терминал непреднамеренно станет "
"управляющим терминалом для службы."

#. type: Plain text
#: man-pages/man3/daemon.3:149
msgid "B<fork>(2), B<setsid>(2), B<daemon>(7), B<logrotate>(8)"
msgstr "B<fork>(2), B<setsid>(2), B<daemon>(7), B<logrotate>(8)"

#. type: TH
#: man-pages/man3/dl_iterate_phdr.3:25
#, no-wrap
msgid "DL_ITERATE_PHDR"
msgstr "DL_ITERATE_PHDR"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:28
msgid "dl_iterate_phdr - walk through list of shared objects"
msgstr "dl_iterate_phdr - обход списка общих объектов"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:37
#, no-wrap
msgid ""
"B<int dl_iterate_phdr(>\n"
"B<          int (*>I<callback>B<) (struct dl_phdr_info *>I<info>B<,>\n"
"B<                           size_t >I<size>B<, void *>I<data>B<),>\n"
"B<          void *>I<data>B<);>\n"
msgstr ""
"B<int dl_iterate_phdr(>\n"
"B<          int (*>I<callback>B<) (struct dl_phdr_info *>I<info>B<,>\n"
"B<                           size_t >I<size>B<, void *>I<data>B<),>\n"
"B<          void *>I<data>B<);>\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:44
msgid ""
"The B<dl_iterate_phdr>()  function allows an application to inquire at run "
"time to find out which shared objects it has loaded, and the order in which "
"they were loaded."
msgstr ""
"Функция B<dl_iterate_phdr>() позволяет приложению во время выполнения "
"узнать, какие общие объекты были загружены и их порядок загрузки."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:54
msgid ""
"The B<dl_iterate_phdr>()  function walks through the list of an "
"application's shared objects and calls the function I<callback> once for "
"each object, until either all shared objects have been processed or "
"I<callback> returns a nonzero value."
msgstr ""
"Функция B<dl_iterate_phdr>() обходит список общих объектов приложения и "
"однократно вызывает функцию I<callback> для каждого объекта до тех пор, пока "
"или все общие объекты не будут просмотрены, или функция I<callback> не "
"вернёт ненулевое значение."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:71
msgid ""
"Each call to I<callback> receives three arguments: I<info>, which is a "
"pointer to a structure containing information about the shared object; "
"I<size>, which is the size of the structure pointed to by I<info>; and "
"I<data>, which is a copy of whatever value was passed by the calling program "
"as the second argument (also named I<data>)  in the call to "
"B<dl_iterate_phdr>()."
msgstr ""
"При каждом вызове в I<callback> передаётся три параметра: I<info> (указатель "
"на структуру с информацией об общем объекте), I<size> (размер структуры, на "
"которую указывает I<info>) и I<data> (копия любого значения, переданного "
"вызывающей программой во втором параметре (также называемом I<data>) в вызов "
"B<dl_iterate_phdr>()."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:75
msgid "The I<info> argument is a structure of the following type:"
msgstr "Параметр I<info> представляет собой структуру следующего вида:"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:86
#, no-wrap
msgid ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* Base address of object */\n"
"    const char       *dlpi_name;  /* (Null-terminated) name of\n"
"                                     object */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* Pointer to array of\n"
"                                     ELF program headers\n"
"                                     for this object */\n"
"    ElfW(Half)        dlpi_phnum; /* # of items in I<dlpi_phdr> */\n"
msgstr ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* базовый адрес объекта */\n"
"    const char       *dlpi_name;  /* имя объекта\n"
"                                     (оканчивается Null) */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* указатель на массив\n"
"                                     программных заголовков ELF\n"
"                                     этого объекта */\n"
"    ElfW(Half)        dlpi_phnum; /* кол-во элементов в I<dlpi_phdr> */\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:91
#, no-wrap
msgid ""
"    /* The following fields were added in glibc 2.4, after the first\n"
"       version of this structure was available.  Check the I<size>\n"
"       argument passed to the dl_iterate_phdr callback to determine\n"
"       whether or not each later member is available.  */\n"
msgstr ""
"    /* Следующие поля были добавлены в glibc 2.4, после опубликования\n"
"       первой версии этой структуры. Из аргумента I<size>,\n"
"       передаваемом в dl_iterate_phdr, можно определить\n"
"       были ли добавлены новые члены. */\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:107
#, no-wrap
msgid ""
"    unsigned long long int dlpi_adds;\n"
"                    /* Incremented when a new object may\n"
"                       have been added */\n"
"    unsigned long long int dlpi_subs;\n"
"                    /* Incremented when an object may\n"
"                       have been removed */\n"
"    size_t dlpi_tls_modid;\n"
"                    /* If there is a PT_TLS segment, its module\n"
"                       ID as used in TLS relocations, else zero */\n"
"    void  *dlpi_tls_data;\n"
"                    /* The address of the calling thread's instance\n"
"                       of this module's PT_TLS segment, if it has\n"
"                       one and it has been allocated in the calling\n"
"                       thread, otherwise a null pointer */\n"
"};\n"
msgstr ""
"    unsigned long long int dlpi_adds;\n"
"                    /* увеличивается, когда мог быть\n"
"                       добавлен новый объект */\n"
"    unsigned long long int dlpi_subs;\n"
"                    /* увеличивается, когда мог быть\n"
"                       удалён новый объект */\n"
"    size_t dlpi_tls_modid;\n"
"                    /* если существует сегмент PT_TLS, это его\n"
"                       ID модуля, используемый в\n"
"                       перестановках TLS, иначе 0 */\n"
"    void  *dlpi_tls_data;\n"
"                    /* адрес экземпляра вызывающей нити\n"
"                       сегмента PT_TLS этого модуля, если он есть\n"
"                       и был выделен в вызывающей нити,\n"
"                       иначе указатель null */\n"
"};\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:121
msgid ""
"(The I<ElfW>()  macro definition turns its argument into the name of an ELF "
"data type suitable for the hardware architecture.  For example, on a 32-bit "
"platform, I<ElfW(Addr)> yields the data type name I<Elf32_Addr>.  Further "
"information on these types can be found in the I<E<lt>elf.hE<gt>> and "
"I<E<lt>link.hE<gt>> header files.)"
msgstr ""
"(Макрос I<ElfW>() преобразует свой аргумент в имя  типа данных ELF, "
"подходящее для аппаратной архитектуры. Например, на 32-битной платформе "
"I<ElfW(Addr)> вернёт имя типа данных I<Elf32_Addr>. Дополнительную "
"информацию можно найти в заголовочных файлах I<E<lt>elf.hE<gt>> и "
"I<E<lt>link.hE<gt>>.)"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:132
msgid ""
"The I<dlpi_addr> field indicates the base address of the shared object (i."
"e., the difference between the virtual memory address of the shared object "
"and the offset of that object in the file from which it was loaded).  The "
"I<dlpi_name> field is a null-terminated string giving the pathname from "
"which the shared object was loaded."
msgstr ""
"В поле I<dlpi_addr> указывается базовый адрес общего объекта (т. е., разница "
"между виртуальным адресом памяти общего объекта и смещением до этого объекта "
"в файле, из которого он был загружен). Поле I<dlpi_name> представляет собой "
"строку с null на конце, определяющую путь, из которого был загружен общий "
"объект."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:147
msgid ""
"To understand the meaning of the I<dlpi_phdr> and I<dlpi_phnum> fields, we "
"need to be aware that an ELF shared object consists of a number of segments, "
"each of which has a corresponding program header describing the segment.  "
"The I<dlpi_phdr> field is a pointer to an array of the program headers for "
"this shared object.  The I<dlpi_phnum> field indicates the size of this "
"array."
msgstr ""
"Чтобы понять назначение полей I<dlpi_phdr> и I<dlpi_phnum>, нам необходимо "
"представлять, что общий объект ELF состоит из набора сегментов, каждый из "
"которых имеет соответствующий программный заголовок, описывающий сегмент. "
"Поле I<dlpi_phdr> представляет собой указатель на массив программных "
"заголовков этого общего объекта. В поле I<dlpi_phnum> задаётся размер этого "
"массива."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:149
msgid "These program headers are structures of the following form:"
msgstr "Программные заголовки представляют собой структуры следующего вида:"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:162
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word  p_type;    /* Segment type */\n"
"    Elf32_Off   p_offset;  /* Segment file offset */\n"
"    Elf32_Addr  p_vaddr;   /* Segment virtual address */\n"
"    Elf32_Addr  p_paddr;   /* Segment physical address */\n"
"    Elf32_Word  p_filesz;  /* Segment size in file */\n"
"    Elf32_Word  p_memsz;   /* Segment size in memory */\n"
"    Elf32_Word  p_flags;   /* Segment flags */\n"
"    Elf32_Word  p_align;   /* Segment alignment */\n"
"} Elf32_Phdr;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Word  p_type;    /* тип сегмента */\n"
"    Elf32_Off   p_offset;  /* смещение сегмента в файле */\n"
"    Elf32_Addr  p_vaddr;   /* виртуальный адрес сегмента */\n"
"    Elf32_Addr  p_paddr;   /* физический адрес сегмента */\n"
"    Elf32_Word  p_filesz;  /* размер сегмента в файле */\n"
"    Elf32_Word  p_memsz;   /* размер сегмента в памяти */\n"
"    Elf32_Word  p_flags;   /* флаги сегмента */\n"
"    Elf32_Word  p_align;   /* выравнивание сегмента */\n"
"} Elf32_Phdr;\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:168
msgid ""
"Note that we can calculate the location of a particular program header, "
"I<x>, in virtual memory using the formula:"
msgstr ""
"Заметим, что мы можем вычислить расположение определённого программного "
"заголовка I<x> в виртуальной памяти по следующей формуле:"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:172
#, no-wrap
msgid "addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"
msgstr "addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:180
msgid ""
"Possible values for I<p_type> include the following (see I<E<lt>elf.hE<gt>> "
"for further details):"
msgstr ""
"Возможными значениями I<p_type> поля могут быть (подробности смотрите в "
"I<E<lt>elf.hE<gt>>):"

#.  For PT_GNU_STACK, see http://www.airs.com/blog/archives/518
#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:194
#, no-wrap
msgid ""
"#define PT_LOAD         1    /* Loadable program segment */\n"
"#define PT_DYNAMIC      2    /* Dynamic linking information */\n"
"#define PT_INTERP       3    /* Program interpreter */\n"
"#define PT_NOTE         4    /* Auxiliary information */\n"
"#define PT_SHLIB        5    /* Reserved */\n"
"#define PT_PHDR         6    /* Entry for header table itself */\n"
"#define PT_TLS          7    /* Thread-local storage segment */\n"
"#define PT_GNU_EH_FRAME 0x6474e550 /* GCC .eh_frame_hdr segment */\n"
"#define PT_GNU_STACK  0x6474e551 /* Indicates stack executability */\n"
"#define PT_GNU_RELRO  0x6474e552 /* Read-only after relocation */\n"
msgstr ""
"#define PT_LOAD         1    /* загружаемый сегмент программы */\n"
"#define PT_DYNAMIC      2    /* информация о динамической компоновке */\n"
"#define PT_INTERP       3    /* интерпретатор программы */\n"
"#define PT_NOTE         4    /* вспомогательная информация */\n"
"#define PT_SHLIB        5    /* зарезервировано */\n"
"#define PT_PHDR         6    /* сам элемент таблицы заголовков */\n"
"#define PT_TLS          7    /* сегмент локального хранилища нити */\n"
"#define PT_GNU_EH_FRAME 0x6474e550 /* сегмент GCC .eh_frame_hdr */\n"
"#define PT_GNU_STACK  0x6474e551 /* показывает, что стек — исполняемый */\n"
"#define PT_GNU_RELRO  0x6474e552 /* только чтения после перемещения */\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:201
msgid ""
"The B<dl_iterate_phdr>()  function returns whatever value was returned by "
"the last call to I<callback>."
msgstr ""
"Функция B<dl_iterate_phdr>() возвращает значение, которое было получено в "
"результате последнего вызова I<callback>."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:204
msgid "B<dl_iterate_phdr>()  has been supported in glibc since version 2.2.4."
msgstr "Функция B<dl_iterate_phdr>() доступна в glibc начиная с версии 2.2.4."

#. type: tbl table
#: man-pages/man3/dl_iterate_phdr.3:214
#, no-wrap
msgid "B<dl_iterate_phdr>()"
msgstr "B<dl_iterate_phdr>()"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:232
msgid ""
"The B<dl_iterate_phdr>()  function is not specified in any standard.  "
"Various other systems provide a version of this function, although details "
"of the returned I<dl_phdr_info> structure differ.  On the BSDs and Solaris, "
"the structure includes the fields I<dlpi_addr>, I<dlpi_name>, I<dlpi_phdr>, "
"and I<dlpi_phnum> in addition to other implementation-specific fields."
msgstr ""
"Функция B<dl_iterate_phdr>() не описана в каком-либо стандарте. Эта функция "
"есть в некоторых других системах, при чём возвращаемая структура "
"I<dl_phdr_info> имеет другой формат. В BSD и Solaris, в структуре есть поля "
"I<dlpi_addr>, I<dlpi_name>, I<dlpi_phdr> и I<dlpi_phnum> (помимо других "
"внесённых реализацией полей)."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:239
msgid ""
"Future versions of the C library may add further fields to the "
"I<dl_phdr_info> structure; in that event, the I<size> argument provides a "
"mechanism for the callback function to discover whether it is running on a "
"system with added fields."
msgstr ""
"В будущих версиях библиотеки C в структуре I<dl_phdr_info> могут появиться "
"дополнительные поля; для этого случая предусмотрен аргумент I<size>, который "
"предоставляет вызываемой функции механизм обнаружения того, что она работает "
"в системе с добавленными полями."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:246
msgid ""
"The first object visited by I<callback> is the main program.  For the main "
"program, the I<dlpi_name> field will be an empty string."
msgstr ""
"Первый объект, просматриваемый I<callback>, это главная программа. У главной "
"программы поле I<dlpi_name> будет содержать пустую строку."

#. type: SH
#: man-pages/man3/dl_iterate_phdr.3:246
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:252
msgid ""
"The following program displays a list of pathnames of the shared objects it "
"has loaded.  For each shared object, the program lists some information "
"(virtual address, size, flags, and type)  for each of the objects ELF "
"segments."
msgstr ""
"Следующая программа выводит список путей общих объектов, из которых они были "
"загружены. Для каждого общего объекта программа выводит информацию из "
"каждого сегмента объектов ELF (виртуальный адрес, размер, флаги и тип)."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:258
msgid ""
"The following shell session demonstrates the output produced by the program "
"on an x86-64 system.  The first shared object for which output is displayed "
"(where the name is an empty string)  is the main program."
msgstr ""
"В следующем сеансе оболочки показан вывод программы, запущенной в системе с "
"архитектурой x86-64. Первый показанный общий объект это основная программа "
"(вместо имени пустая строка)."

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:296
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Name: \"\" (9 segments)\n"
"     0: [      0x400040; memsz:    1f8] flags: 0x5; PT_PHDR\n"
"     1: [      0x400238; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [      0x400000; memsz:    ac4] flags: 0x5; PT_LOAD\n"
"     3: [      0x600e10; memsz:    240] flags: 0x6; PT_LOAD\n"
"     4: [      0x600e28; memsz:    1d0] flags: 0x6; PT_DYNAMIC\n"
"     5: [      0x400254; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [      0x400970; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     7: [         (nil); memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     8: [      0x600e10; memsz:    1f0] flags: 0x4; PT_GNU_RELRO\n"
"Name: \"linux-vdso.so.1\" (4 segments)\n"
"     0: [0x7ffc6edd1000; memsz:    e89] flags: 0x5; PT_LOAD\n"
"     1: [0x7ffc6edd1360; memsz:    110] flags: 0x4; PT_DYNAMIC\n"
"     2: [0x7ffc6edd17b0; memsz:     3c] flags: 0x4; PT_NOTE\n"
"     3: [0x7ffc6edd17ec; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"Name: \"/lib64/libc.so.6\" (10 segments)\n"
"     0: [0x7f55712ce040; memsz:    230] flags: 0x5; PT_PHDR\n"
"     1: [0x7f557145b980; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [0x7f55712ce000; memsz: 1b6a5c] flags: 0x5; PT_LOAD\n"
"     3: [0x7f55716857a0; memsz:   9240] flags: 0x6; PT_LOAD\n"
"     4: [0x7f5571688b80; memsz:    1f0] flags: 0x6; PT_DYNAMIC\n"
"     5: [0x7f55712ce270; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [0x7f55716857a0; memsz:     78] flags: 0x4; PT_TLS\n"
"     7: [0x7f557145b99c; memsz:   544c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     8: [0x7f55712ce000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     9: [0x7f55716857a0; memsz:   3860] flags: 0x4; PT_GNU_RELRO\n"
"Name: \"/lib64/ld-linux-x86-64.so.2\" (7 segments)\n"
"     0: [0x7f557168f000; memsz:  20828] flags: 0x5; PT_LOAD\n"
"     1: [0x7f55718afba0; memsz:   15a8] flags: 0x6; PT_LOAD\n"
"     2: [0x7f55718afe10; memsz:    190] flags: 0x6; PT_DYNAMIC\n"
"     3: [0x7f557168f1c8; memsz:     24] flags: 0x4; PT_NOTE\n"
"     4: [0x7f55716acec4; memsz:    604] flags: 0x4; PT_GNU_EH_FRAME\n"
"     5: [0x7f557168f000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     6: [0x7f55718afba0; memsz:    460] flags: 0x4; PT_GNU_RELRO\n"
msgstr ""
"$ B<./a.out>\n"
"Имя: \"\" (9 сегментов)\n"
"     0: [      0x400040; memsz:    1f8] flags: 0x5; PT_PHDR\n"
"     1: [      0x400238; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [      0x400000; memsz:    ac4] flags: 0x5; PT_LOAD\n"
"     3: [      0x600e10; memsz:    240] flags: 0x6; PT_LOAD\n"
"     4: [      0x600e28; memsz:    1d0] flags: 0x6; PT_DYNAMIC\n"
"     5: [      0x400254; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [      0x400970; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     7: [         (nil); memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     8: [      0x600e10; memsz:    1f0] flags: 0x4; PT_GNU_RELRO\n"
"Имя: \"linux-vdso.so.1\" (4 сегментов)\n"
"     0: [0x7ffc6edd1000; memsz:    e89] flags: 0x5; PT_LOAD\n"
"     1: [0x7ffc6edd1360; memsz:    110] flags: 0x4; PT_DYNAMIC\n"
"     2: [0x7ffc6edd17b0; memsz:     3c] flags: 0x4; PT_NOTE\n"
"     3: [0x7ffc6edd17ec; memsz:     3c] flags: 0x4; PT_GNU_EH_FRAME\n"
"Имя: \"/lib64/libc.so.6\" (10 сегментов)\n"
"     0: [0x7f55712ce040; memsz:    230] flags: 0x5; PT_PHDR\n"
"     1: [0x7f557145b980; memsz:     1c] flags: 0x4; PT_INTERP\n"
"     2: [0x7f55712ce000; memsz: 1b6a5c] flags: 0x5; PT_LOAD\n"
"     3: [0x7f55716857a0; memsz:   9240] flags: 0x6; PT_LOAD\n"
"     4: [0x7f5571688b80; memsz:    1f0] flags: 0x6; PT_DYNAMIC\n"
"     5: [0x7f55712ce270; memsz:     44] flags: 0x4; PT_NOTE\n"
"     6: [0x7f55716857a0; memsz:     78] flags: 0x4; PT_TLS\n"
"     7: [0x7f557145b99c; memsz:   544c] flags: 0x4; PT_GNU_EH_FRAME\n"
"     8: [0x7f55712ce000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     9: [0x7f55716857a0; memsz:   3860] flags: 0x4; PT_GNU_RELRO\n"
"Имя: \"/lib64/ld-linux-x86-64.so.2\" (7 сегментов)\n"
"     0: [0x7f557168f000; memsz:  20828] flags: 0x5; PT_LOAD\n"
"     1: [0x7f55718afba0; memsz:   15a8] flags: 0x6; PT_LOAD\n"
"     2: [0x7f55718afe10; memsz:    190] flags: 0x6; PT_DYNAMIC\n"
"     3: [0x7f557168f1c8; memsz:     24] flags: 0x4; PT_NOTE\n"
"     4: [0x7f55716acec4; memsz:    604] flags: 0x4; PT_GNU_EH_FRAME\n"
"     5: [0x7f557168f000; memsz:      0] flags: 0x6; PT_GNU_STACK\n"
"     6: [0x7f55718afba0; memsz:    460] flags: 0x4; PT_GNU_RELRO\n"

#. type: SS
#: man-pages/man3/dl_iterate_phdr.3:299
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:306
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:312
#, no-wrap
msgid ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    char *type;\n"
"    int p_type, j;\n"
msgstr ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    char *type;\n"
"    int p_type, j;\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:315
#, no-wrap
msgid ""
"    printf(\"Name: \\e\"%s\\e\" (%d segments)\\en\", info-E<gt>dlpi_name,\n"
"               info-E<gt>dlpi_phnum);\n"
msgstr ""
"    printf(\"Имя: \\e\"%s\\e\" (%d сегментов)\\en\", info-E<gt>dlpi_name,\n"
"               info-E<gt>dlpi_phnum);\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:328
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> info-E<gt>dlpi_phnum; j++) {\n"
"        p_type = info-E<gt>dlpi_phdr[j].p_type;\n"
"        type =  (p_type == PT_LOAD) ? \"PT_LOAD\" :\n"
"                (p_type == PT_DYNAMIC) ? \"PT_DYNAMIC\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_NOTE) ? \"PT_NOTE\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_PHDR) ? \"PT_PHDR\" :\n"
"                (p_type == PT_TLS) ? \"PT_TLS\" :\n"
"                (p_type == PT_GNU_EH_FRAME) ? \"PT_GNU_EH_FRAME\" :\n"
"                (p_type == PT_GNU_STACK) ? \"PT_GNU_STACK\" :\n"
"                (p_type == PT_GNU_RELRO) ? \"PT_GNU_RELRO\" : NULL;\n"
msgstr ""
"    for (j = 0; j E<lt> info-E<gt>dlpi_phnum; j++) {\n"
"        p_type = info-E<gt>dlpi_phdr[j].p_type;\n"
"        type =  (p_type == PT_LOAD) ? \"PT_LOAD\" :\n"
"                (p_type == PT_DYNAMIC) ? \"PT_DYNAMIC\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_NOTE) ? \"PT_NOTE\" :\n"
"                (p_type == PT_INTERP) ? \"PT_INTERP\" :\n"
"                (p_type == PT_PHDR) ? \"PT_PHDR\" :\n"
"                (p_type == PT_TLS) ? \"PT_TLS\" :\n"
"                (p_type == PT_GNU_EH_FRAME) ? \"PT_GNU_EH_FRAME\" :\n"
"                (p_type == PT_GNU_STACK) ? \"PT_GNU_STACK\" :\n"
"                (p_type == PT_GNU_RELRO) ? \"PT_GNU_RELRO\" : NULL;\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:338
#, no-wrap
msgid ""
"        printf(\"    %2d: [%14p; memsz:%7lx] flags: 0x%x; \", j,\n"
"                (void *) (info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[j].p_vaddr),\n"
"                info-E<gt>dlpi_phdr[j].p_memsz,\n"
"                info-E<gt>dlpi_phdr[j].p_flags);\n"
"        if (type != NULL)\n"
"            printf(\"%s\\en\", type);\n"
"        else\n"
"            printf(\"[other (0x%x)]\\en\", p_type);\n"
"    }\n"
msgstr ""
"        printf(\"    %2d: [%14p; memsz:%7lx] flags: 0x%x; \", j,\n"
"                (void *) (info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[j].p_vaddr),\n"
"                info-E<gt>dlpi_phdr[j].p_memsz,\n"
"                info-E<gt>dlpi_phdr[j].p_flags);\n"
"        if (type != NULL)\n"
"            printf(\"%s\\en\", type);\n"
"        else\n"
"            printf(\"[другой (0x%x)]\\en\", p_type);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:341
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:346
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:349
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:358
msgid ""
"B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dladdr>(3), B<dlopen>(3), "
"B<elf>(5), B<ld.so>(8)"
msgstr ""
"B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dladdr>(3), B<dlopen>(3), "
"B<elf>(5), B<ld.so>(8)"

#. type: Plain text
#: man-pages/man3/dl_iterate_phdr.3:360
msgid ""
"I<Executable and Linking Format Specification>, available at various "
"locations online."
msgstr "I<Executable and Linking Format Specification> в веб."

#. type: TH
#: man-pages/man3/dbopen.3:36
#, no-wrap
msgid "DBOPEN"
msgstr "DBOPEN"

#. type: Plain text
#: man-pages/man3/dbopen.3:40
msgid "dbopen - database access methods"
msgstr "dbopen - методы доступа к базе данных"

#. type: Plain text
#: man-pages/man3/dbopen.3:46
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/dbopen.3:50
#, no-wrap
msgid ""
"B<DB *dbopen(const char *>I<file>B<, int >I<flags>B<, int >I<mode>B<, DBTYPE >I<type>B<,>\n"
"B<           const void *>I<openinfo>B<);>\n"
msgstr ""
"B<DB *dbopen(const char *>I<file>B<, int >I<flags>B<, int >I<mode>B<, DBTYPE >I<type>B<,>\n"
"B<           const void *>I<openinfo>B<);>\n"

#. type: Plain text
#: man-pages/man3/dbopen.3:58
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces.  "
"Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr ""
"I<Примечание>: В этой странице описаны интерфейсы, предоставляемые glibc до "
"версии 2.1. Начиная с версии 2.2, glibc больше не поддерживает эти "
"интерфейсы. Вероятно, вы ищите API, предоставляемое библиотекой I<libdb>."

#. type: Plain text
#: man-pages/man3/dbopen.3:72
msgid ""
"B<dbopen>()  is the library interface to database files.  The supported file "
"formats are btree, hashed and UNIX file oriented.  The btree format is a "
"representation of a sorted, balanced tree structure.  The hashed format is "
"an extensible, dynamic hashing scheme.  The flat-file format is a byte "
"stream file with fixed or variable length records.  The formats and file-"
"format-specific information are described in detail in their respective "
"manual pages B<btree>(3), B<hash>(3), and B<recno>(3)."
msgstr ""
"B<dbopen>() — это библиотека для взаимодействия с файлами баз данных. "
"Поддерживаются форматы файлов btree, hashed и UNIX. Формат btree "
"представляет собой отсортированную, сбалансированную древовидную структуру. "
"Формат hashed — это гибкая, динамическая схема хэширования. Формат простого "
"файла UNIX — поток байтов с записями постоянной или переменной длины. Сами "
"форматы и формат файлов описываются детально в соответствующих справочных "
"страницах B<btree>(3), B<hash>(3) и B<recno>(3)."

#. type: Plain text
#: man-pages/man3/dbopen.3:81
msgid ""
"B<dbopen>()  opens I<file> for reading and/or writing.  Files never intended "
"to be preserved on disk may be created by setting the I<file> argument to "
"NULL."
msgstr ""
"B<dbopen>() открывает I<file> для чтения и/или записи. Файлы, не "
"предназначенные для хранения на диске, могут быть созданы заданием параметру "
"I<file> значения NULL."

#. Three additional options may be specified by ORing
#. them into the
#. .I flags
#. argument.
#. .TP
#. DB_LOCK
#. Do the necessary locking in the database to support concurrent access.
#. If concurrent access isn't needed or the database is read-only this
#. flag should not be set, as it tends to have an associated performance
#. penalty.
#. .TP
#. DB_SHMEM
#. Place the underlying memory pool used by the database in shared
#. memory.
#. Necessary for concurrent access.
#. .TP
#. DB_TXN
#. Support transactions in the database.
#. The DB_LOCK and DB_SHMEM flags must be set as well.
#. type: Plain text
#: man-pages/man3/dbopen.3:121
msgid ""
"The I<flags> and I<mode> arguments are as specified to the B<open>(2)  "
"routine, however, only the B<O_CREAT>, B<O_EXCL>, B<O_EXLOCK>, "
"B<O_NONBLOCK>, B<O_RDONLY>, B<O_RDWR>, B<O_SHLOCK>, and B<O_TRUNC> flags are "
"meaningful.  (Note, opening a database file B<O_WRONLY> is not possible.)"
msgstr ""
"Значения аргументов I<flags> и I<mode> те же, что у вызова B<open>(2), "
"однако имеют значение только флаги B<O_CREAT>, B<O_EXCL>, B<O_EXLOCK>, "
"B<O_NONBLOCK>, B<O_RDONLY>, B<O_RDWR>, B<O_SHLOCK> и B<O_TRUNC>. Открытие "
"файла базы данных с B<O_WRONLY> невозможно."

#. type: Plain text
#: man-pages/man3/dbopen.3:134
msgid ""
"The I<type> argument is of type I<DBTYPE> (as defined in the I<E<lt>db."
"hE<gt>> include file) and may be set to B<DB_BTREE>, B<DB_HASH>, or "
"B<DB_RECNO>."
msgstr ""
"Аргумент I<type> имеет тип I<DBTYPE> (определён в файле заголовков I<E<lt>db."
"hE<gt>>) и может быть равен B<DB_BTREE>, B<DB_HASH> или B<DB_RECNO>."

#. type: Plain text
#: man-pages/man3/dbopen.3:143
msgid ""
"The I<openinfo> argument is a pointer to an access-method-specific structure "
"described in the access method's manual page.  If I<openinfo> is NULL, each "
"access method will use defaults appropriate for the system and the access "
"method."
msgstr ""
"Аргумент I<openinfo> является указателем на структуру метода доступа, "
"описанную в справочной странице, посвящённой методам доступа. Если значение "
"I<openinfo> равно NULL, то каждый метод доступа будет использовать установки "
"по умолчанию для системы и метода доступа."

#. type: Plain text
#: man-pages/man3/dbopen.3:154
msgid ""
"B<dbopen>()  returns a pointer to a I<DB> structure on success and NULL on "
"error.  The I<DB> structure is defined in the I<E<lt>db.hE<gt>> include "
"file, and contains at least the following fields:"
msgstr ""
"При успешном выполнении B<dbopen>() возвращает указатель на структуру I<DB> "
"и NULL при ошибке. Структура I<DB> определена в файле I<E<lt>db.hE<gt>> и "
"содержит, как минимум, следующие поля:"

#. type: Plain text
#: man-pages/man3/dbopen.3:170
#, no-wrap
msgid ""
"typedef struct {\n"
"    DBTYPE type;\n"
"    int (*close)(const DB *db);\n"
"    int (*del)(const DB *db, const DBT *key, unsigned int flags);\n"
"    int (*fd)(const DB *db);\n"
"    int (*get)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"    int (*put)(const DB *db, DBT *key, const DBT *data,\n"
"               unsigned int flags);\n"
"    int (*sync)(const DB *db, unsigned int flags);\n"
"    int (*seq)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"} DB;\n"
msgstr ""
"typedef struct {\n"
"    DBTYPE type;\n"
"    int (*close)(const DB *db);\n"
"    int (*del)(const DB *db, const DBT *key, unsigned int flags);\n"
"    int (*fd)(const DB *db);\n"
"    int (*get)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"    int (*put)(const DB *db, DBT *key, const DBT *data,\n"
"               unsigned int flags);\n"
"    int (*sync)(const DB *db, unsigned int flags);\n"
"    int (*seq)(const DB *db, DBT *key, DBT *data,\n"
"               unsigned int flags);\n"
"} DB;\n"

#. type: Plain text
#: man-pages/man3/dbopen.3:178
msgid ""
"These elements describe a database type and a set of functions performing "
"various actions.  These functions take a pointer to a structure as returned "
"by B<dbopen>(), and sometimes one or more pointers to key/data structures "
"and a flag value."
msgstr ""
"Эти элементы описывают тип базы данных и набор функций, выполняющих "
"различные действия. Функции используют указатель на структуру, возвращаемый "
"B<dbopen>(), и иногда один или несколько указателей на структуры ключ/данные "
"и на значения флагов."

#. type: TP
#: man-pages/man3/dbopen.3:178
#, no-wrap
msgid "I<type>"
msgstr "I<type>"

#. type: Plain text
#: man-pages/man3/dbopen.3:181
msgid "The type of the underlying access method (and file format)."
msgstr "Тип лежащего в основе метода доступа (и формат файла)."

#. type: TP
#: man-pages/man3/dbopen.3:181
#, no-wrap
msgid "I<close>"
msgstr "I<close>"

#. type: Plain text
#: man-pages/man3/dbopen.3:195
msgid ""
"A pointer to a routine to flush any cached information to disk, free any "
"allocated resources, and close the underlying file(s).  Since key/data pairs "
"may be cached in memory, failing to sync the file with a I<close> or I<sync> "
"function may result in inconsistent or lost information.  I<close> routines "
"return -1 on error (setting I<errno>)  and 0 on success."
msgstr ""
"Указатель на функцию, которая записывает любую кэшированную информацию на "
"диск, освобождает занятые ресурсы и закрывает используемый файл(-ы). Так как "
"пары ключ/данные могут быть кэшированы в памяти, ошибка синхронизации файла "
"при функциях I<close> или I<sync> может привести к повреждению или потере "
"данных. Функция I<close> возвращает -1 при ошибках (меняя при этом, "
"соответственно, значение переменной I<errno>) и 0 при успешном выполнении."

#. type: TP
#: man-pages/man3/dbopen.3:195
#, no-wrap
msgid "I<del>"
msgstr "I<del>"

#. type: Plain text
#: man-pages/man3/dbopen.3:198
msgid "A pointer to a routine to remove key/data pairs from the database."
msgstr "Указатель на функцию для удаления пар ключ/данные из базы данных."

#. type: Plain text
#: man-pages/man3/dbopen.3:202
msgid "The argument I<flag> may be set to the following value:"
msgstr "Значение параметра I<flag> может быть следующим:"

#. type: TP
#: man-pages/man3/dbopen.3:203 man-pages/man3/dbopen.3:259
#: man-pages/man3/dbopen.3:359
#, no-wrap
msgid "B<R_CURSOR>"
msgstr "B<R_CURSOR>"

#. type: Plain text
#: man-pages/man3/dbopen.3:207
msgid ""
"Delete the record referenced by the cursor.  The cursor must have previously "
"been initialized."
msgstr ""
"Удаление записи, на которую ссылается курсор. Курсор предварительно должен "
"быть инициализирован."

#. type: Plain text
#: man-pages/man3/dbopen.3:215
msgid ""
"I<delete> routines return -1 on error (setting I<errno>), 0 on success, and "
"1 if the specified I<key> was not in the file."
msgstr ""
"Функция I<delete> возвращает -1 при ошибке (изменяет I<errno>), 0 при "
"успешном выполнении и 1, если указанного ключа I<key> нет в файле."

#. type: TP
#: man-pages/man3/dbopen.3:215
#, no-wrap
msgid "I<fd>"
msgstr "I<fd>"

#. type: Plain text
#: man-pages/man3/dbopen.3:237
msgid ""
"A pointer to a routine which returns a file descriptor representative of the "
"underlying database.  A file descriptor referencing the same file will be "
"returned to all processes which call B<dbopen>()  with the same I<file> "
"name.  This file descriptor may be safely used as an argument to the "
"B<fcntl>(2)  and B<flock>(2)  locking functions.  The file descriptor is not "
"necessarily associated with any of the underlying files used by the access "
"method.  No file descriptor is available for in memory databases.  I<fd> "
"routines return -1 on error (setting I<errno>), and the file descriptor on "
"success."
msgstr ""
"Указатель на функцию, которая возвращает дескриптор файла, представляющий "
"используемую базу данных. Дескриптор файла, ссылающийся на тот же файл, "
"будет возвращаться всем процессам, которые вызывают B<dbopen>() с этим "
"именем файла I<file>. Этот дескриптор файла может быть использован как "
"аргумент для блокирующих функций B<fcntl>(2) и B<flock>(2). Файловый "
"дескриптор необязательно связывать с какими-либо из файлов, лежащих в основе "
"используемого метода доступа. Для баз данных в памяти файловые дескрипторы "
"недоступны. Функция I<fd> возвращает -1 при ошибке (меняет при этом, "
"соответственно, значение переменной I<errno>) или дескриптор файла при "
"успешном выполнении."

#. type: TP
#: man-pages/man3/dbopen.3:237
#, no-wrap
msgid "I<get>"
msgstr "I<get>"

#. type: Plain text
#: man-pages/man3/dbopen.3:251
msgid ""
"A pointer to a routine which is the interface for keyed retrieval from the "
"database.  The address and length of the data associated with the specified "
"I<key> are returned in the structure referenced by I<data>.  I<get> routines "
"return -1 on error (setting I<errno>), 0 on success, and 1 if the I<key> was "
"not in the file."
msgstr ""
"Указатель на функцию, которая является интерфейсом для поиска по ключу в "
"базе данных. Адрес и размер данных, связанных с указанным ключом I<key>, "
"возвращается в структуре, указываемой I<data>. Функция I<get> возвращает -1 "
"при ошибке (меняя при этом, соответственно, значение переменной I<errno>), 0 "
"при успешном выполнении и 1, если ключа I<key> нет в файле."

#. type: TP
#: man-pages/man3/dbopen.3:251
#, no-wrap
msgid "I<put>"
msgstr "I<put>"

#. type: Plain text
#: man-pages/man3/dbopen.3:254
msgid "A pointer to a routine to store key/data pairs in the database."
msgstr "Указатель на функцию, сохраняющую пары ключ/данные в базе данных."

#. type: Plain text
#: man-pages/man3/dbopen.3:258
msgid "The argument I<flag> may be set to one of the following values:"
msgstr "Значение параметра I<flag> может быть одним из следующих:"

#. type: Plain text
#: man-pages/man3/dbopen.3:263
msgid ""
"Replace the key/data pair referenced by the cursor.  The cursor must have "
"previously been initialized."
msgstr ""
"Замена пары ключ/данные, на которую ссылается курсор. Курсор предварительно "
"должен быть инициализирован."

#. type: TP
#: man-pages/man3/dbopen.3:263
#, no-wrap
msgid "B<R_IAFTER>"
msgstr "B<R_IAFTER>"

#. type: Plain text
#: man-pages/man3/dbopen.3:274
msgid ""
"Append the data immediately after the data referenced by I<key>, creating a "
"new key/data pair.  The record number of the appended key/data pair is "
"returned in the I<key> structure.  (Applicable only to the B<DB_RECNO> "
"access method.)"
msgstr ""
"Добавление данных сразу после тех данных, которые связаны с ключом I<key>; "
"создание новой пары ключ/данные. Номер записи добавленной пары ключ/данные "
"возвращается в структуре I<key> (применимо только в случае метода доступа "
"B<DB_RECNO>)."

#. type: TP
#: man-pages/man3/dbopen.3:274
#, no-wrap
msgid "B<R_IBEFORE>"
msgstr "B<R_IBEFORE>"

#. type: Plain text
#: man-pages/man3/dbopen.3:285
msgid ""
"Insert the data immediately before the data referenced by I<key>, creating a "
"new key/data pair.  The record number of the inserted key/data pair is "
"returned in the I<key> structure.  (Applicable only to the B<DB_RECNO> "
"access method.)"
msgstr ""
"Вставка данных перед данными, связанными с ключом I<key>; создание новой "
"пары ключ/данные. Номер записи добавленной пары ключ/данные возвращается в "
"структуре I<key> (применимо только в случае метода доступа B<DB_RECNO>)."

#. type: TP
#: man-pages/man3/dbopen.3:285
#, no-wrap
msgid "B<R_NOOVERWRITE>"
msgstr "B<R_NOOVERWRITE>"

#. type: Plain text
#: man-pages/man3/dbopen.3:288
msgid "Enter the new key/data pair only if the key does not previously exist."
msgstr ""
"Добавление новой пары ключ/данные, только если ключ ещё не существовал."

#. type: TP
#: man-pages/man3/dbopen.3:288
#, no-wrap
msgid "B<R_SETCURSOR>"
msgstr "B<R_SETCURSOR>"

#. type: Plain text
#: man-pages/man3/dbopen.3:297
msgid ""
"Store the key/data pair, setting or initializing the position of the cursor "
"to reference it.  (Applicable only to the B<DB_BTREE> and B<DB_RECNO> access "
"methods.)"
msgstr ""
"Сохранение пары ключ/данные, установка или инициализация позиции курсора для "
"ссылки на неё (применимо только в случае метода доступа B<DB_BTREE> и "
"B<DB_RECNO>)."

#. type: Plain text
#: man-pages/man3/dbopen.3:307
msgid ""
"B<R_SETCURSOR> is available only for the B<DB_BTREE> and B<DB_RECNO> access "
"methods because it implies that the keys have an inherent order which does "
"not change."
msgstr ""
"Значение B<R_SETCURSOR> доступно только в случае методов доступа B<DB_BTREE> "
"и B<DB_RECNO>, поскольку они предполагают, что ключи имеют определённый "
"порядок, который не изменяется."

#. type: Plain text
#: man-pages/man3/dbopen.3:317
msgid ""
"B<R_IAFTER> and B<R_IBEFORE> are available only for the B<DB_RECNO> access "
"method because they each imply that the access method is able to create new "
"keys.  This is true only if the keys are ordered and independent, record "
"numbers for example."
msgstr ""
"Значения B<R_IAFTER> и B<R_IBEFORE> доступны только в случае метода доступа "
"B<DB_RECNO>, поскольку предполагается, что метод доступа позволяет создавать "
"новые ключи. Это возможно, только если ключи отсортированы и независимы, "
"например, они могут представлять собой номера записей."

#. type: Plain text
#: man-pages/man3/dbopen.3:322
msgid ""
"The default behavior of the I<put> routines is to enter the new key/data "
"pair, replacing any previously existing key."
msgstr ""
"Поведение по умолчанию функции I<put> предусматривает ввод новой пары ключ/"
"данные, заменяя при этом уже существующий ключ."

#. type: Plain text
#: man-pages/man3/dbopen.3:330
msgid ""
"I<put> routines return -1 on error (setting I<errno>), 0 on success, and 1 "
"if the B<R_NOOVERWRITE> I<flag> was set and the key already exists in the "
"file."
msgstr ""
"Функция I<put> возвращает -1 при ошибке (меняя при этом, соответственно, "
"значение переменной I<errno>), 0 при успешном выполнении и 1, если значение "
"I<flag> равно B<R_NOOVERWRITE> и ключ в файле уже существует."

#. type: TP
#: man-pages/man3/dbopen.3:330
#, no-wrap
msgid "I<seq>"
msgstr "I<seq>"

#. type: Plain text
#: man-pages/man3/dbopen.3:341
msgid ""
"A pointer to a routine which is the interface for sequential retrieval from "
"the database.  The address and length of the key are returned in the "
"structure referenced by I<key>, and the address and length of the data are "
"returned in the structure referenced by I<data>."
msgstr ""
"Указатель на функцию, которая является интерфейсом для последовательной "
"выборки в базе данных. Адрес и размер ключа возвращается в структуре, "
"определяемой I<key>, а адрес и размер данных — в структуре, определяемой "
"I<data>."

#. type: Plain text
#: man-pages/man3/dbopen.3:354
msgid ""
"Sequential key/data pair retrieval may begin at any time, and the position "
"of the \"cursor\" is not affected by calls to the I<del>, I<get>, I<put>, or "
"I<sync> routines.  Modifications to the database during a sequential scan "
"will be reflected in the scan, that is, records inserted behind the cursor "
"will not be returned while records inserted in front of the cursor will be "
"returned."
msgstr ""
"Последовательная выборка пар ключ/данные может быть начата в любой момент, и "
"позиция «курсора» не подвергнется изменениям при вызове функций I<del>, "
"I<get>, I<put> или I<sync>. Изменение базы данных в процессе "
"последовательного просмотра отразится на просмотре, т. е. запись, "
"вставленная позади курсора, не будет возвращена, пока не будет возвращена "
"запись, вставленная перед курсором."

#. type: Plain text
#: man-pages/man3/dbopen.3:358
msgid "The flag value B<must> be set to one of the following values:"
msgstr "Значение флага B<должно> быть равно одному из следующих значений:"

#. type: Plain text
#: man-pages/man3/dbopen.3:372
msgid ""
"The data associated with the specified key is returned.  This differs from "
"the I<get> routines in that it sets or initializes the cursor to the "
"location of the key as well.  (Note, for the B<DB_BTREE> access method, the "
"returned key is not necessarily an exact match for the specified key.  The "
"returned key is the smallest key greater than or equal to the specified key, "
"permitting partial key matches and range searches.)"
msgstr ""
"Возвращаются данные, связанные с указанным ключом. Отличается от функции "
"I<get> тем, что дополнительно происходит установка или инициализация "
"курсора. Заметим, что при методе доступа B<DB_BTREE> необязательно, чтобы "
"возвращаемый ключ в точности соответствовал указанному. Возвращаемый ключ — "
"наименьший ключ из больших или равных указанному ключу. При этом допускается "
"частичное соответствие ключей и поиск их в диапазонах."

#. type: TP
#: man-pages/man3/dbopen.3:372
#, no-wrap
msgid "B<R_FIRST>"
msgstr "B<R_FIRST>"

#. type: Plain text
#: man-pages/man3/dbopen.3:376
msgid ""
"The first key/data pair of the database is returned, and the cursor is set "
"or initialized to reference it."
msgstr ""
"Возвращается первая пара ключ/данные из базы данных, а курсор "
"устанавливается или инициализируется для ссылки на него."

#. type: TP
#: man-pages/man3/dbopen.3:376
#, no-wrap
msgid "B<R_LAST>"
msgstr "B<R_LAST>"

#. type: Plain text
#: man-pages/man3/dbopen.3:385
msgid ""
"The last key/data pair of the database is returned, and the cursor is set or "
"initialized to reference it.  (Applicable only to the B<DB_BTREE> and "
"B<DB_RECNO> access methods.)"
msgstr ""
"Возвращается последняя пара ключ/данные из базы данных, а курсор "
"устанавливается или инициализируется для ссылки на него. Применимо только "
"для методов доступа B<DB_BTREE> и B<DB_RECNO>."

#. type: TP
#: man-pages/man3/dbopen.3:385
#, no-wrap
msgid "B<R_NEXT>"
msgstr "B<R_NEXT>"

#. type: Plain text
#: man-pages/man3/dbopen.3:391
msgid ""
"Retrieve the key/data pair immediately after the cursor.  If the cursor is "
"not yet set, this is the same as the B<R_FIRST> flag."
msgstr ""
"Возвращается пара ключ/данные, стоящая непосредственно после курсора. Если "
"курсор ещё не был установлен, выполняется тоже, что при флаге B<R_FIRST>."

#. type: TP
#: man-pages/man3/dbopen.3:391
#, no-wrap
msgid "B<R_PREV>"
msgstr "B<R_PREV>"

#. type: Plain text
#: man-pages/man3/dbopen.3:402
msgid ""
"Retrieve the key/data pair immediately before the cursor.  If the cursor is "
"not yet set, this is the same as the B<R_LAST> flag.  (Applicable only to "
"the B<DB_BTREE> and B<DB_RECNO> access methods.)"
msgstr ""
"Возвращается пара ключ/данные, стоящая непосредственно перед курсором. Если "
"курсор ещё не был установлен, выполняется тоже, что при флаге B<R_LAST>. "
"Применимо только для методов доступа B<DB_BTREE> и B<DB_RECNO>."

#. type: Plain text
#: man-pages/man3/dbopen.3:413
msgid ""
"B<R_LAST> and B<R_PREV> are available only for the B<DB_BTREE> and "
"B<DB_RECNO> access methods because they each imply that the keys have an "
"inherent order which does not change."
msgstr ""
"Флаги B<R_LAST> и B<R_PREV> подходят только для методов доступа B<DB_BTREE> "
"и B<DB_RECNO>, поскольку при этом предполагается, что ключи расположены в "
"строгом неизменном порядке."

#. type: Plain text
#: man-pages/man3/dbopen.3:426
msgid ""
"I<seq> routines return -1 on error (setting I<errno>), 0 on success and 1 if "
"there are no key/data pairs less than or greater than the specified or "
"current key.  If the B<DB_RECNO> access method is being used, and if the "
"database file is a character special file and no complete key/data pairs are "
"currently available, the I<seq> routines return 2."
msgstr ""
"Функция I<seq> возвращает -1 при ошибке (изменяя при этом значение "
"переменной I<errno>), 0 при успешном выполнении и 1, если не обнаруживается "
"пары ключ/данные, меньшей или большей по значению, чем указанный или текущий "
"ключ. Если используется метод доступа B<DB_RECNO>, а файл базы данных "
"представляет собой специальный символьный файл (и нет доступных полных пар "
"ключ/данные), то функция I<seq> возвращает значение 2."

#. type: TP
#: man-pages/man3/dbopen.3:426
#, no-wrap
msgid "I<sync>"
msgstr "I<sync>"

#. type: Plain text
#: man-pages/man3/dbopen.3:432
msgid ""
"A pointer to a routine to flush any cached information to disk.  If the "
"database is in memory only, the I<sync> routine has no effect and will "
"always succeed."
msgstr ""
"Указатель на функцию, которая записывает любые кэшированные данные на диск. "
"Если база данных находится только в памяти, функция I<sync> не выполняет "
"никаких действий и всегда выполняется без ошибок."

#. type: Plain text
#: man-pages/man3/dbopen.3:434
msgid "The flag value may be set to the following value:"
msgstr "Значение параметра I<flag> может быть следующим:"

#. type: TP
#: man-pages/man3/dbopen.3:435
#, no-wrap
msgid "B<R_RECNOSYNC>"
msgstr "B<R_RECNOSYNC>"

#. type: Plain text
#: man-pages/man3/dbopen.3:447
msgid ""
"If the B<DB_RECNO> access method is being used, this flag causes the sync "
"routine to apply to the btree file which underlies the recno file, not the "
"recno file itself.  (See the I<bfname> field of the B<recno>(3)  manual page "
"for more information.)"
msgstr ""
"При методе доступа B<DB_RECNO> этот флаг служит причиной применения функции "
"I<sync> к файлу btree, лежащему в основе файла recno, а не к самому файлу "
"recno (см. поле I<bfname> в справочной странице B<recno>(3))."

#. type: Plain text
#: man-pages/man3/dbopen.3:453
msgid ""
"I<sync> routines return -1 on error (setting I<errno>)  and 0 on success."
msgstr ""
"Функция I<sync> возвращает -1 при ошибке (меняя при этом значение переменной "
"I<errno>) или 0 при успешном выполнении."

#. type: SS
#: man-pages/man3/dbopen.3:453
#, no-wrap
msgid "Key/data pairs"
msgstr "Пары ключ/данные"

#. type: Plain text
#: man-pages/man3/dbopen.3:456
msgid ""
"Access to all file types is based on key/data pairs.  Both keys and data are "
"represented by the following data structure:"
msgstr ""
"Доступ ко всем типам файлов основан на парах ключ/данные. Ключ и данные "
"описываются следующей структурой данных:"

#. type: Plain text
#: man-pages/man3/dbopen.3:463
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *data;\n"
"    size_t size;\n"
"} DBT;\n"
msgstr ""
"typedef struct {\n"
"    void  *data;\n"
"    size_t size;\n"
"} DBT;\n"

#. type: Plain text
#: man-pages/man3/dbopen.3:469
msgid "The elements of the I<DBT> structure are defined as follows:"
msgstr "Элементы структуры B<DBT> определяются так:"

#. type: TP
#: man-pages/man3/dbopen.3:469
#, no-wrap
msgid "I<data>"
msgstr "I<data>"

#. type: Plain text
#: man-pages/man3/dbopen.3:472
msgid "A pointer to a byte string."
msgstr "Указатель на строку байтов."

#. type: TP
#: man-pages/man3/dbopen.3:472
#, no-wrap
msgid "I<size>"
msgstr "I<size>"

#. type: Plain text
#: man-pages/man3/dbopen.3:475
msgid "The length of the byte string."
msgstr "Размер строки байтов."

#. type: Plain text
#: man-pages/man3/dbopen.3:481
msgid ""
"Key and data byte strings may reference strings of essentially unlimited "
"length although any two of them must fit into available memory at the same "
"time.  It should be noted that the access methods provide no guarantees "
"about byte string alignment."
msgstr ""
"Байтовые строки ключа и данных могут ссылаться на строки практически "
"неограниченной длины, хотя любые две из них должны помещаться в доступной "
"памяти одновременно. Не забывайте, что методы доступа не гарантируют "
"выравнивания байтовых строк."

#. type: Plain text
#: man-pages/man3/dbopen.3:491
msgid ""
"The B<dbopen>()  routine may fail and set I<errno> for any of the errors "
"specified for the library routines B<open>(2)  and B<malloc>(3)  or the "
"following:"
msgstr ""
"Функция B<dbopen>() может завершиться с ошибкой и присвоить переменной "
"I<errno> значения, определённые в библиотечных функциях B<open>(2) и "
"B<malloc>(3), а также дополнительно:"

#. type: TP
#: man-pages/man3/dbopen.3:491
#, no-wrap
msgid "B<EFTYPE>"
msgstr "B<EFTYPE>"

#. type: Plain text
#: man-pages/man3/dbopen.3:494
msgid "A file is incorrectly formatted."
msgstr "Файл неверного формата."

#. type: Plain text
#: man-pages/man3/dbopen.3:501
msgid ""
"A parameter has been specified (hash function, pad byte, etc.) that is "
"incompatible with the current file specification or which is not meaningful "
"for the function (for example, use of the cursor without prior "
"initialization) or there is a mismatch between the version number of file "
"and the software."
msgstr ""
"Указанный параметр (функция хэширования, байт заполнения и т. д.) не "
"совместим с текущими установками файла, не имеет смысла для данной функции "
"(например, использование курсора без его предварительной инициализации), или "
"имеется несоответствие версии файла и программного обеспечения."

#. type: Plain text
#: man-pages/man3/dbopen.3:513
msgid ""
"The I<close> routines may fail and set I<errno> for any of the errors "
"specified for the library routines B<close>(2), B<read>(2), B<write>(2), "
"B<free>(3), or B<fsync>(2)."
msgstr ""
"Функция I<close> может завершиться с ошибкой и присвоить переменной I<errno> "
"любое значение из определённых в библиотечных функциях B<close>(2), "
"B<read>(2), B<write>(2), B<free>(3) или B<fsync>(2)."

#. type: Plain text
#: man-pages/man3/dbopen.3:528
msgid ""
"The I<del>, I<get>, I<put>, and I<seq> routines may fail and set I<errno> "
"for any of the errors specified for the library routines B<read>(2), "
"B<write>(2), B<free>(3)  or B<malloc>(3)."
msgstr ""
"Функции I<del>, I<get>, I<put> и I<seq> могут некорректно завершаться с "
"ошибкой и присвоить переменной I<errno> любое значение из определённых в "
"библиотечных функциях B<read>(2), B<write>(2), B<free>(3) или B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/dbopen.3:536
msgid ""
"The I<fd> routines will fail and set I<errno> to B<ENOENT> for in memory "
"databases."
msgstr ""
"Функция I<fd> может завершиться с ошибкой и присвоить переменной I<errno> "
"значение B<ENOENT> (для баз данных, находящихся в памяти)."

#. type: Plain text
#: man-pages/man3/dbopen.3:543
msgid ""
"The I<sync> routines may fail and set I<errno> for any of the errors "
"specified for the library routine B<fsync>(2)."
msgstr ""
"Функции I<sync> могут завершиться с ошибкой и присвоить I<errno> любое "
"значение из определённых для библиотеки функций B<fsync>(2)."

#. type: Plain text
#: man-pages/man3/dbopen.3:548
msgid ""
"The typedef I<DBT> is a mnemonic for \"data base thang\", and was used "
"because no one could think of a reasonable name that wasn't already used."
msgstr ""
"Название типа B<DBT> является сокращением от «data base thang» и "
"используется в настоящее время, поскольку никто ещё не придумал подходящего "
"для него имени, которое ранее нигде не применялось."

#. type: Plain text
#: man-pages/man3/dbopen.3:551
msgid ""
"The file descriptor interface is a kludge and will be deleted in a future "
"version of the interface."
msgstr ""
"Доступ через дескриптор файла устарел и будет удалён в будущей версии "
"интерфейса."

#. type: Plain text
#: man-pages/man3/dbopen.3:554
msgid ""
"None of the access methods provide any form of concurrent access, locking, "
"or transactions."
msgstr ""
"Ни один из методов доступа не предоставляет пользователю каких-либо форм "
"одновременного доступа, блокировок или транкзаций."

#. type: Plain text
#: man-pages/man3/dbopen.3:559
msgid "B<btree>(3), B<hash>(3), B<mpool>(3), B<recno>(3)"
msgstr "B<btree>(3), B<hash>(3), B<mpool>(3), B<recno>(3)"

#. type: Plain text
#: man-pages/man3/dbopen.3:561
msgid ""
"I<LIBTP: Portable, Modular Transactions for UNIX>, Margo Seltzer, Michael "
"Olson, USENIX proceedings, Winter 1992."
msgstr ""
"I<LIBTP: Portable, Modular Transactions for UNIX>, Margo Seltzer, Michael "
"Olson, USENIX proceedings, Winter 1992."

#. type: TH
#: man-pages/man3/dlsym.3:25
#, no-wrap
msgid "DLSYM"
msgstr "DLSYM"

#. type: Plain text
#: man-pages/man3/dlsym.3:28
msgid ""
"dlsym, dlvsym - obtain address of a symbol in a shared object or executable"
msgstr ""
"dlsym, dlvsym - возвращает адрес символа из общего объекта или исполняемого "
"файла"

#. type: Plain text
#: man-pages/man3/dlsym.3:30 man-pages/man3/dlsym.3:36
msgid "B<#include E<lt>dlfcn.hE<gt>>"
msgstr "B<#include E<lt>dlfcn.hE<gt>>"

#. type: Plain text
#: man-pages/man3/dlsym.3:32
msgid "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"
msgstr "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"

#. type: Plain text
#: man-pages/man3/dlsym.3:34
msgid "B<#define _GNU_SOURCE>"
msgstr "B<#define _GNU_SOURCE>"

#. type: Plain text
#: man-pages/man3/dlsym.3:38
msgid ""
"B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char *>I<version>B<);>"
msgstr ""
"B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char *>I<version>B<);>"

#. type: Plain text
#: man-pages/man3/dlsym.3:40
msgid "Link with I<-ldl>."
msgstr "Компонуется при указании параметра I<-ldl>."

#. type: Plain text
#: man-pages/man3/dlsym.3:57
msgid ""
"The function B<dlsym>()  takes a \"handle\" of a dynamic loaded shared "
"object returned by B<dlopen>(3)  along with a null-terminated symbol name, "
"and returns the address where that symbol is loaded into memory.  If the "
"symbol is not found, in the specified object or any of the shared objects "
"that were automatically loaded by B<dlopen>(3)  when that object was loaded, "
"B<dlsym>()  returns NULL.  (The search performed by B<dlsym>()  is breadth "
"first through the dependency tree of these shared objects.)"
msgstr ""
"Функции B<dlsym>() передаётся «описатель» динамически загруженного объекта, "
"возвращаемого B<dlopen>(3) и имя символа (с null в конце). В результате "
"функция возвращает адрес, по которому символ расположен в памяти. Если "
"символ не найден в указанном объекте или во всех общих объектах, которые "
"были автоматически загружены B<dlopen>(3) на момент загрузки объекта, то "
"B<dlsym>() возвращает NULL (поиск, выполняемый B<dlsym>(), охватывает всё "
"дерево зависимостей этих общих объектов)."

#. type: Plain text
#: man-pages/man3/dlsym.3:71
msgid ""
"In unusual cases (see NOTES) the value of the symbol could actually be "
"NULL.  Therefore, a NULL return from B<dlsym>()  need not indicate an "
"error.  The correct way to distinguish an error from a symbol whose value is "
"NULL is to call B<dlerror>(3)  to clear any old error conditions, then call "
"B<dlsym>(), and then call B<dlerror>(3)  again, saving its return value into "
"a variable, and check whether this saved value is not NULL."
msgstr ""
"В нестандартных ситуациях (смотрите ЗАМЕЧАНИЯ) в действительности значение "
"символа может быть NULL. Поэтому NULL, возвращаемый B<dlsym>(), ненужно "
"считать ошибкой. Правильным способом определения ошибки, если символ равен "
"NULL, является вызов B<dlerror>(3) для сброса старого состояния ошибки, а "
"затем вызов B<dlsym>(), и повторный вызов B<dlerror>(3), сохранение "
"полученного значения в переменную и проверка этого значения на NULL."

#. type: Plain text
#: man-pages/man3/dlsym.3:74
msgid ""
"There are two special pseudo-handles that may be specified in I<handle>:"
msgstr ""
"Существует два специальных псевдо-описателя, которые можно указать в "
"I<handle>:"

#. type: TP
#: man-pages/man3/dlsym.3:74
#, no-wrap
msgid "B<RTLD_DEFAULT>"
msgstr "B<RTLD_DEFAULT>"

#. type: Plain text
#: man-pages/man3/dlsym.3:83
msgid ""
"Find the first occurrence of the desired symbol using the default shared "
"object search order.  The search will include global symbols in the "
"executable and its dependencies, as well as symbols in shared objects that "
"were dynamically loaded with the B<RTLD_GLOBAL> flag."
msgstr ""
"Найти первое появление нужного символа, используя порядок поиска по "
"умолчанию для общего объекта. Поиск выполняется среди глобальных символов "
"исполняемого файла и его зависимостям, а также по символам в общих объектах, "
"которые были динамически загружены с флагом B<RTLD_GLOBAL>."

#. type: TP
#: man-pages/man3/dlsym.3:83
#, no-wrap
msgid "B<RTLD_NEXT>"
msgstr "B<RTLD_NEXT>"

#. type: Plain text
#: man-pages/man3/dlsym.3:97
msgid ""
"Find the next occurrence of the desired symbol in the search order after the "
"current object.  This allows one to provide a wrapper around a function in "
"another shared object, so that, for example, the definition of a function in "
"a preloaded shared object (see B<LD_PRELOAD> in B<ld.so>(8))  can find and "
"invoke the \"real\" function provided in another shared object (or for that "
"matter, the \"next\" definition of the function in cases where there are "
"multiple layers of preloading)."
msgstr ""
"Найти следующее появление нужного символа, начиная поиск с текущего объекта. "
"Это позволяет предоставить обёрточную функцию в другой общем объекте, таким "
"образом, что например, определение функции в предварительно загружаемом "
"общем объекте (смотрите B<LD_PRELOAD> в B<ld.so>(8)) может найти и вызвать "
"«реальную» функцию, предоставленную в другом общем объекте (или, что важно, "
"«следующее» определение функции в случаях, когда есть несколько уровней "
"предварительной загрузки)."

#. type: Plain text
#: man-pages/man3/dlsym.3:107
msgid ""
"The B<_GNU_SOURCE> feature test macro must be defined in order to obtain the "
"definitions of B<RTLD_DEFAULT> and B<RTLD_NEXT> from I<E<lt>dlfcn.hE<gt>>."
msgstr ""
"Чтобы получить определения B<RTLD_DEFAULT> и B<RTLD_NEXT> из I<E<lt>dlfcn."
"hE<gt>>, нужно задать макрос тестирования свойств B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man3/dlsym.3:114
msgid ""
"The function B<dlvsym>()  does the same as B<dlsym>()  but takes a version "
"string as an additional argument."
msgstr ""
"Функция B<dlvsym>() делает то же самое что и B<dlsym>(), но в качестве "
"дополнительного аргумента ожидает строку версии."

#. type: Plain text
#: man-pages/man3/dlsym.3:121
msgid ""
"On success, these functions return the address associated with I<symbol>.  "
"On failure, they return NULL; the cause of the error can be diagnosed using "
"B<dlerror>(3)."
msgstr ""
"При успешном выполнении эти функции возвращают адрес, связанный с I<symbol>. "
"При ошибке возвращается NULL; причину ошибки можно определить с помощью "
"B<dlerror>(3)."

#. type: Plain text
#: man-pages/man3/dlsym.3:126
msgid ""
"B<dlsym>()  is present in glibc 2.0 and later.  B<dlvsym>()  first appeared "
"in glibc 2.1."
msgstr ""
"Функция B<dlsym>() есть в glibc 2.0 и новее. Функция B<dlvsym>() впервые "
"появилась в glibc 2.1."

#. type: tbl table
#: man-pages/man3/dlsym.3:137
#, no-wrap
msgid ""
"B<dlsym>(),\n"
"B<dlvsym>()"
msgstr ""
"B<dlsym>(),\n"
"B<dlvsym>()"

#. type: Plain text
#: man-pages/man3/dlsym.3:145
msgid ""
"POSIX.1-2001 describes B<dlsym>().  The B<dlvsym>()  function is a GNU "
"extension."
msgstr ""
"В POSIX.1-2001 есть описание B<dlsym>(). Функция B<dlvsym>() является "
"расширением GNU."

#. type: Plain text
#: man-pages/man3/dlsym.3:157
msgid ""
"The value of a symbol returned by B<dlsym>()  will never be NULL if the "
"shared object is the result of normal compilation, since a global symbol is "
"never placed at the NULL address.  There are nevertheless cases where a "
"lookup using B<dlsym>()  may return NULL as the value of a symbol.  For "
"example, the symbol value may be the result of a GNU indirect function "
"(IFUNC) resolver function that returns NULL as the resolved value."
msgstr ""
"Значение символа, возвращаемое B<dlsym>(), никогда не будет равно NULL, если "
"общий объект является результатом нормальной компиляции, так как глобальный "
"символ никогда не размещается по адресу NULL. Тем не менее, есть ситуации, "
"при которых поиск с помощью B<dlsym>() может дать NULL в качестве значения "
"символа. Например, значение символа может быть результатом неявной "
"определительной функции GNU (IFUNC), которая возвращает NULL в качестве "
"определённого значения."

#. type: SS
#: man-pages/man3/dlsym.3:157
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man3/dlsym.3:163
msgid ""
"The B<dlsym>()  function is part of the dlopen API, derived from SunOS.  "
"That system does not have B<dlvsym>()."
msgstr ""
"Функция B<dlsym>() является частью программного интерфейса dlopen, "
"возникшего в SunOS. В этой системе нет B<dlvsym>()."

#. type: Plain text
#: man-pages/man3/dlsym.3:166
msgid "See B<dlopen>(3)."
msgstr "Смотрите B<dlopen>(3)."

#. type: Plain text
#: man-pages/man3/dlsym.3:172
msgid ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlinfo>(3), "
"B<dlopen>(3), B<ld.so>(8)"
msgstr ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlinfo>(3), "
"B<dlopen>(3), B<ld.so>(8)"

#. type: TH
#: man-pages/man3/duplocale.3:26
#, no-wrap
msgid "DUPLOCALE"
msgstr "DUPLOCALE"

#. type: Plain text
#: man-pages/man3/duplocale.3:29
msgid "duplocale - duplicate a locale object"
msgstr "duplocale - создаёт копию объекта локали"

#. type: Plain text
#: man-pages/man3/duplocale.3:32
#, no-wrap
msgid "B<#include E<lt>locale.hE<gt>>\n"
msgstr "B<#include E<lt>locale.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:34
#, no-wrap
msgid "B<locale_t duplocale(locale_t >I<locobj>B<);>\n"
msgstr "B<locale_t duplocale(locale_t >I<locobj>B<);>\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:42
msgid "B<duplocale>():"
msgstr "B<duplocale>():"

#. type: TP
#: man-pages/man3/duplocale.3:44
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man3/duplocale.3:47
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700"

#. type: TP
#: man-pages/man3/duplocale.3:47
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man3/duplocale.3:50
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/duplocale.3:57
msgid ""
"The B<duplocale>()  function creates a duplicate of the locale object "
"referred to by I<locobj>."
msgstr ""
"Функция B<duplocale>() создаёт копию объекта локали, на которую указывает "
"I<locobj>."

#. type: Plain text
#: man-pages/man3/duplocale.3:66
msgid ""
"If I<locobj> is B<LC_GLOBAL_LOCALE>, B<duplocale>()  creates a locale object "
"containing a copy of the global locale determined by B<setlocale>(3)."
msgstr ""
"Если значение I<locobj> равно B<LC_GLOBAL_LOCALE>, то B<duplocale>() создаёт "
"объект локали, содержащий копию глобальной локали, задаваемой "
"B<setlocale>(3)."

#. type: Plain text
#: man-pages/man3/duplocale.3:75
msgid ""
"On success, B<duplocale>()  returns a handle for the new locale object.  On "
"error, it returns I<(locale_t)\\ 0>, and sets I<errno> to indicate the cause "
"of the error."
msgstr ""
"При успешном выполнении B<duplocale>() возвращает описатель нового объекта "
"локали. При ошибке возвращается I<(locale_t)\\ 0>, а I<errno> присваивается "
"код ошибки."

#. type: TP
#: man-pages/man3/duplocale.3:76
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man3/duplocale.3:79
msgid "Insufficient memory to create the duplicate locale object."
msgstr "Недостаточно памяти для создания копии объекта локали."

#. type: Plain text
#: man-pages/man3/duplocale.3:83
msgid ""
"The B<duplocale>()  function first appeared in version 2.3 of the GNU C "
"library."
msgstr ""
"Функция B<duplocale>() впервые появилась в версии 2.3 библиотеки GNU C."

#. type: Plain text
#: man-pages/man3/duplocale.3:85
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/duplocale.3:87
msgid "Duplicating a locale can serve the following purposes:"
msgstr "Создание копии локали может пригодиться в следующих случаях:"

#. type: Plain text
#: man-pages/man3/duplocale.3:91
msgid ""
"To create a copy of a locale object in which one of more categories are to "
"be modified (using B<newlocale>(3))."
msgstr ""
"Для создания копии объекта локали, в которой одна или более категорий будут "
"изменены (с помощью B<newlocale>(3))."

#. type: Plain text
#: man-pages/man3/duplocale.3:98
msgid ""
"To obtain a handle for the current locale which can used in other functions "
"that employ a locale handle, such as B<toupper_l>(3).  This is done by "
"applying B<duplocale>()  to the value returned by the following call:"
msgstr ""
"Для получения описателя текущей локали, который может использоваться в "
"других функциях, таких как B<toupper_l>(3). Для этого B<duplocale>() "
"передаётся значение, полученное от следующего вызова:"

#. type: Plain text
#: man-pages/man3/duplocale.3:100
#, no-wrap
msgid "    loc = uselocale((locale_t) 0);\n"
msgstr "    loc = uselocale((locale_t) 0);\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:113
msgid ""
"This technique is necessary, because the above B<uselocale>(3)  call may "
"return the value B<LC_GLOBAL_LOCALE>, which results in undefined behavior if "
"passed to functions such as B<toupper_l>(3).  Calling B<duplocale>()  can be "
"used to ensure that the B<LC_GLOBAL_LOCALE> value is converted into a usable "
"locale object.  See EXAMPLE, below."
msgstr ""
"Такая последовательность необходима, так как вызов B<uselocale>(3) может "
"вернуть значение B<LC_GLOBAL_LOCALE>, которое вызовет непредсказуемое "
"поведение, если будет передано в функции, подобные B<toupper_l>(3). Вызов "
"B<duplocale>() можно использовать для проверки, что значение "
"B<LC_GLOBAL_LOCALE> преобразуется в подходящий объект локали. Смотрите "
"ПРИМЕР далее."

#. type: Plain text
#: man-pages/man3/duplocale.3:118
msgid ""
"Each locale object created by B<duplocale>()  should be deallocated using "
"B<freelocale>(3)."
msgstr ""
"Каждый объект локали, созданный B<duplocale>(), должен освобождаться с "
"помощью B<freelocale>(3)."

#. type: Plain text
#: man-pages/man3/duplocale.3:129
msgid ""
"The program below uses B<uselocale>(3)  and B<duplocale>()  to obtain a "
"handle for the current locale which is then passed to B<toupper_l>(3).  The "
"program takes one command-line argument, a string of characters that is "
"converted to uppercase and displayed on standard output.  An example of its "
"use is the following:"
msgstr ""
"Представленная ниже программа использует B<uselocale>(3) и B<duplocale>() "
"для получения описателя текущей локали, который затем передаётся в "
"B<toupper_l>(3). Программа распознаёт один аргумент командной строки, строку "
"символов, которая приводится к верхнему регистру и выводится в стандартный "
"вывод. Пример использования:"

#. type: Plain text
#: man-pages/man3/duplocale.3:134
#, no-wrap
msgid ""
"$ B<./a.out abc>\n"
"ABC\n"
msgstr ""
"$ B<./a.out abc>\n"
"ABC\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:144
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 700\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>locale.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE 700\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>locale.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:147
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:153
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    locale_t loc, nloc;\n"
"    char *p;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    locale_t loc, nloc;\n"
"    char *p;\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:158
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s string\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s строка\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:162
#, no-wrap
msgid ""
"    /* This sequence is necessary, because uselocale() might return\n"
"       the value LC_GLOBAL_LOCALE, which can\\(aqt be passed as an\n"
"       argument to toupper_l() */\n"
msgstr ""
"    /* Эта последовательность необходима, так как uselocale() может\n"
"       вернуть значение LC_GLOBAL_LOCALE, которое нельзя\n"
"       передавать как аргумент в toupper_l() */\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:166
#, no-wrap
msgid ""
"    loc = uselocale((locale_t) 0);\n"
"    if (loc == (locale_t) 0)\n"
"        errExit(\"uselocale\");\n"
msgstr ""
"    loc = uselocale((locale_t) 0);\n"
"    if (loc == (locale_t) 0)\n"
"        errExit(\"uselocale\");\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:170
#, no-wrap
msgid ""
"    nloc = duplocale(loc);\n"
"    if (nloc == (locale_t) 0)\n"
"        errExit(\"duplocale\");\n"
msgstr ""
"    nloc = duplocale(loc);\n"
"    if (nloc == (locale_t) 0)\n"
"        errExit(\"duplocale\");\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:173
#, no-wrap
msgid ""
"    for (p = argv[1]; *p; p++)\n"
"        putchar(toupper_l(*p, nloc));\n"
msgstr ""
"    for (p = argv[1]; *p; p++)\n"
"        putchar(toupper_l(*p, nloc));\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:175
#, no-wrap
msgid "    printf(\"\\en\");\n"
msgstr "    printf(\"\\en\");\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:177
#, no-wrap
msgid "    freelocale(nloc);\n"
msgstr "    freelocale(nloc);\n"

#. type: Plain text
#: man-pages/man3/duplocale.3:187
msgid ""
"B<freelocale>(3), B<newlocale>(3), B<setlocale>(3), B<uselocale>(3), "
"B<locale>(5), B<locale>(7)"
msgstr ""
"B<freelocale>(3), B<newlocale>(3), B<setlocale>(3), B<uselocale>(3), "
"B<locale>(5), B<locale>(7)"

#. type: TH
#: man-pages/man3/drand48.3:30
#, no-wrap
msgid "DRAND48"
msgstr "DRAND48"

#. type: Plain text
#: man-pages/man3/drand48.3:34
msgid ""
"drand48, erand48, lrand48, nrand48, mrand48, jrand48, srand48, seed48, "
"lcong48 - generate uniformly distributed pseudo-random numbers"
msgstr ""
"drand48, erand48, lrand48, nrand48, mrand48, jrand48, srand48, seed48, "
"lcong48 - генерация равномерно распределённых псевдослучайных чисел"

#. type: Plain text
#: man-pages/man3/drand48.3:39
#, no-wrap
msgid "B<double drand48(void);>\n"
msgstr "B<double drand48(void);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:41
#, no-wrap
msgid "B<double erand48(unsigned short >I<xsubi>B<[3]);>\n"
msgstr "B<double erand48(unsigned short >I<xsubi>B<[3]);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:43
#, no-wrap
msgid "B<long int lrand48(void);>\n"
msgstr "B<long int lrand48(void);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:45
#, no-wrap
msgid "B<long int nrand48(unsigned short >I<xsubi>B<[3]);>\n"
msgstr "B<long int nrand48(unsigned short >I<xsubi>B<[3]);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:47
#, no-wrap
msgid "B<long int mrand48(void);>\n"
msgstr "B<long int mrand48(void);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:49
#, no-wrap
msgid "B<long int jrand48(unsigned short >I<xsubi>B<[3]);>\n"
msgstr "B<long int jrand48(unsigned short >I<xsubi>B<[3]);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:51
#, no-wrap
msgid "B<void srand48(long int >I<seedval>B<);>\n"
msgstr "B<void srand48(long int >I<seedval>B<);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:53
#, no-wrap
msgid "B<unsigned short *seed48(unsigned short >I<seed16v>B<[3]);>\n"
msgstr "B<unsigned short *seed48(unsigned short >I<seed16v>B<[3]);>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:55
#, no-wrap
msgid "B<void lcong48(unsigned short >I<param>B<[7]);>\n"
msgstr "B<void lcong48(unsigned short >I<param>B<[7]);>\n"

#.  .BR drand48 (),
#.  .BR erand48 (),
#.  .BR lrand48 (),
#.  .BR nrand48 (),
#.  .BR mrand48 (),
#.  .BR jrand48 (),
#.  .BR srand48 (),
#.  .BR seed48 (),
#.  .BR lcong48 ():
#. type: Plain text
#: man-pages/man3/drand48.3:76
#, no-wrap
msgid ""
"All functions shown above:\n"
"_XOPEN_SOURCE\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""
"Для всех вышеуказанных функций:\n"
"_XOPEN_SOURCE\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии Glibc E<lt>= 2.19: */ _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/drand48.3:80
msgid ""
"These functions generate pseudo-random numbers using the linear congruential "
"algorithm and 48-bit integer arithmetic."
msgstr ""
"Данные функции генерируют псевдослучайные числа при помощи линейного "
"конгруэнтного метода и арифметики на основе 48-битного целого."

#. type: Plain text
#: man-pages/man3/drand48.3:88
msgid ""
"The B<drand48>()  and B<erand48>()  functions return nonnegative double-"
"precision floating-point values uniformly distributed over the interval [0.0,"
"\\ 1.0)."
msgstr ""
"Функции B<drand48>() и B<erand48>() возвращают неотрицательное значение в "
"формате с плавающей запятой двойной точности, равномерно распределённые в "
"диапазоне [0.0,\\ 1.0)."

#. type: Plain text
#: man-pages/man3/drand48.3:95
msgid ""
"The B<lrand48>()  and B<nrand48>()  functions return nonnegative long "
"integers uniformly distributed over the interval [0,\\ 2^31)."
msgstr ""
"Функции B<lrand48>() и B<nrand48>() возвращают неотрицательные целые числа "
"типа long, равномерно распределённые в интервале [0,\\ 2^31)."

#. type: Plain text
#: man-pages/man3/drand48.3:102
msgid ""
"The B<mrand48>()  and B<jrand48>()  functions return signed long integers "
"uniformly distributed over the interval [-2^31,\\ 2^31)."
msgstr ""
"Функции B<mrand48>() и B<jrand48>() возвращают целые числа типа long со "
"знаком, равномерно распределённые в интервале [-2^31,\\ 2^31)."

#. type: Plain text
#: man-pages/man3/drand48.3:121
msgid ""
"The B<srand48>(), B<seed48>()  and B<lcong48>()  functions are "
"initialization functions, one of which should be called before using "
"B<drand48>(), B<lrand48>()  or B<mrand48>().  The functions B<erand48>(), "
"B<nrand48>()  and B<jrand48>()  do not require an initialization function to "
"be called first."
msgstr ""
"Функции B<srand48>(), B<seed48>() и B<lcong48>() являются функциями-"
"инициализаторами и должны быть вызваны до использования B<drand48>(), "
"B<lrand48>() или B<mrand48>(). Функциям B<erand48>(), B<nrand48>() и "
"B<jrand48>() для первого вызова инициализаторы не требуются."

#. type: Plain text
#: man-pages/man3/drand48.3:125
msgid ""
"All the functions work by generating a sequence of 48-bit integers, I<Xi>, "
"according to the linear congruential formula:"
msgstr ""
"Все функции работают за счёт генерации последовательности 48-битных целых "
"чисел I<Xi> согласно формуле линейного конгруэнтного метода:"

#. type: Plain text
#: man-pages/man3/drand48.3:129
#, no-wrap
msgid "B<Xn+1 = (aXn + c) mod m, where n E<gt>= 0>\n"
msgstr "B<Xn+1 = (aXn + c) mod m, где n E<gt>= 0>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:142
msgid ""
"The parameter I<m> = 2^48, hence 48-bit integer arithmetic is performed.  "
"Unless B<lcong48>()  is called, I<a> and I<c> are given by:"
msgstr ""
"Параметр I<m> = 2^48, поэтому в вычислениях используются 48-битные целые "
"числа. Если B<lcong48>() не вызывалась, то I<a> и I<c> принимают следующие "
"значения:"

#. type: Plain text
#: man-pages/man3/drand48.3:147
#, no-wrap
msgid ""
"B<a = 0x5DEECE66D>\n"
"B<c = 0xB>\n"
msgstr ""
"B<a = 0x5DEECE66D>\n"
"B<c = 0xB>\n"

#. type: Plain text
#: man-pages/man3/drand48.3:167
msgid ""
"The value returned by any of the functions B<drand48>(), B<erand48>(), "
"B<lrand48>(), B<nrand48>(), B<mrand48>()  or B<jrand48>()  is computed by "
"first generating the next 48-bit I<Xi> in the sequence.  Then the "
"appropriate number of bits, according to the type of data item to be "
"returned, is copied from the high-order bits of I<Xi> and transformed into "
"the returned value."
msgstr ""
"Для получения значения, возвращаемого любой из функций (B<drand48>(), "
"B<erand48>(), B<lrand48>(), B<nrand48>(), B<mrand48>() или B<jrand48>()), "
"сначала генерируется следующее 48-битное I<Xi> в последовательности. Затем "
"подходящее число бит (согласно типу возвращаемых данных) копируется в "
"верхние биты I<Xi> и трансформируется во возвращаемое значение."

#. type: Plain text
#: man-pages/man3/drand48.3:193
msgid ""
"The functions B<drand48>(), B<lrand48>()  and B<mrand48>()  store the last "
"48-bit I<Xi> generated in an internal buffer.  The functions B<erand48>(), "
"B<nrand48>()  and B<jrand48>()  require the calling program to provide "
"storage for the successive I<Xi> values in the array argument I<xsubi>.  The "
"functions are initialized by placing the initial value of I<Xi> into the "
"array before calling the function for the first time."
msgstr ""
"Функции B<drand48>(), B<lrand48>() и B<mrand48>() сохраняют последнее "
"сгенерированное 48-битное значение I<Xi> во внутреннем буфере. Для функций "
"B<erand48>(), B<nrand48>() и B<jrand48>() требуется, чтобы вызывающая "
"программа создавала хранилище для последующих значений I<Xi> и указывала его "
"в аргументе-массиве I<xsubi>. Функции инициализируются путём помещения "
"начального значения I<Xi> в массив до их первого вызова."

#. type: Plain text
#: man-pages/man3/drand48.3:202
msgid ""
"The initializer function B<srand48>()  sets the high order 32-bits of I<Xi> "
"to the argument I<seedval>.  The low order 16-bits are set to the arbitrary "
"value 0x330E."
msgstr ""
"Функция инициализации B<srand48>() устанавливает верхние 32 бита I<Xi> в "
"аргументе I<seedval>. Нижние 16 бит устанавливаются в обязательное значение "
"0x330E."

#. type: Plain text
#: man-pages/man3/drand48.3:216
msgid ""
"The initializer function B<seed48>()  sets the value of I<Xi> to the 48-bit "
"value specified in the array argument I<seed16v>.  The previous value of "
"I<Xi> is copied into an internal buffer and a pointer to this buffer is "
"returned by B<seed48>()."
msgstr ""
"Функция инициализации B<seed48>() устанавливает I<Xi> в 48-битное значение, "
"указанное в аргументе-массиве I<seed16v>. Предыдущее значение I<Xi> "
"копируется во внутренний буфер, указатель на который возвращается "
"B<seed48>()."

#. type: Plain text
#: man-pages/man3/drand48.3:247
msgid ""
"The initialization function B<lcong48>()  allows the user to specify initial "
"values for I<Xi>, I<a> and I<c>.  Array argument elements I<param[0-2]> "
"specify I<Xi>, I<param[3-5]> specify I<a>, and I<param[6]> specifies I<c>.  "
"After B<lcong48>()  has been called, a subsequent call to either "
"B<srand48>()  or B<seed48>()  will restore the standard values of I<a> and "
"I<c>."
msgstr ""
"Функция инициализации B<lcong48>() позволяет пользователю указывать "
"первоначальные значения для I<Xi>, I<a> и I<c>. Для I<Xi> используется "
"аргумент массива I<param[0-2]>, для I<a> \\(em I<param[3-5]>, а для I<c> "
"\\(em I<param[6]>. После вызова B<lcong48>() следующий вызов B<srand48>() "
"или B<seed48>() восстановит стандартные значения I<a> и I<c>."

#. type: tbl table
#: man-pages/man3/drand48.3:266
#, no-wrap
msgid ""
"B<drand48>(),\n"
"B<erand48>(),\n"
"B<lrand48>(),\n"
"B<nrand48>(),\n"
"B<mrand48>(),\n"
"B<jrand48>(),\n"
"B<srand48>(),\n"
"B<seed48>(),\n"
"B<lcong48>()"
msgstr ""
"B<drand48>(),\n"
"B<erand48>(),\n"
"B<lrand48>(),\n"
"B<nrand48>(),\n"
"B<mrand48>(),\n"
"B<jrand48>(),\n"
"B<srand48>(),\n"
"B<seed48>(),\n"
"B<lcong48>()"

#. type: tbl table
#: man-pages/man3/drand48.3:268
#, no-wrap
msgid "MT-Unsafe race:drand48"
msgstr "MT-Unsafe race:drand48"

#. type: Plain text
#: man-pages/man3/drand48.3:275
msgid ""
"The above functions record global state information for the random number "
"generator, so they are not thread-safe."
msgstr ""
"Перечисленные выше функции записывают информацию о глобальном состоянии "
"генератора случайных чисел, поэтому их нельзя использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/drand48.3:277
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#. type: Plain text
#: man-pages/man3/drand48.3:279
msgid "B<rand>(3), B<random>(3)"
msgstr "B<rand>(3), B<random>(3)"

#. type: TH
#: man-pages/man3/dlinfo.3:26
#, no-wrap
msgid "DLINFO"
msgstr "DLINFO"

#. type: Plain text
#: man-pages/man3/dlinfo.3:29
msgid "dlinfo - obtain information about a dynamically loaded object"
msgstr "dlinfo - возвращает информацию о динамически загруженном объекте"

#. type: Plain text
#: man-pages/man3/dlinfo.3:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>link.hE<gt>>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>link.hE<gt>>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:36
#, no-wrap
msgid "B<int dlinfo(void *>handleB<, int >requestB<, void *>infoB<);>\n"
msgstr "B<int dlinfo(void *>handleB<, int >requestB<, void *>infoB<);>\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:38
#, no-wrap
msgid "Link with I<-ldl>.\n"
msgstr "Компонуется при указании параметра I<-ldl>.\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:57
msgid ""
"The B<dlinfo>()  function obtains information about the dynamically loaded "
"object referred to by I<handle> (typically obtained by an earlier call to "
"B<dlopen>(3)  or B<dlmopen>(3)).  The I<request> argument specifies which "
"information is to be returned.  The I<info> argument is a pointer to a "
"buffer used to store information returned by the call; the type of this "
"argument depends on I<request>."
msgstr ""
"Функция B<dlinfo>() возвращает информацию о динамически загруженном объекте, "
"на который указывает I<handle> (обычно полученный ранее вызовом B<dlopen>(3) "
"или B<dlmopen>(3)). В аргументе I<request> указывается какую информацию "
"нужно получить. Аргумент I<info> — указатель на буфер для хранения "
"информации, возвращаемой вызовом; тип данного аргумента зависит от "
"I<request>."

#. type: Plain text
#: man-pages/man3/dlinfo.3:63
msgid ""
"The following values are supported for I<request> (with the corresponding "
"type for I<info> shown in parentheses):"
msgstr ""
"Для I<request> поддерживаются следующие значения (соответствующий тип "
"I<info> показан в скобках):"

#. type: TP
#: man-pages/man3/dlinfo.3:63
#, no-wrap
msgid "B<RTLD_DI_LMID> (I<Lmid_t *>)"
msgstr "B<RTLD_DI_LMID> (I<Lmid_t *>)"

#. type: Plain text
#: man-pages/man3/dlinfo.3:68
msgid ""
"Obtain the ID of the link-map list (namespace) in which I<handle> is loaded."
msgstr ""
"Возвратить ID списка карты связи (link-map list, пространство имён), в "
"который загружен I<handle>."

#. type: TP
#: man-pages/man3/dlinfo.3:68
#, no-wrap
msgid "B<RTLD_DI_LINKMAP> (I<struct link_map **>)"
msgstr "B<RTLD_DI_LINKMAP> (I<struct link_map **>)"

#. type: Plain text
#: man-pages/man3/dlinfo.3:81
msgid ""
"Obtain a pointer to the I<link_map> structure corresponding to I<handle>.  "
"The I<info> argument points to a pointer to a I<link_map> structure, defined "
"in I<E<lt>link.hE<gt>> as:"
msgstr ""
"Возвратить указатель на структуру I<link_map>, соответствующую I<handle>. "
"Аргумент I<info> указывает на указатель на структуру I<link_map>, "
"определённую в I<E<lt>link.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man3/dlinfo.3:94
#, no-wrap
msgid ""
"struct link_map {\n"
"    ElfW(Addr) l_addr;  /* Difference between the\n"
"                           address in the ELF file and\n"
"                           the address in memory */\n"
"    char      *l_name;  /* Absolute pathname where\n"
"                           object was found */\n"
"    ElfW(Dyn) *l_ld;    /* Dynamic section of the\n"
"                           shared object */\n"
"    struct link_map *l_next, *l_prev;\n"
"                        /* Chain of loaded objects */\n"
msgstr ""
"struct link_map {\n"
"    ElfW(Addr) l_addr;  /* разница между\n"
"                           адресом в файле ELF и\n"
"                           адресом в памяти */\n"
"    char      *l_name;  /* абсолютный путь, где \n"
"                           был найден объект */\n"
"    ElfW(Dyn) *l_ld;    /* динамический раздел\n"
"                           общего объекта */\n"
"    struct link_map *l_next, *l_prev;\n"
"                        /* цепочка загруженных объектов */\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:98
#, no-wrap
msgid ""
"    /* Plus additional fields private to the\n"
"       implementation */\n"
"};\n"
msgstr ""
"    /* дополнительные поля, зависящие от\n"
"       реализации */\n"
"};\n"

#. type: TP
#: man-pages/man3/dlinfo.3:100
#, no-wrap
msgid "B<RTLD_DI_ORIGIN> (I<char *>)"
msgstr "B<RTLD_DI_ORIGIN> (I<char *>)"

#. type: Plain text
#: man-pages/man3/dlinfo.3:106
msgid ""
"Copy the pathname of the origin of the shared object corresponding to "
"I<handle> to the location pointed to by I<info>."
msgstr ""
"Скопировать путь источника общего объекта соответствующего I<handle> в "
"место, указанное I<info>."

#. type: TP
#: man-pages/man3/dlinfo.3:106
#, no-wrap
msgid "B<RTLD_DI_SERINFO> (I<Dl_serinfo *>)"
msgstr "B<RTLD_DI_SERINFO> (I<Dl_serinfo *>)"

#. type: Plain text
#: man-pages/man3/dlinfo.3:123
msgid ""
"Obtain the library search paths for the shared object referred to by "
"I<handle>.  The I<info> argument is a pointer to a I<Dl_serinfo> that "
"contains the search paths.  Because the number of search paths may vary, the "
"size of the structure pointed to by I<info> can vary.  The "
"B<RTLD_DI_SERINFOSIZE> request described below allows applications to size "
"the buffer suitably.  The caller must perform the following steps:"
msgstr ""
"Возвратить пути поиска библиотек общего объекта, на который указывает "
"I<handle>. Аргумент I<info> — указатель на I<Dl_serinfo> с путями поиска. "
"Так как количество путей поиска может быть разным, то размер структуры, на "
"которую указывает I<info>, может быть различным. Запрос "
"B<RTLD_DI_SERINFOSIZE>, описанный далее, позволяет приложению установить "
"подходящий размер. Вызывающий должен выполнить следующие шаги:"

#. type: Plain text
#: man-pages/man3/dlinfo.3:134
msgid ""
"Use a B<RTLD_DI_SERINFOSIZE> request to populate a I<Dl_serinfo> structure "
"with the size (I<dls_size>)  of the structure needed for the subsequent "
"B<RTLD_DI_SERINFO> request."
msgstr ""
"Использовать запрос B<RTLD_DI_SERINFOSIZE> для заполнения структуры "
"I<Dl_serinfo> размером (I<dls_size>) структуры, необходимой для последующего "
"запроса B<RTLD_DI_SERINFO>."

#. type: Plain text
#: man-pages/man3/dlinfo.3:139
msgid "Allocate a I<Dl_serinfo> buffer of the correct size (I<dls_size>)."
msgstr "Выделить буфер I<Dl_serinfo> правильного размера (I<dls_size>)."

#. type: Plain text
#: man-pages/man3/dlinfo.3:147
msgid ""
"Use a further B<RTLD_DI_SERINFOSIZE> request to populate the I<dls_size> and "
"I<dls_cnt> fields of the buffer allocated in the previous step."
msgstr ""
"Использовать запрос B<RTLD_DI_SERINFOSIZE> для заполнения полей I<dls_size> "
"и I<dls_cnt> буфера, выделенного на предыдущем шаге."

#. type: IP
#: man-pages/man3/dlinfo.3:147
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man3/dlinfo.3:151
msgid "Use a B<RTLD_DI_SERINFO> to obtain the library search paths."
msgstr "Использовать B<RTLD_DI_SERINFO> для получения путей поиска библиотек."

#. type: Plain text
#: man-pages/man3/dlinfo.3:157
msgid "The I<Dl_serinfo> structure is defined as follows:"
msgstr "Структура I<Dl_serinfo> определена следующим образом:"

#. type: Plain text
#: man-pages/man3/dlinfo.3:168
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t dls_size;           /* Size in bytes of\n"
"                                  the whole buffer */\n"
"    unsigned int dls_cnt;      /* Number of elements\n"
"                                  in 'dls_serpath' */\n"
"    Dl_serpath dls_serpath[1]; /* Actually longer,\n"
"                                  'dls_cnt' elements */\n"
"} Dl_serinfo;\n"
msgstr ""
"typedef struct {\n"
"    size_t dls_size;           /* размер в байтах\n"
"                                  всего буфера */\n"
"    unsigned int dls_cnt;      /* количество элементов\n"
"                                  в «dls_serpath» */\n"
"    Dl_serpath dls_serpath[1]; /* на самом деле больше,\n"
"                                  элементы «dls_cnt» */\n"
"} Dl_serinfo;\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:174
msgid ""
"Each of the I<dls_serpath> elements in the above structure is a structure of "
"the following form:"
msgstr ""
"Каждый из элементов I<dls_serpath>, в упомянутой выше структуре, "
"представляет собой структуру следующего вида:"

#. type: Plain text
#: man-pages/man3/dlinfo.3:183
#, no-wrap
msgid ""
"typedef struct {\n"
"    char *dls_name;            /* Name of library search\n"
"                                  path directory */\n"
"    unsigned int dls_flags;    /* Indicates where this\n"
"                                  directory came from */\n"
"} Dl_serpath;\n"
msgstr ""
"typedef struct {\n"
"    char *dls_name;            /* имя каталога в\n"
"                                   путях поиска библиотек */\n"
"    unsigned int dls_flags;    /* показывает, откуда\n"
"                                  возник каталог */\n"
"} Dl_serpath;\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:189
msgid "The I<dls_flags> field is currently unused, and always contains zero."
msgstr ""
"Поле I<dls_flags> в настоящее время не используется и всегда равно нулю."

#. type: TP
#: man-pages/man3/dlinfo.3:189
#, no-wrap
msgid "B<RTLD_DI_SERINFOSIZE> (I<Dl_serinfo *>)"
msgstr "B<RTLD_DI_SERINFOSIZE> (I<Dl_serinfo *>)"

#. type: Plain text
#: man-pages/man3/dlinfo.3:202
msgid ""
"Populate the I<dls_size> and I<dls_cnt> fields of the I<Dl_serinfo> "
"structure pointed to by I<info> with values suitable for allocating a buffer "
"for use in a subsequent B<RTLD_DI_SERINFO> request."
msgstr ""
"Заполнить поля I<dls_size> и I<dls_cnt> структуры I<Dl_serinfo>, на которую "
"указывает I<info>, значениями, подходящими для выделения буфера, который "
"будет использоваться в последующем запросе B<RTLD_DI_SERINFO>."

#. type: TP
#: man-pages/man3/dlinfo.3:202
#, no-wrap
msgid "B<RTLD_DI_TLS_MODID> (I<size_t *>, since glibc 2.4)"
msgstr "B<RTLD_DI_TLS_MODID> (I<size_t *>, начиная с glibc 2.4)"

#. type: Plain text
#: man-pages/man3/dlinfo.3:208
msgid ""
"Obtain the module ID of this shared object's TLS (thread-local storage)  "
"segment, as used in TLS relocations.  If this object does not define a TLS "
"segment, zero is placed in I<*info>."
msgstr ""
"Получить ID модуля сегмента TLS (локальное хранилище нити) общего объекта, "
"которое используется в перемещениях TLS. Если этот объект не задаёт сегмент "
"TLS, то в I<*info> помещается ноль."

#. type: TP
#: man-pages/man3/dlinfo.3:208
#, no-wrap
msgid "B<RTLD_DI_TLS_DATA> (I<void **>, since glibc 2.4)"
msgstr "B<RTLD_DI_TLS_DATA> (I<void **>, начиная с glibc 2.4)"

#. type: Plain text
#: man-pages/man3/dlinfo.3:216
msgid ""
"Obtain a pointer to the calling thread's TLS block corresponding to this "
"shared object's TLS segment.  If this object does not define a PT_TLS "
"segment, or if the calling thread has not allocated a block for it, NULL is "
"placed in I<*info>."
msgstr ""
"Получить указатель на блок TLS вызывающей нити, соответствующий этому "
"сегменту TLS общего объекта. Если этот объект не задаёт сегмент PT_TLS, или "
"если у вызывающей нити для этого не выделен блок, то в I<*info> помещается "
"NULL."

#. type: Plain text
#: man-pages/man3/dlinfo.3:222
msgid ""
"On success, B<dlinfo>()  returns 0.  On failure, it returns -1; the cause of "
"the error can be diagnosed using B<dlerror>(3)."
msgstr ""
"При успешном выполнении B<dlinfo>() возвращает 0. При ошибке возвращается "
"-1; причину ошибки можно узнать с помощью B<dlerror>(3)."

#. type: Plain text
#: man-pages/man3/dlinfo.3:225
msgid "B<dlinfo>()  first appeared in glibc 2.3.3."
msgstr "Функция B<dlinfo>() впервые появилась в glibc версии 2.3.3."

#. type: tbl table
#: man-pages/man3/dlinfo.3:235
#, no-wrap
msgid "B<dlinfo>()"
msgstr "B<dlinfo>()"

#. type: Plain text
#: man-pages/man3/dlinfo.3:239
msgid "This function is a nonstandard GNU extension."
msgstr "Эта функция является нестандартным расширением GNU."

#. type: Plain text
#: man-pages/man3/dlinfo.3:244
msgid ""
"This function derives from the Solaris function of the same name and also "
"appears on some other systems.  The sets of requests supported by the "
"various implementations overlaps only partially."
msgstr ""
"Данная функция произошла от функции Solaris с тем же именем, а также есть в "
"некоторых других системах. Набор запросов, поддерживаемых различными "
"реализациями, перекрывается лишь частично."

#. type: Plain text
#: man-pages/man3/dlinfo.3:253
msgid ""
"The program below opens a shared objects using B<dlopen>(3)  and then uses "
"the B<RTLD_DI_SERINFOSIZE> and B<RTLD_DI_SERINFO> requests to obtain the "
"library search path list for the library.  Here is an example of what we "
"might see when running the program:"
msgstr ""
"Программа, показанная ниже, открывает общие объекты с помощью B<dlopen>(3), "
"а затем использует запросы B<RTLD_DI_SERINFOSIZE> и B<RTLD_DI_SERINFO> для "
"получения библиотеки из списка путей поиска библиотек. Пример вывода работы "
"программы:"

#. type: Plain text
#: man-pages/man3/dlinfo.3:259
#, no-wrap
msgid ""
"$ B<./a.out /lib64/libm.so.6>\n"
"dls_serpath[0].dls_name = /lib64\n"
"dls_serpath[1].dls_name = /usr/lib64\n"
msgstr ""
"$ B<./a.out /lib64/libm.so.6>\n"
"dls_serpath[0].dls_name = /lib64\n"
"dls_serpath[1].dls_name = /usr/lib64\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:269
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:277
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    void *handle;\n"
"    Dl_serinfo serinfo;\n"
"    Dl_serinfo *sip;\n"
"    int j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    void *handle;\n"
"    Dl_serinfo serinfo;\n"
"    Dl_serinfo *sip;\n"
"    int j;\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:282
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>libpathE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>libpathE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:284
#, no-wrap
msgid "    /* Obtain a handle for shared object specified on command line */\n"
msgstr "    /* получаем описатель общего объекта, указанного в командной строке */\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:290
#, no-wrap
msgid ""
"    handle = dlopen(argv[1], RTLD_NOW);\n"
"    if (handle == NULL) {\n"
"        fprintf(stderr, \"dlopen() failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    handle = dlopen(argv[1], RTLD_NOW);\n"
"    if (handle == NULL) {\n"
"        fprintf(stderr, \"ошибка dlopen(): %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:293
#, no-wrap
msgid ""
"    /* Discover the size of the buffer that we must pass to\n"
"       RTLD_DI_SERINFO */\n"
msgstr ""
"    /* определяем размер буфера, который мы должны передать\n"
"       RTLD_DI_SERINFO */\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:298
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, &serinfo) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, &serinfo) == -1) {\n"
"        fprintf(stderr, \"ошибка RTLD_DI_SERINFOSIZE: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:300
#, no-wrap
msgid "    /* Allocate the buffer for use with RTLD_DI_SERINFO */\n"
msgstr "    /* выделяем буфер для RTLD_DI_SERINFO */\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:306
#, no-wrap
msgid ""
"    sip = malloc(serinfo.dls_size);\n"
"    if (sip == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sip = malloc(serinfo.dls_size);\n"
"    if (sip == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:309
#, no-wrap
msgid ""
"    /* Initialize the \\(aqdls_size\\(aq and \\(aqdls_cnt\\(aq fields in the newly\n"
"       allocated buffer */\n"
msgstr ""
"    /* инициализируем поля \\(aqdls_size\\(aq и \\(aqdls_cnt\\(aq в только\n"
"       что выделенном буфере */\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:314
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFOSIZE failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (dlinfo(handle, RTLD_DI_SERINFOSIZE, sip) == -1) {\n"
"        fprintf(stderr, \"ошибка RTLD_DI_SERINFOSIZE: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:316
#, no-wrap
msgid "    /* Fetch and print library search list */\n"
msgstr "    /* получаем и печатаем список поиска библиотек */\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:321
#, no-wrap
msgid ""
"    if (dlinfo(handle, RTLD_DI_SERINFO, sip) == -1) {\n"
"        fprintf(stderr, \"RTLD_DI_SERINFO failed: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (dlinfo(handle, RTLD_DI_SERINFO, sip) == -1) {\n"
"        fprintf(stderr, \"ошибка RTLD_DI_SERINFO: %s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:325
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> serinfo.dls_cnt; j++)\n"
"        printf(\"dls_serpath[%d].dls_name = %s\\en\",\n"
"                j, sip-E<gt>dls_serpath[j].dls_name);\n"
msgstr ""
"    for (j = 0; j E<lt> serinfo.dls_cnt; j++)\n"
"        printf(\"dls_serpath[%d].dls_name = %s\\en\",\n"
"                j, sip-E<gt>dls_serpath[j].dls_name);\n"

#. type: Plain text
#: man-pages/man3/dlinfo.3:335
msgid ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlopen>(3), "
"B<dlsym>(3), B<ld.so>(8)"
msgstr ""
"B<dl_iterate_phdr>(3), B<dladdr>(3), B<dlerror>(3), B<dlopen>(3), "
"B<dlsym>(3), B<ld.so>(8)"

#. type: TH
#: man-pages/man3/difftime.3:30
#, no-wrap
msgid "DIFFTIME"
msgstr "DIFFTIME"

#. type: TH
#: man-pages/man3/difftime.3:30
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: man-pages/man3/difftime.3:33
msgid "difftime - calculate time difference"
msgstr "difftime - вычисляет разницу во времени"

#. type: Plain text
#: man-pages/man3/difftime.3:36
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr "B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/difftime.3:38
#, no-wrap
msgid "B<double difftime(time_t >I<time1>B<, time_t >I<time0>B<);>\n"
msgstr "B<double difftime(time_t >I<time1>B<, time_t >I<time0>B<);>\n"

#. type: Plain text
#: man-pages/man3/difftime.3:48
msgid ""
"The B<difftime>()  function returns the number of seconds elapsed between "
"time I<time1> and time I<time0>, represented as a I<double>.  Each of the "
"times is specified in calendar time, which means its value is a measurement "
"(in seconds) relative to the Epoch, 1970-01-01 00:00:00 +0000 (UTC)."
msgstr ""
"Функция B<difftime>() возвращает количество секунд, прошедших со времени "
"I<time1> и до времени I<time0>, представленного типом I<double>. Оба времени "
"должны быть календарным временем, т. е. временем (в секундах), прошедшем с "
"начала эпохи (с 00:00:00 1 января 1970 года всеобщего скоординированного "
"времени (UTC))."

#. type: tbl table
#: man-pages/man3/difftime.3:58
#, no-wrap
msgid "B<difftime>()"
msgstr "B<difftime>()"

#. type: Plain text
#: man-pages/man3/difftime.3:62
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/difftime.3:67
msgid ""
"On a POSIX system, I<time_t> is an arithmetic type, and one could just define"
msgstr ""
"В системе POSIX значение I<time_t> является числом и функция может быть "
"просто определена как"

#. type: Plain text
#: man-pages/man3/difftime.3:71
#, no-wrap
msgid "#define difftime(t1,t0) (double)(t1 - t0)\n"
msgstr "#define difftime(t1,t0) (double)(t1 - t0)\n"

#. type: Plain text
#: man-pages/man3/difftime.3:75
msgid "when the possible overflow in the subtraction is not a concern."
msgstr "когда возможное переполнение при вычитании не проблема."

#. type: Plain text
#: man-pages/man3/difftime.3:81
msgid ""
"B<date>(1), B<gettimeofday>(2), B<time>(2), B<ctime>(3), B<gmtime>(3), "
"B<localtime>(3)"
msgstr ""
"B<date>(1), B<gettimeofday>(2), B<time>(2), B<ctime>(3), B<gmtime>(3), "
"B<localtime>(3)"

#. type: TH
#: man-pages/man3/dysize.3:26
#, no-wrap
msgid "DYSIZE"
msgstr "DYSIZE"

#. type: TH
#: man-pages/man3/dysize.3:26
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: man-pages/man3/dysize.3:29
msgid "dysize - get number of days for a given year"
msgstr "dysize - возвращает количество дней в указанном году"

#. type: Plain text
#: man-pages/man3/dysize.3:31
msgid "B<#include E<lt>time.hE<gt>>"
msgstr "B<#include E<lt>time.hE<gt>>"

#. type: Plain text
#: man-pages/man3/dysize.3:33
msgid "B<int dysize(int >I<year>B<);>"
msgstr "B<int dysize(int >I<year>B<);>"

#. type: Plain text
#: man-pages/man3/dysize.3:44
#, no-wrap
msgid ""
"B<dysize>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"B<dysize>():\n"
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc 2.19 и старее:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/dysize.3:47
msgid ""
"The function returns 365 for a normal year and 366 for a leap year.  The "
"calculation for leap year is based on:"
msgstr ""
"Функция возвращает 365 для обычного года и 366 — для високосного. Подсчёт "
"високосного года основан на формуле:"

#. type: Plain text
#: man-pages/man3/dysize.3:51
#, no-wrap
msgid "(year) %4 == 0 && ((year) %100 != 0 || (year) %400 == 0)\n"
msgstr "(year) %4 == 0 && ((year) %100 != 0 || (year) %400 == 0)\n"

#. type: Plain text
#: man-pages/man3/dysize.3:58
msgid ""
"The formula is defined in the macro I<__isleap(year)> also found in "
"I<E<lt>time.hE<gt>>."
msgstr ""
"Формула определена в макросе I<__isleap(year)>, также находящемся в "
"I<E<lt>time.hE<gt>>."

#. type: tbl table
#: man-pages/man3/dysize.3:68
#, no-wrap
msgid "B<dysize>()"
msgstr "B<dysize>()"

#. type: Plain text
#: man-pages/man3/dysize.3:72
msgid "This function occurs in SunOS 4.x."
msgstr "Функция появилась в SunOS 4.x."

#.  The SCO version of this function had a year-2000 problem.
#. type: Plain text
#: man-pages/man3/dysize.3:76
msgid "This is a compatibility function only.  Don't use it in new programs."
msgstr ""
"Функция введена только для совместимости. Не используйте её в новых "
"программах."

#. type: Plain text
#: man-pages/man3/dysize.3:77
msgid "B<strftime>(3)"
msgstr "B<strftime>(3)"

#. type: TH
#: man-pages/man3/div.3:34
#, no-wrap
msgid "DIV"
msgstr "DIV"

#. type: Plain text
#: man-pages/man3/div.3:38
msgid ""
"div, ldiv, lldiv, imaxdiv - compute quotient and remainder of an integer "
"division"
msgstr ""
"div, ldiv, lldiv, imaxdiv - вычисляет частное и остаток деления целого числа"

#. type: Plain text
#: man-pages/man3/div.3:45
#, no-wrap
msgid ""
"B<div_t div(int >I<numerator>B<, int >I<denominator>B<);>\n"
"B<ldiv_t ldiv(long >I<numerator>B<, long >I<denominator>B<);>\n"
"B<lldiv_t lldiv(long long >I<numerator>B<, long long >I<denominator>B<);>\n"
msgstr ""
"B<div_t div(int >I<numerator>B<, int >I<denominator>B<);>\n"
"B<ldiv_t ldiv(long >I<numerator>B<, long >I<denominator>B<);>\n"
"B<lldiv_t lldiv(long long >I<numerator>B<, long long >I<denominator>B<);>\n"

#. type: Plain text
#: man-pages/man3/div.3:47
#, no-wrap
msgid "B<#include E<lt>inttypes.hE<gt>>\n"
msgstr "B<#include E<lt>inttypes.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/div.3:49
#, no-wrap
msgid "B<imaxdiv_t imaxdiv(intmax_t >I<numerator>B<, intmax_t >I<denominator>B<);>\n"
msgstr "B<imaxdiv_t imaxdiv(intmax_t >I<numerator>B<, intmax_t >I<denominator>B<);>\n"

#. type: Plain text
#: man-pages/man3/div.3:58
msgid "B<lldiv>():"
msgstr "B<lldiv>():"

#. type: Plain text
#: man-pages/man3/div.3:60
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/div.3:72
msgid ""
"The B<div>()  function computes the value I<numerator>/I<denominator> and "
"returns the quotient and remainder in a structure named I<div_t> that "
"contains two integer members (in unspecified order) named I<quot> and "
"I<rem>.  The quotient is rounded toward zero.  The result satisfies "
"I<quot>*I<denominator>+I<rem> = I<numerator>."
msgstr ""
"Функция B<div>() вычисляет величину I<numerator>/I<denominator> и возвращает "
"частное и остаток в структуре I<div_t>, которая содержит два целочисленных "
"поля (в неопределённом порядке) I<quot> и I<rem>. Частное округляется до "
"ближайшего нуля. Результат равняется I<quot>*I<denominator>+I<rem> = "
"I<numerator>."

#. type: Plain text
#: man-pages/man3/div.3:83
msgid ""
"The B<ldiv>(), B<lldiv>(), and B<imaxdiv>()  functions do the same, dividing "
"numbers of the indicated type and returning the result in a structure of the "
"indicated name, in all cases with fields I<quot> and I<rem> of the same type "
"as the function arguments."
msgstr ""
"Функции B<ldiv>(), B<lldiv>() и B<imaxdiv>() выполняют эту же функцию, деля "
"числа соответствующего типа и возвращая результат в структуре с "
"соответствующим именем, всегда с полями I<quot> и I<rem> того же типа, что и "
"аргументы функции."

#. type: Plain text
#: man-pages/man3/div.3:85
msgid "The I<div_t> (etc.) structure."
msgstr "Структура I<div_t> (и т. д.)."

#. type: tbl table
#: man-pages/man3/div.3:98
#, no-wrap
msgid ""
"B<div>(),\n"
"B<ldiv>(),\n"
"B<lldiv>(),\n"
"B<imaxdiv>()"
msgstr ""
"B<div>(),\n"
"B<ldiv>(),\n"
"B<lldiv>(),\n"
"B<imaxdiv>()"

#. type: Plain text
#: man-pages/man3/div.3:107
msgid ""
"POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD.  The functions "
"B<lldiv>()  and B<imaxdiv>()  were added in C99."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD. Функции B<lldiv>() и "
"B<imaxdiv>() добавлены в C99."

#. type: Plain text
#: man-pages/man3/div.3:109
msgid "After"
msgstr "После"

#. type: Plain text
#: man-pages/man3/div.3:113
#, no-wrap
msgid "div_t q = div(-5, 3);\n"
msgstr "div_t q = div(-5, 3);\n"

#. type: Plain text
#: man-pages/man3/div.3:117
msgid "the values I<q.quot> and I<q.rem> are -1 and -2, respectively."
msgstr "значения I<q.quot> и I<q.rem> равны -1 и -2, соответственно."

#. type: Plain text
#: man-pages/man3/div.3:119
msgid "B<abs>(3), B<remainder>(3)"
msgstr "B<abs>(3), B<remainder>(3)"

#. type: TH
#: man-pages/man3/dlopen.3:35
#, no-wrap
msgid "DLOPEN"
msgstr "DLOPEN"

#. type: TH
#: man-pages/man3/dlopen.3:35
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: man-pages/man3/dlopen.3:39
msgid "dlclose, dlopen, dlmopen - open and close a shared object"
msgstr "dlclose, dlopen, dlmopen - открывает и закрывает общий объект"

#. type: Plain text
#: man-pages/man3/dlopen.3:43
msgid "B<void *dlopen(const char *>I<filename>B<, int >I<flags>B<);>"
msgstr "B<void *dlopen(const char *>I<filename>B<, int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man3/dlopen.3:45
msgid "B<int dlclose(void *>I<handle>B<);>"
msgstr "B<int dlclose(void *>I<handle>B<);>"

#. type: Plain text
#: man-pages/man3/dlopen.3:51
msgid ""
"B<void *dlmopen (Lmid_t >I<lmid>B<, const char *>I<filename>B<, int "
">I<flags>B<);>"
msgstr ""
"B<void *dlmopen (Lmid_t >I<lmid>B<, const char *>I<filename>B<, int "
">I<flags>B<);>"

#. type: SS
#: man-pages/man3/dlopen.3:54
#, no-wrap
msgid "dlopen()"
msgstr "dlopen()"

#. type: Plain text
#: man-pages/man3/dlopen.3:68
msgid ""
"The function B<dlopen>()  loads the dynamic shared object (shared library)  "
"file named by the null-terminated string I<filename> and returns an opaque "
"\"handle\" for the loaded object.  This handle is employed with other "
"functions in the dlopen API, such as B<dlsym>(3), B<dladdr>(3), "
"B<dlinfo>(3), and B<dlclose>()."
msgstr ""
"Функция B<dlopen>() загружает динамический общий объект (общую библиотеку) "
"из файла, имя которого указано в строке I<filename> (завершается null) и "
"возвращает скрытный описатель на загруженный объект. Данный описатель "
"используется другими функциями программного интерфейса dlopen, такими как "
"B<dlsym>(3), B<dladdr>(3), B<dlinfo>(3) и B<dlclose>()."

#.  FIXME On Solaris, when handle is NULL, we seem to get back
#.  a handle for (something like) the root of the namespace.
#.  The point here is that if we do a dlmopen(LM_ID_NEWLM), then
#.  the filename==NULL case returns a different handle than
#.  in the initial namespace. But, on glibc, the same handle is
#.  returned. This is probably a bug in glibc.
#. type: Plain text
#: man-pages/man3/dlopen.3:87
msgid ""
"If I<filename> is NULL, then the returned handle is for the main program.  "
"If I<filename> contains a slash (\"/\"), then it is interpreted as a "
"(relative or absolute) pathname.  Otherwise, the dynamic linker searches for "
"the object as follows (see B<ld.so>(8)  for further details):"
msgstr ""
"Если I<filename> равно NULL, то возвращается описатель основной программы. "
"Если I<filename> содержит косую черту («/»), то это воспринимается как имя с "
"путём (относительным или абсолютным). Иначе динамический компоновщик ищет "
"объект в следующих местах (подробности смотрите в B<ld.so>(8)):"

#. type: IP
#: man-pages/man3/dlopen.3:87 man-pages/man3/dlopen.3:91
#: man-pages/man3/dlopen.3:98 man-pages/man3/dlopen.3:102
#: man-pages/man3/dlopen.3:109
#, no-wrap
msgid "o"
msgstr "o"

#. type: Plain text
#: man-pages/man3/dlopen.3:91
msgid ""
"(ELF only) If the executable file for the calling program contains a "
"DT_RPATH tag, and does not contain a DT_RUNPATH tag, then the directories "
"listed in the DT_RPATH tag are searched."
msgstr ""
"(только в ELF) Если исполняемый файл вызывающей программы содержит метку "
"DT_RPATH, т не содержит метки DT_RUNPATH, то производится поиск в каталогах, "
"описанных в метке DT_RPATH."

#. type: Plain text
#: man-pages/man3/dlopen.3:98
msgid ""
"If, at the time that the program was started, the environment variable "
"B<LD_LIBRARY_PATH> was defined to contain a colon-separated list of "
"directories, then these are searched.  (As a security measure, this variable "
"is ignored for set-user-ID and set-group-ID programs.)"
msgstr ""
"Если при запуске программы была определена переменная окружения "
"B<LD_LIBRARY_PATH>, содержащая список каталогов через двоеточие, то "
"производится поиск в этих каталогах (по соображениям безопасности эта "
"переменная игнорируется для программ с установленными битами set-user-ID и "
"set-group-ID)."

#. type: Plain text
#: man-pages/man3/dlopen.3:102
msgid ""
"(ELF only) If the executable file for the calling program contains a "
"DT_RUNPATH tag, then the directories listed in that tag are searched."
msgstr ""
"(только в ELF) Если исполняемый файл вызывающей программы содержит метку "
"DT_RUNPATH, то производится поиск по каталогам, перечисленным в этой метке."

#. type: Plain text
#: man-pages/man3/dlopen.3:109
msgid ""
"The cache file I</etc/ld.so.cache> (maintained by B<ldconfig>(8))  is "
"checked to see whether it contains an entry for I<filename>."
msgstr ""
"Производится проверка в кэширующем файле I</etc/ld.so.cache> (обслуживается "
"B<ldconfig>(8)) на предмет наличия записи для I<filename>."

#. type: Plain text
#: man-pages/man3/dlopen.3:115
msgid "The directories I</lib> and I</usr/lib> are searched (in that order)."
msgstr ""
"Просматриваются каталоги I</lib> и I</usr/lib> (именно в таком порядке)."

#. type: Plain text
#: man-pages/man3/dlopen.3:123
msgid ""
"If the object specified by I<filename> has dependencies on other shared "
"objects, then these are also automatically loaded by the dynamic linker "
"using the same rules.  (This process may occur recursively, if those objects "
"in turn have dependencies, and so on.)"
msgstr ""
"Если объект, указанный I<filename>, зависит от других общих объектов, то они "
"также автоматически загружаются динамическим компоновщиком согласно этим же "
"правилам (процесс может выполняться рекурсивно, если эти объекты, в свою "
"очередь, зависят от других, и так далее)."

#. type: Plain text
#: man-pages/man3/dlopen.3:126
msgid "One of the following two values must be included in I<flags>:"
msgstr "В I<flags> должно быть одно из двух следующих значений:"

#. type: TP
#: man-pages/man3/dlopen.3:126
#, no-wrap
msgid "B<RTLD_LAZY>"
msgstr "B<RTLD_LAZY>"

#.  commit 12b5b6b7f78ea111e89bbf638294a5413c791072
#. type: Plain text
#: man-pages/man3/dlopen.3:139
msgid ""
"Perform lazy binding.  Resolve symbols only as the code that references them "
"is executed.  If the symbol is never referenced, then it is never resolved.  "
"(Lazy binding is performed only for function references; references to "
"variables are always immediately bound when the shared object is loaded.)  "
"Since glibc 2.1.1, this flag is overridden by the effect of the "
"B<LD_BIND_NOW> environment variable."
msgstr ""
"Выполнять позднее связывание (lazy binding). Выполняется поиск только тех "
"символов, на которые есть ссылки из кода. Если на символ никогда не "
"ссылаются, то он никогда не будет разрешён (позднее связывание выполняется "
"только при ссылке на функции; ссылки на переменные всегда привязываются "
"сразу при загрузке общего объекта). Начиная с libc 2.1.1, этот флаг "
"заменяется на значение переменной окружения B<LD_BIND_NOW>."

#. type: TP
#: man-pages/man3/dlopen.3:139
#, no-wrap
msgid "B<RTLD_NOW>"
msgstr "B<RTLD_NOW>"

#. type: Plain text
#: man-pages/man3/dlopen.3:148
msgid ""
"If this value is specified, or the environment variable B<LD_BIND_NOW> is "
"set to a nonempty string, all undefined symbols in the shared object are "
"resolved before B<dlopen>()  returns.  If this cannot be done, an error is "
"returned."
msgstr ""
"Если указано данное значение или переменная окружения B<LD_BIND_NOW> не "
"пуста, то все неопределённые символы в общем объекте ищутся до возврата из "
"B<dlopen>(). Если этого сделать не удаётся, то возвращается ошибка."

#. type: Plain text
#: man-pages/man3/dlopen.3:151
msgid "Zero or more of the following values may also be ORed in I<flags>:"
msgstr ""
"Также в В I<flags> может быть ноль или более значение, объединяемых по ИЛИ:"

#. type: TP
#: man-pages/man3/dlopen.3:151
#, no-wrap
msgid "B<RTLD_GLOBAL>"
msgstr "B<RTLD_GLOBAL>"

#. type: Plain text
#: man-pages/man3/dlopen.3:155
msgid ""
"The symbols defined by this shared object will be made available for symbol "
"resolution of subsequently loaded shared objects."
msgstr ""
"Символы, определённые в этом общем объекте, будут доступны при поиске "
"символов, для общих объектов, загружаемых далее."

#. type: TP
#: man-pages/man3/dlopen.3:155
#, no-wrap
msgid "B<RTLD_LOCAL>"
msgstr "B<RTLD_LOCAL>"

#. type: Plain text
#: man-pages/man3/dlopen.3:162
msgid ""
"This is the converse of B<RTLD_GLOBAL>, and the default if neither flag is "
"specified.  Symbols defined in this shared object are not made available to "
"resolve references in subsequently loaded shared objects."
msgstr ""
"Противоположность B<RTLD_GLOBAL>, используется по умолчанию, если не задано "
"ни одного флага. Символы, определённые в этом общем объекте, не будут "
"доступны при разрешении ссылок для общих объектов, загружаемых далее."

#. type: TP
#: man-pages/man3/dlopen.3:162
#, no-wrap
msgid "B<RTLD_NODELETE> (since glibc 2.2)"
msgstr "B<RTLD_NODELETE> (начиная с glibc 2.2)"

#. type: Plain text
#: man-pages/man3/dlopen.3:170
msgid ""
"Do not unload the shared object during B<dlclose>().  Consequently, the "
"object's static and global variables are not reinitialized if the object is "
"reloaded with B<dlopen>()  at a later time."
msgstr ""
"Не выгружать общий объект при B<dlclose>(). В результате статические и "
"глобальные переменные объекта не инициализируются повторно, если объект "
"загружается снова по B<dlopen>()."

#. type: TP
#: man-pages/man3/dlopen.3:170
#, no-wrap
msgid "B<RTLD_NOLOAD> (since glibc 2.2)"
msgstr "B<RTLD_NOLOAD> (начиная с glibc 2.2)"

#. type: Plain text
#: man-pages/man3/dlopen.3:183
msgid ""
"Don't load the shared object.  This can be used to test if the object is "
"already resident (B<dlopen>()  returns NULL if it is not, or the object's "
"handle if it is resident).  This flag can also be used to promote the flags "
"on a shared object that is already loaded.  For example, a shared object "
"that was previously loaded with B<RTLD_LOCAL> can be reopened with "
"B<RTLD_NOLOAD\\ |\\ RTLD_GLOBAL>."
msgstr ""
"Не загружать общий объект. Это можно использовать для тестирования того, что "
"объект уже загружен (B<dlopen>() возвращает NULL, если нет, или описатель "
"объекта в противном случае). Данный флаг также можно использовать для "
"изменения флагов уже загруженного объекта. Например, общий объект, который "
"был загружен ранее с B<RTLD_LOCAL>, можно открыть повторно с B<RTLD_NOLOAD\\ "
"|\\ RTLD_GLOBAL>."

#. type: TP
#: man-pages/man3/dlopen.3:183
#, no-wrap
msgid "B<RTLD_DEEPBIND> (since glibc 2.3.4)"
msgstr "B<RTLD_DEEPBIND> (начиная с glibc 2.3.4)"

#.  Inimitably described by UD in
#.  http://sources.redhat.com/ml/libc-hacker/2004-09/msg00083.html.
#. type: Plain text
#: man-pages/man3/dlopen.3:192
msgid ""
"Place the lookup scope of the symbols in this shared object ahead of the "
"global scope.  This means that a self-contained object will use its own "
"symbols in preference to global symbols with the same name contained in "
"objects that have already been loaded."
msgstr ""
"Задать объекта, в котором поиск символов будет осуществляться перед поиском "
"в области глобальных символов. Это означает, что самодостаточный объект "
"будет использовать свои собственные символы вместо глобальных символов с тем "
"же именем, содержащихся в объектах, которые уже были загружены."

#. type: Plain text
#: man-pages/man3/dlopen.3:204
msgid ""
"If I<filename> is NULL, then the returned handle is for the main program.  "
"When given to B<dlsym>(), this handle causes a search for a symbol in the "
"main program, followed by all shared objects loaded at program startup, and "
"then all shared objects loaded by B<dlopen>()  with the flag B<RTLD_GLOBAL>."
msgstr ""
"Если значение I<filename> равно NULL, то возвращается описатель для главной "
"программы. При передаче в B<dlsym>(), этот описатель вызывает поиск символа "
"в главной программе, затем во все общих объектах, загруженных при запуске "
"программы, и затем во всех общих объектах, загруженных B<dlopen>() с флагом "
"B<RTLD_GLOBAL>."

#. type: Plain text
#: man-pages/man3/dlopen.3:216
msgid ""
"Symbol references in the shared object are resolved using (in order): "
"symbols in the link map of objects loaded for the main program and its "
"dependencies; symbols in shared objects (and their dependencies)  that were "
"previously opened with B<dlopen>()  using the B<RTLD_GLOBAL> flag; and "
"definitions in the shared object itself (and any dependencies that were "
"loaded for that object)."
msgstr ""
"Поиск символьных ссылок общего объекта производится следующим образом (в "
"таком порядке): символы в карте ссылок объектов, загруженных для главной "
"программы и её зависимостей; символы в общих объектах (и их зависимостях), "
"которые были открыты ранее с помощью B<dlopen>() и флага B<RTLD_GLOBAL>; "
"определения в самом общем объекте (и любых зависимостях, которые были "
"загружены для этого объекта)."

#. type: Plain text
#: man-pages/man3/dlopen.3:228
msgid ""
"Any global symbols in the executable that were placed into its dynamic "
"symbol table by B<ld>(1)  can also be used to resolve references in a "
"dynamically loaded shared object.  Symbols may be placed in the dynamic "
"symbol table either because the executable was linked with the flag \"-"
"rdynamic\" (or, synonymously, \"--export-dynamic\"), which causes all of the "
"executable's global symbols to be placed in the dynamic symbol table, or "
"because B<ld>(1)  noted a dependency on a symbol in another object during "
"static linking."
msgstr ""
"Все глобальные символы в исполняемом файле, которые были помещены в его "
"таблицу динамических символов посредством B<ld>(1), также могут быть "
"использованы при поиске ссылок динамически загружаемого общего объекта. "
"Символы могут попасть в таблицу динамических символов из-за того, что "
"исполняемый файл был скомпонован с флагом «-rdynamic» (или его синонимом «--"
"export-dynamic»), который помещает что все глобальные символы исполняемого "
"файла в таблицу динамических символов, или из-за того, что B<ld>(1) "
"определил зависимость от символа из другого объекта при статической "
"компоновке."

#. type: Plain text
#: man-pages/man3/dlopen.3:241
msgid ""
"If the same shared object is opened again with B<dlopen>(), the same object "
"handle is returned.  The dynamic linker maintains reference counts for "
"object handles, so a dynamically loaded shared object is not deallocated "
"until B<dlclose>()  has been called on it as many times as B<dlopen>()  has "
"succeeded on it.  Constructors (see below) are called only when the object "
"is actually loaded into memory (i.e., when the reference count increases to "
"1)."
msgstr ""
"Если общий объект загружается с помощью B<dlopen>() повторно, то "
"возвращается тот же описатель на объект. Динамический компоновщик ведёт "
"счётчик ссылок для описателей объектов, поэтому динамически загруженный "
"общий объект не высвобождается B<dlclose>() до тех пор, пока он не будет "
"вызвана столько же раз сколько и B<dlopen>(). Процедуры инициализации "
"(смотрите ниже) вызываются только когда объект действительно загружается в "
"память (т. е., когда счётчик ссылок увеличивается на 1)."

#. type: Plain text
#: man-pages/man3/dlopen.3:254
msgid ""
"A subsequent B<dlopen>()  call that loads the same shared object with "
"B<RTLD_NOW> may force symbol resolution for a shared object earlier loaded "
"with B<RTLD_LAZY>.  Similarly, an object that was previously opened with "
"B<RTLD_LOCAL> can be promoted to B<RTLD_GLOBAL> in a subsequent B<dlopen>()."
msgstr ""
"Последующий вызов B<dlopen>(), загружающий тот же общий объект с флагом "
"B<RTLD_NOW>, может привести к поиску символов для общего объекта ранее "
"загруженного с флагом B<RTLD_LAZY>. Схожим образом объект, открытый ранее с "
"флагом B<RTLD_LOCAL>, в последующем вызове B<dlopen>() может быть "
"преобразован в B<RTLD_GLOBAL>."

#. type: Plain text
#: man-pages/man3/dlopen.3:259
msgid "If B<dlopen>()  fails for any reason, it returns NULL."
msgstr ""
"Если по какой-то причине B<dlopen>() завершается неудачно, то возвращается "
"NULL."

#. type: SS
#: man-pages/man3/dlopen.3:259
#, no-wrap
msgid "dlmopen()"
msgstr "dlmopen()"

#. type: Plain text
#: man-pages/man3/dlopen.3:267
msgid ""
"This function performs the same task as B<dlopen>()\\(emthe I<filename> and "
"I<flags> arguments, as well as the return value, are the same, except for "
"the differences noted below."
msgstr ""
"Данная функция делает то же самое что и B<dlopen>(), аргументы I<filename> и "
"I<flags>, а также возвращаемое значение — такие же, отличия описаны далее."

#. type: Plain text
#: man-pages/man3/dlopen.3:286
msgid ""
"The B<dlmopen>()  function differs from B<dlopen>()  primarily in that it "
"accepts an additional argument, I<lmid>, that specifies the link-map list "
"(also referred to as a I<namespace>)  in which the shared object should be "
"loaded.  (By comparison, B<dlopen>()  adds the dynamically loaded shared "
"object to the same namespace as the shared object from which the "
"B<dlopen>()  call is made.)  The I<Lmid_t> type is an opaque handle that "
"refers to a namespace."
msgstr ""
"Функция B<dlmopen>() отличается от B<dlopen>(), главным образом в том, что "
"имеет дополнительный аргумент I<lmid>, в котором задаётся список карт связей "
"(link-map list, ещё называемый I<пространством имён>), в который должен быть "
"загружен общий объект (B<dlopen>() добавляет динамически загружаемый общий "
"объект в тоже пространство имён, в котором находится общий объект, из "
"которого был вызван B<dlopen>()). Тип I<Lmid_t> является скрытым описателем, "
"который ссылается на пространство имён."

#.  FIXME: Is using dlinfo() RTLD_DI_LMID the right technique?
#. type: Plain text
#: man-pages/man3/dlopen.3:295
msgid ""
"The I<lmid> argument is either the ID of an existing namespace (which can be "
"obtained using the B<dlinfo>(3)  B<RTLD_DI_LMID> request) or one of the "
"following special values:"
msgstr ""
"В аргументе I<lmid> может быть указан ID существующего пространства имён "
"(который может быть получен с помощью  B<dlinfo>(3) с запросом "
"B<RTLD_DI_LMID>) или одно из следующих специальных значений:"

#. type: TP
#: man-pages/man3/dlopen.3:295
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr "B<LM_ID_BASE>"

#. type: Plain text
#: man-pages/man3/dlopen.3:299
msgid ""
"Load the shared object in the initial namespace (i.e., the application's "
"namespace)."
msgstr ""
"Загрузить общий объект в начальное пространство имён (т. е., в пространство "
"имён приложения)."

#. type: TP
#: man-pages/man3/dlopen.3:299
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr "B<LM_ID_NEWLM>"

#. type: Plain text
#: man-pages/man3/dlopen.3:305
msgid ""
"Create a new namespace and load the shared object in that namespace.  The "
"object must have been correctly linked to reference all of the other shared "
"objects that it requires, since the new namespace is initially empty."
msgstr ""
"Создать новое пространство имён и загрузить в него общий объект. Объект "
"должен быть корректно скомпонован с ссылками на все остальные общие объекты, "
"которые ему требуются, так как новое пространство имён изначально пустое."

#. type: Plain text
#: man-pages/man3/dlopen.3:312
msgid ""
"If I<filename> is NULL, then the only permitted value for I<lmid> is "
"B<LM_ID_BASE>."
msgstr ""
"Если I<filename> равно NULL, то для I<lmid> разрешено только значение "
"B<LM_ID_BASE>."

#. type: SS
#: man-pages/man3/dlopen.3:312
#, no-wrap
msgid "dlclose()"
msgstr "dlclose()"

#. type: Plain text
#: man-pages/man3/dlopen.3:318
msgid ""
"The function B<dlclose>()  decrements the reference count on the dynamically "
"loaded shared object referred to by I<handle>."
msgstr ""
"Функция B<dlclose>() уменьшает счётчик ссылок на динамически загружаемый "
"общий объект, на который ссылается I<handle>."

#. type: Plain text
#: man-pages/man3/dlopen.3:327
msgid ""
"If the object's reference count drops to zero and no symbols in this object "
"are required by other objects, then the object is unloaded after first "
"calling any destructors defined for the object.  (Symbols in this object "
"might be required in another object because this object was opened with the "
"B<RTLD_GLOBAL> flag and one of its symbols satisfied a relocation in another "
"object.)"
msgstr ""
"Если счётчик ссылок достигает нуля и символы этого объекта не нужны другим "
"объектам, то объект выгружается после первого вызова любого деструктора, "
"определённого в объекте (символы в этом объекте могут требоваться в другом "
"объекте из-за того, что этот объект был открыт с флагом B<RTLD_GLOBAL> и "
"один из его символов совпадает с расположением из другого объекта)."

#. type: Plain text
#: man-pages/man3/dlopen.3:333
msgid ""
"All shared objects that were automatically loaded when B<dlopen>()  was "
"invoked on the object referred to by I<handle> are recursively closed in the "
"same manner."
msgstr ""
"Все общие объекты, которые были автоматически загружены при вызове "
"B<dlopen>() для объекта, на который ссылается I<handle>, рекурсивно "
"закрываются таким же способом."

#. type: Plain text
#: man-pages/man3/dlopen.3:345
msgid ""
"A successful return from B<dlclose>()  does not guarantee that the symbols "
"associated with I<handle> are removed from the caller's address space.  In "
"addition to references resulting from explicit B<dlopen>()  calls, a shared "
"object may have been implicitly loaded (and reference counted) because of "
"dependencies in other shared objects.  Only when all references have been "
"released can the shared object be removed from the address space."
msgstr ""
"Успешный возврат из B<dlclose>() не гарантирует, что символы, связанные с "
"I<handle> удалятся из адресного пространства вызывающего. В дополнении к "
"ссылкам, полученным из-за явного вызова B<dlopen>(), общий объект может быть "
"загружен неявно (и увеличится счётчик ссылок), так как от него зависят "
"другие общие объекты. Общий объект будет удалён из адресного пространства "
"только когда будут удалены все ссылки на него."

#. type: Plain text
#: man-pages/man3/dlopen.3:355
msgid ""
"On success, B<dlopen>()  and B<dlmopen>()  return a non-NULL handle for the "
"loaded object.  On error (file could not be found, was not readable, had the "
"wrong format, or caused errors during loading), these functions return NULL."
msgstr ""
"При успешном выполнении B<dlopen>() и B<dlmopen>() для загруженного объекта "
"возвращают описатель не равный NULL. При ошибке (файл не найден, недоступен "
"для чтения, имеет неправильный формат или возникли ошибке при загрузке) эти "
"функции возвращают NULL."

#. type: Plain text
#: man-pages/man3/dlopen.3:359
msgid ""
"On success, B<dlclose>()  returns 0; on error, it returns a nonzero value."
msgstr ""
"При успешном выполнении B<dlclose>() возвращает 0; при ошибке возвращается "
"ненулевое значение."

#. type: Plain text
#: man-pages/man3/dlopen.3:362
msgid "Errors from these functions can be diagnosed using B<dlerror>(3)."
msgstr ""
"Ошибки, возникшие в этих функциях, можно определить с помощью B<dlerror>(3)."

#. type: Plain text
#: man-pages/man3/dlopen.3:369
msgid ""
"B<dlopen>()  and B<dlclose>()  are present in glibc 2.0 and later.  "
"B<dlmopen>()  first appeared in glibc 2.3.4."
msgstr ""
"Функции B<dlopen>() и B<dlclose>() имеются в glibc 2.0 и новее. Функция "
"B<dlmopen>() впервые появилась в glibc 2.3.4."

#. type: tbl table
#: man-pages/man3/dlopen.3:381
#, no-wrap
msgid ""
"B<dlopen>(),\n"
"B<dlmopen>(),\n"
"B<dlclose>()"
msgstr ""
"B<dlopen>(),\n"
"B<dlmopen>(),\n"
"B<dlclose>()"

#. type: Plain text
#: man-pages/man3/dlopen.3:391
msgid ""
"POSIX.1-2001 describes B<dlclose>()  and B<dlopen>().  The B<dlmopen>()  "
"function is a GNU extension."
msgstr ""
"В POSIX.1-2001 описаны B<dlclose>() и B<dlopen>(). Функция B<dlmopen>() "
"является расширением GNU."

#. type: Plain text
#: man-pages/man3/dlopen.3:399
msgid ""
"The B<RTLD_NOLOAD>, B<RTLD_NODELETE>, and B<RTLD_DEEPBIND> flags are GNU "
"extensions; the first two of these flags are also present on Solaris."
msgstr ""
"Флаги B<RTLD_NOLOAD>, B<RTLD_NODELETE> и B<RTLD_DEEPBIND> являются "
"расширением GNU; первые два этих флага есть также в Solaris."

#. type: SS
#: man-pages/man3/dlopen.3:400
#, no-wrap
msgid "dlmopen() and namespaces"
msgstr "Функция dlmopen() и пространства имён"

#. type: Plain text
#: man-pages/man3/dlopen.3:408
msgid ""
"A link-map list defines an isolated namespace for the resolution of symbols "
"by the dynamic linker.  Within a namespace, dependent shared objects are "
"implicitly loaded according to the usual rules, and symbol references are "
"likewise resolved according to the usual rules, but such resolution is "
"confined to the definitions provided by the objects that have been "
"(explicitly and implicitly) loaded into the namespace."
msgstr ""
"Списком карты связей задаётся изолированное пространство имён для "
"определения символов динамическим компоновщиком. Внутри пространства имён "
"зависимые общие объекты неявно загружаются по обычным правилам, символьные "
"ссылки разрешаются подобным образом, но при этом учитываются только те "
"объекты, которые были загружены (явно и неявно) в пространство имён."

#. type: Plain text
#: man-pages/man3/dlopen.3:428
msgid ""
"The B<dlmopen>()  function permits object-load isolation\\(emthe ability to "
"load a shared object in a new namespace without exposing the rest of the "
"application to the symbols made available by the new object.  Note that the "
"use of the B<RTLD_LOCAL> flag is not sufficient for this purpose, since it "
"prevents a shared object's symbols from being available to I<any> other "
"shared object.  In some cases, we may want to make the symbols provided by a "
"dynamically loaded shared object available to (a subset of) other shared "
"objects without exposing those symbols to the entire application.  This can "
"be achieved by using a separate namespace and the B<RTLD_GLOBAL> flag."
msgstr ""
"Функция B<dlmopen>() позволяет достичь изоляции загружаемых объектов — "
"загружает общий объект в новое пространство имён без показа символов всему "
"приложению, а только новому объекту. Заметим, что использование флага "
"B<RTLD_LOCAL> недостаточно для этой цели, так как он делает недоступным "
"символы общего объекта I<любому> другому общему объекту. В некоторых случаях "
"может понадобиться, чтобы символы динамически загружаемого общего объекта "
"были доступны другим общим объектам (но не всем объектам) без показа этих "
"символов всему приложению. Этого можно достичь используя отдельное "
"пространство имён и флаг B<RTLD_GLOBAL>."

#. type: Plain text
#: man-pages/man3/dlopen.3:444
msgid ""
"The B<dlmopen>()  function also can be used to provide better isolation than "
"the B<RTLD_LOCAL> flag.  In particular, shared objects loaded with "
"B<RTLD_LOCAL> may be promoted to B<RTLD_GLOBAL> if they are dependencies of "
"another shared object loaded with B<RTLD_GLOBAL>.  Thus, B<RTLD_LOCAL> is "
"insufficient to isolate a loaded shared object except in the (uncommon)  "
"case where one has explicit control over all shared object dependencies."
msgstr ""
"Функцию B<dlmopen>() также можно использовать для получения изолированности, "
"большей чем с флагом B<RTLD_LOCAL>. В частности, общие объекты, загруженные "
"с B<RTLD_LOCAL>, могут быть видимы при флаге B<RTLD_GLOBAL>, если они "
"зависят от другого общего объекта, загруженного с флагом B<RTLD_GLOBAL>. То "
"есть, B<RTLD_LOCAL> недостаточно изолирует загружаемый общий объект, за "
"исключением случая (редкого), где он явно контролирует зависимости всех "
"загружаемых общих объектов."

#. type: Plain text
#: man-pages/man3/dlopen.3:459
msgid ""
"Possible uses of B<dlmopen>()  are plugins where the author of the plugin-"
"loading framework can't trust the plugin authors and does not wish any "
"undefined symbols from the plugin framework to be resolved to plugin "
"symbols.  Another use is to load the same object more than once.  Without "
"the use of B<dlmopen>(), this would require the creation of distinct copies "
"of the shared object file.  Using B<dlmopen>(), this can be achieved by "
"loading the same shared object file into different namespaces."
msgstr ""
"Возможный случай применения B<dlmopen>() — модули, где автор инфраструктуры "
"модулей не может доверять авторам модулей и не хочет, чтобы все "
"неопределённые символы инфраструктуры модулей определялись из модулей. "
"Другой случай использования — загрузка одного объекта несколько раз. Без "
"B<dlmopen>() это потребовало бы создание отдельных копий файлов общего "
"объекта. С помощью B<dlmopen>() можно загрузить один файл общего объекта в "
"разные пространства имён."

#.  DL_NNS
#. type: Plain text
#: man-pages/man3/dlopen.3:464
msgid "The glibc implementation supports a maximum of 16 namespaces."
msgstr "В реализации glibc поддерживается до 16 пространств имён."

#. type: SS
#: man-pages/man3/dlopen.3:464
#, no-wrap
msgid "Initialization and finalization functions"
msgstr "Функции инициализации и завершения"

#.  info gcc "C Extensions" "Function attributes"
#. type: Plain text
#: man-pages/man3/dlopen.3:483
msgid ""
"Shared objects may export functions using the "
"B<__attribute__((constructor))> and B<__attribute__((destructor))> function "
"attributes.  Constructor functions are executed before B<dlopen>()  returns, "
"and destructor functions are executed before B<dlclose>()  returns.  A "
"shared object may export multiple constructors and destructors, and "
"priorities can be associated with each function to determine the order in "
"which they are executed.  See the B<gcc> info pages (under \"Function "
"attributes\")  for further information."
msgstr ""
"Общие объекты могут экспортировать с помощью атрибутов функций "
"B<__attribute__((constructor))> и B<__attribute__((destructor))>. Функции-"
"конструкторы выполняются перед возвратом из B<dlopen>(), а функции-"
"деструкторы выполняются перед возвратом из B<dlclose>(). Общий объект может "
"экспортировать несколько конструкторов и деструкторов, с каждой функцией "
"может быть связан приоритет, которым определяется порядок выполнения "
"функций. Подробней смотрите info-страницу B<gcc> (раздел «Атрибуты функции»)."

#. type: Plain text
#: man-pages/man3/dlopen.3:503
msgid ""
"An older method of (partially) achieving the same result is via the use of "
"two special symbols recognized by the linker: B<_init> and B<_fini>.  If a "
"dynamically loaded shared object exports a routine named B<_init>(), then "
"that code is executed after loading a shared object, before B<dlopen>()  "
"returns.  If the shared object exports a routine named B<_fini>(), then that "
"routine is called just before the object is unloaded.  In this case, one "
"must avoid linking against the system startup files, which contain default "
"versions of these files; this can be done by using the B<gcc>(1)  I<-"
"nostartfiles> command-line option."
msgstr ""
"Старым способом достижения того же (частично) результата является "
"использование двух специальных символов, распознаваемых компоновщиком: "
"B<_init> и B<_fini>. Если динамически загружаемый общий объект экспортирует "
"процедуру с именем B<_init>(), то её код выполняется после загрузки общего "
"объекта, но возвращения из B<dlopen>(). Если общий объект экспортирует "
"процедуру с именем B<_fini>(), то её код выполняется перед выгрузкой "
"объекта. В этом случае не должна выполняться компоновка с системными файлами "
"начального запуска, в которых содержатся версии по умолчанию этих файлов; "
"для этого нужно вызывать B<gcc>(1) с параметром командной строки I<-"
"nostartfiles>."

#.  Using these routines, or the gcc
#.  .B \-nostartfiles
#.  or
#.  .B \-nostdlib
#.  options, is not recommended.
#.  Their use may result in undesired behavior,
#.  since the constructor/destructor routines will not be executed
#.  (unless special measures are taken).
#.  .\" void _init(void) __attribute__((constructor));
#.  .\" void _fini(void) __attribute__((destructor));
#. type: Plain text
#: man-pages/man3/dlopen.3:524
msgid ""
"Use of B<_init> and B<_fini> is now deprecated in favor of the "
"aforementioned constructors and destructors, which among other advantages, "
"permit multiple initialization and finalization functions to be defined."
msgstr ""
"Использование B<_init> и B<_fini> теперь не рекомендуется, используйте "
"упомянутые конструкторы и деструкторы, которые, среди прочих преимуществ, "
"позволяют определять многократно вызываемые функции инициализации и "
"завершения."

#. type: Plain text
#: man-pages/man3/dlopen.3:529
msgid ""
"Since glibc 2.2.3, B<atexit>(3)  can be used to register an exit handler "
"that is automatically called when a shared object is unloaded."
msgstr ""
"Начиная с glibc 2.2.3, B<atexit>(3) может использоваться для регистрации "
"обработчика завершения работы, который автоматически вызывается при выгрузке "
"общего объекта."

#. type: Plain text
#: man-pages/man3/dlopen.3:531
msgid "These functions are part of the dlopen API, derived from SunOS."
msgstr ""
"Эти функции являются часть программного интерфейса dlopen, возникшего в "
"SunOS."

#.  dlerror(): "invalid mode"
#. type: Plain text
#: man-pages/man3/dlopen.3:546
msgid ""
"As at glibc 2.24, specifying the B<RTLD_GLOBAL> flag when calling "
"B<dlmopen>()  generates an error.  Furthermore, specifying B<RTLD_GLOBAL> "
"when calling B<dlopen>()  results in a program crash (B<SIGSEGV>)  if the "
"call is made from any object loaded in a namespace other than the initial "
"namespace."
msgstr ""
"В glibc 2.24 указание флага B<RTLD_GLOBAL> при вызове B<dlmopen>() приводит "
"к ошибке. Кроме этого, указание B<RTLD_GLOBAL> при вызове B<dlopen>() "
"приводит к падению программы (B<SIGSEGV>), если вызов делается из любого "
"объекта, загруженного в пространство имён, отличное от начального "
"пространства имён."

#. type: Plain text
#: man-pages/man3/dlopen.3:552
msgid ""
"The program below loads the (glibc) math library, looks up the address of "
"the B<cos>(3)  function, and prints the cosine of 2.0.  The following is an "
"example of building and running the program:"
msgstr ""
"Программа, представленная ниже, загружает библиотеку math (glibc), ищет "
"адрес функции B<cos>(3) и печатает косинус 2.0. Пример сборки и выполнения "
"программы:"

#. type: Plain text
#: man-pages/man3/dlopen.3:558
#, no-wrap
msgid ""
"$ B<cc dlopen_demo.c -ldl>\n"
"$ B<./a.out>\n"
"-0.416147\n"
msgstr ""
"$ B<cc dlopen_demo.c -ldl>\n"
"$ B<./a.out>\n"
"-0.416147\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:574
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>gnu/lib-names.hE<gt>  /* Defines LIBM_SO (which will be a\n"
"                               string such as \"libm.so.6\") */\n"
"int\n"
"main(void)\n"
"{\n"
"    void *handle;\n"
"    double (*cosine)(double);\n"
"    char *error;\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>dlfcn.hE<gt>\n"
"#include E<lt>gnu/lib-names.hE<gt>  /* определение LIBM_SO (который\n"
"                               является строкой вида libm.so.6») */\n"
"int\n"
"main(void)\n"
"{\n"
"    void *handle;\n"
"    double (*cosine)(double);\n"
"    char *error;\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:580
#, no-wrap
msgid ""
"    handle = dlopen(LIBM_SO, RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    handle = dlopen(LIBM_SO, RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:582
#, no-wrap
msgid "    dlerror();    /* Clear any existing error */\n"
msgstr "    dlerror();    /* Очистка всех результатов ошибок */\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:584
#, no-wrap
msgid "    cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"
msgstr "    cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:589
#, no-wrap
msgid ""
"    /* According to the ISO C standard, casting between function\n"
"       pointers and 'void *', as done above, produces undefined results.\n"
"       POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and\n"
"       proposed the following workaround:\n"
msgstr ""
"    /* Согласно стандарту ISO C, преобразование между указателями на\n"
"       функции и «void *», использовавшемуся выше, приводит к\n"
"       неопределённым результатам. В POSIX.1-2003 и POSIX.1-2008\n"
"       принимается такое поведение и предлагается следующий\n"
"       обходной вариант:\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:591
#, no-wrap
msgid "           *(void **) (&cosine) = dlsym(handle, \"cos\");\n"
msgstr "           *(void **) (&cosine) = dlsym(handle, \"cos\");\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:594
#, no-wrap
msgid ""
"       This (clumsy) cast conforms with the ISO C standard and will\n"
"       avoid any compiler warnings.\n"
msgstr ""
"       Такое (топорное) преобразование удовлетворяет стандарту ISO C и\n"
"       предупреждений компилятора не будет.\n"

#.  http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html#tag_03_112_08
#.  http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html#tag_16_96_07
#.  http://austingroupbugs.net/view.php?id=74
#. type: Plain text
#: man-pages/man3/dlopen.3:603
#, no-wrap
msgid ""
"       The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.\n"
"       POSIX.1-2013) improved matters by requiring that conforming\n"
"       implementations support casting 'void *' to a function pointer.\n"
"       Nevertheless, some compilers (e.g., gcc with the '-pedantic'\n"
"       option) may complain about the cast used in this program. */\n"
msgstr ""
"       Список опечаток 2013 к POSIX.1-2008 (т.н. POSIX.1-2013) улучшает\n"
"       состояние, требуя от реализаций поддержки преобразования «void *»\n"
"       в указатель на функцию. Тем не менее, некоторые компиляторы\n"
"       (например, gcc с параметром «-pedantic») могут выдавать\n"
"       предупреждение о преобразовании в этой программе. */\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:609
#, no-wrap
msgid ""
"    error = dlerror();\n"
"    if (error != NULL) {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    error = dlerror();\n"
"    if (error != NULL) {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:614
#, no-wrap
msgid ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/dlopen.3:627
msgid ""
"B<ld>(1), B<ldd>(1), B<pldd>(1), B<dl_iterate_phdr>(3), B<dladdr>(3), "
"B<dlerror>(3), B<dlinfo>(3), B<dlsym>(3), B<rtld-audit>(7), B<ld.so>(8), "
"B<ldconfig>(8)"
msgstr ""
"B<ld>(1), B<ldd>(1), B<pldd>(1), B<dl_iterate_phdr>(3), B<dladdr>(3), "
"B<dlerror>(3), B<dlinfo>(3), B<dlsym>(3), B<rtld-audit>(7), B<ld.so>(8), "
"B<ldconfig>(8)"

#. type: Plain text
#: man-pages/man3/dlopen.3:628
msgid "gcc info pages, ld info pages"
msgstr "Страницы в формате Info для gcc и ld"

#. type: TH
#: man-pages/man3/dladdr.3:27
#, no-wrap
msgid "DLADDR"
msgstr "DLADDR"

#. type: Plain text
#: man-pages/man3/dladdr.3:30
msgid "dladdr, dladdr1 - translate address to symbolic information"
msgstr "dladdr, dladdr1 - транслирует адрес в информацию о символе"

#. type: Plain text
#: man-pages/man3/dladdr.3:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/dladdr.3:36
#, no-wrap
msgid "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"
msgstr "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"

#. type: Plain text
#: man-pages/man3/dladdr.3:39
#, no-wrap
msgid "B<int dladdr1(void *>I<addr>B<, Dl_info *>I<info>B<, void **>I<extra_info>B<, int >I<flags>B<);>\n"
msgstr "B<int dladdr1(void *>I<addr>B<, Dl_info *>I<info>B<, void **>I<extra_info>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/dladdr.3:55
msgid ""
"The function B<dladdr>()  determines whether the address specified in "
"I<addr> is located in one of the shared objects loaded by the calling "
"application.  If it is, then B<dladdr>()  returns information about the "
"shared object and symbol that overlaps I<addr>.  This information is "
"returned in a I<Dl_info> structure:"
msgstr ""
"Функция B<dladdr>() определяет, в каком из загруженных общих объектов "
"приложения расположен адрес, указанный в I<addr>. Если объект находится, то "
"B<dladdr>() возвращает информацию об общем объекте и символе, который "
"относится к адресу I<addr>. Данная информация возвращается в виде структуры "
"I<Dl_info>:"

#. type: Plain text
#: man-pages/man3/dladdr.3:68
#, no-wrap
msgid ""
"typedef struct {\n"
"    const char *dli_fname;  /* Pathname of shared object that\n"
"                               contains address */\n"
"    void       *dli_fbase;  /* Base address at which shared\n"
"                               object is loaded */\n"
"    const char *dli_sname;  /* Name of symbol whose definition\n"
"                               overlaps I<addr> */\n"
"    void       *dli_saddr;  /* Exact address of symbol named\n"
"                               in I<dli_sname> */\n"
"} Dl_info;\n"
msgstr ""
"typedef struct {\n"
"    const char *dli_fname;  /* путь к общему объекту, который\n"
"                               содержит адрес */\n"
"    void       *dli_fbase;  /* начальный адрес, по которому расположен\n"
"                               общий объект */\n"
"    const char *dli_sname;  /* имя символа, к которому относится\n"
"                               адрес I<addr> */\n"
"    void       *dli_saddr;  /* точный адрес символа с\n"
"                               именем I<dli_sname> */\n"
"} Dl_info;\n"

#. type: Plain text
#: man-pages/man3/dladdr.3:78
msgid ""
"If no symbol matching I<addr> could be found, then I<dli_sname> and "
"I<dli_saddr> are set to NULL."
msgstr ""
"Если символ, соответствующий адресу I<addr>, не найден, то I<dli_sname> и "
"I<dli_saddr> устанавливаются в NULL."

#. type: Plain text
#: man-pages/man3/dladdr.3:88
msgid ""
"The function B<dladdr1>()  is like B<dladdr>(), but returns additional "
"information via the argument I<extra_info>.  The information returned "
"depends on the value specified in I<flags>, which can have one of the "
"following values:"
msgstr ""
"Функция B<dladdr1>() подобна B<dladdr>(), но возвращает дополнительную "
"информацию в аргументе I<extra_info>. Возвращаемая информация зависит от "
"значения, указанного в I<flags>, которое может быть одним из:"

#. type: TP
#: man-pages/man3/dladdr.3:88
#, no-wrap
msgid "B<RTLD_DL_LINKMAP>"
msgstr "B<RTLD_DL_LINKMAP>"

#. type: Plain text
#: man-pages/man3/dladdr.3:100
msgid ""
"Obtain a pointer to the link map for the matched file.  The I<extra_info> "
"argument points to a pointer to a I<link_map> structure (i.e., I<struct "
"link_map\\ **>), defined in I<E<lt>link.hE<gt>> as:"
msgstr ""
"Возвратить указатель на карту ссылок для совпадающего файла. Аргумент "
"I<extra_info> указывает на указатель на структуру I<link_map> (т. е., "
"I<struct link_map\\ **>), определённую в I<E<lt>link.hE<gt>> так:"

#. type: TP
#: man-pages/man3/dladdr.3:119
#, no-wrap
msgid "B<RTLD_DL_SYMENT>"
msgstr "B<RTLD_DL_SYMENT>"

#. type: Plain text
#: man-pages/man3/dladdr.3:137
msgid ""
"Obtain a pointer to the ELF symbol table entry of the matching symbol.  The "
"I<extra_info> argument is a pointer to a symbol pointer: I<const ElfW(Sym) "
"**>.  The I<ElfW>()  macro definition turns its argument into the name of an "
"ELF data type suitable for the hardware architecture.  For example, on a 64-"
"bit platform, I<ElfW(Sym)> yields the data type name I<Elf64_Sym>, which is "
"defined in I<E<lt>elf.hE<gt>> as:"
msgstr ""
"Возвращает указатель на элемент символьной таблицы ELF с совпадающим "
"символом. Аргумент I<extra_info> — указатель на символьный указатель: "
"I<const ElfW(Sym) **>. Макрос I<ElfW>() преобразует этот аргумент в имя типа "
"данных ELF, подходящее для аппаратной архитектуры. Например, на 64-битной "
"платформе I<ElfW(Sym)> возвращает имя типа данных I<Elf64_Sym>, которое "
"определено в I<E<lt>elf.hE<gt>> так:"

#. type: Plain text
#: man-pages/man3/dladdr.3:148
#, no-wrap
msgid ""
"typedef struct  {\n"
"    Elf64_Word    st_name;     /* Symbol name */\n"
"    unsigned char st_info;     /* Symbol type and binding */\n"
"    unsigned char st_other;    /* Symbol visibility */\n"
"    Elf64_Section st_shndx;    /* Section index */\n"
"    Elf64_Addr    st_value;    /* Symbol value */\n"
"    Elf64_Xword   st_size;     /* Symbol size */\n"
"} Elf64_Sym;\n"
msgstr ""
"typedef struct  {\n"
"    Elf64_Word    st_name;     /* имя символа */\n"
"    unsigned char st_info;     /* тип символа и привязка */\n"
"    unsigned char st_other;    /* видимость символа */\n"
"    Elf64_Section st_shndx;    /* номер раздела */\n"
"    Elf64_Addr    st_value;    /* значение символа */\n"
"    Elf64_Xword   st_size;     /* размер символа */\n"
"} Elf64_Sym;\n"

#. type: Plain text
#: man-pages/man3/dladdr.3:154
msgid "The I<st_name> field is an index into the string table."
msgstr "Поле I<st_name> — номер в строковой таблице."

#. type: Plain text
#: man-pages/man3/dladdr.3:163
msgid ""
"The I<st_info> field encodes the symbol's type and binding.  The type can be "
"extracted using the macro B<ELF64_ST_TYPE(st_info)> (or B<ELF32_ST_TYPE()> "
"on 32-bit platforms), which yields one of the following values:"
msgstr ""
"В поле I<st_info> закодирован тип и привязка символа. Тип можно извлечь с "
"помощью макроса B<ELF64_ST_TYPE(st_info)> (или B<ELF32_ST_TYPE()>, на 32-"
"битных платформах), который возвращает одно из следующих значений:"

#. type: tbl table
#: man-pages/man3/dladdr.3:167 man-pages/man3/dladdr.3:190
#: man-pages/man3/dladdr.3:209
#, no-wrap
msgid "Description"
msgstr "Описание"

#. type: tbl table
#: man-pages/man3/dladdr.3:168
#, no-wrap
msgid "STT_NOTYPE"
msgstr "STT_NOTYPE"

#. type: tbl table
#: man-pages/man3/dladdr.3:168
#, no-wrap
msgid "Symbol type is unspecified"
msgstr "тип символа не указан"

#. type: tbl table
#: man-pages/man3/dladdr.3:169
#, no-wrap
msgid "STT_OBJECT"
msgstr "STT_OBJECT"

#. type: tbl table
#: man-pages/man3/dladdr.3:169
#, no-wrap
msgid "Symbol is a data object"
msgstr "символ является объектом данных"

#. type: tbl table
#: man-pages/man3/dladdr.3:170
#, no-wrap
msgid "STT_FUNC"
msgstr "STT_FUNC"

#. type: tbl table
#: man-pages/man3/dladdr.3:170
#, no-wrap
msgid "Symbol is a code object"
msgstr "символ является объектом кода"

#. type: tbl table
#: man-pages/man3/dladdr.3:171
#, no-wrap
msgid "STT_SECTION"
msgstr "STT_SECTION"

#. type: tbl table
#: man-pages/man3/dladdr.3:171
#, no-wrap
msgid "Symbol associated with a section"
msgstr "символ, связанный с разделом"

#. type: tbl table
#: man-pages/man3/dladdr.3:172
#, no-wrap
msgid "STT_FILE"
msgstr "STT_FILE"

#. type: tbl table
#: man-pages/man3/dladdr.3:172
#, no-wrap
msgid "Symbol's name is file name"
msgstr "имя символа является именем файла"

#. type: tbl table
#: man-pages/man3/dladdr.3:173
#, no-wrap
msgid "STT_COMMON"
msgstr "STT_COMMON"

#. type: tbl table
#: man-pages/man3/dladdr.3:173
#, no-wrap
msgid "Symbol is a common data object"
msgstr "символ является объектом общих данных"

#. type: tbl table
#: man-pages/man3/dladdr.3:174
#, no-wrap
msgid "STT_TLS"
msgstr "STT_TLS"

#. type: tbl table
#: man-pages/man3/dladdr.3:174
#, no-wrap
msgid "Symbol is thread-local data object"
msgstr "символ является объектом локальных данных нити"

#. type: tbl table
#: man-pages/man3/dladdr.3:175
#, no-wrap
msgid "STT_GNU_IFUNC"
msgstr "STT_GNU_IFUNC"

#. type: tbl table
#: man-pages/man3/dladdr.3:175
#, no-wrap
msgid "Symbol is indirect code object"
msgstr "символ является объектом скрытого кода"

#. type: Plain text
#: man-pages/man3/dladdr.3:186
msgid ""
"The symbol binding can be extracted from the I<st_info> field using the "
"macro B<ELF64_ST_BIND(st_info)> (or B<ELF32_ST_BIND()> on 32-bit platforms), "
"which yields one of the following values:"
msgstr ""
"Привязку символа можно извлечь из поля I<st_info> с помощью макроса "
"B<ELF64_ST_BIND(st_info)> (или B<ELF32_ST_BIND()>, на 32-битных платформах), "
"который возвращает одно из следующих значений:"

#. type: tbl table
#: man-pages/man3/dladdr.3:191
#, no-wrap
msgid "STB_LOCAL"
msgstr "STB_LOCAL"

#. type: tbl table
#: man-pages/man3/dladdr.3:191
#, no-wrap
msgid "Local symbol"
msgstr "локальный символ"

#. type: tbl table
#: man-pages/man3/dladdr.3:192
#, no-wrap
msgid "STB_GLOBAL"
msgstr "STB_GLOBAL"

#. type: tbl table
#: man-pages/man3/dladdr.3:192
#, no-wrap
msgid "Global symbol"
msgstr "глобальный символ"

#. type: tbl table
#: man-pages/man3/dladdr.3:193
#, no-wrap
msgid "STB_WEAK"
msgstr "STB_WEAK"

#. type: tbl table
#: man-pages/man3/dladdr.3:193
#, no-wrap
msgid "Weak symbol"
msgstr "символ со слабой привязкой"

#. type: tbl table
#: man-pages/man3/dladdr.3:194
#, no-wrap
msgid "STB_GNU_UNIQUE"
msgstr "STB_GNU_UNIQUE"

#. type: tbl table
#: man-pages/man3/dladdr.3:194
#, no-wrap
msgid "Unique symbol"
msgstr "уникальный символ"

#. type: Plain text
#: man-pages/man3/dladdr.3:205
msgid ""
"The I<st_other> field contains the symbol's visibility, which can be "
"extracted using the macro B<ELF64_ST_VISIBILITY(st_info)> (or "
"B<ELF32_ST_VISIBILITY()> on 32-bit platforms), which yields one of the "
"following values:"
msgstr ""
"В поле I<st_other> содержится значение видимости символа, которую можно "
"извлечь с помощью макроса  B<ELF64_ST_VISIBILITY(st_info)> (или "
"B<ELF32_ST_VISIBILITY()>, на 32-битных платформах), который возвращает одно "
"из следующих значений:"

#. type: tbl table
#: man-pages/man3/dladdr.3:210
#, no-wrap
msgid "STV_DEFAULT"
msgstr "STV_DEFAULT"

#. type: tbl table
#: man-pages/man3/dladdr.3:210
#, no-wrap
msgid "Default symbol visibility rules"
msgstr "правила видимости символов по умолчанию"

#. type: tbl table
#: man-pages/man3/dladdr.3:211
#, no-wrap
msgid "STV_INTERNAL"
msgstr "STV_INTERNAL"

#. type: tbl table
#: man-pages/man3/dladdr.3:211
#, no-wrap
msgid "Processor-specific hidden class"
msgstr "скрытый класс, зависящий от процессора"

#. type: tbl table
#: man-pages/man3/dladdr.3:212
#, no-wrap
msgid "STV_HIDDEN"
msgstr "STV_HIDDEN"

#. type: tbl table
#: man-pages/man3/dladdr.3:212
#, no-wrap
msgid "Symbol unavailable in other modules"
msgstr "Символ недоступен в других модулях"

#. type: tbl table
#: man-pages/man3/dladdr.3:213
#, no-wrap
msgid "STV_PROTECTED"
msgstr "STV_PROTECTED"

#. type: tbl table
#: man-pages/man3/dladdr.3:213
#, no-wrap
msgid "Not preemptible, not exported"
msgstr "невыгружаемый, не экспортируется"

#. type: Plain text
#: man-pages/man3/dladdr.3:226
msgid ""
"On success, these functions return a nonzero value.  If the address "
"specified in I<addr> could be matched to a shared object, but not to a "
"symbol in the shared object, then the I<info-E<gt>dli_sname> and I<info-"
"E<gt>dli_saddr> fields are set to NULL."
msgstr ""
"При успешном выполнении эти функции возвращают ненулевое значение. Если "
"адрес, указанный в I<addr>, мог бы совпасть с общим объектом, но не с "
"символом в общем объекте, то полям I<info-E<gt>dli_sname> и I<info-"
"E<gt>dli_saddr> присваивается значение NULL."

#.  According to the FreeBSD man page, dladdr1() does signal an
#.  error via dlerror() for this case.
#. type: Plain text
#: man-pages/man3/dladdr.3:236
msgid ""
"If the address specified in I<addr> could not be matched to a shared object, "
"then these functions return 0.  In this case, an error message is I<not> "
"available via B<dlerror>(3)."
msgstr ""
"Если адрес, указанный I<addr>, мог бы совпасть с общим объектом, то эти "
"функции возвращают 0. В этом случае сообщение об ошибке I<не> доступно через "
"B<dlerror>(3)."

#. type: Plain text
#: man-pages/man3/dladdr.3:241
msgid ""
"B<dladdr>()  is present in glibc 2.0 and later.  B<dladdr1>()  first "
"appeared in glibc 2.3.3."
msgstr ""
"Функция B<dladdr>() есть в glibc 2.0 и новее. Функция B<dladdr1>() впервые "
"появилась в glibc 2.3.3."

#. type: tbl table
#: man-pages/man3/dladdr.3:252
#, no-wrap
msgid ""
"B<dladdr>(),\n"
"B<dladdr1>()"
msgstr ""
"B<dladdr>(),\n"
"B<dladdr1>()"

#. type: Plain text
#: man-pages/man3/dladdr.3:257
msgid ""
"These functions are nonstandard GNU extensions that are also present on "
"Solaris."
msgstr ""
"Данные функции являются нестандартными расширениями GNU, которые также "
"присутствуют в Solaris."

#. type: Plain text
#: man-pages/man3/dladdr.3:269
msgid ""
"Sometimes, the function pointers you pass to B<dladdr>()  may surprise you.  "
"On some architectures (notably i386 and x86-64), I<dli_fname> and "
"I<dli_fbase> may end up pointing back at the object from which you called "
"B<dladdr>(), even if the function used as an argument should come from a "
"dynamically linked library."
msgstr ""
"Иногда указатели на функции, передаваемые в B<dladdr>(), могут вас удивить. "
"На некоторых архитектурах (в частности, i386- и x86-64), I<dli_fname> и "
"I<dli_fbase> могут указывать на объект, из которого вызывалась функция "
"B<dladdr>(), даже если функция, использовавшаяся как аргумент, должна быть "
"из динамически скомпонованной библиотеки."

#. type: Plain text
#: man-pages/man3/dladdr.3:285
msgid ""
"The problem is that the function pointer will still be resolved at compile "
"time, but merely point to the I<plt> (Procedure Linkage Table)  section of "
"the original object (which dispatches the call after asking the dynamic "
"linker to resolve the symbol).  To work around this, you can try to compile "
"the code to be position-independent: then, the compiler cannot prepare the "
"pointer at compile time any more and B<gcc>(1)  will generate code that just "
"loads the final symbol address from the I<got> (Global Offset Table) at run "
"time before passing it to B<dladdr>()."
msgstr ""
"Проблема в том, что указатель на функцию по прежнему ищется во время "
"компиляции, но всего лишь указывает на раздел I<plt> (таблицу компоновки "
"процедур) первоначального объекта (которая размещает вызов после запроса "
"динамического компоновщика на поиск символа). Чтобы обойти это, вы можете "
"попробовать скомпилировать независимый от размещения код: в этом случае "
"компилятор больше не сможет подготовить указатель во время компиляции и "
"B<gcc>(1) создаст код, который просто загрузит конечный адрес символа из "
"I<got> (глобальной таблицы смещений) при запуске до передачи его в "
"B<dladdr>()."

#. type: Plain text
#: man-pages/man3/dladdr.3:290
msgid ""
"B<dl_iterate_phdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3), B<ld.so>(8)"
msgstr ""
"B<dl_iterate_phdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3), B<ld.so>(8)"

#. type: TH
#: man-pages/man3/dlerror.3:25
#, no-wrap
msgid "DLERROR"
msgstr "DLERROR"

#. type: Plain text
#: man-pages/man3/dlerror.3:28
msgid "dlerror - obtain error diagnostic for functions in the dlopen API"
msgstr ""
"dlerror - возвращает справку по ошибке для функций программного интерфейса "
"dlopen"

#. type: Plain text
#: man-pages/man3/dlerror.3:32
msgid "B<char *dlerror(void);>"
msgstr "B<char *dlerror(void);>"

#. type: Plain text
#: man-pages/man3/dlerror.3:45
msgid ""
"The B<dlerror>()  function returns a human-readable, null-terminated string "
"describing the most recent error that occurred from a call to one of the "
"functions in the dlopen API since the last call to B<dlerror>().  The "
"returned string does I<not> include a trailing newline."
msgstr ""
"Функция B<dlerror>() возвращает понятную человеку, строку с null в конце, "
"описывающую последнюю ошибку, которая произошла при вызове одной из функций "
"программного интерфейса dlopen, произошедшего после последнего вызова "
"B<dlerror>(). Возвращаемая строка I<не> содержит символа новой строки в "
"конце."

#. type: Plain text
#: man-pages/man3/dlerror.3:49
msgid ""
"B<dlerror>()  returns NULL if no errors have occurred since initialization "
"or since it was last called."
msgstr ""
"Функция B<dlerror>() возвращает NULL, если ошибок не было с начала "
"инициализации или с момента её последнего вызова."

#. type: Plain text
#: man-pages/man3/dlerror.3:52
msgid "B<dlerror>()  is present in glibc 2.0 and later."
msgstr "Функция B<dlerror>() есть в glibc 2.0 и новее."

#. type: tbl table
#: man-pages/man3/dlerror.3:62
#, no-wrap
msgid "B<dlerror>()"
msgstr "B<dlerror>()"

#. type: Plain text
#: man-pages/man3/dlerror.3:66
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#.  .LP
#.  The string returned by
#.  .BR dlerror ()
#.  should not be modified.
#.  Some systems give the prototype as
#.  .sp
#.  .in +5
#.  .B "const char *dlerror(void);"
#.  .in
#. type: Plain text
#: man-pages/man3/dlerror.3:82
msgid ""
"The message returned by B<dlerror>()  may reside in a statically allocated "
"buffer that is overwritten by subsequent B<dlerror>()  calls."
msgstr ""
"Сообщение, возвращаемое B<dlerror>(), может располагаться в статически "
"выделяемом буфере, который перезаписывается последующими вызовами "
"B<dlerror>()."

#. type: Plain text
#: man-pages/man3/dlerror.3:84
msgid "This function is part of the dlopen API, derived from SunOS."
msgstr ""
"Эта функция является частью программного интерфейса dlopen, возникшего в "
"SunOS."

#. type: Plain text
#: man-pages/man3/dlerror.3:91
msgid "B<dladdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3)"
msgstr "B<dladdr>(3), B<dlinfo>(3), B<dlopen>(3), B<dlsym>(3)"

#. type: TH
#: man-pages/man3/dirfd.3:25
#, no-wrap
msgid "DIRFD"
msgstr "DIRFD"

#. type: Plain text
#: man-pages/man3/dirfd.3:28
msgid "dirfd - get directory stream file descriptor"
msgstr "dirfd - получение файлового дескриптора потока каталога"

#. type: Plain text
#: man-pages/man3/dirfd.3:30
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man3/dirfd.3:32
msgid "B<#include E<lt>dirent.hE<gt>>"
msgstr "B<#include E<lt>dirent.hE<gt>>"

#. type: Plain text
#: man-pages/man3/dirfd.3:34
msgid "B<int dirfd(DIR *>I<dirp>B<);>"
msgstr "B<int dirfd(DIR *>I<dirp>B<);>"

#. type: Plain text
#: man-pages/man3/dirfd.3:41
msgid "B<dirfd>():"
msgstr "B<dirfd>():"

#. type: Plain text
#: man-pages/man3/dirfd.3:47
#, no-wrap
msgid ""
"/* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/dirfd.3:55
msgid ""
"The function B<dirfd>()  returns the file descriptor associated with the "
"directory stream I<dirp>."
msgstr ""
"Функция B<dirfd>() возвращает файловый дескриптор, связанный с потоком "
"каталога I<dirp>."

#. type: Plain text
#: man-pages/man3/dirfd.3:65
msgid ""
"This file descriptor is the one used internally by the directory stream.  As "
"a result, it is useful only for functions which do not depend on or alter "
"the file position, such as B<fstat>(2)  and B<fchdir>(2).  It will be "
"automatically closed when B<closedir>(3)  is called."
msgstr ""
"Этот файловый дескриптор используется внутри функции потоком каталога. В "
"результате он полезен только для функций, которые не зависят и не изменяют "
"положение в файле, например B<fstat>(2) и B<fchdir>(2). Он автоматически "
"закрывается при вызове B<closedir>(3)."

#. type: Plain text
#: man-pages/man3/dirfd.3:70
msgid ""
"On success, a nonnegative file descriptor is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the cause of the error."
msgstr ""
"При успешном выполнении возвращается неотрицательный файловый дескриптор. "
"При ошибке возвращается -1 и I<errno> устанавливается в соответствующее "
"значение."

#.  glibc 2.8
#. type: Plain text
#: man-pages/man3/dirfd.3:75
msgid ""
"POSIX.1-2008 specifies two errors, neither of which is returned by the "
"current implementation."
msgstr ""
"В POSIX.1-2008 определены две ошибки, ни одна из которых не возвращается "
"текущей реализацией."

#. type: Plain text
#: man-pages/man3/dirfd.3:79
msgid "I<dirp> does not refer to a valid directory stream."
msgstr "Значение I<dirp> не указывает на допустимый поток каталога."

#. type: TP
#: man-pages/man3/dirfd.3:79
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man3/dirfd.3:83
msgid ""
"The implementation does not support the association of a file descriptor "
"with a directory."
msgstr "Реализация не поддерживает связь файлового дескриптора с каталогом."

#. type: tbl table
#: man-pages/man3/dirfd.3:93
#, no-wrap
msgid "B<dirfd>()"
msgstr "B<dirfd>()"

#.  It is present in libc5 (since 5.1.2) and in glibc2.
#. type: Plain text
#: man-pages/man3/dirfd.3:99
msgid ""
"POSIX.1-2008.  This function was a BSD extension, present in 4.3BSD-Reno, "
"not in 4.2BSD."
msgstr ""
"POSIX.1-2008. Данная функция была расширением BSD, появилась в 4.3BSD-Reno, "
"не в 4.2BSD."

#. type: Plain text
#: man-pages/man3/dirfd.3:107
msgid ""
"B<open>(2), B<closedir>(3), B<opendir>(3), B<readdir>(3), B<rewinddir>(3), "
"B<scandir>(3), B<seekdir>(3), B<telldir>(3)"
msgstr ""
"B<open>(2), B<closedir>(3), B<opendir>(3), B<readdir>(3), B<rewinddir>(3), "
"B<scandir>(3), B<seekdir>(3), B<telldir>(3)"
