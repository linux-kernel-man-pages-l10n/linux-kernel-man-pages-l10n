# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2013,2016.
# Dmitriy Ovchinnikov <dmitriyxt5@gmail.com>, 2012.
# Dmitry Bolkhovskikh <d20052005@yandex.ru>, 2017.
# Katrin Kutepova <blackkatelv@gmail.com>, 2018.
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2019.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
# Иван Павлов <pavia00@gmail.com>, 2017.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:27+0300\n"
"PO-Revision-Date: 2019-09-17 18:54+0300\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n"
"%100>=11 && n%100<=14)? 2 : 3);\n"
"X-Generator: Lokalize 2.0\n"

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "UNITS"
msgstr "UNITS"

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man7/units.7:27
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man7/units.7:29
msgid "units - decimal and binary prefixes"
msgstr "units - десятичные и двоичные приставки"

#. type: SH
#: man-pages/man7/units.7:29
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: SS
#: man-pages/man7/units.7:30
#, no-wrap
msgid "Decimal prefixes"
msgstr "Десятичные приставки"

#. type: Plain text
#: man-pages/man7/units.7:34
msgid ""
"The SI system of units uses prefixes that indicate powers of ten.  A "
"kilometer is 1000 meter, and a megawatt is 1000000 watt.  Below the standard "
"prefixes."
msgstr ""
"В системе единиц СИ используются приставки, значения которых является "
"степенью числа. В километре 1000 метров, а в мегаватте — 1000000 ватт. Далее "
"показаны стандартные приставки."

#. type: tbl table
#: man-pages/man7/units.7:37 man-pages/man7/units.7:79
#, no-wrap
msgid "Prefix"
msgstr "Приставка"

#. type: tbl table
#: man-pages/man7/units.7:37 man-pages/man7/units.7:79
#, no-wrap
msgid "Name"
msgstr "Имя"

#. type: tbl table
#: man-pages/man7/units.7:37 man-pages/man7/units.7:79
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man7/units.7:38
#, no-wrap
msgid "y"
msgstr "и"

#. type: tbl table
#: man-pages/man7/units.7:38
#, no-wrap
msgid "yocto"
msgstr "иокто"

#. type: tbl table
#: man-pages/man7/units.7:38
#, no-wrap
msgid "10^-24 = 0.000000000000000000000001"
msgstr "10^-24 = 0.000000000000000000000001"

#. type: tbl table
#: man-pages/man7/units.7:39
#, no-wrap
msgid "z"
msgstr "з"

#. type: tbl table
#: man-pages/man7/units.7:39
#, no-wrap
msgid "zepto"
msgstr "зепто"

#. type: tbl table
#: man-pages/man7/units.7:39
#, no-wrap
msgid "10^-21 = 0.000000000000000000001"
msgstr "10^-21 = 0.000000000000000000001"

#. type: tbl table
#: man-pages/man7/units.7:40
#, no-wrap
msgid "a"
msgstr "а"

#. type: tbl table
#: man-pages/man7/units.7:40
#, no-wrap
msgid "atto"
msgstr "атто"

#. type: tbl table
#: man-pages/man7/units.7:40
#, no-wrap
msgid "10^-18 = 0.000000000000000001"
msgstr "10^-18 = 0.000000000000000001"

#. type: tbl table
#: man-pages/man7/units.7:41
#, no-wrap
msgid "f"
msgstr "ф"

#. type: tbl table
#: man-pages/man7/units.7:41
#, no-wrap
msgid "femto"
msgstr "фемто"

#. type: tbl table
#: man-pages/man7/units.7:41
#, no-wrap
msgid "10^-15 = 0.000000000000001"
msgstr "10^-15 = 0.000000000000001"

#. type: tbl table
#: man-pages/man7/units.7:42
#, no-wrap
msgid "p"
msgstr "п"

#. type: tbl table
#: man-pages/man7/units.7:42
#, no-wrap
msgid "pico"
msgstr "пико"

#. type: tbl table
#: man-pages/man7/units.7:42
#, no-wrap
msgid "10^-12 = 0.000000000001"
msgstr "10^-12 = 0.000000000001"

#. type: tbl table
#: man-pages/man7/units.7:43
#, no-wrap
msgid "n"
msgstr "н"

#. type: tbl table
#: man-pages/man7/units.7:43
#, no-wrap
msgid "nano"
msgstr "нано"

#. type: tbl table
#: man-pages/man7/units.7:43
#, no-wrap
msgid "10^-9  = 0.000000001"
msgstr "10^-9  = 0.000000001"

#. type: tbl table
#: man-pages/man7/units.7:44
#, no-wrap
msgid "\\(mc"
msgstr "мк"

#. type: tbl table
#: man-pages/man7/units.7:44
#, no-wrap
msgid "micro"
msgstr "микро"

#. type: tbl table
#: man-pages/man7/units.7:44
#, no-wrap
msgid "10^-6  = 0.000001"
msgstr "10^-6  = 0.000001"

#. type: tbl table
#: man-pages/man7/units.7:45
#, no-wrap
msgid "m"
msgstr "м"

#. type: tbl table
#: man-pages/man7/units.7:45
#, no-wrap
msgid "milli"
msgstr "милли"

#. type: tbl table
#: man-pages/man7/units.7:45
#, no-wrap
msgid "10^-3  = 0.001"
msgstr "10^-3  = 0.001"

#. type: tbl table
#: man-pages/man7/units.7:46
#, no-wrap
msgid "c"
msgstr "с"

#. type: tbl table
#: man-pages/man7/units.7:46
#, no-wrap
msgid "centi"
msgstr "санти"

#. type: tbl table
#: man-pages/man7/units.7:46
#, no-wrap
msgid "10^-2  = 0.01"
msgstr "10^-2  = 0.01"

#. type: tbl table
#: man-pages/man7/units.7:47
#, no-wrap
msgid "d"
msgstr "д"

#. type: tbl table
#: man-pages/man7/units.7:47
#, no-wrap
msgid "deci"
msgstr "деци"

#. type: tbl table
#: man-pages/man7/units.7:47
#, no-wrap
msgid "10^-1  = 0.1"
msgstr "10^-1  = 0.1"

#. type: tbl table
#: man-pages/man7/units.7:48
#, no-wrap
msgid "da"
msgstr "да"

#. type: tbl table
#: man-pages/man7/units.7:48
#, no-wrap
msgid "deka"
msgstr "дека"

#. type: tbl table
#: man-pages/man7/units.7:48
#, no-wrap
msgid "10^ 1  = 10"
msgstr "10^ 1  = 10"

#. type: tbl table
#: man-pages/man7/units.7:49
#, no-wrap
msgid "h"
msgstr "г"

#. type: tbl table
#: man-pages/man7/units.7:49
#, no-wrap
msgid "hecto"
msgstr "гекто"

#. type: tbl table
#: man-pages/man7/units.7:49
#, no-wrap
msgid "10^ 2  = 100"
msgstr "10^ 2  = 100"

#. type: tbl table
#: man-pages/man7/units.7:50
#, no-wrap
msgid "k"
msgstr "к"

#. type: tbl table
#: man-pages/man7/units.7:50
#, no-wrap
msgid "kilo"
msgstr "кило"

#. type: tbl table
#: man-pages/man7/units.7:50
#, no-wrap
msgid "10^ 3  = 1000"
msgstr "10^ 3  = 1000"

#. type: tbl table
#: man-pages/man7/units.7:51
#, no-wrap
msgid "M"
msgstr "М"

#. type: tbl table
#: man-pages/man7/units.7:51
#, no-wrap
msgid "mega"
msgstr "мега"

#. type: tbl table
#: man-pages/man7/units.7:51
#, no-wrap
msgid "10^ 6  = 1000000"
msgstr "10^ 6  = 1000000"

#. type: tbl table
#: man-pages/man7/units.7:52
#, no-wrap
msgid "G"
msgstr "Г"

#. type: tbl table
#: man-pages/man7/units.7:52
#, no-wrap
msgid "giga"
msgstr "гига"

#. type: tbl table
#: man-pages/man7/units.7:52
#, no-wrap
msgid "10^ 9  = 1000000000"
msgstr "10^ 9  = 1000000000"

#. type: tbl table
#: man-pages/man7/units.7:53
#, no-wrap
msgid "T"
msgstr "Т"

#. type: tbl table
#: man-pages/man7/units.7:53
#, no-wrap
msgid "tera"
msgstr "тера"

#. type: tbl table
#: man-pages/man7/units.7:53
#, no-wrap
msgid "10^12  = 1000000000000"
msgstr "10^12  = 1000000000000"

#. type: tbl table
#: man-pages/man7/units.7:54
#, no-wrap
msgid "P"
msgstr "П"

#. type: tbl table
#: man-pages/man7/units.7:54
#, no-wrap
msgid "peta"
msgstr "пета"

#. type: tbl table
#: man-pages/man7/units.7:54
#, no-wrap
msgid "10^15  = 1000000000000000"
msgstr "10^15  = 1000000000000000"

#. type: tbl table
#: man-pages/man7/units.7:55
#, no-wrap
msgid "E"
msgstr "Э"

#. type: tbl table
#: man-pages/man7/units.7:55
#, no-wrap
msgid "exa"
msgstr "экса"

#. type: tbl table
#: man-pages/man7/units.7:55
#, no-wrap
msgid "10^18  = 1000000000000000000"
msgstr "10^18  = 1000000000000000000"

#. type: tbl table
#: man-pages/man7/units.7:56
#, no-wrap
msgid "Z"
msgstr "З"

#. type: tbl table
#: man-pages/man7/units.7:56
#, no-wrap
msgid "zetta"
msgstr "зетта"

#. type: tbl table
#: man-pages/man7/units.7:56
#, no-wrap
msgid "10^21  = 1000000000000000000000"
msgstr "10^21  = 1000000000000000000000"

#. type: tbl table
#: man-pages/man7/units.7:57
#, no-wrap
msgid "Y"
msgstr "И"

#. type: tbl table
#: man-pages/man7/units.7:57
#, no-wrap
msgid "yotta"
msgstr "иотта"

#. type: tbl table
#: man-pages/man7/units.7:57
#, no-wrap
msgid "10^24  = 1000000000000000000000000"
msgstr "10^24  = 1000000000000000000000000"

#. type: Plain text
#: man-pages/man7/units.7:64
msgid ""
"The symbol for micro is the Greek letter mu, often written u in an ASCII "
"context where this Greek letter is not available.  See also"
msgstr ""
"Для обозначения micro используется греческая буква мю. В кодировке ASCII, "
"где она отсутствует, вместо неё часто используют латинскую u. Смотрите также"

#. type: Plain text
#: man-pages/man7/units.7:68
msgid "E<.UR http://physics.nist.gov\\:/cuu\\:/Units\\:/prefixes.html> E<.UE>"
msgstr "E<.UR http://physics.nist.gov\\:/cuu\\:/Units\\:/prefixes.html> E<.UE>"

#. type: SS
#: man-pages/man7/units.7:69
#, no-wrap
msgid "Binary prefixes"
msgstr "Двоичные префиксы"

#. type: Plain text
#: man-pages/man7/units.7:76
msgid ""
"The binary prefixes resemble the decimal ones, but have an additional \\(aqi"
"\\(aq (and \"Ki\" starts with a capital \\(aqK\\(aq).  The names are formed "
"by taking the first syllable of the names of the decimal prefix with roughly "
"the same size, followed by \"bi\" for \"binary\"."
msgstr ""
"Двоичные префиксы походят на десятичные, но имеют дополнительную \\(aqi\\(aq "
"(и «Ki» начинается с заглавной \\(aqK\\(aq). Имена формируются из первого "
"звука имени десятичных префиксов примерно того же размера, за которым "
"следует «bi» (от «binary» — «двоичный»)."

#. type: tbl table
#: man-pages/man7/units.7:80
#, no-wrap
msgid "Ki"
msgstr "КиБ"

#. type: tbl table
#: man-pages/man7/units.7:80
#, no-wrap
msgid "kibi"
msgstr "киби"

#. type: tbl table
#: man-pages/man7/units.7:80
#, no-wrap
msgid "2^10 = 1024"
msgstr "2^10 = 1024"

#. type: tbl table
#: man-pages/man7/units.7:81
#, no-wrap
msgid "Mi"
msgstr "МиБ"

#. type: tbl table
#: man-pages/man7/units.7:81
#, no-wrap
msgid "mebi"
msgstr "меби"

#. type: tbl table
#: man-pages/man7/units.7:81
#, no-wrap
msgid "2^20 = 1048576"
msgstr "2^20 = 1048576"

#. type: tbl table
#: man-pages/man7/units.7:82
#, no-wrap
msgid "Gi"
msgstr "ГиБ"

#. type: tbl table
#: man-pages/man7/units.7:82
#, no-wrap
msgid "gibi"
msgstr "гиби"

#. type: tbl table
#: man-pages/man7/units.7:82
#, no-wrap
msgid "2^30 = 1073741824"
msgstr "2^30 = 1073741824"

#. type: tbl table
#: man-pages/man7/units.7:83
#, no-wrap
msgid "Ti"
msgstr "ТиБ"

#. type: tbl table
#: man-pages/man7/units.7:83
#, no-wrap
msgid "tebi"
msgstr "теби"

#. type: tbl table
#: man-pages/man7/units.7:83
#, no-wrap
msgid "2^40 = 1099511627776"
msgstr "2^40 = 1099511627776"

#. type: tbl table
#: man-pages/man7/units.7:84
#, no-wrap
msgid "Pi"
msgstr "ПиБ"

#. type: tbl table
#: man-pages/man7/units.7:84
#, no-wrap
msgid "pebi"
msgstr "пеби"

#. type: tbl table
#: man-pages/man7/units.7:84
#, no-wrap
msgid "2^50 = 1125899906842624"
msgstr "2^50 = 1125899906842624"

#. type: tbl table
#: man-pages/man7/units.7:85
#, no-wrap
msgid "Ei"
msgstr "ЭиБ"

#. type: tbl table
#: man-pages/man7/units.7:85
#, no-wrap
msgid "exbi"
msgstr "эксби"

#. type: tbl table
#: man-pages/man7/units.7:85
#, no-wrap
msgid "2^60 = 1152921504606846976"
msgstr "2^60 = 1152921504606846976"

#. type: Plain text
#: man-pages/man7/units.7:90
msgid "See also"
msgstr "Смотрите также"

#. type: Plain text
#: man-pages/man7/units.7:93
msgid "E<.UR http://physics.nist.gov\\:/cuu\\:/Units\\:/binary.html> E<.UE>"
msgstr "E<.UR http://physics.nist.gov\\:/cuu\\:/Units\\:/binary.html> E<.UE>"

#. type: SS
#: man-pages/man7/units.7:93
#, no-wrap
msgid "Discussion"
msgstr "Обсуждение"

#. type: Plain text
#: man-pages/man7/units.7:98
msgid ""
"Before these binary prefixes were introduced, it was fairly common to use "
"k=1000 and K=1024, just like b=bit, B=byte.  Unfortunately, the M is capital "
"already, and cannot be capitalized to indicate binary-ness."
msgstr ""
"До введения двоичных префиксов довольно часто использовалось k=1000 и "
"K=1024, также как и b=bit (бит), B=byte (байт). К сожалению, заглавная M уже "
"занята, и не может быть использована как признак двоичности."

#. type: Plain text
#: man-pages/man7/units.7:109
msgid ""
"At first that didn't matter too much, since memory modules and disks came in "
"sizes that were powers of two, so everyone knew that in such contexts "
"\"kilobyte\" and \"megabyte\" meant 1024 and 1048576 bytes, respectively.  "
"What originally was a sloppy use of the prefixes \"kilo\" and \"mega\" "
"started to become regarded as the \"real true meaning\" when computers were "
"involved.  But then disk technology changed, and disk sizes became arbitrary "
"numbers.  After a period of uncertainty all disk manufacturers settled on "
"the standard, namely k=1000, M=1000\\ k, G=1000\\ M."
msgstr ""
"Поначалу это не имело большого значения, модули памяти и диски имели размер, "
"равный степеням двойки, и все знали, что в таких случаях «килобайт» означает "
"1024, а «мегабайт» — 1048576 байтов. Впрочем, некоторая путаница связанная с "
"этим всё же была. После некоторых колебаний все производители дисков "
"установили стандарт, по которому k=1000, M=1000\\ к, G=1000\\ М."

#.  also common: 14.4k modem
#. type: Plain text
#: man-pages/man7/units.7:116
msgid ""
"The situation was messy: in the 14k4 modems, k=1000; in the 1.44\\ MB "
"diskettes, M=1024000; and so on.  In 1998 the IEC approved the standard that "
"defines the binary prefixes given above, enabling people to be precise and "
"unambiguous."
msgstr ""
"Ситуация получилась запутанной: в модемах со скоростью 14k4 k=1000; в "
"дискетах 1.44\\ МБ M=1024000 и т. п. В 1998 году IEC принял стандарт, "
"который определяет двоичные префиксы как указано выше, что позволяет людям "
"быть точными и однозначными."

#. type: Plain text
#: man-pages/man7/units.7:118
msgid "Thus, today, MB = 1000000\\ B and MiB = 1048576\\ B."
msgstr "Таким образом, сегодня МБ = 1000000 \\Б, а МиБ = 1048576 \\Б."

#. type: Plain text
#: man-pages/man7/units.7:122
msgid ""
"In the free software world programs are slowly being changed to conform.  "
"When the Linux kernel boots and says"
msgstr ""
"В мире свободного программного обеспечения программы медленно переходят к "
"таким обозначениям. Когда ядро Linux при загрузке выводит"

#. type: Plain text
#: man-pages/man7/units.7:126
#, no-wrap
msgid "hda: 120064896 sectors (61473 MB) w/2048KiB Cache\n"
msgstr "hda: 120064896 sectors (61473 MB) w/2048KiB Cache\n"

#. type: Plain text
#: man-pages/man7/units.7:129
msgid "the MB are megabytes and the KiB are kibibytes."
msgstr "то MB — это мегабайты, а KiB — кибибайты."

#. type: TH
#: man-pages/man7/unix.7:20
#, no-wrap
msgid "UNIX"
msgstr "UNIX"

#. type: TH
#: man-pages/man7/unix.7:20
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: man-pages/man7/unix.7:23
msgid "unix - sockets for local interprocess communication"
msgstr "unix - сокеты для локального межпроцессного взаимодействия"

#. type: SH
#: man-pages/man7/unix.7:23
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man7/unix.7:25
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man7/unix.7:27
msgid "B<#include E<lt>sys/un.hE<gt>>"
msgstr "B<#include E<lt>sys/un.hE<gt>>"

#. type: Plain text
#: man-pages/man7/unix.7:29
msgid "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"
msgstr "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"

#. type: Plain text
#: man-pages/man7/unix.7:31
msgid "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"
msgstr "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"

#. type: Plain text
#: man-pages/man7/unix.7:42
msgid ""
"The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
"communicate between processes on the same machine efficiently.  "
"Traditionally, UNIX domain sockets can be either unnamed, or bound to a "
"filesystem pathname (marked as being of type socket).  Linux also supports "
"an abstract namespace which is independent of the filesystem."
msgstr ""
"Семейство сокетов B<AF_UNIX> (также известное, как B<AF_LOCAL>) используется "
"для эффективного взаимодействия между процессами на одной машине. Доменные "
"сокеты UNIX могут быть как безымянными, так и иметь имя файла в файловой "
"системе (типизированный сокет). В Linux также поддерживается абстрактное "
"пространство имён, которое не зависит от файловой системы."

#. type: Plain text
#: man-pages/man7/unix.7:55
msgid ""
"Valid socket types in the UNIX domain are: B<SOCK_STREAM>, for a stream-"
"oriented socket; B<SOCK_DGRAM>, for a datagram-oriented socket that "
"preserves message boundaries (as on most UNIX implementations, UNIX domain "
"datagram sockets are always reliable and don't reorder datagrams); and "
"(since Linux 2.6.4)  B<SOCK_SEQPACKET>, for a sequenced-packet socket that "
"is connection-oriented, preserves message boundaries, and delivers messages "
"in the order that they were sent."
msgstr ""
"Допустимые типы сокета для домена UNIX: потоковый сокет B<SOCK_STREAM>, "
"датаграмный сокет B<SOCK_DGRAM>, сохраняющий границы сообщений (в "
"большинстве реализаций UNIX, доменные датаграмные сокеты UNIX всегда надёжны "
"и не меняют порядок датаграмм); и (начиная с Linux 2.6.4)  ориентированный "
"на соединение задающий последовательность пакетам сокет B<SOCK_SEQPACKET>, "
"сохраняющий границы сообщений и доставляющий сообщения в том же порядке, в "
"каком они были отправлены."

#. type: Plain text
#: man-pages/man7/unix.7:58
msgid ""
"UNIX domain sockets support passing file descriptors or process credentials "
"to other processes using ancillary data."
msgstr ""
"Доменные сокеты UNIX поддерживают передачу файловых дескрипторов или учётных "
"данных (credentials) о процессе другим процессам, используя вспомогательные "
"(ancillary) данные."

#. type: SS
#: man-pages/man7/unix.7:58
#, no-wrap
msgid "Address format"
msgstr "Формат адреса"

#. type: Plain text
#: man-pages/man7/unix.7:60
msgid "A UNIX domain socket address is represented in the following structure:"
msgstr "Адрес доменного сокета UNIX представляет собой следующую структуру:"

#.  #define UNIX_PATH_MAX    108
#. type: Plain text
#: man-pages/man7/unix.7:69
#, no-wrap
msgid ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* Pathname */\n"
"};\n"
msgstr ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* имя пути */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/unix.7:79
msgid ""
"The I<sun_family> field always contains B<AF_UNIX>.  On Linux, I<sun_path> "
"is 108 bytes in size; see also NOTES, below."
msgstr ""
"Поле I<sun_family> всегда содержит B<AF_UNIX>. В Linux размер I<sun_path> "
"равен 108 байтам; также смотрите ЗАМЕЧАНИЯ ниже."

#. type: Plain text
#: man-pages/man7/unix.7:95
msgid ""
"Various systems calls (for example, B<bind>(2), B<connect>(2), and "
"B<sendto>(2))  take a I<sockaddr_un> argument as input.  Some other system "
"calls (for example, B<getsockname>(2), B<getpeername>(2), B<recvfrom>(2), "
"and B<accept>(2))  return an argument of this type."
msgstr ""
"В различных системных вызовах (например, B<bind>(2), B<connect>(2) и "
"B<sendto>(2)) в качестве входных данных используется параметр "
"I<sockaddr_un>. Другие системные вызовы (например, B<getsockname>(2), "
"B<getpeername>(2), B<recvfrom>(2) и B<accept>(2)) возвращают результат в "
"параметре этого типа."

#. type: Plain text
#: man-pages/man7/unix.7:99
msgid ""
"Three types of address are distinguished in the I<sockaddr_un> structure:"
msgstr "В I<sockaddr_un> структуре различают три типа адресов:"

#. type: IP
#: man-pages/man7/unix.7:99 man-pages/man7/unix.7:124 man-pages/man7/unix.7:140
#: man-pages/man7/unix.7:165 man-pages/man7/unix.7:169
#: man-pages/man7/unix.7:173
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man7/unix.7:107
msgid ""
"I<pathname>: a UNIX domain socket can be bound to a null-terminated "
"filesystem pathname using B<bind>(2).  When the address of a pathname socket "
"is returned (by one of the system calls noted above), its length is"
msgstr ""
"I<с именем пути>: доменный сокет UNIX может быть привязан к имени пути (с "
"завершающимся null) в файловой системе с помощью B<bind>(2). При возврате "
"адреса имени пути сокета (одним и системных вызовов, упомянутых выше), его "
"длина равна"

#. type: Plain text
#: man-pages/man7/unix.7:109
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"
msgstr "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"

#. type: Plain text
#: man-pages/man7/unix.7:122
msgid ""
"and I<sun_path> contains the null-terminated pathname.  (On Linux, the above "
"B<offsetof>()  expression equates to the same value as "
"I<sizeof(sa_family_t)>, but some other implementations include other fields "
"before I<sun_path>, so the B<offsetof>()  expression more portably describes "
"the size of the address structure.)"
msgstr ""
"и I<sun_path> содержит путь, оканчивающийся null (в Linux, указанное выше "
"выражение B<offsetof>() равно I<sizeof(sa_family_t)>, но в некоторых "
"реализациях включаются другие поля перед I<sun_path>, поэтому выражение "
"B<offsetof>() описывает размер адресной структуры более переносимым "
"способом)."

#. type: Plain text
#: man-pages/man7/unix.7:124
msgid "For further details of pathname sockets, see below."
msgstr "Дополнительную информацию о путях сокета смотрите далее."

#.  There is quite some variation across implementations: FreeBSD
#.  says the length is 16 bytes, HP-UX 11 says it's zero bytes.
#. type: Plain text
#: man-pages/man7/unix.7:140
msgid ""
"I<unnamed>: A stream socket that has not been bound to a pathname using "
"B<bind>(2)  has no name.  Likewise, the two sockets created by "
"B<socketpair>(2)  are unnamed.  When the address of an unnamed socket is "
"returned, its length is I<sizeof(sa_family_t)>, and I<sun_path> should not "
"be inspected."
msgstr ""
"I<безымянный>: Потоковый сокет, который не привязан к имени пути с помощью "
"B<bind>(), не имеет имени. Аналогично, два сокета, создаваемые "
"B<socketpair>(), также не имеют имён.  При возврате адреса сокета его длина "
"равна I<sizeof(sa_family_t)>, а значение I<sun_path> не используется."

#. type: Plain text
#: man-pages/man7/unix.7:162
msgid ""
"I<abstract>: an abstract socket address is distinguished (from a pathname "
"socket)  by the fact that I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  "
"The socket's address in this namespace is given by the additional bytes in "
"I<sun_path> that are covered by the specified length of the address "
"structure.  (Null bytes in the name have no special significance.)  The name "
"has no connection with filesystem pathnames.  When the address of an "
"abstract socket is returned, the returned I<addrlen> is greater than "
"I<sizeof(sa_family_t)> (i.e., greater than 2), and the name of the socket is "
"contained in the first I<(addrlen - sizeof(sa_family_t))> bytes of "
"I<sun_path>."
msgstr ""
"I<абстрактный>: абстрактный адрес сокета отличается (от имени пути сокета) "
"тем, что значением I<sun_path[0]> является байт null (\\(aq\\e0\\(aq). Адрес "
"сокета в этом пространстве имён определяется дополнительными байтами в "
"I<sun_path>, количество которых определяется длиной указанной структуры "
"адреса. Байты null в имени не имеют специального значения. Имя не связано с "
"именем пути в файловой системе. При возврате адреса абстрактного сокета "
"возвращаемое значение I<addrlen> больше чем I<sizeof(sa_family_t)> (т.е. "
"больше 2), а имя сокета содержится в первых I<(addrlen - "
"sizeof(sa_family_t))> байтах I<sun_path>."

#. type: SS
#: man-pages/man7/unix.7:162
#, no-wrap
msgid "Pathname sockets"
msgstr "Путевые сокеты"

#. type: Plain text
#: man-pages/man7/unix.7:165
msgid ""
"When binding a socket to a pathname, a few rules should be observed for "
"maximum portability and ease of coding:"
msgstr ""
"При привязке сокета к пути для максимальной переносимости и простоте "
"кодирования нужно учесть несколько правил:"

#. type: Plain text
#: man-pages/man7/unix.7:169
msgid "The pathname in I<sun_path> should be null-terminated."
msgstr "Имя пути в I<sun_path> должно завершаться null."

#. type: Plain text
#: man-pages/man7/unix.7:173
msgid ""
"The length of the pathname, including the terminating null byte, should not "
"exceed the size of I<sun_path>."
msgstr ""
"Длина имени пути, включая завершающий байт null, не должна превышать размер "
"I<sun_path>."

#. type: Plain text
#: man-pages/man7/unix.7:179
msgid ""
"The I<addrlen> argument that describes the enclosing I<sockaddr_un> "
"structure should have a value of at least:"
msgstr ""
"Аргумент I<addrlen>, описывающий включаемую структуру I<sockaddr_un>, должен "
"содержать значение, как минимум:"

#. type: Plain text
#: man-pages/man7/unix.7:182
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"
msgstr "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"

#. type: Plain text
#: man-pages/man7/unix.7:188
msgid ""
"or, more simply, I<addrlen> can be specified as I<sizeof(struct "
"sockaddr_un)>."
msgstr ""
"или, проще говоря, для I<addrlen> можно использовать I<sizeof(struct "
"sockaddr_un)>."

#.  Linux does this, including for the case where the supplied path
#.  is 108 bytes
#. type: Plain text
#: man-pages/man7/unix.7:196
msgid ""
"There is some variation in how implementations handle UNIX domain socket "
"addresses that do not follow the above rules.  For example, some (but not "
"all) implementations append a null terminator if none is present in the "
"supplied I<sun_path>."
msgstr ""
"Есть несколько реализаций по работе с адресами доменных сокетов UNIX, "
"которые не следуют данным правилам. Например, в некоторых реализациях (но не "
"во всех) добавляется конечный null, если если его нет в I<sun_path>."

#.  HP-UX
#.  Modern BSDs generally have 104, Tru64 and AIX have 104,
#.  Solaris and Irix have 108
#. type: Plain text
#: man-pages/man7/unix.7:205
msgid ""
"When coding portable applications, keep in mind that some implementations "
"have I<sun_path> as short as 92 bytes."
msgstr ""
"При написании переносимых приложений учтите, что в некоторых реализациях "
"размер I<sun_path>равен 92 байтам."

#. type: Plain text
#: man-pages/man7/unix.7:224
msgid ""
"Various system calls (B<accept>(2), B<recvfrom>(2), B<getsockname>(2), "
"B<getpeername>(2))  return socket address structures.  When applied to UNIX "
"domain sockets, the value-result I<addrlen> argument supplied to the call "
"should be initialized as above.  Upon return, the argument is set to "
"indicate the I<actual> size of the address structure.  The caller should "
"check the value returned in this argument: if the output value exceeds the "
"input value, then there is no guarantee that a null terminator is present in "
"I<sun_path>.  (See BUGS.)"
msgstr ""
"Различные системные вызовы (например, B<accept>(2), B<recvfrom>(2), "
"B<getsockname>(2), B<getpeername>(2)) возвращают адресные структуры сокета. "
"В случае с доменными сокетами UNIX аргумент значение-результат I<addrlen>, "
"передаваемый вызову, должен быть инициализирован как описано выше. При "
"возврате в аргументе содержится I<реальный> размер адресной структуры. "
"Вызывающий должен проверить полученное значение этого аргумента: если оно "
"превышает значение до вызова, то не гарантируется наличие конечного null в "
"I<sun_path> (смотрите ДЕФЕКТЫ)."

#. type: SS
#: man-pages/man7/unix.7:224
#, no-wrap
msgid "Pathname socket ownership and permissions"
msgstr "Пути к сокетам и права"

#. type: Plain text
#: man-pages/man7/unix.7:229
msgid ""
"In the Linux implementation, pathname sockets honor the permissions of the "
"directory they are in.  Creation of a new socket fails if the process does "
"not have write and search (execute) permission on the directory in which the "
"socket is created."
msgstr ""
"В реализации Linux учитываются права на каталоги, в которых располагаются "
"сокеты. Создание нового сокета завершается ошибкой, если процесс не имеет "
"права писать или искать (выполнять) в каталог, в котором создаётся сокет."

#. type: Plain text
#: man-pages/man7/unix.7:239
msgid ""
"On Linux, connecting to a stream socket object requires write permission on "
"that socket; sending a datagram to a datagram socket likewise requires write "
"permission on that socket.  POSIX does not make any statement about the "
"effect of the permissions on a socket file, and on some systems (e.g., older "
"BSDs), the socket permissions are ignored.  Portable programs should not "
"rely on this feature for security."
msgstr ""
"В Linux для подключения к объекту потокового сокета требуются права на "
"запись в этот сокет; схожим образом, для отправки дейтаграммы в "
"дейтаграммный сокет требуются права на запись в этот сокет. В POSIX ничего "
"не сказано о влиянии прав файла сокета и в некоторых системах (например, в "
"старых BSD) права на сокет игнорируются. Переносимые программы не должны "
"полагаться на это свойство для обеспечения безопасности."

#. type: Plain text
#: man-pages/man7/unix.7:245
msgid ""
"When creating a new socket, the owner and group of the socket file are set "
"according to the usual rules.  The socket file has all permissions enabled, "
"other than those that are turned off by the process B<umask>(2)."
msgstr ""
"При создании нового сокета владелец и группа файла сокета назначаются "
"согласно обычных правил. К файлу сокета разрешается любой доступ кроме "
"выключенного процессом с помощью B<umask>(2)."

#.  However, fchown() and fchmod() do not seem to have an effect
#. type: Plain text
#: man-pages/man7/unix.7:252
msgid ""
"The owner, group, and permissions of a pathname socket can be changed (using "
"B<chown>(2)  and B<chmod>(2))."
msgstr ""
"Владелец, группа и права доступа пути сокета можно изменять (с помощью "
"B<chown>(2) и B<chmod>(2))."

#. type: SS
#: man-pages/man7/unix.7:252
#, no-wrap
msgid "Abstract sockets"
msgstr "Абстрактные сокеты"

#. type: Plain text
#: man-pages/man7/unix.7:262
msgid ""
"Socket permissions have no meaning for abstract sockets: the process "
"B<umask>(2)  has no effect when binding an abstract socket, and changing the "
"ownership and permissions of the object (via B<fchown>(2)  and "
"B<fchmod>(2))  has no effect on the accessibility of the socket."
msgstr ""
"Права на сокеты не учитываются у абстрактных сокетов: B<umask>(2) процесса "
"не учитывается при подключении к абстрактному сокету как и изменение "
"владельца и прав доступа к объекту (посредством B<fchown>(2) и B<fchmod>(2)) "
"не влияют на доступность сокета."

#. type: Plain text
#: man-pages/man7/unix.7:265
msgid ""
"Abstract sockets automatically disappear when all open references to the "
"socket are closed."
msgstr ""
"Абстрактные сокеты автоматически исчезают при закрытии всех открытых ссылок "
"на них."

#. type: Plain text
#: man-pages/man7/unix.7:268
msgid "The abstract socket namespace is a nonportable Linux extension."
msgstr ""
"Пространство имён абстрактных сокетов является непереносимым расширением "
"Linux."

#. type: SS
#: man-pages/man7/unix.7:268
#, no-wrap
msgid "Socket options"
msgstr "Параметры сокета"

#. type: Plain text
#: man-pages/man7/unix.7:281
msgid ""
"For historical reasons, these socket options are specified with a "
"B<SOL_SOCKET> type even though they are B<AF_UNIX> specific.  They can be "
"set with B<setsockopt>(2)  and read with B<getsockopt>(2)  by specifying "
"B<SOL_SOCKET> as the socket family."
msgstr ""
"В силу исторических причин эти параметры сокетов относятся к типу "
"B<SOL_SOCKET>, даже если они относятся к B<AF_UNIX>. Они могут быть "
"установлены с помощью B<setsockopt>(2) и прочитаны с помощью "
"B<getsockopt>(2); тип B<SOL_SOCKET> указывается в качестве семейства сокета."

#. type: TP
#: man-pages/man7/unix.7:281
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#. type: Plain text
#: man-pages/man7/unix.7:293
msgid ""
"Enabling this socket option causes receipt of the credentials of the sending "
"process in an B<SCM_CREDENTIALS ancillary> message in each subsequently "
"received message.  The returned credentials are those specified by the "
"sender using B<SCM_CREDENTIALS>, or a default that includes the sender's "
"PID, real user ID, and real group ID, if the sender did not specify "
"B<SCM_CREDENTIALS> ancillary data."
msgstr ""
"Разрешает приём учётных данных посылающего процесса в вспомогательном "
"сообщении B<SCM_CREDENTIALS> каждого последующего принятого сообщения. "
"Полученные учётные данные были заданы отправителем с помощью "
"B<SCM_CREDENTIALS>, или имеют значение по умолчанию, которое содержит PID "
"отправителя, фактический пользовательский и групповой ID, если отправитель "
"не задал вспомогательные данные B<SCM_CREDENTIALS>."

#. type: Plain text
#: man-pages/man7/unix.7:296
msgid ""
"When this option is set and the socket is not yet connected, a unique name "
"in the abstract namespace will be generated automatically."
msgstr ""
"Если при включении этого параметра сокет ещё не соединён, то в абстрактном "
"пространстве имён будет автоматически создано уникальное имя."

#. type: Plain text
#: man-pages/man7/unix.7:302 man-pages/man7/unix.7:314
msgid ""
"The value given as an argument to B<setsockopt>(2)  and returned as the "
"result of B<getsockopt>(2)  is an integer boolean flag."
msgstr ""
"Значение передаётся в аргументе B<setsockopt>(2) и возвращается в результате "
"B<getsockopt>(2) в виде целочисленного логического флага."

#. type: TP
#: man-pages/man7/unix.7:302
#, no-wrap
msgid "B<SO_PASSSEC>"
msgstr "B<SO_PASSSEC>"

#. type: Plain text
#: man-pages/man7/unix.7:308
msgid ""
"Enables receiving of the SELinux security label of the peer socket in an "
"ancillary message of type B<SCM_SECURITY> (see below)."
msgstr ""
"Разрешает приём метки безопасности SELinux однорангового сокета в "
"вспомогательном сообщении с типом B<SCM_SECURITY> (смотрите ниже)."

#.  commit 877ce7c1b3afd69a9b1caeb1b9964c992641f52a
#.  commit 37a9a8df8ce9de6ea73349c9ac8bdf6ba4ec4f70
#. type: Plain text
#: man-pages/man7/unix.7:323
msgid ""
"The B<SO_PASSSEC> option is supported for UNIX domain datagram sockets since "
"Linux 2.6.18; support for UNIX domain stream sockets was added in Linux 4.2."
msgstr ""
"Параметр B<SO_PASSSEC> поддерживается для дейтаграммных доменных сокетов "
"UNIX начиная с Linux 2.6.18; поддержка потоковых доменных сокетов UNIX "
"добавлена в Linux 4.2."

#. type: TP
#: man-pages/man7/unix.7:323
#, no-wrap
msgid "B<SO_PEEK_OFF>"
msgstr "B<SO_PEEK_OFF>"

#. type: Plain text
#: man-pages/man7/unix.7:327
msgid "See B<socket>(7)."
msgstr "Смотрите B<socket>(7)."

#. type: TP
#: man-pages/man7/unix.7:327
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr "B<SO_PEERCRED>"

#. type: Plain text
#: man-pages/man7/unix.7:336
msgid ""
"This read-only socket option returns the credentials of the peer process "
"connected to this socket.  The returned credentials are those that were in "
"effect at the time of the call to B<connect>(2)  or B<socketpair>(2)."
msgstr ""
"С параметром сокета, доступным только для чтения, возвращаются учётные "
"данные однорангового процесса, соединённого с сокетом. Возвращаются "
"информационные данные, которые были действительными на момент вызова "
"B<connect>(2) или B<socketpair>(2)."

#. type: Plain text
#: man-pages/man7/unix.7:345
msgid ""
"The argument to B<getsockopt>(2)  is a pointer to a I<ucred> structure; "
"define the B<_GNU_SOURCE> feature test macro to obtain the definition of "
"that structure from I<E<lt>sys/socket.hE<gt>>."
msgstr ""
"Аргументом B<getsockopt>(2) является указатель на структуру I<ucred>; "
"определите макрос тестирования свойств B<_GNU_SOURCE> для получения "
"определения этой структуры из I<E<lt>sys/socket.hE<gt>>."

#. type: Plain text
#: man-pages/man7/unix.7:353
msgid ""
"The use of this option is possible only for connected B<AF_UNIX> stream "
"sockets and for B<AF_UNIX> stream and datagram socket pairs created using "
"B<socketpair>(2)."
msgstr ""
"Использование этого параметра возможо только для соединённых потоковых "
"сокетов B<AF_UNIX> и потоков B<AF_UNIX> и для дейтаграммных сокетных пар, "
"созданных с помощью B<socketpair>(2)."

#. type: SS
#: man-pages/man7/unix.7:353
#, no-wrap
msgid "Autobind feature"
msgstr "Свойство автоматической привязки"

#.  i.e., sizeof(short)
#. type: Plain text
#: man-pages/man7/unix.7:373
msgid ""
"If a B<bind>(2)  call specifies I<addrlen> as I<sizeof(sa_family_t)>, or the "
"B<SO_PASSCRED> socket option was specified for a socket that was not "
"explicitly bound to an address, then the socket is autobound to an abstract "
"address.  The address consists of a null byte followed by 5 bytes in the "
"character set I<[0-9a-f]>.  Thus, there is a limit of 2^20 autobind "
"addresses.  (From Linux 2.1.15, when the autobind feature was added, 8 bytes "
"were used, and the limit was thus 2^32 autobind addresses.  The change to 5 "
"bytes came in Linux 2.3.15.)"
msgstr ""
"Если в вызов B<bind>(2) передано значение I<addrlen> равное "
"I<sizeof(sa_family_t)>, или для сокета, который не привязан к адресу явно, "
"был указан параметр сокета B<SO_PASSCRED>, то сокет автоматически "
"привязывается к абстрактному адресу. Адрес состоит из байта null и 5 байтов "
"символов из набора I<[0-9a-f]>. Таким образом, максимальное количество "
"автоматически привязываемых адресов равно 2^20 (в Linux 2.1.15, когда была "
"добавлена автоматическая привязка, использовалось 8 байт, и, таким образом, "
"ограничение было 2^32 адресов. В Linux 2.3.15 количество байт сократили до "
"5)."

#. type: SS
#: man-pages/man7/unix.7:373
#, no-wrap
msgid "Sockets API"
msgstr "Программный интерфейс сокетов"

#. type: Plain text
#: man-pages/man7/unix.7:376
msgid ""
"The following paragraphs describe domain-specific details and unsupported "
"features of the sockets API for UNIX domain sockets on Linux."
msgstr ""
"В следующих параграфах описываются специфичные тонкости доменов и "
"неподдерживаемые возможности программного интерфейса сокетов для доменных "
"сокетов UNIX в Linux."

#. type: Plain text
#: man-pages/man7/unix.7:384
msgid ""
"UNIX domain sockets do not support the transmission of out-of-band data (the "
"B<MSG_OOB> flag for B<send>(2)  and B<recv>(2))."
msgstr ""
"Доменные сокеты UNIX не поддерживают передачу внеполосных данных (флаг "
"B<MSG_OOB> у B<send>(2) и B<recv>(2))."

#. type: Plain text
#: man-pages/man7/unix.7:389
msgid ""
"The B<send>(2)  B<MSG_MORE> flag is not supported by UNIX domain sockets."
msgstr ""
"Флаг B<MSG_MORE> у B<send>(2) не поддерживается доменными сокетами UNIX."

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: man-pages/man7/unix.7:399
msgid ""
"Before Linux 3.4, the use of B<MSG_TRUNC> in the I<flags> argument of "
"B<recv>(2)  was not supported by UNIX domain sockets."
msgstr ""
"До Linux 3.4 использование B<MSG_TRUNC> в аргументе I<flags> у B<recv>(2) не "
"поддерживалось доменными сокетами UNIX."

#. type: Plain text
#: man-pages/man7/unix.7:411
msgid ""
"The B<SO_SNDBUF> socket option does have an effect for UNIX domain sockets, "
"but the B<SO_RCVBUF> option does not.  For datagram sockets, the "
"B<SO_SNDBUF> value imposes an upper limit on the size of outgoing "
"datagrams.  This limit is calculated as the doubled (see B<socket>(7))  "
"option value less 32 bytes used for overhead."
msgstr ""
"Параметр сокета B<SO_SNDBUF> учитывается в доменных сокетах UNIX, а параметр "
"B<SO_RCVBUF> \\(em нет. Для датаграмных сокетов значение B<SO_SNDBUF> "
"считается максимальным размером для исходящих датаграмм. Это ограничение, "
"вычисляемое как удвоенное значение (см. B<socket>(7))  параметра, содержит "
"меньше 32 байт накладных расходов."

#. type: SS
#: man-pages/man7/unix.7:411
#, no-wrap
msgid "Ancillary messages"
msgstr "Вспомогательные сообщения"

#. type: Plain text
#: man-pages/man7/unix.7:433
msgid ""
"Ancillary data is sent and received using B<sendmsg>(2)  and B<recvmsg>(2).  "
"For historical reasons, the ancillary message types listed below are "
"specified with a B<SOL_SOCKET> type even though they are B<AF_UNIX> "
"specific.  To send them, set the I<cmsg_level> field of the struct "
"I<cmsghdr> to B<SOL_SOCKET> and the I<cmsg_type> field to the type.  For "
"more information, see B<cmsg>(3)."
msgstr ""
"Вспомогательные данные отправляются и принимаются с помощью B<sendmsg>(2) и "
"B<recvmsg>(2). В силу исторических причин перечисленные типы вспомогательных "
"сообщений относятся к типу B<SOL_SOCKET>, даже если они относятся к "
"B<AF_UNIX>. Для того, чтобы отправить их, установите значение поля "
"I<cmsg_level> структуры I<cmsghdr> равным B<SOL_SOCKET>, а в значении поля "
"I<cmsg_type> укажите его тип. Дополнительная информация приведена в "
"B<cmsg>(3)."

#. type: TP
#: man-pages/man7/unix.7:433
#, no-wrap
msgid "B<SCM_RIGHTS>"
msgstr "B<SCM_RIGHTS>"

#. type: Plain text
#: man-pages/man7/unix.7:437
msgid ""
"Send or receive a set of open file descriptors from another process.  The "
"data portion contains an integer array of the file descriptors."
msgstr ""
"Передать или принять набор открытых файловых дескрипторов из другого "
"процесса. Часть с данными содержит целочисленный массив файловых "
"дескрипторов."

#. type: Plain text
#: man-pages/man7/unix.7:448
msgid ""
"Commonly, this operation is referred to as \"passing a file descriptor\" to "
"another process.  However, more accurately, what is being passed is a "
"reference to an open file description (see B<open>(2)), and in the receiving "
"process it is likely that a different file descriptor number will be used.  "
"Semantically, this operation is equivalent to duplicating (B<dup>(2))  a "
"file descriptor into the file descriptor table of another process."
msgstr ""
"Обычно, эта операция упоминается как «передача дескриптора файла» другому "
"процессу. Но если точнее, то передается ссылка на открытое файловое описание "
"(смотрите B<open>(2)) и в принимающем процессе будет использоваться, "
"вероятно, файловый дескриптор с другим номером. Семантически, эта операция "
"эквивалентна дублированию (B<dup>(2)) файлового дескриптора в таблицу "
"файловых дескрипторов другого процесса."

#. type: Plain text
#: man-pages/man7/unix.7:454
msgid ""
"If the buffer used to receive the ancillary data containing file descriptors "
"is too small (or is absent), then the ancillary data is truncated (or "
"discarded)  and the excess file descriptors are automatically closed in the "
"receiving process."
msgstr ""
"Если используемый для приёма вспомогательных данных с файловыми "
"дескрипторами буфер слишком мал (или отсутствует), то вспомогательные данные "
"обрезаются (или отбрасываются), а избыточные файловые дескрипторы "
"автоматически закрываются в принимающем процессе."

#. type: Plain text
#: man-pages/man7/unix.7:462
msgid ""
"If the number of file descriptors received in the ancillary data would cause "
"the process to exceed its B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2)), the excess file descriptors are automatically closed in "
"the receiving process."
msgstr ""
"Если количество файловых дескрипторов, полученных во вспомогательных данных, "
"превышает ограничение ресурса процесса B<RLIMIT_NOFILE> (смотрите "
"B<getrlimit>(2)), то превысившие файловые дескрипторы автоматически "
"закрываются в принимающем процессе."

#.  commit bba14de98753cb6599a2dae0e520714b2153522d
#. type: Plain text
#: man-pages/man7/unix.7:475
msgid ""
"The kernel constant B<SCM_MAX_FD> defines a limit on the number of file "
"descriptors in the array.  Attempting to send an array larger than this "
"limit causes B<sendmsg>(2)  to fail with the error B<EINVAL>.  B<SCM_MAX_FD> "
"has the value 253 (or 255 in kernels before 2.6.38)."
msgstr ""
"Константой ядра B<SCM_MAX_FD> задаётся ограничение на количество файловых "
"дескрипторов в массиве. Попытка послать с помощью B<sendmsg>(2) массив "
"превышающий ограничение завершается ошибкой B<EINVAL>. Значение "
"B<SCM_MAX_FD> равно 253 (или 255 в ядрах до версии 2.6.38)."

#. type: TP
#: man-pages/man7/unix.7:475
#, no-wrap
msgid "B<SCM_CREDENTIALS>"
msgstr "B<SCM_CREDENTIALS>"

#. type: Plain text
#: man-pages/man7/unix.7:485
msgid ""
"Send or receive UNIX credentials.  This can be used for authentication.  The "
"credentials are passed as a I<struct ucred> ancillary message.  Thus "
"structure is defined in I<E<lt>sys/socket.hE<gt>> as follows:"
msgstr ""
"Передать или принять учётные данные UNIX. Может быть использована для "
"аутентификации. Учётные данные передаются в виде структуры I<struct ucred> "
"вспомогательного сообщения. Эта структура определена в I<E<lt>sys/socket."
"hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man7/unix.7:493
#, no-wrap
msgid ""
"struct ucred {\n"
"    pid_t pid;    /* Process ID of the sending process */\n"
"    uid_t uid;    /* User ID of the sending process */\n"
"    gid_t gid;    /* Group ID of the sending process */\n"
"};\n"
msgstr ""
"struct ucred {\n"
"    pid_t pid;    /* идентификатор посылающего процесса */\n"
"    uid_t uid;    /* идентификатор пользователя посылающего процесса */\n"
"    gid_t gid;    /* идентификатор группы посылающего процесса */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/unix.7:502
msgid ""
"Since glibc 2.8, the B<_GNU_SOURCE> feature test macro must be defined "
"(before including I<any> header files) in order to obtain the definition of "
"this structure."
msgstr ""
"Начиная с glibc 2.8, чтобы получить определение данной структуры должен быть "
"определён макрос тестирования свойств B<_GNU_SOURCE> (до включения I<каких-"
"либо> заголовочных файлов)."

#. type: Plain text
#: man-pages/man7/unix.7:512
msgid ""
"The credentials which the sender specifies are checked by the kernel.  A "
"privileged process is allowed to specify values that do not match its own.  "
"The sender must specify its own process ID (unless it has the capability "
"B<CAP_SYS_ADMIN>), its real user ID, effective user ID, or saved set-user-ID "
"(unless it has B<CAP_SETUID>), and its real group ID, effective group ID, or "
"saved set-group-ID (unless it has B<CAP_SETGID>)."
msgstr ""
"Учётные данные (credentials), указываемые отправителем, проверяются ядром. "
"Привилегированный процесс может указывать значения, отличные от его "
"собственных. Отправитель должен указать идентификатор своего процесса (если "
"только он не имеет мандата B<CAP_SYS_ADMIN>), свой реальный идентификатор "
"пользователя, действующий идентификатор или сохранённый set-user-ID (если "
"только он не имеет B<CAP_SETUID>) и реальный идентификатор своей группы, "
"действующий идентификатор группы или сохранённый set-group-ID (если только "
"он не имеет B<CAP_SETGID>)."

#. type: Plain text
#: man-pages/man7/unix.7:518
msgid ""
"To receive a I<struct ucred> message, the B<SO_PASSCRED> option must be "
"enabled on the socket."
msgstr ""
"Для получения сообщения со структурой I<struct ucred> у сокета должен быть "
"включён параметр B<SO_PASSCRED>."

#. type: TP
#: man-pages/man7/unix.7:518
#, no-wrap
msgid "B<SCM_SECURITY>"
msgstr "B<SCM_SECURITY>"

#. type: Plain text
#: man-pages/man7/unix.7:527
msgid ""
"Receive the SELinux security context (the security label)  of the peer "
"socket.  The received ancillary data is a null-terminated string containing "
"the security context.  The receiver should allocate at least B<NAME_MAX> "
"bytes in the data portion of the ancillary message for this data."
msgstr ""
"Получить контекст безопасности SELinux (метку безопасности) однорангового "
"сокета. Полученные вспомогательные данные представляют собой строку (с null "
"в конце) с контекстом безопасности. Получатель должен выделить не менее "
"B<NAME_MAX> байт под эти данные в в части данных вспомогательного сообщения."

#. type: Plain text
#: man-pages/man7/unix.7:531
msgid ""
"To receive the security context, the B<SO_PASSSEC> option must be enabled on "
"the socket (see above)."
msgstr ""
"Для получения контекста безопасности у сокета должен быть включён параметр "
"B<SO_PASSSEC> (смотрите выше)."

#. type: Plain text
#: man-pages/man7/unix.7:535
msgid ""
"When sending ancillary data with B<sendmsg>(2), only one item of each of the "
"above types may be included in the sent message."
msgstr ""
"При отправке вспомогательных данных с помощью B<sendmsg>(2) посылаемое "
"сообщение может содержать только по одному элементу каждого типа, из "
"представленных выше."

#. type: Plain text
#: man-pages/man7/unix.7:543
msgid ""
"At least one byte of real data should be sent when sending ancillary data.  "
"On Linux, this is required to successfully send ancillary data over a UNIX "
"domain stream socket.  When sending ancillary data over a UNIX domain "
"datagram socket, it is not necessary on Linux to send any accompanying real "
"data.  However, portable applications should also include at least one byte "
"of real data when sending ancillary data over a datagram socket."
msgstr ""
"По крайней мере один байт реальных данных должен быть отправлен при отправке "
"вспомогательных данных. В Linux это требуется для успешной отправки "
"вспомогательных данных через потоковый доменный сокет UNIX. При отправке "
"вспомогательных данных через дейтаграммный доменный сокет UNIX в Linux "
"необязательно отправлять какие-либо реальные сопровождающие данные. Однако "
"переносимые приложения должны также включать, по крайней мере, один байт "
"реальных данных при отправке вспомогательных данных через дейтаграммный "
"сокет."

#. type: Plain text
#: man-pages/man7/unix.7:547
msgid ""
"When receiving from a stream socket, ancillary data forms a kind of barrier "
"for the received data.  For example, suppose that the sender transmits as "
"follows:"
msgstr ""
"При получении из потокового сокета вспомогательные данные формируют своего "
"рода барьер для полученных данных. Например, предположим, что отправитель "
"передает так:"

#. type: IP
#: man-pages/man7/unix.7:550
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man7/unix.7:553 man-pages/man7/unix.7:559
msgid "B<sendmsg>(2)  of four bytes, with no ancillary data."
msgstr "B<sendmsg>(2) отправляет четыре байта без вспомогательных данных."

#. type: IP
#: man-pages/man7/unix.7:553
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man7/unix.7:556
msgid "B<sendmsg>(2)  of one byte, with ancillary data."
msgstr "B<sendmsg>(2) отправляет один байт вспомогательных данных."

#. type: IP
#: man-pages/man7/unix.7:556
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man7/unix.7:570
msgid ""
"Suppose that the receiver now performs B<recvmsg>(2)  calls each with a "
"buffer size of 20 bytes.  The first call will receive five bytes of data, "
"along with the ancillary data sent by the second B<sendmsg>(2)  call.  The "
"next call will receive the remaining five bytes of data."
msgstr ""
"Предположим, что получатель теперь выполняет каждый вызов B<recvmsg>(2) с "
"буфером размером 20 байтов. Первый вызов получит пять байтов данных вместе с "
"вспомогательными данными, отправленными вторым вызовом B<sendmsg>(2). "
"Следующий вызов получит оставшиеся пять байтов данных."

#. type: Plain text
#: man-pages/man7/unix.7:591
msgid ""
"If the space allocated for receiving incoming ancillary data is too small "
"then the ancillary data is truncated to the number of headers that will fit "
"in the supplied buffer (or, in the case of an B<SCM_RIGHTS> file descriptor "
"list, the list of file descriptors may be truncated).  If no buffer is "
"provided for incoming ancillary data (i.e., the I<msg_control> field of the "
"I<msghdr> structure supplied to B<recvmsg>(2)  is NULL), then the incoming "
"ancillary data is discarded.  In both of these cases, the B<MSG_CTRUNC> flag "
"will be set in the I<msg.msg_flags> value returned by B<recvmsg>(2)."
msgstr ""
"Если место, выделенное для получения входящих вспомогательных данных, "
"слишком маленькое, то вспомогательные данные обрезаются по количеству "
"заголовков, которые влезут в предоставленной буфер (или, в случае списка "
"файловых дескрипторов B<SCM_RIGHTS>, может быть обрезан список файловых "
"дескрипторов). Если для входящих вспомогательных данных буфер не был "
"предусмотрен (т. е., поле I<msg_control> в структуре I<msghdr>, указанное "
"B<recvmsg>(2),  равно NULL), то входящие вспомогательные данные "
"отбрасываются. В обоих случаях, в возвращаемом значении B<recvmsg>(2) в "
"I<msg.msg_flags> будет установлен флаг B<MSG_CTRUNC>."

#. type: SS
#: man-pages/man7/unix.7:591
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#. type: Plain text
#: man-pages/man7/unix.7:597
msgid ""
"The following B<ioctl>(2)  calls return information in I<value>.  The "
"correct syntax is:"
msgstr ""
"Следующие вызовы B<ioctl>(2) возвращают информацию в аргументе I<value>. "
"Корректный синтаксис:"

#. type: Plain text
#: man-pages/man7/unix.7:602
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: Plain text
#: man-pages/man7/unix.7:607
msgid "I<ioctl_type> can be:"
msgstr "Значением I<ioctl_type> может быть:"

#. type: TP
#: man-pages/man7/unix.7:607
#, no-wrap
msgid "B<SIOCINQ>"
msgstr "B<SIOCINQ>"

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#.  SIOCOUTQ also has an effect for UNIX domain sockets, but not
#.  quite what userland might expect. It seems to return the number
#.  of bytes allocated for buffers containing pending output.
#.  That number is normally larger than the number of bytes of pending
#.  output. Since this info is, from userland's point of view, imprecise,
#.  and it may well change, probably best not to document this now.
#. type: Plain text
#: man-pages/man7/unix.7:638
msgid ""
"For B<SOCK_STREAM> sockets, this call returns the number of unread bytes in "
"the receive buffer.  The socket must not be in LISTEN state, otherwise an "
"error (B<EINVAL>)  is returned.  B<SIOCINQ> is defined in I<E<lt>linux/"
"sockios.hE<gt>>.  Alternatively, you can use the synonymous B<FIONREAD>, "
"defined in I<E<lt>sys/ioctl.hE<gt>>.  For B<SOCK_DGRAM> sockets, the "
"returned value is the same as for Internet domain datagram sockets; see "
"B<udp>(7)."
msgstr ""
"Для сокетов B<SOCK_STREAM> этот вызов возвращает количество непрочитанных "
"данных в приёмном буфере. Сокет не должен быть в состоянии LISTEN, иначе "
"возвращается ошибка (B<EINVAL>). Значение B<SIOCINQ> определено в "
"I<E<lt>linux/sockios.hE<gt>>. В качестве альтернативы можно использовать "
"синоним B<FIONREAD>, определённый в I<E<lt>sys/ioctl.hE<gt>>. Для сокетов "
"B<SOCK_DGRAM> возвращаемое значение совпадает с дейтаграммными доменными "
"сокетами Интернета; смотрите B<udp>(7)."

#. type: SH
#: man-pages/man7/unix.7:638
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/unix.7:639
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: man-pages/man7/unix.7:643
msgid ""
"The specified local address is already in use or the filesystem socket "
"object already exists."
msgstr ""
"Заданный локальный адрес уже используется, или сокетный объект файловой "
"системы уже существует."

#. type: TP
#: man-pages/man7/unix.7:643
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man7/unix.7:652
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above), and indicates that the file descriptor number that is "
"being sent is not valid (e.g., it is not an open file descriptor)."
msgstr ""
"Эта ошибка может возникать в B<sendmsg>(2) при отправке файлового "
"дескриптора в вспомогательных данных через доменный сокет UNIX (смотрите "
"описание B<SCM_RIGHTS> выше), и указывает на то, что отправляемый номер "
"файлового дескриптора некорректен (например, не является открытым файловым "
"дескриптором)."

#. type: TP
#: man-pages/man7/unix.7:652
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: man-pages/man7/unix.7:658
msgid ""
"The remote address specified by B<connect>(2)  was not a listening socket.  "
"This error can also occur if the target pathname is not a socket."
msgstr ""
"Удалённый адрес, указанный B<connect>(2) не является слушающим сокетом. Эта "
"ошибка также может возникнуть, если путь назначения не является сокетом."

#. type: TP
#: man-pages/man7/unix.7:658
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: man-pages/man7/unix.7:661
msgid "Remote socket was unexpectedly closed."
msgstr "Удалённый сокет был неожиданно закрыт."

#. type: TP
#: man-pages/man7/unix.7:661
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man7/unix.7:664
msgid "User memory address was not valid."
msgstr "Некорректный адрес пользовательской памяти."

#. type: TP
#: man-pages/man7/unix.7:664
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/unix.7:673
msgid ""
"Invalid argument passed.  A common cause is that the value B<AF_UNIX> was "
"not specified in the I<sun_type> field of passed addresses, or the socket "
"was in an invalid state for the applied operation."
msgstr ""
"Передан неправильный аргумент. Основная причина \\(em не задано значение "
"B<AF_UNIX> в поле I<sun_type> передаваемых адресов или сокет находится в "
"некорректном состоянии для производимой операции."

#. type: TP
#: man-pages/man7/unix.7:673
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: man-pages/man7/unix.7:678
msgid ""
"B<connect>(2)  called on an already connected socket or a target address was "
"specified on a connected socket."
msgstr ""
"Вызов B<connect>(2) запущен для уже соединённого сокета, или адрес "
"назначения указывает на соединённый сокет."

#. type: TP
#: man-pages/man7/unix.7:678
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man7/unix.7:683
msgid ""
"The pathname in the remote address specified to B<connect>(2)  did not exist."
msgstr "Путь, указанный в удалённом адресе для B<connect>(2), не существует."

#. type: TP
#: man-pages/man7/unix.7:683
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man7/unix.7:686
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: TP
#: man-pages/man7/unix.7:686
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man7/unix.7:689
msgid ""
"Socket operation needs a target address, but the socket is not connected."
msgstr ""
"Для операции над сокетом требуется адрес назначения, а сокет не соединён."

#. type: TP
#: man-pages/man7/unix.7:689
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man7/unix.7:693
msgid ""
"Stream operation called on non-stream oriented socket or tried to use the "
"out-of-band data option."
msgstr ""
"Вызвана потоковая операция для не потокового сокета, или произведена попытка "
"использования параметра для внеполосных данных."

#. type: TP
#: man-pages/man7/unix.7:693
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man7/unix.7:697
msgid "The sender passed invalid credentials in the I<struct ucred>."
msgstr ""
"Отправитель указал неправильную информацию (credentials) в структуре "
"I<struct ucred>."

#. type: TP
#: man-pages/man7/unix.7:697
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: man-pages/man7/unix.7:709
msgid ""
"Remote socket was closed on a stream socket.  If enabled, a B<SIGPIPE> is "
"sent as well.  This can be avoided by passing the B<MSG_NOSIGNAL> flag to "
"B<send>(2)  or B<sendmsg>(2)."
msgstr ""
"Удалённый сокет был закрыт в потоковом сокете. Если разрешено, также будет "
"послан сигнал B<SIGPIPE>. Этого можно избежать, передав флаг B<MSG_NOSIGNAL> "
"при вызове B<send>(2) или B<sendmsg>(2)."

#. type: TP
#: man-pages/man7/unix.7:709
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: man-pages/man7/unix.7:713
msgid "Passed protocol is not B<AF_UNIX>."
msgstr "Указанный протокол не является B<AF_UNIX>."

#. type: TP
#: man-pages/man7/unix.7:713
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr "B<EPROTOTYPE>"

#. type: Plain text
#: man-pages/man7/unix.7:719
msgid ""
"Remote socket does not match the local socket type (B<SOCK_DGRAM> versus "
"B<SOCK_STREAM>)."
msgstr ""
"Удалённый сокет не совпадает с типом локального сокета (B<SOCK_DGRAM> против "
"B<SOCK_STREAM>)."

#. type: TP
#: man-pages/man7/unix.7:719
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: man-pages/man7/unix.7:722
msgid "Unknown socket type."
msgstr "Неизвестный тип сокета."

#. type: TP
#: man-pages/man7/unix.7:722
#, no-wrap
msgid "B<ETOOMANYREFS>"
msgstr "B<ETOOMANYREFS>"

#. type: Plain text
#: man-pages/man7/unix.7:739
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above).  It occurs if the number of \"in-flight\" file "
"descriptors exceeds the B<RLIMIT_NOFILE> resource limit and the caller does "
"not have the B<CAP_SYS_RESOURCE> capability.  An in-flight file descriptor "
"is one that has been sent using B<sendmsg>(2)  but has not yet been accepted "
"in the recipient process using B<recvmsg>(2)."
msgstr ""
"Эта ошибка может возникнуть в B<sendmsg>(2) при передаче через доменный "
"сокет UNIX в качестве вспомогательных данных файлового дескриптора (смотрите "
"описание B<SCM_RIGHTS> выше). Это происходит, если количество файловых "
"дескрипторов «в полёте» превышает ограничитель ресурса B<RLIMIT_NOFILE> и "
"вызывающий не имеет мандата B<CAP_SYS_RESOURCE>. Файловым дескриптором в "
"полёте считается посланный с помощью B<sendmsg>(2), но ещё не принятый "
"процессом-получателем с помощью B<recvmsg>(2)."

#.  commit 712f4aad406bb1ed67f3f98d04c044191f0ff593
#. type: Plain text
#: man-pages/man7/unix.7:750
msgid ""
"This error is diagnosed since mainline Linux 4.5 (and in some earlier kernel "
"versions where the fix has been backported).  In earlier kernel versions, it "
"was possible to place an unlimited number of file descriptors in flight, by "
"sending each file descriptor with B<sendmsg>(2)  and then closing the file "
"descriptor so that it was not accounted against the B<RLIMIT_NOFILE> "
"resource limit."
msgstr ""
"Данная ошибка выявляется начиная с Linux 4.5 (и в некоторых старых версиях, "
"в которые перенесено исправление). В ранних версиях ядра было возможно "
"получить неограниченное количество файловых дескрипторов в полёте, посылая "
"каждый файловый дескриптор с помощью B<sendmsg>(2) и затем закрывая файловый "
"дескриптор, и таким образом он не учитывался в ограничителе ресурса "
"B<RLIMIT_NOFILE>."

#. type: Plain text
#: man-pages/man7/unix.7:754
msgid ""
"Other errors can be generated by the generic socket layer or by the "
"filesystem while generating a filesystem socket object.  See the appropriate "
"manual pages for more information."
msgstr ""
"При создании сокетного объекта на уровне сокетов или файловой системы могут "
"генерироваться другие ошибки. За дополнительной информацией обращайтесь к "
"соответствующей справочной странице."

#. type: SH
#: man-pages/man7/unix.7:754
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/unix.7:760
msgid ""
"B<SCM_CREDENTIALS> and the abstract namespace were introduced with Linux 2.2 "
"and should not be used in portable programs.  (Some BSD-derived systems also "
"support credential passing, but the implementation details differ.)"
msgstr ""
"B<SCM_CREDENTIALS> и абстрактное пространство имён появились в Linux 2.2 и "
"не должны использоваться в переносимых программах. Некоторые клоны BSD также "
"поддерживают передачу дополнительной информации (credential), но методы "
"реализации передачи могут серьезно отличаться на разных системах."

#. type: SH
#: man-pages/man7/unix.7:760
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man7/unix.7:768
msgid ""
"Binding to a socket with a filename creates a socket in the filesystem that "
"must be deleted by the caller when it is no longer needed (using "
"B<unlink>(2)).  The usual UNIX close-behind semantics apply; the socket can "
"be unlinked at any time and will be finally removed from the filesystem when "
"the last reference to it is closed."
msgstr ""
"Привязка сокета к имени файла создаёт сокет в файловой системе, который "
"должен быть удалён создателем, когда необходимость в нём отпадёт (с помощью "
"B<unlink>(2)). Обычная система ссылок UNIX также подходит для работы с "
"сокетами; сокет может быть удалён в любое время, а реальное удаление из "
"файловой системы будет произведено при закрытии последней на него ссылки."

#. type: Plain text
#: man-pages/man7/unix.7:777
msgid ""
"To pass file descriptors or credentials over a B<SOCK_STREAM> socket, you "
"must to send or receive at least one byte of nonancillary data in the same "
"B<sendmsg>(2)  or B<recvmsg>(2)  call."
msgstr ""
"Для передачи файловых дескрипторов или учётных данных (credentials) через "
"сокет B<SOCK_STREAM> необходимо передать или принять, по меньшей мере, один "
"байт не вспомогательных данных в том же вызове B<sendmsg>(2) или "
"B<recvmsg>(2)."

#. type: Plain text
#: man-pages/man7/unix.7:780
msgid ""
"UNIX domain stream sockets do not support the notion of out-of-band data."
msgstr ""
"В потоковых доменных сокетах UNIX отсутствует такое понятие как внеполосные "
"данные."

#. type: SH
#: man-pages/man7/unix.7:780
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  The behavior on Solaris is quite similar.
#. type: Plain text
#: man-pages/man7/unix.7:805
msgid ""
"When binding a socket to an address, Linux is one of the implementations "
"that appends a null terminator if none is supplied in I<sun_path>.  In most "
"cases this is unproblematic: when the socket address is retrieved, it will "
"be one byte longer than that supplied when the socket was bound.  However, "
"there is one case where confusing behavior can result: if 108 non-null bytes "
"are supplied when a socket is bound, then the addition of the null "
"terminator takes the length of the pathname beyond I<sizeof(sun_path)>.  "
"Consequently, when retrieving the socket address (for example, via "
"B<accept>(2)), if the input I<addrlen> argument for the retrieving call is "
"specified as I<sizeof(struct sockaddr_un)>, then the returned address "
"structure I<won't> have a null terminator in I<sun_path>."
msgstr ""
"При привязке сокета к адресу Linux является одной из реализаций, которые "
"добавляют конечный null, если он отсутствует в I<sun_path>. В большинстве "
"случаев в этом нет проблемы: когда адрес сокета возвращается, он будет на "
"один байт длиннее чем был перед привязкой сокета. Однако такое неожиданное "
"поведение может привести к следующему: если передаётся 108 не-null байтов "
"при привязке сокета, то с дополнительным конечным null  пути превышает длину "
"I<sizeof(sun_path)>. В последствии при возврате адреса сокета (например, из "
"B<accept>(2)), если входной аргумент I<addrlen> перед вызовом был равен "
"I<sizeof(struct sockaddr_un)>, то в I<sun_path> возвращаемой структуры "
"адреса I<будет отсутствовать> конечный null."

#.  i.e., traditional BSD
#. type: Plain text
#: man-pages/man7/unix.7:815
msgid ""
"In addition, some implementations don't require a null terminator when "
"binding a socket (the I<addrlen> argument is used to determine the length of "
"I<sun_path>)  and when the socket address is retrieved on these "
"implementations, there is no null terminator in I<sun_path>."
msgstr ""
"Также, некоторые реализации не требуют наличия конечного null при привязке "
"сокета (для определения длины I<sun_path> используется аргумент I<addrlen>) "
"и когда в этих реализациях возвращается адрес сокета, то в I<sun_path> также "
"отсутствует конечный null."

#. type: Plain text
#: man-pages/man7/unix.7:820
msgid ""
"Applications that retrieve socket addresses can (portably) code to handle "
"the possibility that there is no null terminator in I<sun_path> by "
"respecting the fact that the number of valid bytes in the pathname is:"
msgstr ""
"Приложения, которые получают адрес сокета могут содержать код (переносимый) "
"для обработки случая, когда нет конечного null в I<sun_path>, учитывая "
"фактическое количество пригодных байт в пути:"

#.  The following patch to amend kernel behavior was rejected:
#.  http://thread.gmane.org/gmane.linux.kernel.api/2437
#.  Subject: [patch] Fix handling of overlength pathname in AF_UNIX sun_path
#.  2012-04-17
#.  And there was a related discussion in the Austin list:
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/5735
#.  Subject: Having a sun_path with no null terminator
#.  2012-04-18
#.  FIXME . Track http://austingroupbugs.net/view.php?id=561
#. type: Plain text
#: man-pages/man7/unix.7:832
#, no-wrap
msgid "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"
msgstr "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"

#. type: Plain text
#: man-pages/man7/unix.7:844
msgid ""
"Alternatively, an application can retrieve the socket address by allocating "
"a buffer of size I<sizeof(struct sockaddr_un)+1> that is zeroed out before "
"the retrieval.  The retrieving call can specify I<addrlen> as "
"I<sizeof(struct sockaddr_un)>, and the extra zero byte ensures that there "
"will be a null terminator for the string returned in I<sun_path>:"
msgstr ""
"Или же приложение может перед получением адреса сокета выделить буфер "
"размера I<sizeof(struct sockaddr_un)+1>, который будет обнулён перед "
"возвращением. Возвращающий вызов может задать в I<addrlen> значение "
"I<sizeof(struct sockaddr_un)>, и дополнительный нулевой байт здесь будет "
"конечным null в строке, возвращаемой в I<sun_path>:"

#. type: Plain text
#: man-pages/man7/unix.7:848
#, no-wrap
msgid "void *addrp;\n"
msgstr "void *addrp;\n"

#. type: Plain text
#: man-pages/man7/unix.7:854
#, no-wrap
msgid ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* Handle error */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"
msgstr ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* обработка ошибки */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"

#. type: Plain text
#: man-pages/man7/unix.7:857
#, no-wrap
msgid ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* handle error */ ;\n"
msgstr ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* обработка ошибки */ ;\n"

#. type: Plain text
#: man-pages/man7/unix.7:859
#, no-wrap
msgid "printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) addrp)-E<gt>sun_path);\n"
msgstr "printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) addrp)-E<gt>sun_path);\n"

#. type: Plain text
#: man-pages/man7/unix.7:867
msgid ""
"This sort of messiness can be avoided if it is guaranteed that the "
"applications that I<create> pathname sockets follow the rules outlined above "
"under I<Pathname sockets>."
msgstr ""
"Данного беспорядка можно избежать, если гарантировать, что приложения, "
"I<создающие> путевые сокеты, следуют правилам, описанным в общих чертах выше "
"в I<Путевые сокеты>."

#. type: SH
#: man-pages/man7/unix.7:867
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man7/unix.7:879
msgid ""
"The following code demonstrates the use of sequenced-packet sockets for "
"local interprocess communication.  It consists of two programs.  The server "
"program waits for a connection from the client program.  The client sends "
"each of its command-line arguments in separate messages.  The server treats "
"the incoming messages as integers and adds them up.  The client sends the "
"command string \"END\".  The server sends back a message containing the sum "
"of the client's integers.  The client prints the sum and exits.  The server "
"waits for the next client to connect.  To stop the server, the client is "
"called with the command-line argument \"DOWN\"."
msgstr ""
"В следующем коде демонстрируется использование пакето-упорядочивающих "
"сокетов для локального межпроцессного обмена. Он состоит из двух программ. "
"Программа-сервер ждёт подключения программы-клиента. Клиент посылает свой "
"каждый аргумент командной строки в виде отдельного сообщения. Сервер считает "
"входящие сообщения как целые числа и складывает их. Клиент посылает строку-"
"команду «END». Сервер посылает ответное сообщение, содержащее сумму чисел "
"клиента. Клиент печатает сумму и завершает работу. Сервер ждёт подключение "
"следующего клиента. Для остановки сервера, клиент вызывается с аргументом "
"командной строки «DOWN»."

#. type: Plain text
#: man-pages/man7/unix.7:883
msgid ""
"The following output was recorded while running the server in the background "
"and repeatedly executing the client.  Execution of the server program ends "
"when it receives the \"DOWN\" command."
msgstr ""
"Следующий вывод был записан при работе сервера в фоновом режиме и "
"повторяющемся запуске клиента. Выполнение программы-сервера завершилось "
"после получения им команды «DOWN»."

#. type: SS
#: man-pages/man7/unix.7:883
#, no-wrap
msgid "Example output"
msgstr "Пример вывода"

#. type: Plain text
#: man-pages/man7/unix.7:896
#, no-wrap
msgid ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Result = 7\n"
"$ B<./client 11 -5>\n"
"Result = 6\n"
"$ B<./client DOWN>\n"
"Result = 0\n"
"[1]+  Done                    ./server\n"
"$\n"
msgstr ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Результат = 7\n"
"$ B<./client 11 -5>\n"
"Результат = 6\n"
"$ B<./client DOWN>\n"
"Результат = 0\n"
"[1]+  Done                    ./server\n"
"$\n"

#. type: SS
#: man-pages/man7/unix.7:898
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man7/unix.7:904
#, no-wrap
msgid ""
"/*\n"
" * File connection.h\n"
" */\n"
msgstr ""
"/*\n"
" * Файл connection.h\n"
" */\n"

#. type: Plain text
#: man-pages/man7/unix.7:907
#, no-wrap
msgid ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"
msgstr ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"

#. type: Plain text
#: man-pages/man7/unix.7:911
#, no-wrap
msgid ""
"/*\n"
" * File server.c\n"
" */\n"
msgstr ""
"/*\n"
" * Файл server.c\n"
" */\n"

#. type: Plain text
#: man-pages/man7/unix.7:919
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"

#. type: Plain text
#: man-pages/man7/unix.7:930
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"

#. type: Plain text
#: man-pages/man7/unix.7:935
#, no-wrap
msgid ""
"    /*\n"
"     * In case the program exited inadvertently on the last run,\n"
"     * remove the socket.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * Удалить сокет, оставшийся после последнего\n"
"     * некорректного завершения программы.\n"
"     */\n"

#. type: Plain text
#: man-pages/man7/unix.7:937 man-pages/man7/unix.7:1046
#, no-wrap
msgid "    unlink(SOCKET_NAME);\n"
msgstr "    unlink(SOCKET_NAME);\n"

#. type: Plain text
#: man-pages/man7/unix.7:939 man-pages/man7/unix.7:1073
#, no-wrap
msgid "    /* Create local socket. */\n"
msgstr "    /* Создание локального сокета. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:945
#, no-wrap
msgid ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:951 man-pages/man7/unix.7:1085
#, no-wrap
msgid ""
"    /*\n"
"     * For portability clear the whole structure, since some\n"
"     * implementations have additional (nonstandard) fields in\n"
"     * the structure.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * Для переносимости очищаем всю структуру, так как в некоторых\n"
"     * реализациях имеются дополнительные (нестандартные) поля.\n"
"     */\n"

#. type: Plain text
#: man-pages/man7/unix.7:953
#, no-wrap
msgid "    memset(&name, 0, sizeof(struct sockaddr_un));\n"
msgstr "    memset(&name, 0, sizeof(struct sockaddr_un));\n"

#. type: Plain text
#: man-pages/man7/unix.7:955
#, no-wrap
msgid "    /* Bind socket to socket name. */\n"
msgstr "    /* Привязываем сокет к имени сокета. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:958
#, no-wrap
msgid ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"
msgstr ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"

#. type: Plain text
#: man-pages/man7/unix.7:965
#, no-wrap
msgid ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:971
#, no-wrap
msgid ""
"    /*\n"
"     * Prepare for accepting connections. The backlog size is set\n"
"     * to 20. So while one request is being processed other requests\n"
"     * can be waiting.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * Готовимся принимать подключения. Размер очереди (backlog)\n"
"     * устанавливаем равным 20. Пока один запрос обрабатывается, другие\n"
"     * запросы смогут подождать.\n"
"     */\n"

#. type: Plain text
#: man-pages/man7/unix.7:977
#, no-wrap
msgid ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:979
#, no-wrap
msgid "    /* This is the main loop for handling connections. */\n"
msgstr "    /* Основной цикл обработки подключений. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:981
#, no-wrap
msgid "    for (;;) {\n"
msgstr "    for (;;) {\n"

#. type: Plain text
#: man-pages/man7/unix.7:983
#, no-wrap
msgid "        /* Wait for incoming connection. */\n"
msgstr "        /* Ожидание входящих подключений. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:989
#, no-wrap
msgid ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (data_socket == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (data_socket == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/unix.7:992
#, no-wrap
msgid ""
"        result = 0;\n"
"        for (;;) {\n"
msgstr ""
"        result = 0;\n"
"        for (;;) {\n"

#. type: Plain text
#: man-pages/man7/unix.7:994
#, no-wrap
msgid "            /* Wait for next data packet. */\n"
msgstr "            /* Ожидание следующего пакета с данными. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1000
#, no-wrap
msgid ""
"            ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"            ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1002
#, no-wrap
msgid "            /* Ensure buffer is 0-terminated. */\n"
msgstr "            /* Проверяем, что буфер завершается 0. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1004
#, no-wrap
msgid "            buffer[BUFFER_SIZE - 1] = 0;\n"
msgstr "            buffer[BUFFER_SIZE - 1] = 0;\n"

#. type: Plain text
#: man-pages/man7/unix.7:1006
#, no-wrap
msgid "            /* Handle commands. */\n"
msgstr "            /* Обработка команд. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1011
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"DOWN\", BUFFER_SIZE)) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"
msgstr ""
"            if (!strncmp(buffer, \"DOWN\", BUFFER_SIZE)) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1015
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"END\", BUFFER_SIZE)) {\n"
"                break;\n"
"            }\n"
msgstr ""
"            if (!strncmp(buffer, \"END\", BUFFER_SIZE)) {\n"
"                break;\n"
"            }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1017
#, no-wrap
msgid "            /* Add received summand. */\n"
msgstr "            /* Добавляем полученную команду. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1020
#, no-wrap
msgid ""
"            result += atoi(buffer);\n"
"        }\n"
msgstr ""
"            result += atoi(buffer);\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1022
#, no-wrap
msgid "        /* Send result. */\n"
msgstr "        /* Отправка результата. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1029
#, no-wrap
msgid ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, BUFFER_SIZE);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, BUFFER_SIZE);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1031
#, no-wrap
msgid "        /* Close socket. */\n"
msgstr "        /* Закрытие сокета. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1033
#, no-wrap
msgid "        close(data_socket);\n"
msgstr "        close(data_socket);\n"

#. type: Plain text
#: man-pages/man7/unix.7:1035
#, no-wrap
msgid "        /* Quit on DOWN command. */\n"
msgstr "        /* Завершаем работу по команде DOWN. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1040
#, no-wrap
msgid ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1042
#, no-wrap
msgid "    close(connection_socket);\n"
msgstr "    close(connection_socket);\n"

#. type: Plain text
#: man-pages/man7/unix.7:1044
#, no-wrap
msgid "    /* Unlink the socket. */\n"
msgstr "    /* Удаляем сокет. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1049 man-pages/man7/unix.7:1139
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/unix.7:1053
#, no-wrap
msgid ""
"/*\n"
" * File client.c\n"
" */\n"
msgstr ""
"/*\n"
" * Файл client.c\n"
" */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1062
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"

#. type: Plain text
#: man-pages/man7/unix.7:1071
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int i;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int i;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"

#. type: Plain text
#: man-pages/man7/unix.7:1079
#, no-wrap
msgid ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1087
#, no-wrap
msgid "    memset(&addr, 0, sizeof(struct sockaddr_un));\n"
msgstr "    memset(&addr, 0, sizeof(struct sockaddr_un));\n"

#. type: Plain text
#: man-pages/man7/unix.7:1089
#, no-wrap
msgid "    /* Connect socket to socket address */\n"
msgstr "    /* соединяем сокет с адресом сокета */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1092
#, no-wrap
msgid ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"
msgstr ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"

#. type: Plain text
#: man-pages/man7/unix.7:1099
#, no-wrap
msgid ""
"    ret = connect (data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = connect (data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1101
#, no-wrap
msgid "    /* Send arguments. */\n"
msgstr "    /* Посылаем аргументы. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1109
#, no-wrap
msgid ""
"    for (i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"    for (i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1111
#, no-wrap
msgid "    /* Request result. */\n"
msgstr "    /* Отправка результата. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1118
#, no-wrap
msgid ""
"    strcpy (buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    strcpy (buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1120
#, no-wrap
msgid "    /* Receive result. */\n"
msgstr "    /* Получение результата. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1126
#, no-wrap
msgid ""
"    ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/unix.7:1128
#, no-wrap
msgid "    /* Ensure buffer is 0-terminated. */\n"
msgstr "    /* Проверяем, что буфер завершается 0. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1130
#, no-wrap
msgid "    buffer[BUFFER_SIZE - 1] = 0;\n"
msgstr "    buffer[BUFFER_SIZE - 1] = 0;\n"

#. type: Plain text
#: man-pages/man7/unix.7:1132
#, no-wrap
msgid "    printf(\"Result = %s\\en\", buffer);\n"
msgstr "    printf(\"Result = %s\\en\", buffer);\n"

#. type: Plain text
#: man-pages/man7/unix.7:1134
#, no-wrap
msgid "    /* Close socket. */\n"
msgstr "    /* Закрытие сокета. */\n"

#. type: Plain text
#: man-pages/man7/unix.7:1136
#, no-wrap
msgid "    close(data_socket);\n"
msgstr "    close(data_socket);\n"

#. type: Plain text
#: man-pages/man7/unix.7:1145
msgid "For an example of the use of B<SCM_RIGHTS> see B<cmsg>(3)."
msgstr "Пример использования B<SCM_RIGHTS> приведён в B<cmsg>(3)."

#. type: SH
#: man-pages/man7/unix.7:1145
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man7/unix.7:1154
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"

#. type: TH
#: man-pages/man7/user-keyring.7:12
#, no-wrap
msgid "USER-KEYRING"
msgstr "USER-KEYRING"

#. type: TH
#: man-pages/man7/user-keyring.7:12
#, no-wrap
msgid "2017-03-13"
msgstr "2017-03-13"

#. type: Plain text
#: man-pages/man7/user-keyring.7:15
msgid "user-keyring - per-user keyring"
msgstr "user-keyring - пользовательская связка ключей"

#. type: Plain text
#: man-pages/man7/user-keyring.7:24
msgid ""
"The user keyring is a keyring used to anchor keys on behalf of a user.  Each "
"UID the kernel deals with has its own user keyring that is shared by all "
"processes with that UID.  The user keyring has a name (description) of the "
"form I<_uid.E<lt>UIDE<gt>> where I<E<lt>UIDE<gt>> is the user ID of the "
"corresponding user."
msgstr ""
"Пользовательская связка ключей используется для хранения ключей "
"пользователя. Для каждого UID у ядра есть своя связка ключей пользователя, "
"которая доступна из всех процессов с этим UID. Пользовательская связка "
"ключей имеет имя (описание) в виде I<_uid.E<lt>UIDE<gt>>, где "
"I<E<lt>UIDE<gt>> идентификатор пользователя соответствующего пользователя."

#. type: Plain text
#: man-pages/man7/user-keyring.7:36
msgid ""
"The user keyring is associated with the record that the kernel maintains for "
"the UID.  It comes into existence upon the first attempt to access either "
"the user keyring, the B<user-session-keyring>(7), or the B<session-"
"keyring>(7).  The keyring remains pinned in existence so long as there are "
"processes running with that real UID or files opened by those processes "
"remain open.  (The keyring can also be pinned indefinitely by linking it "
"into another keyring.)"
msgstr ""
"Пользовательская связка ключей связана с записью, которая обслуживается "
"ядром для UID. Она начинает существовать при попытке первого обращения к "
"пользовательской связке ключей, к B<user-session-keyring>(7) или к B<session-"
"keyring>(7). Связка ключей существует привязанной всё время пока выполняются "
"процессы с этим реальным UID или остаются открытыми файлы, открытые этими "
"процессами (связка ключей также может быть привязана бесконечно, если её "
"прицепить к другой связке ключей)."

#. type: Plain text
#: man-pages/man7/user-keyring.7:40
msgid ""
"Typically, the user keyring is created by B<pam_keyinit>(8)  when a user "
"logs in."
msgstr ""
"Обычно, пользовательская связка ключей создаётся B<pam_keyinit>(8) при входе "
"пользователя в систему."

#. type: Plain text
#: man-pages/man7/user-keyring.7:47
msgid ""
"The user keyring is not searched by default by B<request_key>(2).  When "
"B<pam_keyinit>(8)  creates a session keyring, it adds to it a link to the "
"user keyring so that the user keyring will be searched when the session "
"keyring is."
msgstr ""
"По умолчанию в пользовательской связке ключей вызов B<request_key>(2) не "
"производит поиск. Когда B<pam_keyinit>(8) создаёт связку ключей сеанса, он "
"добавляет в неё пользовательскую связку ключей, и таким образом поиск "
"выполняется в пользовательской связке ключей, если происходит поиск в связке "
"ключей сеанса."

#. type: Plain text
#: man-pages/man7/user-keyring.7:52
msgid ""
"A special serial number value, B<KEY_SPEC_USER_KEYRING>, is defined that can "
"be used in lieu of the actual serial number of the calling process's user "
"keyring."
msgstr ""
"Существует специальный серийный номер, B<KEY_SPEC_USER_KEYRING>, который "
"можно указывать вместо реального серийного номера пользовательской связки "
"ключей вызывающего процесса."

#. type: Plain text
#: man-pages/man7/user-keyring.7:57
msgid ""
"From the B<keyctl>(1)  utility, 'B<@u>' can be used instead of a numeric key "
"ID in much the same way."
msgstr ""
"В утилите B<keyctl>(1) подобным образом можно использовать «B<@u>» вместо "
"числового идентификатора ключа."

#. type: Plain text
#: man-pages/man7/user-keyring.7:67
msgid ""
"User keyrings are independent of B<clone>(2), B<fork>(2), B<vfork>(2), "
"B<execve>(2), and B<_exit>(2)  excepting that the keyring is destroyed when "
"the UID record is destroyed when the last process pinning it exits."
msgstr ""
"Пользовательские связки ключей не зависят от B<clone>(2), B<fork>(2), "
"B<vfork>(2), B<execve>(2) и B<_exit>(2) за исключением того, что эта связка "
"ключей уничтожается когда запись UID уничтожается при завершении последнего "
"привязанного процесса."

#. type: Plain text
#: man-pages/man7/user-keyring.7:74
msgid ""
"If it is necessary for a key associated with a user to exist beyond the UID "
"record being garbage collected\\(emfor example, for use by a B<cron>(8)  "
"script\\(emthen the B<persistent-keyring>(7)  should be used instead."
msgstr ""
"Если нужно, чтобы ключ, связанный с пользователем, существовал и после сбора "
"мусорщиком записи UID — например, для сценария B<cron>(8) — то должна быть "
"использована B<persistent-keyring>(7)."

#. type: Plain text
#: man-pages/man7/user-keyring.7:76
msgid ""
"If a user keyring does not exist when it is accessed, it will be created."
msgstr ""
"Если связка ключей пользователя не существует на момент доступа, то она "
"создаётся."

#. type: Plain text
#: man-pages/man7/user-keyring.7:87
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"session-keyring>(7), B<pam_keyinit>(8)"
msgstr ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"session-keyring>(7), B<pam_keyinit>(8)"

#. type: TH
#: man-pages/man7/utf-8.7:29
#, no-wrap
msgid "UTF-8"
msgstr "UTF-8"

#. type: TH
#: man-pages/man7/utf-8.7:29
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: man-pages/man7/utf-8.7:29
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man7/utf-8.7:32
msgid "UTF-8 - an ASCII compatible multibyte Unicode encoding"
msgstr "UTF-8 - ASCII-совместимая многобайтовая юникодная кодировка"

#. type: Plain text
#: man-pages/man7/utf-8.7:49
msgid ""
"The Unicode 3.0 character set occupies a 16-bit code space.  The most "
"obvious Unicode encoding (known as UCS-2)  consists of a sequence of 16-bit "
"words.  Such strings can contain\\(emas part of many 16-bit characters"
"\\(embytes such as \\(aq\\e0\\(aq or \\(aq/\\(aq, which have a special "
"meaning in filenames and other C library function arguments.  In addition, "
"the majority of UNIX tools expect ASCII files and can't read 16-bit words as "
"characters without major modifications.  For these reasons, UCS-2 is not a "
"suitable external encoding of Unicode in filenames, text files, environment "
"variables, and so on.  The ISO 10646 Universal Character Set (UCS), a "
"superset of Unicode, occupies an even larger code space\\(em31\\ bits"
"\\(emand the obvious UCS-4 encoding for it (a sequence of 32-bit words) has "
"the same problems."
msgstr ""
"Набор символов Unicode 3.0 занимает 16-битное кодовое пространство. Наиболее "
"распространённая юникодная кодировка, известная как UCS-2, содержит "
"последовательности 16-битных слов. Закодированные таким образом строки могут "
"состоять из частей 16-битных символов например, \\(aq\\e0\\(aq или \\(aq/"
"\\(aq, которые имеют специальное значение в именах файлов и других "
"параметрах функций библиотеки языка Си. Кроме того, большинство утилит UNIX "
"предназначено для обработки ASCII-файлов и не может воспринимать 16-битные "
"слова как символы. По этим причинам UCS-2 является неподходящей кодировкой "
"Юникода для имён файлов, текстовых файлов, переменных окружения и т.д. Набор "
"ISO  Universal Character Set (UCS), расширенный набор Юникода, занимает "
"более 31-битного кодового пространства, а используемая для него кодировка "
"UCS-4 (последовательность 32-битных слов) имеет те же недостатки, что и "
"описанные выше."

#. type: Plain text
#: man-pages/man7/utf-8.7:53
msgid ""
"The UTF-8 encoding of Unicode and UCS does not have these problems and is "
"the common way in which Unicode is used on UNIX-style operating systems."
msgstr ""
"Кодировка UTF-8 для представления Юникода и UCS лишена этих недостатков и "
"поэтому в UNIX-подобных операционных системах используется наиболее часто."

#. type: SS
#: man-pages/man7/utf-8.7:53
#, no-wrap
msgid "Properties"
msgstr "Свойства"

#. type: Plain text
#: man-pages/man7/utf-8.7:55
msgid "The UTF-8 encoding has the following nice properties:"
msgstr "Кодировка UTF-8 обладает следующими полезными свойствами:"

#. type: Plain text
#: man-pages/man7/utf-8.7:66
msgid ""
"UCS characters 0x00000000 to 0x0000007f (the classic US-ASCII characters) "
"are encoded simply as bytes 0x00 to 0x7f (ASCII compatibility).  This means "
"that files and strings which contain only 7-bit ASCII characters have the "
"same encoding under both ASCII and UTF-8 ."
msgstr ""
"UCS-символы с кодами от 0x00000000 до 0x0000007f (стандартный набор US-"
"ASCII) кодируются как байты с кодами от 0x00 до 0x7f (для совместимости с "
"кодовой таблицей ASCII). Это означает, что файлы и строки, содержащие только "
"7-битные ASCII-символы, будут иметь одинаковое представление как в ASCII так "
"и в UTF-8."

#. type: Plain text
#: man-pages/man7/utf-8.7:72
msgid ""
"All UCS characters greater than 0x7f are encoded as a multibyte sequence "
"consisting only of bytes in the range 0x80 to 0xfd, so no ASCII byte can "
"appear as part of another character and there are no problems with, for "
"example, \\(aq\\e0\\(aq or \\(aq/\\(aq."
msgstr ""
"Все UCS-символы с кодами больше чем 0x7f кодируются как многобайтовые "
"последовательности, содержащие только байты в диапазоне от 0x80 до 0xfd, так "
"что ASCII-байты не могут оказаться частью другого символа и, как следствие, "
"не будет проблем с использованием \\(aq\\e0\\(aq или \\(aq/\\(aq."

#. type: Plain text
#: man-pages/man7/utf-8.7:75
msgid "The lexicographic sorting order of UCS-4 strings is preserved."
msgstr ""
"Сохраняется лексикографический порядок сортировки строк как в кодировке "
"UCS-4."

#. type: Plain text
#: man-pages/man7/utf-8.7:78
msgid "All possible 2^31 UCS codes can be encoded using UTF-8."
msgstr "При помощи UTF-8 могут быть закодированы все 2^31 значения UCS."

#. type: Plain text
#: man-pages/man7/utf-8.7:81
msgid ""
"The bytes 0xc0, 0xc1, 0xfe, and 0xff are never used in the UTF-8 encoding."
msgstr ""
"В кодировке UTF-8 никогда не используются байты с кодами 0xc0, 0xc1, 0xfe и "
"0xff."

#. type: Plain text
#: man-pages/man7/utf-8.7:90
msgid ""
"The first byte of a multibyte sequence which represents a single non-ASCII "
"UCS character is always in the range 0xc2 to 0xfd and indicates how long "
"this multibyte sequence is.  All further bytes in a multibyte sequence are "
"in the range 0x80 to 0xbf.  This allows easy resynchronization and makes the "
"encoding stateless and robust against missing bytes."
msgstr ""
"Первый байт многобайтовой последовательности, представляющей один не ASCII "
"UCS-символ, всегда находится в диапазоне от 0xc2 до 0xfd и указывает на "
"длину многобайтовой последовательности. Все последующие байты в "
"многобайтовой последовательности находятся в диапазоне от 0x80 до 0xbf. Это "
"позволяет облегчить ресинхронизацию, устраняет необходимость учитывать "
"состояние кодировки (statelessness) и делает кодировку независимой от "
"пропущенных байтов."

#. type: Plain text
#: man-pages/man7/utf-8.7:96
msgid ""
"UTF-8 encoded UCS characters may be up to six bytes long, however the "
"Unicode standard specifies no characters above 0x10ffff, so Unicode "
"characters can be only up to four bytes long in UTF-8."
msgstr ""
"Символы UCS, закодированные в UTF-8, могут занимать до шести байтов, однако "
"в стандарте Юникода не определены символы выше 0x10ffff, поэтому в UTF-8 "
"юникодные символы могут иметь максимальный размер 4 байта."

#. type: SS
#: man-pages/man7/utf-8.7:96
#, no-wrap
msgid "Encoding"
msgstr "Кодирование"

#. type: Plain text
#: man-pages/man7/utf-8.7:99
msgid ""
"The following byte sequences are used to represent a character.  The "
"sequence to be used depends on the UCS code number of the character:"
msgstr ""
"Приведённые ниже последовательности байтов используются для отображения "
"символа. Конкретная последовательность зависит от номера символа в кодировке "
"UCS:"

#. type: TP
#: man-pages/man7/utf-8.7:99
#, no-wrap
msgid "0x00000000 - 0x0000007F:"
msgstr "0x00000000 - 0x0000007F:"

#. type: Plain text
#: man-pages/man7/utf-8.7:102
msgid "0I<xxxxxxx>"
msgstr "0I<xxxxxxx>"

#. type: TP
#: man-pages/man7/utf-8.7:102
#, no-wrap
msgid "0x00000080 - 0x000007FF:"
msgstr "0x00000080 - 0x000007FF:"

#. type: Plain text
#: man-pages/man7/utf-8.7:106
msgid "110I<xxxxx> 10I<xxxxxx>"
msgstr "110I<xxxxx> 10I<xxxxxx>"

#. type: TP
#: man-pages/man7/utf-8.7:106
#, no-wrap
msgid "0x00000800 - 0x0000FFFF:"
msgstr "0x00000800 - 0x0000FFFF:"

#. type: Plain text
#: man-pages/man7/utf-8.7:111
msgid "1110I<xxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr "1110I<xxxx> 10I<xxxxxx> 10I<xxxxxx>"

#. type: TP
#: man-pages/man7/utf-8.7:111
#, no-wrap
msgid "0x00010000 - 0x001FFFFF:"
msgstr "0x00010000 - 0x001FFFFF:"

#. type: Plain text
#: man-pages/man7/utf-8.7:117
msgid "11110I<xxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr "11110I<xxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"

#. type: TP
#: man-pages/man7/utf-8.7:117
#, no-wrap
msgid "0x00200000 - 0x03FFFFFF:"
msgstr "0x00200000 - 0x03FFFFFF:"

#. type: Plain text
#: man-pages/man7/utf-8.7:124
msgid "111110I<xx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr "111110I<xx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"

#. type: TP
#: man-pages/man7/utf-8.7:124
#, no-wrap
msgid "0x04000000 - 0x7FFFFFFF:"
msgstr "0x04000000 - 0x7FFFFFFF:"

#. type: Plain text
#: man-pages/man7/utf-8.7:132
msgid "1111110I<x> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr ""
"1111110I<x> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"

#. type: Plain text
#: man-pages/man7/utf-8.7:139
msgid ""
"The I<xxx> bit positions are filled with the bits of the character code "
"number in binary representation, most significant bit first (big-endian).  "
"Only the shortest possible multibyte sequence which can represent the code "
"number of the character can be used."
msgstr ""
"Позиции битов, обозначенные как I<xxx>, заполняются соответствующими битами "
"из кода символа в двоичном виде, наиболее значимый бит первый (прямой "
"порядок байт).Используется самая короткая из возможных многобайтовых "
"последовательностей, которые могут представить код символа."

#. type: Plain text
#: man-pages/man7/utf-8.7:144
msgid ""
"The UCS code values 0xd800\\(en0xdfff (UTF-16 surrogates) as well as 0xfffe "
"and 0xffff (UCS noncharacters) should not appear in conforming UTF-8 "
"streams. According to RFC 3629 no point above U+10FFFF should be used, which "
"limits characters to four bytes."
msgstr ""
"Значения кодов UCS 0xd00\\(en0xdfff (суррогаты UTF-16), а также 0xfffe и "
"0xffff (не символьные значения UCS), не должны появляться в потоках UTF-8. "
"Согласно RFC 3629 точки выше U+10FFFF не должны использоваться, что "
"ограничивает символы четырьмя байтами."

#. type: SS
#: man-pages/man7/utf-8.7:144
#, no-wrap
msgid "Example"
msgstr "Пример"

#. type: Plain text
#: man-pages/man7/utf-8.7:147
msgid ""
"The Unicode character 0xa9 = 1010 1001 (the copyright sign) is encoded in "
"UTF-8 as"
msgstr ""
"Символ Юникода с кодом 0xa9 = 1010 1001 (знак авторского права) кодируется в "
"UTF-8 как"

#. type: Plain text
#: man-pages/man7/utf-8.7:150
msgid "11000010 10101001 = 0xc2 0xa9"
msgstr "11000010 10101001 = 0xc2 0xa9"

#. type: Plain text
#: man-pages/man7/utf-8.7:154
msgid ""
"and character 0x2260 = 0010 0010 0110 0000 (the \"not equal\" symbol) is "
"encoded as:"
msgstr ""
"а символ с кодом 0x2260 = 0010 0010 0110 0000 (знак неравенства) кодируется "
"так:"

#. type: Plain text
#: man-pages/man7/utf-8.7:157
msgid "11100010 10001001 10100000 = 0xe2 0x89 0xa0"
msgstr "11100010 10001001 10100000 = 0xe2 0x89 0xa0"

#. type: SS
#: man-pages/man7/utf-8.7:158
#, no-wrap
msgid "Application notes"
msgstr "Замечания к применению"

#. type: Plain text
#: man-pages/man7/utf-8.7:160
msgid "Users have to select a UTF-8 locale, for example with"
msgstr "Например, с помощью "

#. type: Plain text
#: man-pages/man7/utf-8.7:163
msgid "export LANG=en_GB.UTF-8"
msgstr "export LANG=en_GB.UTF-8"

#. type: Plain text
#: man-pages/man7/utf-8.7:166
msgid "in order to activate the UTF-8 support in applications."
msgstr ""
"пользователи должны выбрать локаль UTF-8 для включения поддержки UTF-8 в "
"приложениях."

#. type: Plain text
#: man-pages/man7/utf-8.7:169
msgid ""
"Application software that has to be aware of the used character encoding "
"should always set the locale with for example"
msgstr ""
"Программы, в которых учитывается используемая пользователем кодировка, "
"должны всегда устанавливать локаль с помощью"

#. type: Plain text
#: man-pages/man7/utf-8.7:172
msgid "setlocale(LC_CTYPE, \"\")"
msgstr "setlocale(LC_CTYPE, \"\")"

#. type: Plain text
#: man-pages/man7/utf-8.7:175
msgid "and programmers can then test the expression"
msgstr "и затем проверять выражением"

#. type: Plain text
#: man-pages/man7/utf-8.7:178
msgid "strcmp(nl_langinfo(CODESET), \"UTF-8\") == 0"
msgstr "strcmp(nl_langinfo(CODESET), \"UTF-8\") == 0"

#. type: Plain text
#: man-pages/man7/utf-8.7:184
msgid ""
"to determine whether a UTF-8 locale has been selected and whether therefore "
"all plaintext standard input and output, terminal communication, plaintext "
"file content, filenames and environment variables are encoded in UTF-8."
msgstr ""
"что локаль UTF-8 выбрана и во всех стандартных текстовых потоках ввода и "
"вывода, на терминалах, в содержимом простых текстовых файлов, именах файлов "
"и переменных окружения будет использоваться кодировка UTF-8."

#. type: Plain text
#: man-pages/man7/utf-8.7:200
msgid ""
"Programmers accustomed to single-byte encodings such as US-ASCII or ISO 8859 "
"have to be aware that two assumptions made so far are no longer valid in "
"UTF-8 locales.  Firstly, a single byte does not necessarily correspond any "
"more to a single character.  Secondly, since modern terminal emulators in "
"UTF-8 mode also support Chinese, Japanese, and Korean double-width "
"characters as well as nonspacing combining characters, outputting a single "
"character does not necessarily advance the cursor by one position as it did "
"in ASCII.  Library functions such as B<mbsrtowcs>(3)  and B<wcswidth>(3)  "
"should be used today to count characters and cursor positions."
msgstr ""
"Программисты, привыкшие к однобайтовым кодировкам, таким как, US-ASCII или "
"ISO 8859, должны учесть, что два предположения, действовавших ранее, в "
"локалях UTF-8 не работают. Первое: один байт теперь не обязательно "
"соответствует одному символу. Второе: современные эмуляторы терминала в "
"режиме UTF-8 также поддерживают китайские, японские и корейские символы "
"двойной ширины (double-width characters), а также комбинированные символы "
"без пробелов, и вывод одного символа необязательно смещает курсор на одну "
"позицию, как это было в ASCII. Для подсчёта количества символов и позиций "
"курсора нужно использовать библиотечные функции, такие как B<mbsrtowcs>(3) и "
"B<wcswidth>(3)."

#. type: Plain text
#: man-pages/man7/utf-8.7:209
msgid ""
"The official ESC sequence to switch from an ISO 2022 encoding scheme (as "
"used for instance by VT100 terminals) to UTF-8 is ESC % G (\"\\ex1b%G\").  "
"The corresponding return sequence from UTF-8 to ISO 2022 is ESC % @ (\"\\ex1b"
"%@\").  Other ISO 2022 sequences (such as for switching the G0 and G1 sets) "
"are not applicable in UTF-8 mode."
msgstr ""
"Стандартной ESC-последовательностью для переключения из схемы кодировки ISO "
"2022 (используется в терминалах VT100) в UTF-8 является ESC % G (\"\\ex1b%G"
"\"). Соответственно, обратной последовательностью для переключения из UTF-8 "
"в ISO 2022 будет ESC % @ (\"\\ex1b%@\"). Остальные последовательности ISO "
"2022 (такие, как переключение в наборы G0 и G1) в режиме UTF-8 не работают."

#. type: SS
#: man-pages/man7/utf-8.7:209
#, no-wrap
msgid "Security"
msgstr "Безопасность"

#. type: Plain text
#: man-pages/man7/utf-8.7:221
msgid ""
"The Unicode and UCS standards require that producers of UTF-8 shall use the "
"shortest form possible, for example, producing a two-byte sequence with "
"first byte 0xc0 is nonconforming.  Unicode 3.1 has added the requirement "
"that conforming programs must not accept non-shortest forms in their input.  "
"This is for security reasons: if user input is checked for possible security "
"violations, a program might check only for the ASCII version of \"/../\" or "
"\";\" or NUL and overlook that there are many non-ASCII ways to represent "
"these things in a non-shortest UTF-8 encoding."
msgstr ""
"Стандарты Юникода и UCS требуют, чтобы генераторы UTF-8 использовали самую "
"короткую возможную форму представления символов, то есть создание "
"двухбайтной последовательности с первым байтом, равным 0xc0, запрещено. В "
"стандарте Unicode 3.1 это правило расширено и запрещает программам "
"воспринимать не самую короткую форму при вводе. Это сделано из соображений "
"безопасности: если вводимые пользователем символы проверяются системой "
"безопасности на возможные нарушения, то программам остаётся проверить только "
"ASCII версии символов «/../», «;» или NUL, так как для этих символов может "
"быть очень много не ASCII способов представления при не самом коротком "
"кодировании в UTF-8."

#. type: SS
#: man-pages/man7/utf-8.7:221
#, no-wrap
msgid "Standards"
msgstr "Стандарты"

#.  .SH AUTHOR
#.  Markus Kuhn <mgk25@cl.cam.ac.uk>
#. type: Plain text
#: man-pages/man7/utf-8.7:225
msgid "ISO/IEC 10646-1:2000, Unicode 3.1, RFC\\ 3629, Plan 9."
msgstr "ISO/IEC 10646-1:2000, Unicode 3.1, RFC\\ 3629, Plan 9."

#. type: Plain text
#: man-pages/man7/utf-8.7:230
msgid ""
"B<locale>(1), B<nl_langinfo>(3), B<setlocale>(3), B<charsets>(7), "
"B<unicode>(7)"
msgstr ""
"B<locale>(1), B<nl_langinfo>(3), B<setlocale>(3), B<charsets>(7), "
"B<unicode>(7)"

#. type: TH
#: man-pages/man7/udplite.7:27
#, no-wrap
msgid "UDPLITE"
msgstr "UDPLITE"

#. type: Plain text
#: man-pages/man7/udplite.7:30
msgid "udplite - Lightweight User Datagram Protocol"
msgstr "udplite - облегчённый протокол пользовательских датаграмм"

#. type: Plain text
#: man-pages/man7/udplite.7:38
msgid "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"
msgstr "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"

#. type: Plain text
#: man-pages/man7/udplite.7:41
msgid ""
"This is an implementation of the Lightweight User Datagram Protocol (UDP-"
"Lite), as described in RFC\\ 3828."
msgstr ""
"Это реализация облегчённого протокола пользовательских датаграмм (UDP-Lite), "
"описанная в RFC\\ 3828."

#. type: Plain text
#: man-pages/man7/udplite.7:47
msgid ""
"UDP-Lite is an extension of UDP (RFC\\ 768) to support variable-length "
"checksums.  This has advantages for some types of multimedia transport that "
"may be able to make use of slightly damaged datagrams, rather than having "
"them discarded by lower-layer protocols."
msgstr ""
"UDP-Lite представляет собой расширение UDP (RFC\\ 768), содержащее поддержку "
"контрольных сумм переменной длины. Это даёт преимущества при передаче данных "
"некоторых типов мультимедиа, для которых допустимо использовать слегка "
"повреждённые датаграммы, если бы они не отбрасывались другими нижележащими "
"протоколами."

#. type: Plain text
#: man-pages/man7/udplite.7:53
msgid ""
"The variable-length checksum coverage is set via a B<setsockopt>(2)  "
"option.  If this option is not set, the only difference from UDP is in using "
"a different IP protocol identifier (IANA number 136)."
msgstr ""
"Охват (coverage) контрольной суммы переменной длины задаётся с помощью "
"параметра через B<setsockopt>(2). Если параметр не установлен, то отличием "
"от UDP будет только другой идентификатор протокола IP (номер по IANA — 136)."

#. type: Plain text
#: man-pages/man7/udplite.7:58
msgid ""
"The UDP-Lite implementation is a full extension of B<udp>(7)\\(emthat is, it "
"shares the same API and API behavior, and in addition offers two socket "
"options to control the checksum coverage."
msgstr ""
"Реализация UDP-Lite представляет собой полноценное расширение B<udp>(7) — "
"используется тот же программный интерфейс и поведение; кроме этого имеются "
"два параметра сокета для управления охватом контрольной суммы."

#. type: Plain text
#: man-pages/man7/udplite.7:67
msgid ""
"UDP-Litev4 uses the I<sockaddr_in> address format described in B<ip>(7).  "
"UDP-Litev6 uses the I<sockaddr_in6> address format described in B<ipv6>(7)."
msgstr ""
"В UDP-Litev4 используется формат адреса I<sockaddr_in>, описанный в "
"B<ip>(7). В UDP-Litev6 используется формат адреса I<sockaddr_in6>, описанный "
"в B<ipv6>(7)."

#. type: Plain text
#: man-pages/man7/udplite.7:80
msgid ""
"To set or get a UDP-Lite socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDPLITE>.  In addition, all B<IPPROTO_UDP> socket options are "
"valid on a UDP-Lite socket.  See B<udp>(7)  for more information."
msgstr ""
"Для получения и задания параметров сокетов UDP-Lite, используйте вызовы "
"B<getsockopt>(2) и B<setsockopt>(2), соответственно. Значение аргумента "
"уровня параметров должно быть равно B<IPPROTO_UDPLITE>. Кроме того, сокетам "
"UDP-Lite доступно большинство параметров сокета B<IPPROTO_UDP>. "
"Дополнительная информация приведена в B<udp>(7)."

#. type: Plain text
#: man-pages/man7/udplite.7:82
msgid "The following two options are specific to UDP-Lite."
msgstr "Следующие параметры относятся только к UDP-Lite."

#. type: TP
#: man-pages/man7/udplite.7:82
#, no-wrap
msgid "B<UDPLITE_SEND_CSCOV>"
msgstr "B<UDPLITE_SEND_CSCOV>"

#. type: Plain text
#: man-pages/man7/udplite.7:87
msgid ""
"This option sets the sender checksum coverage and takes an I<int> as "
"argument, with a checksum coverage value in the range 0..2^16-1."
msgstr ""
"Этим параметром задаётся охват данных контрольной суммой; в качестве "
"аргумента ожидается значение типа I<int>, которым задаётся охват в диапазоне "
"0..2^16-1."

#. type: Plain text
#: man-pages/man7/udplite.7:91
msgid ""
"A value of 0 means that the entire datagram is always covered.  Values from "
"1-7 are illegal (RFC\\ 3828, 3.1) and are rounded up to the minimum coverage "
"of 8."
msgstr ""
"Значение 0 означает, что охватывается вся датаграмма. Значения 1-7 "
"некорректны (RFC\\ 3828, 3.1) и округляются до минимального охвата — 8."

#. type: Plain text
#: man-pages/man7/udplite.7:97
msgid ""
"With regard to IPv6 jumbograms (RFC\\ 2675), the UDP-Litev6 checksum "
"coverage is limited to the first 2^16-1 octets, as per RFC\\ 3828, 3.5.  "
"Higher values are therefore silently truncated to 2^16-1.  If in doubt, the "
"current coverage value can always be queried using B<getsockopt>(2)."
msgstr ""
"При использовании джумбограмм (jumbograms) IPv6 (RFC\\ 2675), охват "
"контрольной суммы в UDP-Litev6 ограничен первыми 2^16-1 октетами (согласно "
"RFC\\ 3828, 3.5). Большие значения безошибочно урезаются до 2^16-1. Текущее "
"значение охвата всегда можно запросить с помощью B<getsockopt>(2)."

#. type: TP
#: man-pages/man7/udplite.7:97
#, no-wrap
msgid "B<UDPLITE_RECV_CSCOV>"
msgstr "B<UDPLITE_RECV_CSCOV>"

#. type: Plain text
#: man-pages/man7/udplite.7:108
msgid ""
"This is the receiver-side analogue and uses the same argument format and "
"value range as B<UDPLITE_SEND_CSCOV>.  This option is not required to enable "
"traffic with partial checksum coverage.  Its function is that of a traffic "
"filter: when enabled, it instructs the kernel to drop all packets which have "
"a coverage I<less> than the specified coverage value."
msgstr ""
"Это аналог с приёмной стороны, использует тот же формат аргумента и диапазон "
"значений, что и у B<UDPLITE_SEND_CSCOV>. Данный параметр не требуется для "
"приёма трафика с контрольной суммой частичного охвата. Он предназначен для "
"фильтрации трафика: если включён, то это указывает ядру отбрасывать все "
"пакеты, у которых охват I<менее> заданного значения."

#.  SO_NO_CHECK exists and is supported by UDPv4, but is
#.  commented out in socket(7), hence also commented out here
#. .PP
#. Since UDP-Lite mandates checksums, checksumming can not be disabled
#. via the
#. .B SO_NO_CHECK
#. option from
#. .BR socket (7).
#. type: Plain text
#: man-pages/man7/udplite.7:121
msgid ""
"When the value of B<UDPLITE_RECV_CSCOV> exceeds the actual packet coverage, "
"incoming packets are silently dropped, but may generate a warning message in "
"the system log."
msgstr ""
"Если значение B<UDPLITE_RECV_CSCOV> превышает реальный охват пакета, то "
"поступающие пакеты просто отбрасываются, но при этом может генерироваться "
"предупреждающее сообщение в системный журнал."

#. type: Plain text
#: man-pages/man7/udplite.7:126
msgid ""
"All errors documented for B<udp>(7)  may be returned.  UDP-Lite does not add "
"further errors."
msgstr ""
"Могут быть возвращены любые ошибки, описанные для B<udp>(7). UDP-Lite не "
"вносит никаких дополнительных типов ошибок."

#. type: SH
#: man-pages/man7/udplite.7:126
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: TP
#: man-pages/man7/udplite.7:127
#, no-wrap
msgid "I</proc/net/snmp>"
msgstr "I</proc/net/snmp>"

#. type: Plain text
#: man-pages/man7/udplite.7:130
msgid "Basic UDP-Litev4 statistics counters."
msgstr "Основные счётчики статистики UDP-Litev4."

#. type: TP
#: man-pages/man7/udplite.7:130
#, no-wrap
msgid "I</proc/net/snmp6>"
msgstr "I</proc/net/snmp6>"

#. type: Plain text
#: man-pages/man7/udplite.7:133
msgid "Basic UDP-Litev6 statistics counters."
msgstr "Основные счётчики статистики UDP-Litev6."

#. type: Plain text
#: man-pages/man7/udplite.7:135
msgid "UDP-Litev4/v6 first appeared in Linux 2.6.20."
msgstr "UDP-Litev4/v6 впервые появился в Linux 2.6.20."

#.  FIXME . remove this section once glibc supports UDP-Lite
#. type: Plain text
#: man-pages/man7/udplite.7:138
msgid "Where glibc support is missing, the following definitions are needed:"
msgstr ""
"Если поддержка в glibc отсутствует, то требуются следующие определения:"

#.  The following two are defined in the kernel in linux/net/udplite.h
#. type: Plain text
#: man-pages/man7/udplite.7:145
#, no-wrap
msgid ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"
msgstr ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"

#. type: Plain text
#: man-pages/man7/udplite.7:152
msgid "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"
msgstr "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"

#. type: Plain text
#: man-pages/man7/udplite.7:154
msgid "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)."
msgstr ""
"В RFC\\ 3828 описан облегчённый протокол пользовательских датаграмм "
"(Lightweight User Datagram Protocol — UDP-Lite)."

#. type: Plain text
#: man-pages/man7/udplite.7:156
msgid "I<Documentation/networking/udplite.txt> in the Linux kernel source tree"
msgstr ""
"Файл I<Documentation/networking/udplite.txt> в дереве исходного кода ядра "
"Linux"

#. type: TH
#: man-pages/man7/user_namespaces.7:27
#, no-wrap
msgid "USER_NAMESPACES"
msgstr "USER_NAMESPACES"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:30
msgid "user_namespaces - overview of Linux user namespaces"
msgstr "user_namespaces - обзор пользовательских пространств имён Linux"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:33
msgid "For an overview of namespaces, see B<namespaces>(7)."
msgstr "Обзор пространств имён смотрите в B<namespaces>(7)."

#.  FIXME: This page says very little about the interaction
#.  of user namespaces and keys. Add something on this topic.
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:56
msgid ""
"User namespaces isolate security-related identifiers and attributes, in "
"particular, user IDs and group IDs (see B<credentials>(7)), the root "
"directory, keys (see B<keyrings>(7)), and capabilities (see "
"B<capabilities>(7)).  A process's user and group IDs can be different inside "
"and outside a user namespace.  In particular, a process can have a normal "
"unprivileged user ID outside a user namespace while at the same time having "
"a user ID of 0 inside the namespace; in other words, the process has full "
"privileges for operations inside the user namespace, but is unprivileged for "
"operations outside the namespace."
msgstr ""
"Пользовательские пространства имён изолируют идентификаторы и атрибуты "
"безопасности, в частности ID пользователя и ID группы (смотрите "
"B<credentials>(7)), корневой каталог, ключи (смотрите B<keyrings>(7)) и "
"мандаты (смотрите B<capabilities>(7)). Идентификаторы пользователя и группы "
"процесса могут отличаться внутри и снаружи пользовательского пространства "
"имён. В частности, процесс может иметь обычный бесправный пользовательский "
"ID снаружи и ID равный 0 внутри пространства имён; другими  словами, процесс "
"имеет доступ ко всем операциям внутри пользовательского пространства имён, "
"но не имеет доступа к привилегированным операциям вне пространства имён."

#. type: SS
#: man-pages/man7/user_namespaces.7:56
#, no-wrap
msgid "Nested namespaces, namespace membership"
msgstr "Вложенные пространства имён, членство пространств имён"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:69
msgid ""
"User namespaces can be nested; that is, each user namespace\\(emexcept the "
"initial (\"root\")  namespace\\(emhas a parent user namespace, and can have "
"zero or more child user namespaces.  The parent user namespace is the user "
"namespace of the process that creates the user namespace via a call to "
"B<unshare>(2)  or B<clone>(2)  with the B<CLONE_NEWUSER> flag."
msgstr ""
"Пользовательские пространства имён могут быть вложенными, то есть каждое "
"пользовательское пространство имён — за исключением первого («корневого») — "
"имеет родительское пространство имён и может иметь ноль или более дочерних "
"пространств имён. Родительское пространство имён — это пользовательское "
"пространство имён процесса, которое создаётся с помощью вызова B<unshare>(2) "
"или B<clone>(2) с флагом B<CLONE_NEWUSER>."

#.  commit 8742f229b635bf1c1c84a3dfe5e47c814c20b5c8
#.  FIXME Explain the rationale for this limit. (What is the rationale?)
#. type: Plain text
#: man-pages/man7/user_namespaces.7:80
msgid ""
"The kernel imposes (since version 3.11) a limit of 32 nested levels of user "
"namespaces.  Calls to B<unshare>(2)  or B<clone>(2)  that would cause this "
"limit to be exceeded fail with the error B<EUSERS>."
msgstr ""
"Ядро ограничивает (начиная с версии 3.11) глубину вложенности "
"пользовательских пространств имён 32 уровнями. Вызовы B<unshare>(2) или "
"B<clone>(2), которые бы превысили это ограничение, завершаются с ошибкой "
"B<EUSERS>."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:95
msgid ""
"Each process is a member of exactly one user namespace.  A process created "
"via B<fork>(2)  or B<clone>(2)  without the B<CLONE_NEWUSER> flag is a "
"member of the same user namespace as its parent.  A single-threaded process "
"can join another user namespace with B<setns>(2)  if it has the "
"B<CAP_SYS_ADMIN> in that namespace; upon doing so, it gains a full set of "
"capabilities in that namespace."
msgstr ""
"Каждый процесс является членом только одного пользовательского пространства "
"имён. Процесс, созданный с помощью B<fork>(2) или B<clone>(2) без флага "
"B<CLONE_NEWUSER>, является членом того же пользовательского пространства "
"имён что и его родитель. Однонитевой процесс может перейти в другое "
"пользовательское пространство имён с помощью B<setns>(2), если в этом "
"пространстве у него есть мандат B<CAP_SYS_ADMIN>; после перехода он получает "
"полный набор мандатов в этом пространстве имён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:107
msgid ""
"A call to B<clone>(2)  or B<unshare>(2)  with the B<CLONE_NEWUSER> flag "
"makes the new child process (for B<clone>(2))  or the caller (for "
"B<unshare>(2))  a member of the new user namespace created by the call."
msgstr ""
"Вызов B<clone>(2) или B<unshare>(2) с флагом B<CLONE_NEWUSER> делает новый "
"дочерний (для B<clone>(2)) или вызвавший (для B<unshare>(2)) процесс членом "
"нового пользовательского пространства имён, создаваемого вызовом."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:117
msgid ""
"The B<NS_GET_PARENT> B<ioctl>(2)  operation can be used to discover the "
"parental relationship between user namespaces; see B<ioctl_ns>(2)."
msgstr ""
"Операцию B<NS_GET_PARENT> B<ioctl>(2) можно использовать для обнаружения "
"родительской связи между пространствами имён пользователя; смотрите "
"B<ioctl_ns>(2)."

#. type: SS
#: man-pages/man7/user_namespaces.7:117
#, no-wrap
msgid "Capabilities"
msgstr "Мандаты"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:139
msgid ""
"The child process created by B<clone>(2)  with the B<CLONE_NEWUSER> flag "
"starts out with a complete set of capabilities in the new user namespace.  "
"Likewise, a process that creates a new user namespace using B<unshare>(2)  "
"or joins an existing user namespace using B<setns>(2)  gains a full set of "
"capabilities in that namespace.  On the other hand, that process has no "
"capabilities in the parent (in the case of B<clone>(2))  or previous (in the "
"case of B<unshare>(2)  and B<setns>(2))  user namespace, even if the new "
"namespace is created or joined by the root user (i.e., a process with user "
"ID 0 in the root namespace)."
msgstr ""
"Дочерний процесс, созданный B<clone>(2) с флагом B<CLONE_NEWUSER>, "
"запускается в новом пользовательском пространстве имён с полным набором "
"мандатов. Аналогично, процесс, создающий новое пользовательское пространство "
"имён с помощью B<unshare>(2) или переходящий в существующее пользовательское "
"пространство имён с помощью B<setns>(2), получает полный набор мандатов  в "
"этом пространстве имён. С другой стороны, этот процесс не имеет мандатов в "
"родительском (в случае B<clone>(2)) или предыдущем (в случае B<unshare>(2) и "
"B<setns>(2)) пользовательском пространстве имён, даже если новое "
"пространство имён создано или переход осуществлялся суперпользователем (т. "
"е., процесс с ID пользователя 0 в корневом пространстве имён)."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:149
msgid ""
"Note that a call to B<execve>(2)  will cause a process's capabilities to be "
"recalculated in the usual way (see B<capabilities>(7)).  Consequently, "
"unless the process has a user ID of 0 within the namespace, or the "
"executable file has a nonempty inheritable capabilities mask, the process "
"will lose all capabilities.  See the discussion of user and group ID "
"mappings, below."
msgstr ""
"Заметим, что вызов B<execve>(2) приводит к пересчёту мандатов процесса "
"обычным порядком (смотрите B<capabilities>(7)). Следовательно, если ID "
"пользователя процесс не равно 0 внутри пространства имён или исполняемый "
"файл имеет непустую маску наследования мандатов, то процесс теряет все "
"мандаты. Смотрите описание отображения пользовательских и групповых ID далее."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:174
msgid ""
"A call to B<clone>(2), B<unshare>(2), or B<setns>(2)  using the "
"B<CLONE_NEWUSER> flag sets the \"securebits\" flags (see "
"B<capabilities>(7))  to their default values (all flags disabled) in the "
"child (for B<clone>(2))  or caller (for B<unshare>(2), or B<setns>(2)).  "
"Note that because the caller no longer has capabilities in its original user "
"namespace after a call to B<setns>(2), it is not possible for a process to "
"reset its \"securebits\" flags while retaining its user namespace membership "
"by using a pair of B<setns>(2)  calls to move to another user namespace and "
"then return to its original user namespace."
msgstr ""
"Вызов B<clone>(2), B<unshare>(2) или B<setns>(2) с флагом B<CLONE_NEWUSER> "
"устанавливает флаги «securebits» (смотрите B<capabilities>(7)) в их значения "
"по умолчанию (все флаги сброшены) в потомке (для B<clone>(2)) или вызывающем "
"(для B<unshare>(2) или B<setns>(2)). Заметим, что из-то того, что вызывающий "
"больше не имеет мандатов в своём первоначальном пользовательском "
"пространстве имён после вызова B<setns>(2), невозможно у процесса сбросить "
"его флаги «securebits», хотя удержать своё членство в пользовательском "
"пространстве имён можно с помощью пары вызовов B<setns>(2) — сначала "
"переместиться в другое пользовательское пространство имён и затем вернуться "
"в своё первоначальное пользовательское пространство имён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:177
msgid ""
"The rules for determining whether or not a process has a capability in a "
"particular user namespace are as follows:"
msgstr ""
"Правила определения наличия мандата у процесса в определённом "
"пользовательском пространстве имён следующие:"

#.  In the 3.8 sources, see security/commoncap.c::cap_capable():
#. type: Plain text
#: man-pages/man7/user_namespaces.7:193
msgid ""
"A process has a capability inside a user namespace if it is a member of that "
"namespace and it has the capability in its effective capability set.  A "
"process can gain capabilities in its effective capability set in various "
"ways.  For example, it may execute a set-user-ID program or an executable "
"with associated file capabilities.  In addition, a process may gain "
"capabilities via the effect of B<clone>(2), B<unshare>(2), or B<setns>(2), "
"as already described."
msgstr ""
"Процесс имеет мандат внутри пользовательского пространства имён, если он "
"является членом этого пространства имён и имеет мандат в своём наборе "
"эффективных мандатов. Процесс может получить мандаты в своём наборе "
"эффективных мандатов различными способами. Например, он может запустить "
"программу с битом set-user-ID или исполняемый файл, имеющий мандаты файла. "
"Также процесс может получить мандаты при выполнении B<clone>(2), "
"B<unshare>(2) или B<setns>(2), как описывалось ранее."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:197
msgid ""
"If a process has a capability in a user namespace, then it has that "
"capability in all child (and further removed descendant)  namespaces as well."
msgstr ""
"Если процесс имеет мандат в пользовательском пространстве имён, то он также "
"имеет этот мандат во всех дочерних (и позже удалённых потомках) "
"пространствах имён."

#.  * The owner of the user namespace in the parent of the
#.  * user namespace has all caps.
#.  (and likewise associates the effective group ID of the creating process
#.  with the namespace).
#.  See kernel commit 520d9eabce18edfef76a60b7b839d54facafe1f9 for a fix
#.  on this point
#.      This includes the case where the process executes a set-user-ID
#.      program that confers the effective UID of the creator of the namespace.
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:224
msgid ""
"When a user namespace is created, the kernel records the effective user ID "
"of the creating process as being the \"owner\" of the namespace.  A process "
"that resides in the parent of the user namespace and whose effective user ID "
"matches the owner of the namespace has all capabilities in the namespace.  "
"By virtue of the previous rule, this means that the process has all "
"capabilities in all further removed descendant user namespaces as well.  The "
"B<NS_GET_OWNER_UID> B<ioctl>(2)  operation can be used to discover the user "
"ID of the owner of the namespace; see B<ioctl_ns>(2)."
msgstr ""
"При создании пользовательского пространства имён ядро записывает эффективный "
"пользовательский ID создающего процесса как «владельца» пространства имён. "
"Процесс, располагающийся в родительском пространстве имён пользовательского "
"пространства имён и чей эффективный пользовательский ID совпадает с "
"владельцем пространства имён, имеет все мандаты в пространстве имён. "
"Предыдущее правило означает, что у процесса также есть все мандаты во всех в "
"последствии удалённых потомках пользовательских пространств имён. Для "
"обнаружения идентификатора пользователя-владельца пространства имён можно "
"использовать операцию B<NS_GET_OWNER_UID> вызова B<ioctl>(2); смотрите "
"B<ioctl_ns>(2)."

#. type: SS
#: man-pages/man7/user_namespaces.7:224
#, no-wrap
msgid "Effect of capabilities within a user namespace"
msgstr "Влияние мандатов внутри пространства имён пользователя"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:232
msgid ""
"Having a capability inside a user namespace permits a process to perform "
"operations (that require privilege)  only on resources governed by that "
"namespace.  In other words, having a capability in a user namespace permits "
"a process to perform privileged operations on resources that are governed by "
"(nonuser)  namespaces owned by (associated with) the user namespace (see the "
"next subsection)."
msgstr ""
"Наличие мандата внутри пространства имён пользователя разрешает процессу "
"выполнять операции (требующие привилегий) с ресурсами, управляемыми только "
"этим пространством имён. Иначе говоря, наличие мандата в пользовательском "
"пространстве имён разрешает процессу выполнять привилегированные операции с "
"ресурсами, которые управляются (не пользовательскими) пространствами имён, "
"принадлежащими (связанными с) пространству имён пользователя (смотрите "
"следующий подраздел)."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:244
msgid ""
"On the other hand, there are many privileged operations that affect "
"resources that are not associated with any namespace type, for example, "
"changing the system time (governed by B<CAP_SYS_TIME>), loading a kernel "
"module (governed by B<CAP_SYS_MODULE>), and creating a device (governed by "
"B<CAP_MKNOD>).  Only a process with privileges in the I<initial> user "
"namespace can perform such operations."
msgstr ""
"С другой стороны, существует много привилегированных операций, которые "
"влияют на ресурсы не связанные с каким-либо типом пространства имён, "
"например, изменение системного времени (регулируется B<CAP_SYS_TIME>), "
"загрузка модуля ядра (регулируется B<CAP_SYS_MODULE>) и создание устройства "
"(регулируется B<CAP_MKNOD>). Такие операции может выполнять только процесс с "
"привилегиями в I<начальном> пользовательском пространстве имён."

#.  fs_flags = FS_USERNS_MOUNT in kernel sources
#. type: Plain text
#: man-pages/man7/user_namespaces.7:251
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"mount namespace allows that process to create bind mounts and mount the "
"following types of filesystems:"
msgstr ""
"Наличие B<CAP_SYS_ADMIN> внутри пользовательского пространства имён, "
"принадлежащему пространству имён монтирования процесса, позволяет этому "
"процессу создавать привязки монтирования и монтировать следующие типы "
"файловых систем:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:257
msgid "I</proc> (since Linux 3.8)"
msgstr "I</proc> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:260
msgid "I</sys> (since Linux 3.8)"
msgstr "I</sys> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:263
msgid "I<devpts> (since Linux 3.9)"
msgstr "I<devpts> (начиная с Linux 3.9)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:266
msgid "B<tmpfs>(5)  (since Linux 3.9)"
msgstr "B<tmpfs>(5)  (начиная с Linux 3.9)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:269
msgid "I<ramfs> (since Linux 3.9)"
msgstr "I<ramfs> (начиная с Linux 3.9)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:272
msgid "I<mqueue> (since Linux 3.9)"
msgstr "I<mqueue> (начиная с Linux 3.9)"

#.  commit b2197755b2633e164a439682fb05a9b5ea48f706
#. type: Plain text
#: man-pages/man7/user_namespaces.7:276
msgid "I<bpf> (since Linux 4.4)"
msgstr "I<bpf> (начиная с Linux 4.4)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:288
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"cgroup namespace allows (since Linux 4.6)  that process to the mount the "
"cgroup version 2 filesystem and cgroup version 1 named hierarchies (i.e., "
"cgroup filesystems mounted with the I<\"none,name=\"> option)."
msgstr ""
"Наличие B<CAP_SYS_ADMIN> внутри пользовательского пространства имён, "
"принадлежащему пространству имён cgroup процесса, позволяет (начиная с Linux "
"4.6) этому процессу монтировать именованные иерархии файловой системы cgroup "
"версии 2 и cgroup версии 1 (т. е., файловые системы cgroup, монтируемые с "
"параметром I<\"none,name=\">)."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:296
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's PID "
"namespace allows (since Linux 3.8)  that process to mount I</proc> "
"filesystems."
msgstr ""
"Наличие B<CAP_SYS_ADMIN> внутри пользовательского пространства имён, "
"принадлежащему пространству имён PID процесса, позволяет (начиная с Linux "
"3.8) этому процессу монтировать файловые системы I</proc>."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:304
msgid ""
"Note however, that mounting block-based filesystems can be done only by a "
"process that holds B<CAP_SYS_ADMIN> in the initial user namespace."
msgstr ""
"Однако заметим, что монтирование блочных файловых систем может производиться "
"только процессом, имеющим B<CAP_SYS_ADMIN> в начальном пространстве имён "
"пользователя."

#. type: SS
#: man-pages/man7/user_namespaces.7:304
#, no-wrap
msgid "Interaction of user namespaces and other types of namespaces"
msgstr "Взаимодействие между пользовательскими и другими типами пространств имён"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:309
msgid ""
"Starting in Linux 3.8, unprivileged processes can create user namespaces, "
"and the other types of namespaces can be created with just the "
"B<CAP_SYS_ADMIN> capability in the caller's user namespace."
msgstr ""
"Начиная с Linux 3.8, непривилегированные процессы могут создавать "
"пользовательские пространства имён, а для создания пространств имён других "
"типов требуется мандат B<CAP_SYS_ADMIN> в пользовательском пространстве имён "
"вызывающего."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:316
msgid ""
"When a nonuser namespace is created, it is owned by the user namespace in "
"which the creating process was a member at the time of the creation of the "
"namespace.  Privileged operations on resources governed by the nonuser "
"namespace require that the process has the necessary capabilities in the "
"user namespace that owns the nonuser namespace."
msgstr ""
"После создания не пользовательского пространства имён оно принадлежит "
"пользовательскому пространству имён, в котором на момент создания "
"пространства имён создающий процесс являлся членом. Для привилегированных "
"операций над ресурсами, управляемыми не пользовательским пространством имён, "
"от процесса требуется иметь мандаты в пользовательском пространстве имён, "
"которому принадлежит не пользовательское пространство имён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:333
msgid ""
"If B<CLONE_NEWUSER> is specified along with other B<CLONE_NEW*> flags in a "
"single B<clone>(2)  or B<unshare>(2)  call, the user namespace is guaranteed "
"to be created first, giving the child (B<clone>(2))  or caller "
"(B<unshare>(2))  privileges over the remaining namespaces created by the "
"call.  Thus, it is possible for an unprivileged caller to specify this "
"combination of flags."
msgstr ""
"Если вместе с флагами B<CLONE_NEW*> указан флаг B<CLONE_NEWUSER> в вызове "
"B<clone>(2) или B<unshare>(2), то пользовательское пространство имён "
"гарантированно создаётся первым, давая потомку (B<clone>(2)) или вызывающему "
"(B<unshare>(2))  права на остальные пространства имён, создаваемые вызовом. "
"Даже бесправный вызывающий может задать такую комбинацию флагов."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:355
msgid ""
"When a new namespace (other than a user namespace) is created via "
"B<clone>(2)  or B<unshare>(2), the kernel records the user namespace of the "
"creating process as the owner of the new namespace.  (This association can't "
"be changed.)  When a process in the new namespace subsequently performs "
"privileged operations that operate on global resources isolated by the "
"namespace, the permission checks are performed according to the process's "
"capabilities in the user namespace that the kernel associated with the new "
"namespace.  For example, suppose that a process attempts to change the "
"hostname (B<sethostname>(2)), a resource governed by the UTS namespace.  In "
"this case, the kernel will determine which user namespace owns the process's "
"UTS namespace, and check whether the process has the required capability "
"(B<CAP_SYS_ADMIN>)  in that user namespace."
msgstr ""
"При создании нового пространства имён (не пользовательского пространства "
"имён) посредством B<clone>(2) или B<unshare>(2), ядро записывает "
"пользовательское пространство имён создающего процесса как владельца нового "
"пространства имён (эту связь нельзя изменить). Когда процесс в новом "
"пространстве имён в дальнейшем выполняет привилегированные операции, которые "
"работают с глобальными ресурсами, изолированными пространством имён, "
"выполняется проверка прав согласно мандатам процесса в пользовательском "
"пространстве имён, которое ядро связало с новым пространством имён. "
"Например, предположим, что процесс пытается изменить имя узла "
"(B<sethostname>(2)) — ресурс, управляемый пространство имён UTS. В этом "
"случае, ядро будет искать пространство имён пользователя, принадлежащее "
"пространству имён UTS процесса, и проверять что процесс имеет необходимый "
"мандат (B<CAP_SYS_ADMIN>) в этом пространстве имён пользователя."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:365
msgid ""
"The B<NS_GET_USERNS> B<ioctl>(2)  operation can be used to discover the user "
"namespace that owns a nonuser namespace; see B<ioctl_ns>(2)."
msgstr ""
"Операцию B<NS_GET_USERNS> B<ioctl>(2) можно использовать для обнаружения "
"пространства имён пользователя, которое владеет не пользовательским "
"пространством имён; смотрите B<ioctl_ns>(2)."

#. type: SS
#: man-pages/man7/user_namespaces.7:365
#, no-wrap
msgid "User and group ID mappings: uid_map and gid_map"
msgstr "Отображение идентификаторов пользователей и групп: uid_map и gid_map"

#.  commit 22d917d80e842829d0ca0a561967d728eb1d6303
#. type: Plain text
#: man-pages/man7/user_namespaces.7:380
msgid ""
"When a user namespace is created, it starts out without a mapping of user "
"IDs (group IDs)  to the parent user namespace.  The I</proc/[pid]/uid_map> "
"and I</proc/[pid]/gid_map> files (available since Linux 3.5)  expose the "
"mappings for user and group IDs inside the user namespace for the process "
"I<pid>.  These files can be read to view the mappings in a user namespace "
"and written to (once) to define the mappings."
msgstr ""
"В новом созданном пользовательском пространстве имён отсутствует отображение "
"пользовательских ID (ID групп) в родительское пользовательское пространство. "
"Файл I</proc/[pid]/uid_map> и I</proc/[pid]/gid_map> (доступны начиная с "
"Linux 3.5) предоставляют отображения пользовательских и групповых ID внутри "
"пользовательского пространства имён для процесса I<pid>. Эти файлы можно "
"читать для просмотра отображений в пользовательском пространстве имён и "
"писать (однократно) для определения отображений."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:386
msgid ""
"The description in the following paragraphs explains the details for "
"I<uid_map>; I<gid_map> is exactly the same, but each instance of \"user ID\" "
"is replaced by \"group ID\"."
msgstr ""
"В следующих параграфах объясняется формат I<uid_map>; I<gid_map> имеет тот "
"же формат, но каждый экземпляр «ID пользователя» заменяется на «ID группы»."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:400
msgid ""
"The I<uid_map> file exposes the mapping of user IDs from the user namespace "
"of the process I<pid> to the user namespace of the process that opened "
"I<uid_map> (but see a qualification to this point below).  In other words, "
"processes that are in different user namespaces will potentially see "
"different values when reading from a particular I<uid_map> file, depending "
"on the user ID mappings for the user namespaces of the reading processes."
msgstr ""
"Файл I<uid_map> предоставляет отображение пользовательских ID из "
"пользовательского пространства имён процесса I<pid> в пользовательское "
"пространство имён процесса, который открыл I<uid_map> (но смотрите уточнение "
"далее). Другими словами, процессы, которые находятся в разных "
"пользовательских пространствах имён, возможно будут видеть разные значения "
"при чтении соответствующего файла I<uid_map>, в зависимости от отображений "
"пользовательских ID у пользовательских пространств имён читающего процесса."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:412
msgid ""
"Each line in the I<uid_map> file specifies a 1-to-1 mapping of a range of "
"contiguous user IDs between two user namespaces.  (When a user namespace is "
"first created, this file is empty.)  The specification in each line takes "
"the form of three numbers delimited by white space.  The first two numbers "
"specify the starting user ID in each of the two user namespaces.  The third "
"number specifies the length of the mapped range.  In detail, the fields are "
"interpreted as follows:"
msgstr ""
"Каждая строка в файле I<uid_map> определяет отображение 1-в-1 непрерывного "
"диапазона пользовательских ID между двумя пользовательскими пространствами "
"имён (при создании пользовательского пространства имён этот файл пуст). В "
"каждой строке содержится три числа через пробел. Первые два числа определяют "
"начальный пользовательский ID в каждом из двух пользовательских пространств "
"имён. Третье число определяет длину отображаемого диапазона. Эти поля "
"рассматриваются так:"

#. type: IP
#: man-pages/man7/user_namespaces.7:412
#, no-wrap
msgid "(1)"
msgstr "(1)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:416
msgid ""
"The start of the range of user IDs in the user namespace of the process "
"I<pid>."
msgstr ""
"Начало диапазона пользовательских ID в пользовательском пространстве имён "
"процесса I<pid>."

#. type: IP
#: man-pages/man7/user_namespaces.7:416
#, no-wrap
msgid "(2)"
msgstr "(2)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:424
msgid ""
"The start of the range of user IDs to which the user IDs specified by field "
"one map.  How field two is interpreted depends on whether the process that "
"opened I<uid_map> and the process I<pid> are in the same user namespace, as "
"follows:"
msgstr ""
"Начало диапазона пользовательских ID, на который отображаются "
"пользовательские ID, указанные в первом поле. Интерпретация второго поля "
"зависит от того, находится ли процесс, открывший I<uid_map>, и процесс "
"I<pid>, в одном пользовательском пространстве имён:"

#. type: IP
#: man-pages/man7/user_namespaces.7:425
#, no-wrap
msgid "a)"
msgstr "а)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:430
msgid ""
"If the two processes are in different user namespaces: field two is the "
"start of a range of user IDs in the user namespace of the process that "
"opened I<uid_map>."
msgstr ""
"Если два процесса находятся в разных пользовательских пространствах имён: "
"поле два — начало диапазона пользовательских ID в пользовательском "
"пространстве имён процесса, который открыл I<uid_map>."

#. type: IP
#: man-pages/man7/user_namespaces.7:430
#, no-wrap
msgid "b)"
msgstr "б)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:441
msgid ""
"If the two processes are in the same user namespace: field two is the start "
"of the range of user IDs in the parent user namespace of the process "
"I<pid>.  This case enables the opener of I<uid_map> (the common case here is "
"opening I</proc/self/uid_map>)  to see the mapping of user IDs into the user "
"namespace of the process that created this user namespace."
msgstr ""
"Если два процесса находятся в одном пользовательском пространстве имён: поле "
"два — начало диапазона пользовательских ID в родительском пользовательском "
"пространстве имён процесса I<pid>. Это позволяет открывшему I<uid_map> "
"(обычно открывают I</proc/self/uid_map>) видеть отображение пользовательских "
"ID в пользовательском пространстве имён процесса, создавшего это "
"пользовательское пространство имён."

#. type: IP
#: man-pages/man7/user_namespaces.7:442
#, no-wrap
msgid "(3)"
msgstr "(3)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:445
msgid ""
"The length of the range of user IDs that is mapped between the two user "
"namespaces."
msgstr ""
"Длина диапазона пользовательских ID, выполняющего отображение между двумя "
"пользовательскими пространствами имён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:452
msgid ""
"System calls that return user IDs (group IDs)\\(emfor example, B<getuid>(2), "
"B<getgid>(2), and the credential fields in the structure returned by "
"B<stat>(2)\\(emreturn the user ID (group ID) mapped into the caller's user "
"namespace."
msgstr ""
"Системные вызовы, возвращающие пользовательские ID (ID групп), например, "
"B<getuid>(2), B<getgid>(2), и мандатные поля в структуре, возвращаемой "
"B<stat>(2), возвращают пользовательский ID (ID группы), отображённый в "
"пользовательском пространстве имён вызывающего."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:460
msgid ""
"When a process accesses a file, its user and group IDs are mapped into the "
"initial user namespace for the purpose of permission checking and assigning "
"IDs when creating a file.  When a process retrieves file user and group IDs "
"via B<stat>(2), the IDs are mapped in the opposite direction, to produce "
"values relative to the process user and group ID mappings."
msgstr ""
"Когда процесс обращается к файлу, его ID пользователя и группы отображаются "
"в начальном пользовательском пространстве имён с целью проверки прав доступа "
"и назначенного ID при создании файла. Когда процесс получает ID пользователя "
"и группы файла через B<stat>(2), то ID отображаются в обратном направлении, "
"для создания значений, относительно отображений ID пользователя и группы "
"процесса."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:469
msgid ""
"The initial user namespace has no parent namespace, but, for consistency, "
"the kernel provides dummy user and group ID mapping files for this "
"namespace.  Looking at the I<uid_map> file (I<gid_map> is the same) from a "
"shell in the initial namespace shows:"
msgstr ""
"Начальное пользовательское пространство имён не имеет родительского "
"пространства имён, но для однородности, для него ядро предоставляет "
"фиктивные файлы отображения ID пользователей и групп. Посмотрим на файл "
"I<uid_map> (в I<gid_map> тоже самое) из оболочки в начальном пространстве "
"имён:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:474
#, no-wrap
msgid ""
"$ B<cat /proc/$$/uid_map>\n"
"         0          0 4294967295\n"
msgstr ""
"$ B<cat /proc/$$/uid_map>\n"
"         0          0 4294967295\n"

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:494
msgid ""
"This mapping tells us that the range starting at user ID 0 in this namespace "
"maps to a range starting at 0 in the (nonexistent) parent namespace, and the "
"length of the range is the largest 32-bit unsigned integer.  This leaves "
"4294967295 (the 32-bit signed -1 value) unmapped.  This is deliberate: "
"I<(uid_t)\\ -1> is used in several interfaces (e.g., B<setreuid>(2))  as a "
"way to specify \"no user ID\".  Leaving I<(uid_t)\\ -1> unmapped and "
"unusable guarantees that there will be no confusion when using these "
"interfaces."
msgstr ""
"Данное отображение показывает, что диапазон начинающийся с пользовательского "
"ID 0 в этом пространстве имён, отображается в диапазон, начинающийся, с 0, в "
"(несуществующее) родительское пространство имён, и длина диапазона равна "
"самому большому 32-битному беззнаковому целому. Значение 4294967295 (32-"
"битное знаковое значение -1) оставлено без отображения. Предназначение: "
"I<(uid_t)\\ -\\1> используется в некоторых интерфейсах (например, "
"B<setreuid>(2)) для указания «отсутствия ID пользователя». Оставление "
"I<(uid_t)\\ -\\1> без отображения и его не использование гарантирует, что "
"при использовании этих интерфейсов не будет проблем)."

#. type: SS
#: man-pages/man7/user_namespaces.7:494
#, no-wrap
msgid "Defining user and group ID mappings: writing to uid_map and gid_map"
msgstr "Отображение идентификаторов пользователей и групп: запись в uid_map и gid_map"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:510
msgid ""
"After the creation of a new user namespace, the I<uid_map> file of I<one> of "
"the processes in the namespace may be written to I<once> to define the "
"mapping of user IDs in the new user namespace.  An attempt to write more "
"than once to a I<uid_map> file in a user namespace fails with the error "
"B<EPERM>.  Similar rules apply for I<gid_map> files."
msgstr ""
"После создания нового пользовательского пространства имён в файл I<uid_map> "
"I<один> из процессов в пространстве имён может выполнить I<однократную> "
"запись для определения отображения пользовательских ID в новом "
"пользовательском пространстве имён. Повторная попытка записи в файл "
"I<uid_map> в пользовательском пространстве имён завершится с ошибкой "
"B<EPERM>. Эти же правила применимы к файлам I<gid_map>."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:515
msgid ""
"The lines written to I<uid_map> (I<gid_map>)  must conform to the following "
"rules:"
msgstr ""
"Записываемые в I<uid_map> (I<gid_map>) строки должны соответствовать "
"следующим правилам:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:518
msgid ""
"The three fields must be valid numbers, and the last field must be greater "
"than 0."
msgstr ""
"В трёх полях должны быть корректные числа и последнее поле должно быть "
"больше 0."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:520
msgid "Lines are terminated by newline characters."
msgstr "Строки заканчиваются символами новой строки."

#.  5*12-byte records could fit in a 64B cache line
#.  commit 6397fac4915ab3002dc15aae751455da1a852f25
#. type: Plain text
#: man-pages/man7/user_namespaces.7:535
msgid ""
"There is a limit on the number of lines in the file.  In Linux 4.14 and "
"earlier, this limit was (arbitrarily)  set at 5 lines.  Since Linux 4.15, "
"the limit is 340 lines.  In addition, the number of bytes written to the "
"file must be less than the system page size, and the write must be performed "
"at the start of the file (i.e., B<lseek>(2)  and B<pwrite>(2)  can't be used "
"to write to nonzero offsets in the file)."
msgstr ""
"Существует ограничение на количество строк в файле. В Linux 4.14 и старее "
"оно установлено (произвольно) равным пятью строкам. Начиная с Linux 4.14 его "
"значение равно 340 строкам. Также, количество байт, записываемых в файл, "
"должно быть меньше размера системной страницы, и запись должна выполняться в "
"начало файла (т. е., нельзя использовать B<lseek>(2) и B<pwrite>(2) для "
"записи в файл при ненулевом смещении)."

#.  commit 0bd14b4fd72afd5df41e9fd59f356740f22fceba
#. type: Plain text
#: man-pages/man7/user_namespaces.7:548
msgid ""
"The range of user IDs (group IDs)  specified in each line cannot overlap "
"with the ranges in any other lines.  In the initial implementation (Linux "
"3.8), this requirement was satisfied by a simplistic implementation that "
"imposed the further requirement that the values in both field 1 and field 2 "
"of successive lines must be in ascending numerical order, which prevented "
"some otherwise valid maps from being created.  Linux 3.9 and later fix this "
"limitation, allowing any valid set of nonoverlapping maps."
msgstr ""
"Диапазон пользовательских ID (групповых ID), указанный в каждой строке, не "
"должен перекрываться с диапазонами в других строках. В первой реализации "
"(Linux 3.8) это требование удовлетворялось простейшим способом, который "
"задавал другое требование: значения в полях 1 и 2 следующих одна за одной "
"строк, должны увеличиваться, что не давало создавать некоторые корректные "
"отображения. В Linux 3.9 и новее это ограничение было снято, и допустим "
"любой набор не перекрывающихся отображений."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:550
msgid "At least one line must be written to the file."
msgstr "В файл должна быть записана, как минимум, одна строка."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:553
msgid "Writes that violate the above rules fail with the error B<EINVAL>."
msgstr ""
"Попытки записи, нарушающие перечисленные выше правила, завершаются с ошибкой "
"B<EINVAL>."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:558
msgid ""
"In order for a process to write to the I</proc/[pid]/uid_map> (I</proc/[pid]/"
"gid_map>)  file, all of the following requirements must be met:"
msgstr ""
"Чтобы процесс мог записывать в файл I</proc/[pid]/uid_map> (I</proc/[pid]/"
"gid_map>) должны быть удовлетворены все условия:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:564
msgid ""
"The writing process must have the B<CAP_SETUID> (B<CAP_SETGID>)  capability "
"in the user namespace of the process I<pid>."
msgstr ""
"Записывающий процесс должен иметь мандат B<CAP_SETUID> (B<CAP_SETGID>) в "
"пользовательском пространстве имён процесса I<pid>."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:569
msgid ""
"The writing process must either be in the user namespace of the process "
"I<pid> or be in the parent user namespace of the process I<pid>."
msgstr ""
"Записывающий процесс должен находиться в пользовательском пространстве имён "
"процесса I<pid> или быть родительским пользовательским пространством имён "
"процесса I<pid>."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:572
msgid ""
"The mapped user IDs (group IDs) must in turn have a mapping in the parent "
"user namespace."
msgstr ""
"Отображаемые пользовательские ID (групповые ID) должны иметь соответствующее "
"отображение в родительском пользовательском пространстве имён."

#. type: IP
#: man-pages/man7/user_namespaces.7:572
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:574
msgid "One of the following two cases applies:"
msgstr "Применимо к одному из двух случаев:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:583
msgid ""
"I<Either> the writing process has the B<CAP_SETUID> (B<CAP_SETGID>)  "
"capability in the I<parent> user namespace."
msgstr ""
"I<Или> записывающий процесс имеет мандат B<CAP_SETUID> (B<CAP_SETGID>) в "
"I<родительском> пользовательском пространстве имён."

#. type: IP
#: man-pages/man7/user_namespaces.7:584 man-pages/man7/user_namespaces.7:593
#: man-pages/man7/user_namespaces.7:601 man-pages/man7/user_namespaces.7:604
#, no-wrap
msgid "+"
msgstr "+"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:588
msgid ""
"No further restrictions apply: the process can make mappings to arbitrary "
"user IDs (group IDs)  in the parent user namespace."
msgstr ""
"В дальнейшем ограничения не применяются: процесс может создавать отображения "
"в произвольные пользовательские ID (групповые ID) в родительском "
"пользовательском пространстве имён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:592
msgid "I<Or> otherwise all of the following restrictions apply:"
msgstr "I<Или> в противном случае накладываются следующие (все) ограничения:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:601
msgid ""
"The data written to I<uid_map> (I<gid_map>)  must consist of a single line "
"that maps the writing process's effective user ID (group ID) in the parent "
"user namespace to a user ID (group ID)  in the user namespace."
msgstr ""
"Данные, записываемые в I<uid_map> (I<gid_map>), должны состоять из одной "
"строки, которая отображает эффективный пользовательский ID (групповой ID) "
"записывающего процесса в родительском пользовательском пространстве имён в "
"пользовательский ID (групповой ID) в пользовательском пространстве имён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:604
msgid ""
"The writing process must have the same effective user ID as the process that "
"created the user namespace."
msgstr ""
"Записывающий процесс должен иметь мандат тот же эффективный пользовательский "
"ID что и процесс, который создал пользовательское пространство имён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:615
msgid ""
"In the case of I<gid_map>, use of the B<setgroups>(2)  system call must "
"first be denied by writing \"I<deny>\" to the I</proc/[pid]/setgroups> file "
"(see below) before writing to I<gid_map>."
msgstr ""
"В случае I<gid_map>, перед записью в I<gid_map> сначала нужно использовать "
"системный B<setgroups>(2) для записи \"I<deny>\" в файл I</proc/[pid]/"
"setgroups> (смотрите ниже)."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:623
msgid "Writes that violate the above rules fail with the error B<EPERM>."
msgstr ""
"Попытки записи, нарушающие перечисленные выше правила, завершаются с ошибкой "
"B<EPERM>."

#. type: SS
#: man-pages/man7/user_namespaces.7:623
#, no-wrap
msgid "Interaction with system calls that change process UIDs or GIDs"
msgstr "Взаимодействие с системными вызовами, которые изменяют UID или GID процесса."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:636
msgid ""
"In a user namespace where the I<uid_map> file has not been written, the "
"system calls that change user IDs will fail.  Similarly, if the I<gid_map> "
"file has not been written, the system calls that change group IDs will "
"fail.  After the I<uid_map> and I<gid_map> files have been written, only the "
"mapped values may be used in system calls that change user and group IDs."
msgstr ""
"В пользовательском пространстве имён, в котором не выполнялась запись в файл "
"I<uid_map>, системные вызовы, изменяющие ID пользователя, будут завершаться "
"с ошибкой. Подобными образом, если не выполнялась запись в файл I<gid_map>, "
"то системные вызовы, изменяющие ID группы, будут завершаться с ошибкой. "
"После записи в файл I<uid_map> и I<gid_map> только отображённые значения "
"могут использоваться в системных вызовах, изменяющих ID пользователя или "
"группы."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:650
msgid ""
"For user IDs, the relevant system calls include B<setuid>(2), "
"B<setfsuid>(2), B<setreuid>(2), and B<setresuid>(2).  For group IDs, the "
"relevant system calls include B<setgid>(2), B<setfsgid>(2), B<setregid>(2), "
"B<setresgid>(2), and B<setgroups>(2)."
msgstr ""
"Для ID пользователя, это относится  к следующим системным вызовам: "
"B<setuid>(2), B<setfsuid>(2), B<setreuid>(2) и B<setresuid>(2). Для ID "
"группы, это относится  к следующим системным вызовам: B<setgid>(2), "
"B<setfsgid>(2), B<setregid>(2), B<setresgid>(2) и B<setgroups>(2)."

#.  Things changed in Linux 3.19
#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:671
msgid ""
"Writing \"I<deny>\" to the I</proc/[pid]/setgroups> file before writing to "
"I</proc/[pid]/gid_map> will permanently disable B<setgroups>(2)  in a user "
"namespace and allow writing to I</proc/[pid]/gid_map> without having the "
"B<CAP_SETGID> capability in the parent user namespace."
msgstr ""
"Запись \"I<deny>\" в файле I</proc/[pid]/setgroups> перед записью в I</proc/"
"[pid]/gid_map> насовсем отключает B<setgroups>(2) в пользовательском "
"пространстве имён, а также разрешает запись в I</proc/[pid]/gid_map> без "
"мандата B<CAP_SETGID> в родительском пользовательском пространстве имён."

#. type: SS
#: man-pages/man7/user_namespaces.7:671
#, no-wrap
msgid "The /proc/[pid]/setgroups file"
msgstr "Файл /proc/[pid]/setgroups"

#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#.  http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-8989
#. type: Plain text
#: man-pages/man7/user_namespaces.7:698
msgid ""
"The I</proc/[pid]/setgroups> file displays the string \"I<allow>\" if "
"processes in the user namespace that contains the process I<pid> are "
"permitted to employ the B<setgroups>(2)  system call; it displays \"I<deny>"
"\" if B<setgroups>(2)  is not permitted in that user namespace.  Note that "
"regardless of the value in the I</proc/[pid]/setgroups> file (and regardless "
"of the process's capabilities), calls to B<setgroups>(2)  are also not "
"permitted if I</proc/[pid]/gid_map> has not yet been set."
msgstr ""
"Файл I</proc/[pid]/setgroups> содержит строку \"I<allow>\", если процессам в "
"пользовательском пространстве имён, которые содержат процесс с I<pid>, "
"разрешено выполнять системный вызов B<setgroups>(2); в файл содержится "
"строка \"I<deny>\", если B<setgroups>(2) запрещён в этом пользовательском "
"пространстве имён. Заметим, что независимо от значения в файле I</proc/[pid]/"
"setgroups> (и независимо от мандатов процесса) вызовы B<setgroups>(2) также "
"запрещены, если I</proc/[pid]/gid_map> до этого не был настроен."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:714
msgid ""
"A privileged process (one with the B<CAP_SYS_ADMIN> capability in the "
"namespace) may write either of the strings \"I<allow>\" or \"I<deny>\" to "
"this file I<before> writing a group ID mapping for this user namespace to "
"the file I</proc/[pid]/gid_map>.  Writing the string \"I<deny>\" prevents "
"any process in the user namespace from employing B<setgroups>(2)."
msgstr ""
"Привилегированный процесс (с мандатом B<CAP_SYS_ADMIN> в пространстве имён) "
"может записать строку \"I<allow>\" или \"I<deny>\" в этот файл I<до> записи "
"отображения ID групп для этого пользовательского пространства имён в файл I</"
"proc/[pid]/gid_map>. Запись строки \"I<deny>\" запрещает любому процессу в "
"пользовательском пространстве имён выполнять B<setgroups>(2)."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:733
msgid ""
"The essence of the restrictions described in the preceding paragraph is that "
"it is permitted to write to I</proc/[pid]/setgroups> only so long as calling "
"B<setgroups>(2)  is disallowed because I</proc/[pid]gid_map> has not been "
"set.  This ensures that a process cannot transition from a state where "
"B<setgroups>(2)  is allowed to a state where B<setgroups>(2)  is denied; a "
"process can transition only from B<setgroups>(2)  being disallowed to "
"B<setgroups>(2)  being allowed."
msgstr ""
"Сущность ограничений, описанных в предыдущем абзаце в том, чтобы разрешить "
"запись в I</proc/[pid]/setgroups> только когда запрещено вызывать "
"B<setgroups>(2), так как I</proc/[pid]gid_map> не настроен. Это гарантирует, "
"что процесс не сможет перейти из состояния, в котором B<setgroups>(2) "
"разрешён, в состояние, в котором B<setgroups>(2) запрещён; процесс может "
"переходить только из состояния, когда B<setgroups>(2) запрещён, в состояние, "
"когда B<setgroups>(2) разрешён."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:736
msgid ""
"The default value of this file in the initial user namespace is \"I<allow>\"."
msgstr ""
"Значение по умолчанию в этом файле для начального состояния "
"пользовательского пространства имён равно \"I<allow>\"."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:751
msgid ""
"Once I</proc/[pid]/gid_map> has been written to (which has the effect of "
"enabling B<setgroups>(2)  in the user namespace), it is no longer possible "
"to disallow B<setgroups>(2)  by writing \"I<deny>\" to I</proc/[pid]/"
"setgroups> (the write fails with the error B<EPERM>)."
msgstr ""
"После записи в I</proc/[pid]/gid_map> (что действует как разрешение работы "
"B<setgroups>(2) в пользовательском пространстве имён), больше невозможно "
"запретить B<setgroups>(2) записью \"I<deny>\" в I</proc/[pid]/setgroups> "
"(запись завершается ошибкой B<EPERM>)."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:755
msgid ""
"A child user namespace inherits the I</proc/[pid]/setgroups> setting from "
"its parent."
msgstr ""
"Дочернее пользовательское пространство имён наследует значение I</proc/[pid]/"
"setgroups> своего родителя."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:769
msgid ""
"If the I<setgroups> file has the value \"I<deny>\", then the "
"B<setgroups>(2)  system call can't subsequently be reenabled (by writing "
"\"I<allow>\" to the file) in this user namespace.  (Attempts to do so fail "
"with the error B<EPERM>.)  This restriction also propagates down to all "
"child user namespaces of this user namespace."
msgstr ""
"Если файл I<setgroups> содержит значение \"I<deny>\", то системный вызов "
"B<setgroups>(2) не может быть повторно включён в дальнейшем (записью "
"\"I<allow>\" в файл) в этом пользовательском пространстве имён (попытка это "
"сделать завершается ошибкой B<EPERM>). Это ограничение также "
"распространяется на всех потомков пользовательского пространства имён этого "
"пользовательского пространства имён."

#.  /proc/PID/setgroups
#. 	[allow == setgroups() is allowed, "deny" == setgroups() is disallowed]
#. 	* Can write if have CAP_SYS_ADMIN in NS
#. 	* Must write BEFORE writing to /proc/PID/gid_map
#.  setgroups()
#. 	* Must already have written to gid_map
#. 	* /proc/PID/setgroups must be "allow"
#.  /proc/PID/gid_map -- writing
#. 	* Must already have written "deny" to /proc/PID/setgroups
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:811
msgid ""
"The I</proc/[pid]/setgroups> file was added in Linux 3.19, but was "
"backported to many earlier stable kernel series, because it addresses a "
"security issue.  The issue concerned files with permissions such as \"rwx---"
"rwx\".  Such files give fewer permissions to \"group\" than they do to "
"\"other\".  This means that dropping groups using B<setgroups>(2)  might "
"allow a process file access that it did not formerly have.  Before the "
"existence of user namespaces this was not a concern, since only a privileged "
"process (one with the B<CAP_SETGID> capability) could call B<setgroups>(2).  "
"However, with the introduction of user namespaces, it became possible for an "
"unprivileged process to create a new namespace in which the user had all "
"privileges.  This then allowed formerly unprivileged users to drop groups "
"and thus gain file access that they did not previously have.  The I</proc/"
"[pid]/setgroups> file was added to address this security issue, by denying "
"any pathway for an unprivileged process to drop groups with B<setgroups>(2)."
msgstr ""
"Файл I</proc/[pid]/setgroups> был добавлен в Linux 3.19, но перенесён и в "
"старшие серии ядра, так как служит для обеспечения безопасности. В "
"частности, это влияет на файлы с правами доступа «rwx---rwx». Эти файлы "
"меньшие права «группе» по сравнению с группой «остальные». Это означает, что "
"удаление группы с помощью B<setgroups>(2) может открыть доступ к файлу, тем "
"которые не имели его. До существования пользовательских пространств имён это "
"не было проблемой, так как только привилегированный процесс (с мандатом "
"B<CAP_SETGID>) мог вызывать B<setgroups>(2). Однако с введение "
"пользовательских пространств имён стало возможным и непривилегированному "
"процессу создавать новое пространство имён, в котором пользователь имеет все "
"права. После этого ранее непривилегированный пользователь может удалить "
"группы и таким образом получить доступ к файлу, которого раньше не имел. "
"Файл I</proc/[pid]/setgroups> был добавлен для решения этой проблемы "
"безопасности; он запрещает непривилегированному процессу удалять группы с "
"помощью  B<setgroups>(2)."

#. type: SS
#: man-pages/man7/user_namespaces.7:811
#, no-wrap
msgid "Unmapped user and group IDs"
msgstr "Неотображённые пользовательские и групповые ID"

#.  from_kuid_munged(), from_kgid_munged()
#. type: Plain text
#: man-pages/man7/user_namespaces.7:828
msgid ""
"There are various places where an unmapped user ID (group ID)  may be "
"exposed to user space.  For example, the first process in a new user "
"namespace may call B<getuid>(2)  before a user ID mapping has been defined "
"for the namespace.  In most such cases, an unmapped user ID is converted to "
"the overflow user ID (group ID); the default value for the overflow user ID "
"(group ID) is 65534.  See the descriptions of I</proc/sys/kernel/"
"overflowuid> and I</proc/sys/kernel/overflowgid> in B<proc>(5)."
msgstr ""
"Есть несколько мест, где в пользовательском пространстве могут появиться "
"неотображённые пользовательские ID (групповые ID). Например, первый процесс "
"в новом пользовательском пространстве имён может вызвать B<getuid>(2) до "
"определения отображения пользовательских ID для пространства имён. В "
"большинстве случаев, неотображённый пользовательский ID преобразуется в "
"пользовательский ID (групповой ID) переполнения (overflow); значение по "
"умолчанию для пользовательского ID (группового ID) переполнения равно 65534. "
"Смотрите описание I</proc/sys/kernel/overflowuid> и I</proc/sys/kernel/"
"overflowgid> в B<proc>(5)."

#.  also SO_PEERCRED
#. type: Plain text
#: man-pages/man7/user_namespaces.7:856
msgid ""
"The cases where unmapped IDs are mapped in this fashion include system calls "
"that return user IDs (B<getuid>(2), B<getgid>(2), and similar), credentials "
"passed over a UNIX domain socket, credentials returned by B<stat>(2), "
"B<waitid>(2), and the System V IPC \"ctl\" B<IPC_STAT> operations, "
"credentials exposed by I</proc/[pid]/status> and the files in I</proc/"
"sysvipc/*>, credentials returned via the I<si_uid> field in the I<siginfo_t> "
"received with a signal (see B<sigaction>(2)), credentials written to the "
"process accounting file (see B<acct>(5)), and credentials returned with "
"POSIX message queue notifications (see B<mq_notify>(3))."
msgstr ""
"Случаи, где неотображённые ID отображаются в таком виде, относятся к "
"системным вызовам, которые возвращают пользовательские ID (B<getuid>(2), "
"B<getgid>(2) и подобные), мандаты, передаваемые через доменный сокет UNIX, "
"мандаты, возвращаемые B<stat>(2), B<waitid>(2) и System V IPC «ctl»-"
"операциями B<IPC_STAT>, мандаты, показываемые в I</proc/[pid]/status> и "
"файлах в I</proc/sysvipc/*>, мандаты, возвращаемые в поле I<si_uid> "
"структуры I<siginfo_t>, полученной по сигналу (смотрите B<sigaction>(2)), "
"мандаты, записываемые в файл учёта процесса (смотрите B<acct>(5)), и "
"мандаты, возвращаемые с уведомлениями очереди сообщений POSIX (смотрите "
"B<mq_notify>(3))."

#.  from_kuid(), from_kgid()
#.  Also F_GETOWNER_UIDS is an exception
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:871
msgid ""
"There is one notable case where unmapped user and group IDs are I<not> "
"converted to the corresponding overflow ID value.  When viewing a I<uid_map> "
"or I<gid_map> file in which there is no mapping for the second field, that "
"field is displayed as 4294967295 (-1 as an unsigned integer)."
msgstr ""
"Есть один известный случай, где неотображённый пользовательский и групповой "
"ID I<не> преобразуется в соответствующее значение ID переполнения. Если при "
"просмотре файла I<uid_map> или I<gid_map> обнаруживается, что для второго "
"поля нет отображения, то поле отображается как 4294967295 (-1 для "
"беззнакового целого)."

#. type: SS
#: man-pages/man7/user_namespaces.7:871
#, no-wrap
msgid "Accessing files"
msgstr "Доступ к файлам"

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:883
msgid ""
"In order to determine permissions when an unprivileged process accesses a "
"file, the process credentials (UID, GID) and the file credentials are in "
"effect mapped back to what they would be in the initial user namespace and "
"then compared to determine the permissions that the process has on the "
"file.  The same is also of other objects that employ the credentials plus "
"permissions mask accessibility model, such as System V IPC objects"
msgstr ""
"Чтобы определить права, с которыми непривилегированный процесс обращается к "
"файлу, берутся идентификаторы процесса (UID, GID) и идентификаторы файла, "
"отображаемые в те, которые были бы в исходном пространстве имён "
"пользователя, и затем сравниваются для определения прав, которые процесс "
"имеет на файл. Это также выполняется и для других объектов, использующих "
"идентификаторы плюс модель маски прав доступа, например для объектов System "
"V IPC."

#. type: SS
#: man-pages/man7/user_namespaces.7:883
#, no-wrap
msgid "Operation of file-related capabilities"
msgstr "Операции с файловыми мандатами"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:895
msgid ""
"Certain capabilities allow a process to bypass various kernel-enforced "
"restrictions when performing operations on files owned by other users or "
"groups.  These capabilities are: B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, "
"B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, and B<CAP_FSETID>."
msgstr ""
"Некоторые мандаты позволяют процессу обходить различные ограничения, "
"налагаемые ядром на выполнение операций над файлами, принадлежащими другим "
"пользователям или группам. Список мандатов: B<CAP_CHOWN>, "
"B<CAP_DAC_OVERRIDE>, B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER> и B<CAP_FSETID>."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:900
msgid ""
"Within a user namespace, these capabilities allow a process to bypass the "
"rules if the process has the relevant capability over the file, meaning that:"
msgstr ""
"Внутри пользовательского пространства имён эти мандаты позволяют процессу "
"обходить правила, если процесс имеет соответствующий мандат на файле, "
"подразумевающий что:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:902
msgid ""
"the process has the relevant effective capability in its user namespace; and"
msgstr ""
"процесс имеет соответствующий эффективный мандат в своём пространстве имён "
"пользователя; и"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:905
msgid ""
"the file's user ID and group ID both have valid mappings in the user "
"namespace."
msgstr ""
"файловые ID пользователя и группы корректно отображаются в "
"пользовательскомпространстве имён."

#.  These are the checks performed by the kernel function
#.  inode_owner_or_capable(). There is one exception to the exception:
#.  overriding the directory sticky permission bit requires that
#.  the file has a valid mapping for both its UID and GID.
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:919
msgid ""
"The B<CAP_FOWNER> capability is treated somewhat exceptionally: it allows a "
"process to bypass the corresponding rules so long as at least the file's "
"user ID has a mapping in the user namespace (i.e., the file's group ID does "
"not need to have a valid mapping)."
msgstr ""
"Мандат B<CAP_FOWNER> учитывается по-другому: it allows a process to bypass "
"the corresponding rules so long as at least the file's user ID has a mapping "
"in the user namespace (т. е., файловый ID группы может не иметь корректного "
"отображения)."

#. type: SS
#: man-pages/man7/user_namespaces.7:919
#, no-wrap
msgid "Set-user-ID and set-group-ID programs"
msgstr "Программы с установленными битами set-user-ID и set-group-ID"

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:939
msgid ""
"When a process inside a user namespace executes a set-user-ID (set-group-ID) "
"program, the process's effective user (group) ID inside the namespace is "
"changed to whatever value is mapped for the user (group) ID of the file.  "
"However, if either the user I<or> the group ID of the file has no mapping "
"inside the namespace, the set-user-ID (set-group-ID) bit is silently "
"ignored: the new program is executed, but the process's effective user "
"(group) ID is left unchanged.  (This mirrors the semantics of executing a "
"set-user-ID or set-group-ID program that resides on a filesystem that was "
"mounted with the B<MS_NOSUID> flag, as described in B<mount>(2).)"
msgstr ""
"Когда процесс внутри пользовательского пространства имён выполняет программу "
"с установленным битом set-user-ID (set-group-ID), то эффективный ID "
"пользователя (группы) внутри пространства имён изменяется на значение, "
"отображённое для ID пользователя (группы) файла. Однако, если ID "
"пользователя I<или> группы файла не имеет отображения внутри пространства "
"имён, то бит set-user-ID (set-group-ID) просто игнорируется: выполняется "
"новая программа, но эффективный ID пользователя (группы) остаётся не "
"изменённым (такое поведение зеркально семантике выполнения программы с set-"
"user-ID или set-group-ID, располагающейся в файловой системе, которая была "
"смонтирована с флагом B<MS_NOSUID>, как описано в B<mount>(2))."

#. type: SS
#: man-pages/man7/user_namespaces.7:939
#, no-wrap
msgid "Miscellaneous"
msgstr "Разное"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:949
msgid ""
"When a process's user and group IDs are passed over a UNIX domain socket to "
"a process in a different user namespace (see the description of "
"B<SCM_CREDENTIALS> in B<unix>(7)), they are translated into the "
"corresponding values as per the receiving process's user and group ID "
"mappings."
msgstr ""
"Когда ID пользователя и группы процесса передаются через доменный сокет UNIX "
"в процесс в другом пользовательском пространстве имён (смотрите описание "
"B<SCM_CREDENTIALS> в B<unix>(7)), то они транслируются в соответствующие "
"значения согласно отображению ID пользователя и группы принимающего процесса."

#. type: SH
#: man-pages/man7/user_namespaces.7:949
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:952
msgid "Namespaces are a Linux-specific feature."
msgstr "Пространства имён есть только в Linux."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:962
msgid ""
"Over the years, there have been a lot of features that have been added to "
"the Linux kernel that have been made available only to privileged users "
"because of their potential to confuse set-user-ID-root applications.  In "
"general, it becomes safe to allow the root user in a user namespace to use "
"those features because it is impossible, while in a user namespace, to gain "
"more privilege than the root user of a user namespace has."
msgstr ""
"За эти годы в ядро Linux добавлено много свойств, которые были доступны "
"только привилегированным пользователям, так как их возможности слишком "
"велики, чтобы наделять ими приложения с set-user-ID. В целом, становится "
"безопасно разрешать пользователю root в пользовательском пространстве имён "
"использовать эти свойства, так как будучи в пользовательском пространстве "
"имён, он не может получить больше прав, чем имеет root в пользовательском "
"пространстве имён."

#. type: SS
#: man-pages/man7/user_namespaces.7:962
#, no-wrap
msgid "Availability"
msgstr "Доступность"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:970
msgid ""
"Use of user namespaces requires a kernel that is configured with the "
"B<CONFIG_USER_NS> option.  User namespaces require support in a range of "
"subsystems across the kernel.  When an unsupported subsystem is configured "
"into the kernel, it is not possible to configure user namespaces support."
msgstr ""
"Для использования пользовательских пространств имён ядро должно быть собрано "
"с параметром B<CONFIG_USER_NS>. Пользовательские пространства имён требуют "
"поддержки во многих подсистемах ядра. Если в ядре задействована "
"неподдерживаемая подсистема, то включить поддержку пользовательских "
"пространств имён невозможно."

#.  commit d6970d4b726cea6d7a9bc4120814f95c09571fc3
#. type: Plain text
#: man-pages/man7/user_namespaces.7:981
msgid ""
"As at Linux 3.8, most relevant subsystems supported user namespaces, but a "
"number of filesystems did not have the infrastructure needed to map user and "
"group IDs between user namespaces.  Linux 3.9 added the required "
"infrastructure support for many of the remaining unsupported filesystems "
"(Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS, and OCFS2).  "
"Linux 3.12 added support for the last of the unsupported major filesystems, "
"XFS."
msgstr ""
"В Linux 3.8 самые важные подсистемы поддерживают пользовательские "
"пространства имён, но значительное количество файловых систем не имеют "
"инфраструктуры для отображения пользовательских и групповых ID между "
"пользовательскими пространствами имён. В Linux 3.9 добавлена требуемая "
"поддержка инфраструктуры во многие неподдерживаемые файловые системы (Plan 9 "
"(9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS и OCFS2). В Linux 3.12 "
"добавлена поддержка в последние основные файловые системы (XFS)."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:990
msgid ""
"The program below is designed to allow experimenting with user namespaces, "
"as well as other types of namespaces.  It creates namespaces as specified by "
"command-line options and then executes a command inside those namespaces.  "
"The comments and I<usage()> function inside the program provide a full "
"explanation of the program.  The following shell session demonstrates its "
"use."
msgstr ""
"Представленная далее программа разработана для экспериментов с "
"пользовательскими пространствами имён. Она создаёт пространства имён "
"согласно параметрам командной строки и затем выполняет команду внутри этих "
"пространств имён. В комментариях и функции I<usage()> предоставлено полное "
"описание программы. Следующий сеанс оболочки показывает её работу."

#. type: Plain text
#: man-pages/man7/user_namespaces.7:992
msgid "First, we look at the run-time environment:"
msgstr "Сначала, посмотрим на окружение выполнения:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1001
#, no-wrap
msgid ""
"$ B<uname -rs>     # Need Linux 3.8 or later\n"
"Linux 3.8.0\n"
"$ B<id -u>         # Running as unprivileged user\n"
"1000\n"
"$ B<id -g>\n"
"1000\n"
msgstr ""
"$ B<uname -rs>     # требуется Linux 3.8 или новее\n"
"Linux 3.8.0\n"
"$ B<id -u>         # работа от непривилегированного пользователя\n"
"1000\n"
"$ B<id -g>\n"
"1000\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1015
msgid ""
"Now start a new shell in new user (I<-U>), mount (I<-m>), and PID (I<-p>)  "
"namespaces, with user ID (I<-M>)  and group ID (I<-G>)  1000 mapped to 0 "
"inside the user namespace:"
msgstr ""
"Теперь запустим новую оболочку в новых пользовательском (I<-U>), "
"монтирования (I<-m>) и PID (I<-p>) пространствах имён с пользовательским (I<-"
"M>) и групповым ID (I<-G>)  1000, отображающимся в 0 внутри "
"пользовательского пространства имён:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1019
#, no-wrap
msgid "$ B<./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1' bash>\n"
msgstr "$ B<./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1' bash>\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1024
msgid ""
"The shell has PID 1, because it is the first process in the new PID "
"namespace:"
msgstr ""
"У оболочки PID равен 1, так как это первый процесс в новом пространстве имён "
"PID:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1029
#, no-wrap
msgid ""
"bash$ B<echo $$>\n"
"1\n"
msgstr ""
"bash$ B<echo $$>\n"
"1\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1037
msgid ""
"Mounting a new I</proc> filesystem and listing all of the processes visible "
"in the new PID namespace shows that the shell can't see any processes "
"outside the PID namespace:"
msgstr ""
"Смонтируем новую файловую систему I</proc> и просмотрим все процессы, "
"видимые в новом пространстве имён PID; убедимся, что оболочка не видит ни "
"одного процесса вне своего пространства имён PID:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1045
#, no-wrap
msgid ""
"bash$ B<mount -t proc proc /proc>\n"
"bash$ B<ps ax>\n"
"  PID TTY      STAT   TIME COMMAND\n"
"    1 pts/3    S      0:00 bash\n"
"   22 pts/3    R+     0:00 ps ax\n"
msgstr ""
"bash$ B<mount -t proc proc /proc>\n"
"bash$ B<ps ax>\n"
"  PID TTY      STAT   TIME COMMAND\n"
"    1 pts/3    S      0:00 bash\n"
"   22 pts/3    R+     0:00 ps ax\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1050
msgid ""
"Inside the user namespace, the shell has user and group ID 0, and a full set "
"of permitted and effective capabilities:"
msgstr ""
"Внутри пользовательского пространства имён идентификаторы пользователя и "
"группы оболочки равны 0, и она имеет полный набор разрешённых и эффективных "
"мандатов:"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1060
#, no-wrap
msgid ""
"bash$ B<cat /proc/$$/status | egrep '^[UG]id'>\n"
"Uid:\t0\t0\t0\t0\n"
"Gid:\t0\t0\t0\t0\n"
"bash$ B<cat /proc/$$/status | egrep '^Cap(Prm|Inh|Eff)'>\n"
"CapInh:\t0000000000000000\n"
"CapPrm:\t0000001fffffffff\n"
"CapEff:\t0000001fffffffff\n"
msgstr ""
"bash$ B<cat /proc/$$/status | egrep '^[UG]id'>\n"
"Uid:\t0\t0\t0\t0\n"
"Gid:\t0\t0\t0\t0\n"
"bash$ B<cat /proc/$$/status | egrep '^Cap(Prm|Inh|Eff)'>\n"
"CapInh:\t0000000000000000\n"
"CapPrm:\t0000001fffffffff\n"
"CapEff:\t0000001fffffffff\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1066
#, no-wrap
msgid "/* userns_child_exec.c\n"
msgstr "/* userns_child_exec.c\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1068
#, no-wrap
msgid "   Licensed under GNU General Public License v2 or later\n"
msgstr ""
"   Лицензируется на условиях Универсальной общественной лицензии\n"
"   GNU версии 2 и новее\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1084
#, no-wrap
msgid ""
"   Create a child process that executes a shell command in new\n"
"   namespace(s); allow UID and GID mappings to be specified when\n"
"   creating a user namespace.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"   Создаёт дочерний процесс, который запускает командную оболочку\n"
"   в новых пространствах имён; может выполнять отображение UID и GID,\n"
"   если они указаны при создании пользовательского пространства имён.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1087
#, no-wrap
msgid ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
msgstr ""
"/* Простая функция обработки ошибок: выводит сообщение об ошибке согласно\n"
"   значению в «errno» и завершает вызвавший процесс */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1090
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1095
#, no-wrap
msgid ""
"struct child_args {\n"
"    char **argv;        /* Command to be executed by child, with args */\n"
"    int    pipe_fd[2];  /* Pipe used to synchronize parent and child */\n"
"};\n"
msgstr ""
"struct child_args {\n"
"    char **argv;        /* команда, выполняемая потомком с параметрами */\n"
"    int    pipe_fd[2];  /* канал для синхронизации родителя и потомка */\n"
"};\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1097
#, no-wrap
msgid "static int verbose;\n"
msgstr "static int verbose;\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1130
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] cmd [arg...]\\en\\en\", pname);\n"
"    fprintf(stderr, \"Create a child process that executes a shell \"\n"
"            \"command in a new user namespace,\\en\"\n"
"            \"and possibly also other new namespace(s).\\en\\en\");\n"
"    fprintf(stderr, \"Options can be:\\en\\en\");\n"
"#define fpe(str) fprintf(stderr, \"    %s\", str);\n"
"    fpe(\"-i          New IPC namespace\\en\");\n"
"    fpe(\"-m          New mount namespace\\en\");\n"
"    fpe(\"-n          New network namespace\\en\");\n"
"    fpe(\"-p          New PID namespace\\en\");\n"
"    fpe(\"-u          New UTS namespace\\en\");\n"
"    fpe(\"-U          New user namespace\\en\");\n"
"    fpe(\"-M uid_map  Specify UID map for user namespace\\en\");\n"
"    fpe(\"-G gid_map  Specify GID map for user namespace\\en\");\n"
"    fpe(\"-z          Map user\\(aqs UID and GID to 0 in user namespace\\en\");\n"
"    fpe(\"            (equivalent to: -M \\(aq0 E<lt>uidE<gt> 1\\(aq -G \\(aq0 E<lt>gidE<gt> 1\\(aq)\\en\");\n"
"    fpe(\"-v          Display verbose messages\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"If -z, -M, or -G is specified, -U is required.\\en\");\n"
"    fpe(\"It is not permitted to specify both -z and either -M or -G.\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Map strings for -M and -G consist of records of the form:\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"    ID-inside-ns   ID-outside-ns   len\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"A map string can contain multiple records, separated\"\n"
"        \" by commas;\\en\");\n"
"    fpe(\"the commas are replaced by newlines before writing\"\n"
"        \" to map files.\\en\");\n"
msgstr ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Использование: %s [параметры] кмд [арг…]\\en\\en\", pname);\n"
"    fprintf(stderr, \"Создаёт дочерний процесс, который запускает командную \"\n"
"            \"оболочку в новом пользовательском пространстве имён,\\en\"\n"
"            \"и, возможно, также в других новых пространствах имён.\\en\\en\");\n"
"    fprintf(stderr, \"Параметры:\\en\\en\");\n"
"#define fpe(str) fprintf(stderr, \"    %s\", str);\n"
"    fpe(\"-i          Новое пространство имён IPC\\en\");\n"
"    fpe(\"-m          Новое пространство имён монтирования\\en\");\n"
"    fpe(\"-n          Новое сетевое пространство имён\\en\");\n"
"    fpe(\"-p          Новое пространство имён PID\\en\");\n"
"    fpe(\"-u          Новое пространство имён UTS\\en\");\n"
"    fpe(\"-U          Новое пользовательское пространство имён\\en\");\n"
"    fpe(\"-M uid_map  карта UID для пользовательского пространства имён\\en\");\n"
"    fpe(\"-G gid_map  карта GID для пользовательского пространства имён\\en\");\n"
"    fpe(\"-z          Отображать пользовательский UID и GID в 0 в пользовательском пространстве имён\\en\");\n"
"    fpe(\"            (эквивалентно: -M \\(aq0 E<lt>uidE<gt> 1\\(aq -G \\(aq0 E<lt>gidE<gt> 1\\(aq)\\en\");\n"
"    fpe(\"-v          показывать дополнительные сообщения\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Если указан -z, -M или -G, то требуется -U.\\en\");\n"
"    fpe(\"Нельзя указывать -z вместе с -M или -G.\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Строка карты для -M и -G состоит из записей вида:\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"    ID-внутри-ns   ID-вне-ns   длина\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Строка карты может содержать несколько записей через запятую;\\en\");\n"
"    fpe(\"запятые замещаются на символы новой строки перед записью\"\n"
"        \" в файлы карт.\\en\");\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1133
#, no-wrap
msgid ""
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1138
#, no-wrap
msgid ""
"/* Update the mapping file \\(aqmap_file\\(aq, with the value provided in\n"
"   \\(aqmapping\\(aq, a string that defines a UID or GID mapping. A UID or\n"
"   GID mapping consists of one or more newline-delimited records\n"
"   of the form:\n"
msgstr ""
"/* Обновляем файл отображения «map_file» значением из\n"
"   «mapping» — строкой, в которой определены отображения UID или GID.\n"
"   Отображения UID или GID состоят из одной или более записей\n"
"   (разделённых символом новой строки) вида:\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1140
#, no-wrap
msgid "       ID_inside-ns    ID-outside-ns   length\n"
msgstr "       ID-внутри-ns    ID-снаружи-ns   длина\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1145
#, no-wrap
msgid ""
"   Requiring the user to supply a string that contains newlines is\n"
"   of course inconvenient for command-line use. Thus, we permit the\n"
"   use of commas to delimit records in this string, and replace them\n"
"   with newlines before writing the string to the file. */\n"
msgstr ""
"   Требовать от пользователя указывать строку с символами новой строки\n"
"   в командной строке неприемлемо. Поэтому мы позволим использовать\n"
"   для разделения записей запятые и заменим их символами новой строки\n"
"   перед записью строки в файл. */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1151
#, no-wrap
msgid ""
"static void\n"
"update_map(char *mapping, char *map_file)\n"
"{\n"
"    int fd, j;\n"
"    size_t map_len;     /* Length of \\(aqmapping\\(aq */\n"
msgstr ""
"static void\n"
"update_map(char *mapping, char *map_file)\n"
"{\n"
"    int fd, j;\n"
"    size_t map_len;     /* длина «mapping» */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1153
#, no-wrap
msgid "    /* Replace commas in mapping string with newlines */\n"
msgstr "    /* Заменяем запятые на символы новой строки в строке отображения */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1158
#, no-wrap
msgid ""
"    map_len = strlen(mapping);\n"
"    for (j = 0; j E<lt> map_len; j++)\n"
"        if (mapping[j] == \\(aq,\\(aq)\n"
"            mapping[j] = \\(aq\\en\\(aq;\n"
msgstr ""
"    map_len = strlen(mapping);\n"
"    for (j = 0; j E<lt> map_len; j++)\n"
"        if (mapping[j] == \\(aq,\\(aq)\n"
"            mapping[j] = \\(aq\\en\\(aq;\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1165
#, no-wrap
msgid ""
"    fd = open(map_file, O_RDWR);\n"
"    if (fd == -1) {\n"
"        fprintf(stderr, \"ERROR: open %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = open(map_file, O_RDWR);\n"
"    if (fd == -1) {\n"
"        fprintf(stderr, \"ОШИБКА: open %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1171
#, no-wrap
msgid ""
"    if (write(fd, mapping, map_len) != map_len) {\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (write(fd, mapping, map_len) != map_len) {\n"
"        fprintf(stderr, \"ОШИБКА: write %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1174 man-pages/man7/user_namespaces.7:1218
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""
"    close(fd);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1183
#, no-wrap
msgid ""
"/* Linux 3.19 made a change in the handling of setgroups(2) and the\n"
"   \\(aqgid_map\\(aq file to address a security issue. The issue allowed\n"
"   *unprivileged* users to employ user namespaces in order to drop\n"
"   The upshot of the 3.19 changes is that in order to update the\n"
"   \\(aqgid_maps\\(aq file, use of the setgroups() system call in this\n"
"   user namespace must first be disabled by writing \"deny\" to one of\n"
"   the /proc/PID/setgroups files for this namespace.  That is the\n"
"   purpose of the following function. */\n"
msgstr ""
"/* В Linux 3.19 изменена работа с setgroups(2) и добавлен файл\n"
"   \\(aqgid_map\\(aq для обеспечения безопасности. Задача в том,\n"
"   чтобы запретить удалять группы *непривилегированному* пользователю\n"
"   через создание пространства имён. Результат изменений 3.19 в том, что\n"
"   для обновления файла \\(aqgid_maps\\(aq, сначала нужно запретить системный\n"
"   вызов setgroups() в этом пользовательском пространстве имён, записав\n"
"   \"deny\" в один из файлов /proc/PID/setgroups в этом пространстве имён.\n"
"   Это цель данной функции. */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1189
#, no-wrap
msgid ""
"static void\n"
"proc_setgroups_write(pid_t child_pid, char *str)\n"
"{\n"
"    char setgroups_path[PATH_MAX];\n"
"    int fd;\n"
msgstr ""
"static void\n"
"proc_setgroups_write(pid_t child_pid, char *str)\n"
"{\n"
"    char setgroups_path[PATH_MAX];\n"
"    int fd;\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1192
#, no-wrap
msgid ""
"    snprintf(setgroups_path, PATH_MAX, \"/proc/%ld/setgroups\",\n"
"            (long) child_pid);\n"
msgstr ""
"    snprintf(setgroups_path, PATH_MAX, \"/proc/%ld/setgroups\",\n"
"            (long) child_pid);\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1195
#, no-wrap
msgid ""
"    fd = open(setgroups_path, O_RDWR);\n"
"    if (fd == -1) {\n"
msgstr ""
"    fd = open(setgroups_path, O_RDWR);\n"
"    if (fd == -1) {\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1201
#, no-wrap
msgid ""
"        /* We may be on a system that doesn\\(aqt support\n"
"           /proc/PID/setgroups. In that case, the file won\\(aqt exist,\n"
"           and the system won\\(aqt impose the restrictions that Linux 3.19\n"
"           added. That\\(aqs fine: we don\\(aqt need to do anything in order\n"
"           to permit \\(aqgid_map\\(aq to be updated.\n"
msgstr ""
"        /* Система может не поддерживать\n"
"           /proc/PID/setgroups. В этом случае файл не существует,\n"
"           и система не закладывает ограничений, добавленных в Linux 3.19.\n"
"           Хорошо, нам не нужно ничего делать, чтобы разрешить\n"
"           обновлять \\(aqgid_map\\(aq.\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1205
#, no-wrap
msgid ""
"           However, if the error from open() was something other than\n"
"           the ENOENT error that is expected for that case,  let the\n"
"           user know. */\n"
msgstr ""
"           Однако, если ошибка open() отличается от\n"
"           ENOENT, сообщим об этом пользователю. */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1211
#, no-wrap
msgid ""
"        if (errno != ENOENT)\n"
"            fprintf(stderr, \"ERROR: open %s: %s\\en\", setgroups_path,\n"
"                strerror(errno));\n"
"        return;\n"
"    }\n"
msgstr ""
"        if (errno != ENOENT)\n"
"            fprintf(stderr, \"ERROR: open %s: %s\\en\", setgroups_path,\n"
"                strerror(errno));\n"
"        return;\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1215
#, no-wrap
msgid ""
"    if (write(fd, str, strlen(str)) == -1)\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", setgroups_path,\n"
"            strerror(errno));\n"
msgstr ""
"    if (write(fd, str, strlen(str)) == -1)\n"
"        fprintf(stderr, \"ОШИБКА: write %s: %s\\en\", setgroups_path,\n"
"            strerror(errno));\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1224
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct child_args *args = (struct child_args *) arg;\n"
"    char ch;\n"
msgstr ""
"static int              /* Начальная функция клонированного потомка */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct child_args *args = (struct child_args *) arg;\n"
"    char ch;\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1229
#, no-wrap
msgid ""
"    /* Wait until the parent has updated the UID and GID mappings.\n"
"       See the comment in main(). We wait for end of file on a\n"
"       pipe that will be closed by the parent process once it has\n"
"       updated the mappings. */\n"
msgstr ""
"    /* Ждём пока родитель обновит отображения UID и GID.\n"
"       Смотрите комментарий в main(). Мы ждём конца файла в канале,\n"
"       который будет закрыт родительским процессом после обновления\n"
"       отображений. */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1238
#, no-wrap
msgid ""
"    close(args-E<gt>pipe_fd[1]);    /* Close our descriptor for the write\n"
"                                   end of the pipe so that we see EOF\n"
"                                   when parent closes its descriptor */\n"
"    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
"        fprintf(stderr,\n"
"                \"Failure in child: read from pipe returned != 0\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    close(args-E<gt>pipe_fd[1]);    /* закрываем наш дескриптор для записи\n"
"                                   конца канала для того, чтобы мы\n"
"                                   увидели EOF, когда родитель закроет\n"
"                                   свой дескриптор */\n"
"    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
"        fprintf(stderr,\n"
"                \"Ошибка в потомке: при чтении из канала получен != 0\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1240
#, no-wrap
msgid "    close(args-E<gt>pipe_fd[0]);\n"
msgstr "    close(args-E<gt>pipe_fd[0]);\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1242
#, no-wrap
msgid "    /* Execute a shell command */\n"
msgstr "    /* Запускаем командную оболочку */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1247
#, no-wrap
msgid ""
"    printf(\"About to exec %s\\en\", args-E<gt>argv[0]);\n"
"    execvp(args-E<gt>argv[0], args-E<gt>argv);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""
"    printf(\"О exec %s\\en\", args-E<gt>argv[0]);\n"
"    execvp(args-E<gt>argv[0], args-E<gt>argv);\n"
"    errExit(\"execvp\");\n"
"}\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1249
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)\n"
msgstr "#define STACK_SIZE (1024 * 1024)\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1251
#, no-wrap
msgid "static char child_stack[STACK_SIZE];    /* Space for child\\(aqs stack */\n"
msgstr "static char child_stack[STACK_SIZE];    /* место под стек в потомке */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1262
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt, map_zero;\n"
"    pid_t child_pid;\n"
"    struct child_args args;\n"
"    char *uid_map, *gid_map;\n"
"    const int MAP_BUF_SIZE = 100;\n"
"    char map_buf[MAP_BUF_SIZE];\n"
"    char map_path[PATH_MAX];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt, map_zero;\n"
"    pid_t child_pid;\n"
"    struct child_args args;\n"
"    char *uid_map, *gid_map;\n"
"    const int MAP_BUF_SIZE = 100;\n"
"    char map_buf[MAP_BUF_SIZE];\n"
"    char map_path[PATH_MAX];\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1269
#, no-wrap
msgid ""
"    /* Parse command-line options. The initial \\(aq+\\(aq character in\n"
"       the final getopt() argument prevents GNU-style permutation\n"
"       of command-line options. That\\(aqs useful, since sometimes\n"
"       the \\(aqcommand\\(aq to be executed by this program itself\n"
"       has command-line options. We don\\(aqt want getopt() to treat\n"
"       those as options to this program. */\n"
msgstr ""
"    /* Разбираем параметры командной строки. Начальный символ «+» в\n"
"       последнем аргументе getopt() предотвращает подстановку параметров\n"
"       командной строки в стиле GNU. Это полезно, так как иногда\n"
"       «команда», выполняемая этой программой, сама имеет параметры\n"
"       командной строки. Мы не хотим, чтобы getopt() передала их\n"
"       нашей программе. */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1290
#, no-wrap
msgid ""
"    flags = 0;\n"
"    verbose = 0;\n"
"    gid_map = NULL;\n"
"    uid_map = NULL;\n"
"    map_zero = 0;\n"
"    while ((opt = getopt(argc, argv, \"+imnpuUM:G:zv\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqv\\(aq: verbose = 1;                  break;\n"
"        case \\(aqz\\(aq: map_zero = 1;                 break;\n"
"        case \\(aqM\\(aq: uid_map = optarg;             break;\n"
"        case \\(aqG\\(aq: gid_map = optarg;             break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""
"    flags = 0;\n"
"    verbose = 0;\n"
"    gid_map = NULL;\n"
"    uid_map = NULL;\n"
"    map_zero = 0;\n"
"    while ((opt = getopt(argc, argv, \"+imnpuUM:G:zv\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqv\\(aq: verbose = 1;                  break;\n"
"        case \\(aqz\\(aq: map_zero = 1;                 break;\n"
"        case \\(aqM\\(aq: uid_map = optarg;             break;\n"
"        case \\(aqG\\(aq: gid_map = optarg;             break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1292
#, no-wrap
msgid "    /* -M or -G without -U is nonsensical */\n"
msgstr "    /* -M или -G без -U не имеют смысла */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1297
#, no-wrap
msgid ""
"    if (((uid_map != NULL || gid_map != NULL || map_zero) &&\n"
"                !(flags & CLONE_NEWUSER)) ||\n"
"            (map_zero && (uid_map != NULL || gid_map != NULL)))\n"
"        usage(argv[0]);\n"
msgstr ""
"    if (((uid_map != NULL || gid_map != NULL || map_zero) &&\n"
"                !(flags & CLONE_NEWUSER)) ||\n"
"            (map_zero && (uid_map != NULL || gid_map != NULL)))\n"
"        usage(argv[0]);\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1299
#, no-wrap
msgid "    args.argv = &argv[optind];\n"
msgstr "    args.argv = &argv[optind];\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1309
#, no-wrap
msgid ""
"    /* We use a pipe to synchronize the parent and child, in order to\n"
"       ensure that the parent sets the UID and GID maps before the child\n"
"       calls execve(). This ensures that the child maintains its\n"
"       capabilities during the execve() in the common case where we\n"
"       want to map the child\\(aqs effective user ID to 0 in the new user\n"
"       namespace. Without this synchronization, the child would lose\n"
"       its capabilities if it performed an execve() with nonzero\n"
"       user IDs (see the capabilities(7) man page for details of the\n"
"       transformation of a process\\(aqs capabilities during execve()). */\n"
msgstr ""
"    /* Мы используем канал для синхронизации родителя и потомка, чтобы\n"
"       родитель настроил отображения UID и GID до того, как потомок\n"
"       вызовет execve(). Это гарантирует, что потомок предъявит свои\n"
"       мандаты при execve(); обычно мы хотим отобразить эффективный\n"
"       пользовательский ID потомка в 0 в новом пользовательском\n"
"       пространстве имён. Без этой синхронизации потомок потерял\n"
"       бы свои мандаты при вызове execve() с ненулевым пользовательским\n"
"       ID (смотрите в справочной странице capabilities(7) подробности\n"
"       преобразования мандатов процесса при execve()). */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1312
#, no-wrap
msgid ""
"    if (pipe(args.pipe_fd) == -1)\n"
"        errExit(\"pipe\");\n"
msgstr ""
"    if (pipe(args.pipe_fd) == -1)\n"
"        errExit(\"pipe\");\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1314
#, no-wrap
msgid "    /* Create the child in new namespace(s) */\n"
msgstr "    /* создаём потомка в новом пространстве имён */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1319
#, no-wrap
msgid ""
"    child_pid = clone(childFunc, child_stack + STACK_SIZE,\n"
"                      flags | SIGCHLD, &args);\n"
"    if (child_pid == -1)\n"
"        errExit(\"clone\");\n"
msgstr ""
"    child_pid = clone(childFunc, child_stack + STACK_SIZE,\n"
"                      flags | SIGCHLD, &args);\n"
"    if (child_pid == -1)\n"
"        errExit(\"clone\");\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1321
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr "    /* предок попадает сюда */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1325
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: PID of child created by clone() is %ld\\en\",\n"
"                argv[0], (long) child_pid);\n"
msgstr ""
"    if (verbose)\n"
"        printf(\"%s: PID потомка, созданного clone(): %ld\\en\",\n"
"                argv[0], (long) child_pid);\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1327
#, no-wrap
msgid "    /* Update the UID and GID maps in the child */\n"
msgstr "    /* обновляем отображения UID и GID в потомке */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1337
#, no-wrap
msgid ""
"    if (uid_map != NULL || map_zero) {\n"
"        snprintf(map_path, PATH_MAX, \"/proc/%ld/uid_map\",\n"
"                (long) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\", (long) getuid());\n"
"            uid_map = map_buf;\n"
"        }\n"
"        update_map(uid_map, map_path);\n"
"    }\n"
msgstr ""
"    if (uid_map != NULL || map_zero) {\n"
"        snprintf(map_path, PATH_MAX, \"/proc/%ld/uid_map\",\n"
"                (long) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\", (long) getuid());\n"
"            uid_map = map_buf;\n"
"        }\n"
"        update_map(uid_map, map_path);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1340
#, no-wrap
msgid ""
"    if (gid_map != NULL || map_zero) {\n"
"        proc_setgroups_write(child_pid, \"deny\");\n"
msgstr ""
"    if (gid_map != NULL || map_zero) {\n"
"        proc_setgroups_write(child_pid, \"deny\");\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1349
#, no-wrap
msgid ""
"        snprintf(map_path, PATH_MAX, \"/proc/%ld/gid_map\",\n"
"                (long) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\", (long) getgid());\n"
"            gid_map = map_buf;\n"
"        }\n"
"        update_map(gid_map, map_path);\n"
"    }\n"
msgstr ""
"        snprintf(map_path, PATH_MAX, \"/proc/%ld/gid_map\",\n"
"                (long) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\", (long) getgid());\n"
"            gid_map = map_buf;\n"
"        }\n"
"        update_map(gid_map, map_path);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1352
#, no-wrap
msgid ""
"    /* Close the write end of the pipe, to signal to the child that we\n"
"       have updated the UID and GID maps */\n"
msgstr ""
"    /* закрываем конец канала на стороне записи для сообщения потомку\n"
"       о том, что мы обновили отображения UID и GID */\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1354
#, no-wrap
msgid "    close(args.pipe_fd[1]);\n"
msgstr "    close(args.pipe_fd[1]);\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1357
#, no-wrap
msgid ""
"    if (waitpid(child_pid, NULL, 0) == -1)      /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
msgstr ""
"    if (waitpid(child_pid, NULL, 0) == -1)      /* ждём потомка */\n"
"        errExit(\"waitpid\");\n"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1360
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: terminating\\en\", argv[0]);\n"
msgstr ""
"    if (verbose)\n"
"        printf(\"%s: завершение\\en\", argv[0]);\n"

#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#. type: Plain text
#: man-pages/man7/user_namespaces.7:1379
msgid ""
"B<newgidmap>(1), B<newuidmap>(1), B<clone>(2), B<ptrace>(2), B<setns>(2), "
"B<unshare>(2), B<proc>(5), B<subgid>(5), B<subuid>(5), B<capabilities>(7), "
"B<cgroup_namespaces>(7)  B<credentials>(7), B<namespaces>(7), "
"B<pid_namespaces>(7)"
msgstr ""
"B<newgidmap>(1), B<newuidmap>(1), B<clone>(2), B<ptrace>(2), B<setns>(2), "
"B<unshare>(2), B<proc>(5), B<subgid>(5), B<subuid>(5), B<capabilities>(7), "
"B<cgroup_namespaces>(7)  B<credentials>(7), B<namespaces>(7), "
"B<pid_namespaces>(7)"

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1381
msgid ""
"The kernel source file I<Documentation/namespaces/resource-control.txt>."
msgstr ""
"Файл из дерева исходного кода ядра I<Documentation/namespaces/resource-"
"control.txt>."

#. type: TH
#: man-pages/man7/unicode.7:29
#, no-wrap
msgid "UNICODE"
msgstr "UNICODE"

#. type: Plain text
#: man-pages/man7/unicode.7:32
msgid "unicode - universal character set"
msgstr "unicode - универсальный набор символов"

#. type: Plain text
#: man-pages/man7/unicode.7:40
msgid ""
"The international standard ISO 10646 defines the Universal Character Set "
"(UCS).  UCS contains all characters of all other character set standards.  "
"It also guarantees \"round-trip compatibility\"; in other words, conversion "
"tables can be built such that no information is lost when a string is "
"converted from any other encoding to UCS and back."
msgstr ""
"Universal Character Set (UCS) (универсальный набор символов — Юникод) "
"определён в международном стандарте ISO 10646. UCS содержит все символы "
"других стандартов. Его использование гарантирует «полную "
"взаимозаменяемость», другими словами, таблицы для преобразований могут быть "
"построены таким образом, что не произойдёт потери информации при "
"преобразовании строки из сторонней кодировки в UCS и обратно."

#. type: Plain text
#: man-pages/man7/unicode.7:62
msgid ""
"UCS contains the characters required to represent practically all known "
"languages.  This includes not only the Latin, Greek, Cyrillic, Hebrew, "
"Arabic, Armenian, and Georgian scripts, but also Chinese, Japanese and "
"Korean Han ideographs as well as scripts such as Hiragana, Katakana, Hangul, "
"Devanagari, Bengali, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada, "
"Malayalam, Thai, Lao, Khmer, Bopomofo, Tibetan, Runic, Ethiopic, Canadian "
"Syllabics, Cherokee, Mongolian, Ogham, Myanmar, Sinhala, Thaana, Yi, and "
"others.  For scripts not yet covered, research on how to best encode them "
"for computer usage is still going on and they will be added eventually.  "
"This might eventually include not only Hieroglyphs and various historic Indo-"
"European languages, but even some selected artistic scripts such as Tengwar, "
"Cirth, and Klingon.  UCS also covers a large number of graphical, "
"typographical, mathematical, and scientific symbols, including those "
"provided by TeX, Postscript, APL, MS-DOS, MS-Windows, Macintosh, OCR fonts, "
"as well as many word processing and publishing systems, and more are being "
"added."
msgstr ""
"UCS содержит символы, необходимые для представления практически всех "
"известных сейчас языковых символов. В него включены не только языковые "
"символы из латинской, греческой, кириллицы, иврита, арабской, армянской, "
"грузинской письменности, но и китайские, японские и корейские идеограммы, а "
"также символы из таких письменностей как хирагана, катакана, хангул, "
"деванагари, бенгальской, гурмуки, гуджарати, ория, тамильской, телугской, "
"каннада, малаяламской, тайской, лаосской, кхмерской, бопомофо, тибетской, "
"рунической, эфиопской, канадского слогового письма, чероки, монгольской, "
"охамской, мьянмарской, синхальской,таанской, юи и других. По ещё не "
"включённым письменностям постоянно ведутся работы для поиска их самой "
"оптимальной кодировки для компьютеров и добавлении. К ним относятся не "
"только различные иероглифы и письменности из индо-европейской исторической "
"группы, но и некоторые искусственные языки, такие как тенгвар, сирт и "
"клингонский. Также UCS содержит большое множество графических, "
"типографических, математических и научных символов, используемых в таких "
"программах, как TeX, Postscript, APL, MS-DOS, MS-Windows, Macintosh, шрифтах "
"OCR и многих других текстовых процессорах и издательских системах."

#. type: Plain text
#: man-pages/man7/unicode.7:93
msgid ""
"The UCS standard (ISO 10646) describes a 31-bit character set architecture "
"consisting of 128 24-bit I<groups>, each divided into 256 16-bit I<planes> "
"made up of 256 8-bit I<rows> with 256 I<column> positions, one for each "
"character.  Part 1 of the standard (ISO 10646-1)  defines the first 65534 "
"code positions (0x0000 to 0xfffd), which form the I<Basic Multilingual "
"Plane> (BMP), that is plane 0 in group 0.  Part 2 of the standard (ISO "
"10646-2)  adds characters to group 0 outside the BMP in several "
"I<supplementary planes> in the range 0x10000 to 0x10ffff.  There are no "
"plans to add characters beyond 0x10ffff to the standard, therefore of the "
"entire code space, only a small fraction of group 0 will ever be actually "
"used in the foreseeable future.  The BMP contains all characters found in "
"the commonly used other character sets.  The supplemental planes added by "
"ISO 10646-2 cover only more exotic characters for special scientific, "
"dictionary printing, publishing industry, higher-level protocol and "
"enthusiast needs."
msgstr ""
"Стандарт UCS (ISO 10646) описывает 31-битную архитектуру набора символов, "
"состоящую из 128 24-битных I<групп>, каждая из которых разделена на 256 16-"
"битных I<плоскостей>, которые, в свою очередь, состоят из 256 8-битных "
"I<строк> и 256 I<колонок>, каждая для одного символа. В 1 части стандарта "
"(ISO 10646-1) определяются первые 65534 кодируемых позиций (с 0x0000 по "
"0xfffd), каждая из которых образует Basic Multilingual Plane (BMP) "
"(I<основную многоязычную матрицу>), являющуюся плоскостью 0 в группе 0. В 2 "
"части стандарта (ISO 10646-2) добавляются символы, не вошедшие в BMP,  в "
"некоторые I<дополнительные плоскости> в диапазоне от 0x10000 до 0x10ffff "
"группы 0. Пока нет планов по добавлению символов за предел 0x10ffff в "
"существующий стандарт, поэтому в обозримом будущем во всём закодированном "
"пространстве в действительности будет использоваться только малая часть "
"группы 0. BMP содержит все символы, используемые в других наборах символов. "
"Дополнительные плоскости, добавляемые ISO 10646-2 покрывают некоторые "
"особенные, специальные и экзотические символы, используемые в науке, при "
"печати словарей, издательской индустрии, протоколах высокого уровня и "
"некоторыми энтузиастами."

#. type: Plain text
#: man-pages/man7/unicode.7:101
msgid ""
"The representation of each UCS character as a 2-byte word is referred to as "
"the UCS-2 form (only for BMP characters), whereas UCS-4 is the "
"representation of each character by a 4-byte word.  In addition, there exist "
"two encoding forms UTF-8 for backward compatibility with ASCII processing "
"software and UTF-16 for the backward-compatible handling of non-BMP "
"characters up to 0x10ffff by UCS-2 software."
msgstr ""
"Представление каждого символа в UCS в виде -байтного слова называют формой "
"UCS-2 (только для символов BMP), UCS-4 называют представление каждого "
"символа 4-байтным словом. Также существуют 2 формы кодировки: UTF-8 — для "
"совместимости со старым ПО, работающим с кодировкой ASCII, и UTF-16 — для "
"совместимости с ПО, работающим с кодировкой UCS-2, для не BMP символов до "
"0x10ffff позиции."

#. type: Plain text
#: man-pages/man7/unicode.7:107
msgid ""
"The UCS characters 0x0000 to 0x007f are identical to those of the classic US-"
"ASCII character set and the characters in the range 0x0000 to 0x00ff are "
"identical to those in ISO 8859-1 (Latin-1)."
msgstr ""
"Символы UCS от 0x0000 до 0x007f идентичны обычному набору символов US-ASCII, "
"а символы в диапазоне от 0x0000 до 0x00ff идентичны символам ISO 8859-1 "
"(Latin-1)."

#. type: SS
#: man-pages/man7/unicode.7:107
#, no-wrap
msgid "Combining characters"
msgstr "Комбинирующие символы"

#. type: Plain text
#: man-pages/man7/unicode.7:123
msgid ""
"Some code points in UCS have been assigned to I<combining characters>.  "
"These are similar to the nonspacing accent keys on a typewriter.  A "
"combining character just adds an accent to the previous character.  The most "
"important accented characters have codes of their own in UCS, however, the "
"combining character mechanism allows us to add accents and other diacritical "
"marks to any character.  The combining characters always follow the "
"character which they modify.  For example, the German character Umlaut-A "
"(\"Latin capital letter A with diaeresis\") can either be represented by the "
"precomposed UCS code 0x00c4, or alternatively as the combination of a normal "
"\"Latin capital letter A\" followed by a \"combining diaeresis\": 0x0041 "
"0x0308."
msgstr ""
"Некоторые позиции в UCS зарезервированы для I<комбинирующих символов>. Они "
"аналогичны клавишам печатной машинки, которые служат для набора букв с "
"ударением. Комбинирующий символ лишь добавляет ударение к предыдущему "
"символу. Наиболее употребляемые символы, требующие ударения, имеют "
"собственный код в UCS, однако комбинирующий символ позволяет добавить "
"ударение или другой диакритический знак к любому символу. Комбинирующие "
"символы всегда указываются после буквы, которую они изменяют. Например, "
"немецкий символ «умляут-А» (латинская заглавная буква А с диерезой) может "
"быть представлен как зарезервированный специальный символ UCS с кодом "
"0x00c4, или как комбинация обыкновенной «латинской заглавной буквы А» и "
"последующей «комбинирующей диерезы: 0x0041 0x0308."

#. type: Plain text
#: man-pages/man7/unicode.7:127
msgid ""
"Combining characters are essential for instance for encoding the Thai script "
"or for mathematical typesetting and users of the International Phonetic "
"Alphabet."
msgstr ""
"Комбинирующие символы являются необходимым инструментом для кодирования "
"символов тайского языка, математики и для пользователей международного "
"фонетического алфавита (International Phonetic Alphabet)."

#. type: SS
#: man-pages/man7/unicode.7:127
#, no-wrap
msgid "Implementation levels"
msgstr "Уровни реализации"

#. type: Plain text
#: man-pages/man7/unicode.7:132
msgid ""
"As not all systems are expected to support advanced mechanisms like "
"combining characters, ISO 10646-1 specifies the following three "
"I<implementation levels> of UCS:"
msgstr ""
"Так как не все системы могут поддерживать такой сложный механизм, как "
"реализацию комбинирующих символов, стандарт ISO 10646-1 предусматривает "
"следующие три I<уровня реализации> UCS:"

#. type: TP
#: man-pages/man7/unicode.7:132
#, no-wrap
msgid "Level 1"
msgstr "Уровень 1"

#. type: Plain text
#: man-pages/man7/unicode.7:138
msgid ""
"Combining characters and Hangul Jamo (a variant encoding of the Korean "
"script, where a Hangul syllable glyph is coded as a triplet or pair of vowel/"
"consonant codes) are not supported."
msgstr ""
"Комбинирующие символы и символы Hangul Jamo (вариант кодировки корейского "
"письма, где слоги хангыль кодируются по два или по три гласных кода) не "
"поддерживаются."

#. type: TP
#: man-pages/man7/unicode.7:138
#, no-wrap
msgid "Level 2"
msgstr "Уровень 2"

#. type: Plain text
#: man-pages/man7/unicode.7:143
msgid ""
"In addition to level 1, combining characters are now allowed for some "
"languages where they are essential (e.g., Thai, Lao, Hebrew, Arabic, "
"Devanagari, Malayalam)."
msgstr ""
"В дополнении к символам уровня 1 комбинирующие символы разрешено "
"использовать для некоторых языков, в которых они важны (например: тайский, "
"лаосский, иврит, арабский, деванагари, малаяламский)."

#. type: TP
#: man-pages/man7/unicode.7:143
#, no-wrap
msgid "Level 3"
msgstr "Уровень 3"

#. type: Plain text
#: man-pages/man7/unicode.7:146
msgid "All UCS characters are supported."
msgstr "Поддерживаются все символы UCS."

#. type: Plain text
#: man-pages/man7/unicode.7:159
msgid ""
"The Unicode 3.0 Standard published by the Unicode Consortium contains "
"exactly the UCS Basic Multilingual Plane at implementation level 3, as "
"described in ISO 10646-1:2000.  Unicode 3.1 added the supplemental planes of "
"ISO 10646-2.  The Unicode standard and technical reports published by the "
"Unicode Consortium provide much additional information on the semantics and "
"recommended usages of various characters.  They provide guidelines and "
"algorithms for editing, sorting, comparing, normalizing, converting, and "
"displaying Unicode strings."
msgstr ""
"Стандарт Unicode 3.0, опубликованный Unicode Consortium, содержит точную "
"реализацию UCS Basic Multilingual Plane на уровне 3, как описано в стандарте "
"ISO 10646-1:2000. В Unicode 3.1 добавлены дополнительные плоскости ISO "
"10646-2. Стандарт Юникода и технические сообщения, публикуемые Unicode "
"Consortium, предоставляют много дополнительной информации по семантике и "
"рекомендации по использованию разных символов. Также поясняются принципы и "
"алгоритмы для редактирования, сортировки, сравнения, нормализации, "
"преобразования и вывода строк Юникода."

#. type: SS
#: man-pages/man7/unicode.7:159
#, no-wrap
msgid "Unicode under Linux"
msgstr "Юникод в Linux"

#. type: Plain text
#: man-pages/man7/unicode.7:169
msgid ""
"Under GNU/Linux, the C type I<wchar_t> is a signed 32-bit integer type.  Its "
"values are always interpreted by the C library as UCS code values (in all "
"locales), a convention that is signaled by the GNU C library to applications "
"by defining the constant B<__STDC_ISO_10646__> as specified in the ISO C99 "
"standard."
msgstr ""
"В системах GNU/Linux тип языка Cи I<wchar_t> является 32-битным знаковым "
"целым типом. Его значения всегда интерпретируются библиотекой Си как "
"значения кодов UCS (во всех локалях); в этом случае, согласно стандарту ISO "
"C99, библиотека GNU C определяет константу B<__STDC_ISO_10646__>."

#. type: Plain text
#: man-pages/man7/unicode.7:178
msgid ""
"UCS/Unicode can be used just like ASCII in input/output streams, terminal "
"communication, plaintext files, filenames, and environment variables in the "
"ASCII compatible UTF-8 multibyte encoding.  To signal the use of UTF-8 as "
"the character encoding to all applications, a suitable I<locale> has to be "
"selected via environment variables (e.g., \"LANG=en_GB.UTF-8\")."
msgstr ""
"UCS/Unicode может использоваться подобно ASCII в потоках ввода/вывода, "
"соединениях с терминалами, в текстовых файлах, названиях файлов и в "
"переменных окружения в виде многобайтовой кодировке UTF-8, совместимой с "
"ASCII. Для обозначения использования UTF-8 как кодировки во всех приложениях "
"должна быть выбрана подходящая I<локаль> через переменные окружения "
"(например, «LANG=ru_RU.UTF-8»)."

#. type: Plain text
#: man-pages/man7/unicode.7:193
msgid ""
"The B<nl_langinfo(CODESET)> function returns the name of the selected "
"encoding.  Library functions such as B<wctomb>(3)  and B<mbsrtowcs>(3)  can "
"be used to transform the internal I<wchar_t> characters and strings into the "
"system character encoding and back and B<wcwidth>(3)  tells, how many "
"positions (0\\(en2) the cursor is advanced by the output of a character."
msgstr ""
"Функция B<nl_langinfo(CODESET)> возвращает название выбранной кодировки. "
"Библиотечные функции, такие как B<wctomb>(3) и B<mbsrtowcs>(3), могут "
"использоваться для преобразования внутренних символов I<wchar_t> и строк в "
"кодировку системных символов и наоборот; B<wcwidth>(3) определяет, на "
"сколько позиций (0\\(en2) сместился курсор при выводе символа."

#. type: SS
#: man-pages/man7/unicode.7:194
#, no-wrap
msgid "Private Use Areas (PUA)"
msgstr "Закрытые используемые области (Private Use Areas, PUA)"

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: man-pages/man7/unicode.7:212
msgid ""
"In the Basic Multilingual Plane, the range 0xe000 to 0xf8ff will never be "
"assigned to any characters by the standard and is reserved for private "
"usage.  For the Linux community, this private area has been subdivided "
"further into the range 0xe000 to 0xefff which can be used individually by "
"any end-user and the Linux zone in the range 0xf000 to 0xf8ff where "
"extensions are coordinated among all Linux users.  The registry of the "
"characters assigned to the Linux zone is maintained by LANANA and the "
"registry itself is I<Documentation/admin-guide/unicode.rst> in the Linux "
"kernel sources (or I<Documentation/unicode.txt> before Linux 4.10)."
msgstr ""
"В основной многоязычной матрице диапазон с 0xe000 до 0xf8ff никогда не будет "
"использован для обозначения стандартных символов, он зарезервирован для "
"частного использования. В Linux эта закрытая область делится на: диапазон "
"0xe000 по 0xefff может использоваться конечным пользователем; диапазон "
"0xf000 по 0xf8ff (так называемая зона Linux) может использоваться для "
"расширений, согласованных среди пользователей Linux. В настоящее время "
"регистрацией символов в зоне Linux занимается LANANA, а сам реестр находится "
"в файле I<Documentation/admin-guide/unicode.rst> исходного кода ядра Linux "
"(в I<Documentation/unicode.txt> до Linux 4.10)."

#. type: Plain text
#: man-pages/man7/unicode.7:217
msgid ""
"Two other planes are reserved for private usage, plane 15 (Supplementary "
"Private Use Area-A, range 0xf0000 to 0xffffd)  and plane 16 (Supplementary "
"Private Use Area-B, range 0x100000 to 0x10fffd)."
msgstr ""
"Две другие плоскости зарезервированы для закрытого использования, плоскость "
"15 (дополнительная закрытая используемая область-A, диапазон от 0xf0000 до "
"0xffffd) и плоскость 16 (дополнительная закрытая используемая область-B, "
"диапазон от 0x100000 до 0x10fffd)."

#. type: SS
#: man-pages/man7/unicode.7:217
#, no-wrap
msgid "Literature"
msgstr "Литература"

#. type: Plain text
#: man-pages/man7/unicode.7:223
msgid ""
"Information technology \\(em Universal Multiple-Octet Coded Character Set "
"(UCS) \\(em Part 1: Architecture and Basic Multilingual Plane.  "
"International Standard ISO/IEC 10646-1, International Organization for "
"Standardization, Geneva, 2000."
msgstr ""
"Information technology \\(em Universal Multiple-Octet Coded Character Set "
"(UCS) \\(em Part 1: Architecture and Basic Multilingual Plane.  "
"International Standard ISO/IEC 10646-1, International Organization for "
"Standardization, Geneva, 2000."

#. type: Plain text
#: man-pages/man7/unicode.7:228
msgid ""
"This is the official specification of UCS .  Available from E<.UR http://www."
"iso.ch/> E<.UE .>"
msgstr ""
"Официальная спецификация UCS. Доступна с E<.UR http://www.iso.ch/> E<.UE .>"

#. type: Plain text
#: man-pages/man7/unicode.7:232
msgid ""
"The Unicode Standard, Version 3.0.  The Unicode Consortium, Addison-Wesley, "
"Reading, MA, 2000, ISBN 0-201-61633-5."
msgstr ""
"The Unicode Standard, Version 3.0.  The Unicode Consortium, Addison-Wesley, "
"Reading, MA, 2000, ISBN 0-201-61633-5."

#. type: Plain text
#: man-pages/man7/unicode.7:235
msgid ""
"S.\\& Harbison, G.\\& Steele. C: A Reference Manual. Fourth edition, "
"Prentice Hall, Englewood Cliffs, 1995, ISBN 0-13-326224-3."
msgstr ""
"S.\\& Harbison, G.\\& Steele. C: A Reference Manual. Fourth edition, "
"Prentice Hall, Englewood Cliffs, 1995, ISBN 0-13-326224-3."

#. type: Plain text
#: man-pages/man7/unicode.7:242
msgid ""
"A good reference book about the C programming language.  The fourth edition "
"covers the 1994 Amendment 1 to the ISO C90 standard, which adds a large "
"number of new C library functions for handling wide and multibyte character "
"encodings, but it does not yet cover ISO C99, which improved wide and "
"multibyte character support even further."
msgstr ""
"Хорошая книга о программировании на языке Си. Четвёртое издание включает в "
"себя описание поправки 1, сделанной в стандарте ISO C90 в 1994 году. Эта "
"поправка добавляет к стандарту большое количество новых библиотечных функций "
"Си для поддержки кодирования широких и многобайтовых символов, но она не так "
"полна как стандарт ISO C99, который расширяет поддержку широких и "
"многобайтовых символов."

#. type: Plain text
#: man-pages/man7/unicode.7:244
msgid "Unicode Technical Reports."
msgstr "Unicode Technical Reports."

#. type: Plain text
#: man-pages/man7/unicode.7:247
msgid "E<.UR http://www.unicode.org\\:/reports/> E<.UE>"
msgstr "E<.UR http://www.unicode.org\\:/reports/> E<.UE>"

#. type: Plain text
#: man-pages/man7/unicode.7:250
msgid "Markus Kuhn: UTF-8 and Unicode FAQ for UNIX/Linux."
msgstr "Markus Kuhn: UTF-8 and Unicode FAQ for UNIX/Linux."

#. type: Plain text
#: man-pages/man7/unicode.7:253
msgid "E<.UR http://www.cl.cam.ac.uk\\:/~mgk25\\:/unicode.html> E<.UE>"
msgstr "E<.UR http://www.cl.cam.ac.uk\\:/~mgk25\\:/unicode.html> E<.UE>"

#. type: Plain text
#: man-pages/man7/unicode.7:256
msgid "Bruno Haible: Unicode HOWTO."
msgstr "Bruno Haible: Unicode HOWTO."

#. type: Plain text
#: man-pages/man7/unicode.7:259
msgid "E<.UR http://www.tldp.org\\:/HOWTO\\:/Unicode-HOWTO.html> E<.UE>"
msgstr "E<.UR http://www.tldp.org\\:/HOWTO\\:/Unicode-HOWTO.html> E<.UE>"

#. type: Plain text
#: man-pages/man7/unicode.7:266
msgid "B<locale>(1), B<setlocale>(3), B<charsets>(7), B<utf-8>(7)"
msgstr "B<locale>(1), B<setlocale>(3), B<charsets>(7), B<utf-8>(7)"

#. type: TH
#: man-pages/man7/uri.7:48
#, no-wrap
msgid "URI"
msgstr "URI"

#. type: Plain text
#: man-pages/man7/uri.7:51
msgid ""
"uri, url, urn - uniform resource identifier (URI), including a URL or URN"
msgstr ""
"uri, url, urn - единый идентификатор ресурса (URI), содержащий URL или URN"

#. type: Plain text
#: man-pages/man7/uri.7:55
#, no-wrap
msgid "URI = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n"
msgstr "URI = [ абсолютный_URI | относительный_URI ] [ \"#\" фрагмент ]\n"

#. type: Plain text
#: man-pages/man7/uri.7:57
#, no-wrap
msgid "absoluteURI = scheme \":\" ( hierarchical_part | opaque_part )\n"
msgstr "абсолютныйURI = схема \":\" ( иерархическая_часть | неясная_часть )\n"

#. type: Plain text
#: man-pages/man7/uri.7:59
#, no-wrap
msgid "relativeURI = ( net_path | absolute_path | relative_path ) [ \"?\" query ]\n"
msgstr "относительныйURI = ( сетевой_путь | абсолютный_путь | относительный_путь ) [ \"?\" запрос ]\n"

#. type: Plain text
#: man-pages/man7/uri.7:62
#, no-wrap
msgid ""
"scheme = \"http\" | \"ftp\" | \"gopher\" | \"mailto\" | \"news\" | \"telnet\" |\n"
"         \"file\" | \"man\" | \"info\" | \"whatis\" | \"ldap\" | \"wais\" | \\&...\n"
msgstr ""
"схема = \"http\" | \"ftp\" | \"gopher\" | \"mailto\" | \"news\" | \"telnet\" |\n"
"         \"file\" | \"man\" | \"info\" | \"whatis\" | \"ldap\" | \"wais\" | …\n"

#. type: Plain text
#: man-pages/man7/uri.7:64
#, no-wrap
msgid "hierarchical_part = ( net_path | absolute_path ) [ \"?\" query ]\n"
msgstr "иерархическая_часть = ( сетевой_путь | абсолютный_путь ) [ \"?\" запрос ]\n"

#. type: Plain text
#: man-pages/man7/uri.7:66
#, no-wrap
msgid "net_path = \"//\" authority [ absolute_path ]\n"
msgstr "сетевой_путь = \"//\" полномочия [ абсолютный_путь ]\n"

#. type: Plain text
#: man-pages/man7/uri.7:68
#, no-wrap
msgid "absolute_path = \"/\"  path_segments\n"
msgstr "абсолютный_путь = \"/\"  сегменты_пути\n"

#. type: Plain text
#: man-pages/man7/uri.7:70
#, no-wrap
msgid "relative_path = relative_segment [ absolute_path ]\n"
msgstr "относительный_путь = относительный_сегмент [ абсолютный_путь ]\n"

#. type: Plain text
#: man-pages/man7/uri.7:82
msgid ""
"A Uniform Resource Identifier (URI) is a short string of characters "
"identifying an abstract or physical resource (for example, a web page).  A "
"Uniform Resource Locator (URL) is a URI that identifies a resource through "
"its primary access mechanism (e.g., its network \"location\"), rather than "
"by name or some other attribute of that resource.  A Uniform Resource Name "
"(URN) is a URI that must remain globally unique and persistent even when the "
"resource ceases to exist or becomes unavailable."
msgstr ""
"Единый идентификатор ресурса (Uniform Resource Identifier (URI)) — это "
"короткая строка символов, идентифицирующая абстрактный или физический ресурс "
"(например, веб-страницу). Единый указатель местоположения ресурса (Uniform "
"Resource Locator (URL)) — это URI, который идентифицирует ресурс по "
"основному способу доступа к нему (например, его «местонахождению в сети»), а "
"не по названию или другим атрибутам этого ресурса. Единое название ресурса "
"(Uniform Resource Name (URN)) — это URI, который должен оставаться "
"уникальным и неизменным даже в том случае, когда ресурс уже не существует "
"или недоступен."

#. type: Plain text
#: man-pages/man7/uri.7:89
msgid ""
"URIs are the standard way to name hypertext link destinations for tools such "
"as web browsers.  The string \"http://www.kernel.org\" is a URL (and thus it "
"is also a URI).  Many people use the term URL loosely as a synonym for URI "
"(though technically URLs are a subset of URIs)."
msgstr ""
"URI являются стандартным способом создания конечных адресов гипертекстовых "
"ссылок для таких инструментов как веб-браузеры. Строка «http://www.kernel."
"org» является URL (а значит и URI). Многие используют термин URL "
"неправильно, как синоним URI (технически, URL являются частью URI)."

#. type: Plain text
#: man-pages/man7/uri.7:105
msgid ""
"URIs can be absolute or relative.  An absolute identifier refers to a "
"resource independent of context, while a relative identifier refers to a "
"resource by describing the difference from the current context.  Within a "
"relative path reference, the complete path segments \".\" and \"..\" have "
"special meanings: \"the current hierarchy level\" and \"the level above this "
"hierarchy level\", respectively, just like they do in UNIX-like systems.  A "
"path segment which contains a colon character can't be used as the first "
"segment of a relative URI path (e.g., \"this:that\"), because it would be "
"mistaken for a scheme name; precede such segments with ./ (e.g., \"./this:"
"that\").  Note that descendants of MS-DOS (e.g., Microsoft Windows) replace "
"devicename colons with the vertical bar (\"|\") in URIs, so \"C:\" becomes "
"\"C|\"."
msgstr ""
"URI могут быть абсолютными или относительными. Абсолютный идентификатор "
"ссылается на ресурс независимо от контекста, в то время как относительный "
"идентификатор ссылается на ресурс, описывая его относительно текущего "
"контекста. В относительном идентификаторе части пути «.» и «..» имеют "
"специальные значения: «текущий иерархический уровень» и «уровень выше "
"текущего иерархического уровня», соответственно —аналогично UNIX-подобным "
"системам. Часть пути, содержащая двоеточие, не может быть использована как "
"первая часть пути относительного URI (например, «это:то»), потому что это "
"приведёт к ошибке; перед такими частями надо ставить ./ (например, «./это:"
"то»). Заметим, что в производных MS-DOS (например, Microsoft Windows) в URI "
"в именах устройств двоеточие заменено на вертикальную черту («|»), то есть "
"«C:» заменяется на «C|»."

#. type: Plain text
#: man-pages/man7/uri.7:109
msgid ""
"A fragment identifier, if included, refers to a particular named portion "
"(fragment) of a resource; text after a \\(aq#\\(aq identifies the fragment.  "
"A URI beginning with \\(aq#\\(aq refers to that fragment in the current "
"resource."
msgstr ""
"Если используется идентификатор фрагмента, то он ссылается на часть ресурса "
"с конкретным названием; фрагментом называют текст после символа «#». URI, "
"начинающийся с «#», ссылается на такой фрагмент в текущем ресурсе."

#. type: SS
#: man-pages/man7/uri.7:109
#, no-wrap
msgid "Usage"
msgstr "Использование"

#. type: Plain text
#: man-pages/man7/uri.7:117
msgid ""
"There are many different URI schemes, each with specific additional rules "
"and meanings, but they are intentionally made to be as similar as possible.  "
"For example, many URL schemes permit the authority to be the following "
"format, called here an I<ip_server> (square brackets show what's optional):"
msgstr ""
"Существует множество различных схем URI, в каждой могут быть свои "
"дополнительные правила и смыслы, но все они создаются максимально похожими "
"друг на друга. Например, многие схемы URL позволяют задавать полномочия в "
"следующем формате, обозначаемом здесь как I<ip_server> (квадратные скобки "
"указывают на необязательность):"

#. type: Plain text
#: man-pages/man7/uri.7:119
msgid "I<ip_server = >[I<user> [ : I<password> ] @ ] I<host> [ : I<port>]"
msgstr ""
"I<ip_server = >[I<пользователь> [ : I<пароль> ] @ ] I<узел> [ : I<порт>]"

#. type: Plain text
#: man-pages/man7/uri.7:135
msgid ""
"This format allows you to optionally insert a username, a user plus "
"password, and/or a port number.  The I<host> is the name of the host "
"computer, either its name as determined by DNS or an IP address (numbers "
"separated by periods).  Thus the URI E<lt>http://fred:fredpassword@example."
"com:8080/E<gt> logs into a web server on host example.com as fred (using "
"fredpassword) using port 8080.  Avoid including a password in a URI if "
"possible because of the many security risks of having a password written "
"down.  If the URL supplies a username but no password, and the remote server "
"requests a password, the program interpreting the URL should request one "
"from the user."
msgstr ""
"Этот формат позволяет указать имя пользователя, его пароль и/или номер "
"порта. I<Узел> — это имя компьютера-узла; он может быть указан в виде имени "
"DNS или IP-адреса (числа через точку). Таким образом, URI E<lt>http://fred:"
"fredpassword@example.com:8080/E<gt> определяется подключение к веб-серверу "
"example.com по порту 8080 пользователем fred (с помощью пароля "
"fredpassword). Желательно в целях безопасности не указывать пароль в URI. "
"Если в URL указано имя пользователя, но нет пароля, а серверу этот пароль "
"требуется, то программа, обрабатывающая URL, должна запросить его у "
"пользователя."

#. type: Plain text
#: man-pages/man7/uri.7:140
msgid ""
"Here are some of the most common schemes in use on UNIX-like systems that "
"are understood by many tools.  Note that many tools using URIs also have "
"internal schemes or specialized schemes; see those tools' documentation for "
"information on those schemes."
msgstr ""
"Далее приводятся наиболее распространённые схемы, используемые в UNIX-"
"подобных системах. Заметьте, что многие программы, использующие URI, имеют "
"внутренние или специализированные схемы, поэтому советуем прочитать на них "
"документацию."

#. type: Plain text
#: man-pages/man7/uri.7:142
msgid "B<http - Web (HTTP) server>"
msgstr "B<http — веб-сервер (HTTP)>"

#. type: Plain text
#: man-pages/man7/uri.7:144
msgid "http://I<ip_server>/I<path>"
msgstr "http://I<ip_server>/I<путь>"

#. type: Plain text
#: man-pages/man7/uri.7:146
msgid "http://I<ip_server>/I<path>?I<query>"
msgstr "http://I<ip_server>/I<путь>?I<запрос>"

#. type: Plain text
#: man-pages/man7/uri.7:154
msgid ""
"This is a URL accessing a web (HTTP) server.  The default port is 80.  If "
"the path refers to a directory, the web server will choose what to return; "
"usually if there is a file named \"index.html\" or \"index.htm\" its content "
"is returned, otherwise, a list of the files in the current directory (with "
"appropriate links) is generated and returned.  An example is E<lt>http://lwn."
"netE<gt>."
msgstr ""
"Это URL для доступа к веб-серверу (HTTP). По умолчанию используется порт 80. "
"Если путь указывает на каталог, то веб-сервер сам выберет, что необходимо "
"вернуть; обычно, если есть файл «index.html» или «index.htm», то "
"возвращается его содержимое, в ином случае возвращается список файлов в "
"каталоге. Пример: E<lt>http://lwn.netE<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:177
msgid ""
"A query can be given in the archaic \"isindex\" format, consisting of a word "
"or phrase and not including an equal sign (=).  A query can also be in the "
"longer \"GET\" format, which has one or more query entries of the form "
"I<key>=I<value> separated by the ampersand character (&).  Note that I<key> "
"can be repeated more than once, though it's up to the web server and its "
"application programs to determine if there's any meaning to that.  There is "
"an unfortunate interaction with HTML/XML/SGML and the GET query format; when "
"such URIs with more than one key are embedded in SGML/XML documents "
"(including HTML), the ampersand (&) has to be rewritten as &amp;.  Note that "
"not all queries use this format; larger forms may be too long to store as a "
"URI, so they use a different interaction mechanism (called POST) which does "
"not include the data in the URI.  See the Common Gateway Interface "
"specification at E<.UR http://www.w3.org\\:/CGI> E<.UE> for more information."
msgstr ""
"Запрос может быть задан в устаревшем формате «isindex», состоящим из слова "
"или фразы, и не содержащим знака равенства (=). Запрос может быть также в "
"удлинённом формате «GET», в котором может быть несколько запрашиваемых "
"элементов в виде I<ключ>=I<значение> и разделяемых амперсандом (&). Заметим, "
"что I<ключ> может повторяться, но как это обрабатывать будет решать сам веб-"
"сервер и его прикладная программа. Есть проблемы при работе с HTML/XML/SGML "
"с помощью формата запроса GET: когда в такие URI добавляются несколько "
"ключей, используемый в документах SGML/XML (включая HTML) амперсанд (&) "
"перезаписывается в виде &amp;. Заметим, что не все запросы используют этот "
"формат; огромные формы могут быть слишком большими для записи в виде URI, "
"поэтому они используют другой механизм взаимодействия (называемый POST), в "
"котором данные в URI не включаются. Подробности смотрите в спецификации на "
"Common Gateway Interface E<.UR http://www.w3.org\\:/CGI> E<.UE .>"

#. type: Plain text
#: man-pages/man7/uri.7:179
msgid "B<ftp - File Transfer Protocol (FTP)>"
msgstr "B<ftp — протокол передачи файлов (FTP)>"

#. type: Plain text
#: man-pages/man7/uri.7:181
msgid "ftp://I<ip_server>/I<path>"
msgstr "ftp://I<ip_server>/I<путь>"

#. type: Plain text
#: man-pages/man7/uri.7:189
msgid ""
"This is a URL accessing a file through the file transfer protocol (FTP).  "
"The default port (for control) is 21.  If no username is included, the "
"username \"anonymous\" is supplied, and in that case many clients provide as "
"the password the requestor's Internet email address.  An example is "
"E<lt>ftp://ftp.is.co.za/rfc/rfc1808.txtE<gt>."
msgstr ""
"Это URL для получения доступа к файлу с помощью протокола передачи файлов "
"FTP. Номер порта (управляющего) по умолчанию равен 21. Если не указано имя "
"пользователя, то пишется слово «anonymous», и в этом случае многие "
"клиентские программы в качестве пароля отправляют адрес электронной почты "
"пользователя. Пример: E<lt>ftp://ftp.is.co.za/rfc/rfc1808.txtE<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:191
msgid "B<gopher - Gopher server>"
msgstr "B<gopher — сервер Gopher>"

#. type: Plain text
#: man-pages/man7/uri.7:193
msgid "gopher://I<ip_server>/I<gophertype selector>"
msgstr "gopher://I<ip_server>/I<тип_gopher селектор>"

#. type: Plain text
#: man-pages/man7/uri.7:195
msgid "gopher://I<ip_server>/I<gophertype selector>%09I<search>"
msgstr "gopher://I<ip_server>/I<тип_gopher селектор>%09I<поиск>"

#. type: Plain text
#: man-pages/man7/uri.7:197
msgid ""
"gopher://I<ip_server>/I<gophertype selector>%09I<search>%09I<gopher+_string>"
msgstr ""
"gopher://I<ip_server>/I<тип_gopher селектор>%09I<поиск>%09I<gopher+_строка>"

#. type: Plain text
#: man-pages/man7/uri.7:207
msgid ""
"The default gopher port is 70.  I<gophertype> is a single-character field to "
"denote the Gopher type of the resource to which the URL refers.  The entire "
"path may also be empty, in which case the delimiting \"/\" is also optional "
"and the gophertype defaults to \"1\"."
msgstr ""
"По умолчанию служба gopher использует порт 70. I<тип_gopher> — "
"односимвольное поле для указания типа ресурса Gopher, на который ссылается "
"URL. Полный путь может быть пустым; в этом случае знак «/» тоже является "
"необязательным, а значение тип_gopher по умолчанию равно «1»."

#. type: Plain text
#: man-pages/man7/uri.7:214
msgid ""
"I<selector> is the Gopher selector string.  In the Gopher protocol, Gopher "
"selector strings are a sequence of octets which may contain any octets "
"except 09 hexadecimal (US-ASCII HT or tab), 0A hexadecimal (US-ASCII "
"character LF), and 0D (US-ASCII character CR)."
msgstr ""
"I<селектор> — это строка селектора в Gopher. В протоколе Gopher строки "
"селектора могут содержать любые байты, кроме шестнадцатеричных 09 (US-ASCII "
"HT или tab), 0A (US-ASCII-символ LF) и 0D (US-ASCII-символ CR)."

#. type: Plain text
#: man-pages/man7/uri.7:216
msgid "B<mailto - Email address>"
msgstr "B<mailto — адрес электронной почты>"

#. type: Plain text
#: man-pages/man7/uri.7:218
msgid "mailto:I<email-address>"
msgstr "mailto:I<адрес_email>"

#. type: Plain text
#: man-pages/man7/uri.7:226
msgid ""
"This is an email address, usually of the form I<name>@I<hostname>.  See "
"B<mailaddr>(7)  for more information on the correct format of an email "
"address.  Note that any % character must be rewritten as %25.  An example is "
"E<lt>mailto:dwheeler@dwheeler.comE<gt>."
msgstr ""
"Это адрес электронный почты, обычно имеющий форму "
"I<имя_пользователя>@I<имя_узла>. Для получения более подробной информации о "
"формате адресов электронной почты смотрите B<mailaddr>(7). Заметим, что "
"любой символ % должен записываться как %25. Пример: E<lt>mailto:"
"dwheeler@dwheeler.comE<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:228
msgid "B<news - Newsgroup or News message>"
msgstr "B<news — сообщение или группа новостей>"

#. type: Plain text
#: man-pages/man7/uri.7:230
msgid "news:I<newsgroup-name>"
msgstr "news:I<newsgroup-name>"

#. type: Plain text
#: man-pages/man7/uri.7:232
msgid "news:I<message-id>"
msgstr "news:I<message-id>"

#. type: Plain text
#: man-pages/man7/uri.7:240
msgid ""
"A I<newsgroup-name> is a period-delimited hierarchical name, such as \"comp."
"infosystems.www.misc\".  If E<lt>newsgroup-nameE<gt> is \"*\" (as in "
"E<lt>news:*E<gt>), it is used to refer to \"all available news groups\".  An "
"example is E<lt>news:comp.lang.adaE<gt>."
msgstr ""
"В I<newsgroup-name> задаётся иерархическое имя, разделённое точками, "
"например, «comp.infosystems.www.misc». Если значение E<lt>newsgroup-"
"nameE<gt> равно «*» (записывается как E<lt>news:*E<gt>), то такая запись "
"используется для указания «всех доступных групп новостей». Пример: E<lt>news:"
"comp.lang.adaE<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:252
msgid ""
"A I<message-id> corresponds to the Message-ID of E<.UR http://www.ietf.org"
"\\:/rfc\\:/rfc1036.txt> IETF RFC\\ 1036, E<.UE> without the enclosing \"E<lt>"
"\" and \"E<gt>\"; it takes the form I<unique>@I<full_domain_name>.  A "
"message identifier may be distinguished from a news group name by the "
"presence of the \"@\" character."
msgstr ""
"Значение I<message-id> соответствует Message-ID из E<.UR http://www.ietf.org"
"\\:/rfc\\:/rfc1036.txt> IETF RFC\\ 1036, E<.UE> без крайних «E<lt>» и "
"«E<gt>»; оно имеет вид I<уникальная_часть>@I<полное_доменное_имя>. "
"Идентификатор сообщения можно отличить от названия группы новостей по "
"находящемуся в названии символу «@»."

#. type: Plain text
#: man-pages/man7/uri.7:254
msgid "B<telnet - Telnet login>"
msgstr "B<telnet — удалённый вход>"

#. type: Plain text
#: man-pages/man7/uri.7:256
msgid "telnet://I<ip_server>/"
msgstr "telnet://I<ip_server>/"

#. type: Plain text
#: man-pages/man7/uri.7:262
msgid ""
"The Telnet URL scheme is used to designate interactive text services that "
"may be accessed by the Telnet protocol.  The final \"/\" character may be "
"omitted.  The default port is 23.  An example is E<lt>telnet://melvyl.ucop."
"edu/E<gt>."
msgstr ""
"Схема URL для Telnet используется для определения интерактивных текстовых "
"служб, которые доступны по протоколу Telnet. Последний символ «/» может быть "
"опущен. По умолчанию используется порт 23. Пример: E<lt>telnet://melvyl.ucop."
"edu/E<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:264
msgid "B<file - Normal file>"
msgstr "B<file — обычный файл>"

#. type: Plain text
#: man-pages/man7/uri.7:266
msgid "file://I<ip_server>/I<path_segments>"
msgstr "file://I<ip_server>/I<сегменты_пути>"

#. type: Plain text
#: man-pages/man7/uri.7:268
msgid "file:I<path_segments>"
msgstr "file:I<сегменты_пути>"

#. type: Plain text
#: man-pages/man7/uri.7:285
msgid ""
"This represents a file or directory accessible locally.  As a special case, "
"I<ip_server> can be the string \"localhost\" or the empty string; this is "
"interpreted as \"the machine from which the URL is being interpreted\".  If "
"the path is to a directory, the viewer should display the directory's "
"contents with links to each containee; not all viewers currently do this.  "
"KDE supports generated files through the URL E<lt>file:/cgi-binE<gt>.  If "
"the given file isn't found, browser writers may want to try to expand the "
"filename via filename globbing (see B<glob>(7)  and B<glob>(3))."
msgstr ""
"Представляет файл или каталог, доступный локально. Исключение: значение "
"I<ip_server> может быть пустым или равно строке «localhost»; это означает: "
"«машина, с которой обращаются по URL». Если путь указывает на каталог, то "
"программа просмотра представит содержимое каталога с ссылками на каждый "
"элемент, что выполняется не всеми просмотрщиками. KDE поддерживает "
"генерируемые файлы с помощью URL E<lt>file:/cgi-binE<gt>. Если указанный "
"файл не найден, то обозреватель может попробовать расширить имя файла при "
"помощи функций охвата (смотрите B<glob>(7) и B<glob>(3))."

#. type: Plain text
#: man-pages/man7/uri.7:299
msgid ""
"The second format (e.g., E<lt>file:/etc/passwdE<gt>)  is a correct format "
"for referring to a local file.  However, older standards did not permit this "
"format, and some programs don't recognize this as a URI.  A more portable "
"syntax is to use an empty string as the server name, for example, "
"E<lt>file:///etc/passwdE<gt>; this form does the same thing and is easily "
"recognized by pattern matchers and older programs as a URI.  Note that if "
"you really mean to say \"start from the current location,\" don't specify "
"the scheme at all; use a relative address like E<lt>../test.txtE<gt>, which "
"has the side-effect of being scheme-independent.  An example of this scheme "
"is E<lt>file:///etc/passwdE<gt>."
msgstr ""
"Второй формат (например, E<lt>file:/etc/passwdE<gt>) существует для ссылки "
"на локальные файлы. Однако, в старых стандартах этот формат не допускался и "
"некоторые программы не воспринимают его как URI. Более переносим следующий "
"синтаксис: пустая строка вместо имени сервера, например, E<lt>file:///etc/"
"passwdE<gt>; эта форма имеет тот же смысл, легко распознаётся определителями "
"по шаблону и старыми программами как URI. Заметим, что если вы на самом деле "
"хотите «начать с текущего места», то не используйте такую схему вообще; "
"рекомендуется использовать относительный адрес, такой как, E<lt>../test."
"txtE<gt>, который имеет побочный эффект: он не зависит от схемы. Пример "
"такой схемы: E<lt>file:///etc/passwdE<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:301
msgid "B<man - Man page documentation>"
msgstr "B<man — справочная страница man>"

#. type: Plain text
#: man-pages/man7/uri.7:303
msgid "man:I<command-name>"
msgstr "man:I<имя_команды>"

#. type: Plain text
#: man-pages/man7/uri.7:305
msgid "man:I<command-name>(I<section>)"
msgstr "man:I<имя_команды>(I<раздел>)"

#. type: Plain text
#: man-pages/man7/uri.7:314
msgid ""
"This refers to local online manual (man) reference pages.  The command name "
"can optionally be followed by a parenthesis and section number; see "
"B<man>(7)  for more information on the meaning of the section numbers.  This "
"URI scheme is unique to UNIX-like systems (such as Linux)  and is not "
"currently registered by the IETF.  An example is E<lt>man:ls(1)E<gt>."
msgstr ""
"Это ссылка на локальные справочные страницы (man). За именем команды может "
"следовать номер раздела в круглых скобках; для получения более подробной "
"информации о разделах прочтите B<man>(7). Схемы URI в UNIX-подобных системах "
"(например, Linux) различаются и до сих пор не зарегистрированы в IETF. "
"Пример: E<lt>man:ls(1)E<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:316
msgid "B<info - Info page documentation>"
msgstr "B<info — страница документации info>"

#. type: Plain text
#: man-pages/man7/uri.7:318
msgid "info:I<virtual-filename>"
msgstr "info:I<виртуальное_имя_файла>"

#. type: Plain text
#: man-pages/man7/uri.7:320
msgid "info:I<virtual-filename>#I<nodename>"
msgstr "info:I<виртуальное_имя_файла>#I<имя_узла>"

#. type: Plain text
#: man-pages/man7/uri.7:322
msgid "info:(I<virtual-filename>)"
msgstr "info:(I<виртуальное_имя_файла>)"

#. type: Plain text
#: man-pages/man7/uri.7:324
msgid "info:(I<virtual-filename>)I<nodename>"
msgstr "info:(I<виртуальное_имя_файла>)I<имя_узла>"

#. type: Plain text
#: man-pages/man7/uri.7:343
msgid ""
"This scheme refers to online info reference pages (generated from texinfo "
"files), a documentation format used by programs such as the GNU tools.  This "
"URI scheme is unique to UNIX-like systems (such as Linux)  and is not "
"currently registered by the IETF.  As of this writing, GNOME and KDE differ "
"in their URI syntax and do not accept the other's syntax.  The first two "
"formats are the GNOME format; in nodenames all spaces are written as "
"underscores.  The second two formats are the KDE format; spaces in nodenames "
"must be written as spaces, even though this is forbidden by the URI "
"standards.  It's hoped that in the future most tools will understand all of "
"these formats and will always accept underscores for spaces in nodenames.  "
"In both GNOME and KDE, if the form without the nodename is used the nodename "
"is assumed to be \"Top\".  Examples of the GNOME format are E<lt>info:"
"gccE<gt> and E<lt>info:gcc#G++_and_GCCE<gt>.  Examples of the KDE format are "
"E<lt>info:(gcc)E<gt> and E<lt>info:(gcc)G++ and GCCE<gt>."
msgstr ""
"Эта схема ссылается на справочные страницы info (созданные из файлов "
"texinfo); данный формат документации используется в инструментах GNU. Схемы "
"URI в UNIX-подобных системах (например, Linux) различаются и до сих пор не "
"зарегистрированы в IETF. На момент написания синтаксисы URI у GNOME и KDE "
"различались, поэтому они не понимают синтаксис друг друга. Первые два "
"формата — GNOME: в именах узлов все пробелы заменены подчеркиванием. "
"Следующие два формата — KDE: пробелы в названиях узлов остаются пробелами, "
"даже если это запрещено стандартами URI. Это делалось в надежде на то, что в "
"будущем все программы будут принимать все эти форматы и будут считать "
"подчеркивания как пробелы. В GNOME и KDE, если используется форма без "
"названия узла, то названием по умолчанию считается «Top». Пример формата "
"GNOME:  E<lt>info:gccE<gt> и E<lt>info:gcc#G++_and_GCCE<gt>. Пример формата "
"КDE: E<lt>info:(gcc)E<gt> и E<lt>info:(gcc)G++ and GCCE<gt>."

#. type: Plain text
#: man-pages/man7/uri.7:345
msgid "B<whatis - Documentation search>"
msgstr "B<whatis — поиск документации>"

#. type: Plain text
#: man-pages/man7/uri.7:347
msgid "whatis:I<string>"
msgstr "whatis:I<строка>"

#. type: Plain text
#: man-pages/man7/uri.7:355
msgid ""
"This scheme searches the database of short (one-line) descriptions of "
"commands and returns a list of descriptions containing that string.  Only "
"complete word matches are returned.  See B<whatis>(1).  This URI scheme is "
"unique to UNIX-like systems (such as Linux)  and is not currently registered "
"by the IETF."
msgstr ""
"Эта схема применяет для поиска в базе однострочных описаний команд и "
"возвращает список описаний, содержащих искомую строку. Возвращаются только "
"полные совпадения. За более полной информацией обращайтесь к B<whatis>(1). "
"Данная схема URI в UNIX-подобных системах (например, Linux) различается и до "
"сих пор не зарегистрирована IETF."

#. type: Plain text
#: man-pages/man7/uri.7:357
msgid "B<ghelp - GNOME help documentation>"
msgstr "B<ghelp — справочная документация GNOME>"

#. type: Plain text
#: man-pages/man7/uri.7:359
msgid "ghelp:I<name-of-application>"
msgstr "ghelp:I<название_приложения>"

#. type: Plain text
#: man-pages/man7/uri.7:362
msgid ""
"This loads GNOME help for the given application.  Note that not much "
"documentation currently exists in this format."
msgstr ""
"Схема загружает справку GNOME для заданного приложения. Замечание: пока в "
"документации описаны не все приложения в этом формате."

#. type: Plain text
#: man-pages/man7/uri.7:364
msgid "B<ldap - Lightweight Directory Access Protocol>"
msgstr ""
"B<ldap — простой протокол доступа к каталогам (Lightweight Directory Access "
"Protocol)>"

#. type: Plain text
#: man-pages/man7/uri.7:366
msgid "ldap://I<hostport>"
msgstr "ldap://I<узел_порт>"

#. type: Plain text
#: man-pages/man7/uri.7:368
msgid "ldap://I<hostport>/"
msgstr "ldap://I<узел_порт>/"

#. type: Plain text
#: man-pages/man7/uri.7:370
msgid "ldap://I<hostport>/I<dn>"
msgstr "ldap://I<узел_порт>/I<dn>"

#. type: Plain text
#: man-pages/man7/uri.7:372
msgid "ldap://I<hostport>/I<dn>?I<attributes>"
msgstr "ldap://I<узел_порт>/I<dn>?I<атрибуты>"

#. type: Plain text
#: man-pages/man7/uri.7:374
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>"
msgstr "ldap://I<узел_порт>/I<dn>?I<атрибуты>?I<область>"

#. type: Plain text
#: man-pages/man7/uri.7:376
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>"
msgstr "ldap://I<узел_порт>/I<dn>?I<атрибуты>?I<область>?I<фильтр>"

#. type: Plain text
#: man-pages/man7/uri.7:378
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>?I<extensions>"
msgstr ""
"ldap://I<узел_порт>/I<dn>?I<атрибуты>?I<область>?I<фильтр>?I<расширения>"

#. type: Plain text
#: man-pages/man7/uri.7:389
msgid ""
"This scheme supports queries to the Lightweight Directory Access Protocol "
"(LDAP), a protocol for querying a set of servers for hierarchically "
"organized information (such as people and computing resources).  See E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc2255.txt> RFC\\ 2255 E<.UE> for more "
"information on the LDAP URL scheme.  The components of this URL are:"
msgstr ""
"Эта схема поддерживает запросы, направляемые по протоколу LDAP одному или "
"нескольким серверам для получения иерархически упорядоченной информации "
"(например, о людях или ресурсах компьютеров). Подробности о схеме LDAP URL "
"смотрите в E<.UR http://www.ietf.org\\:/rfc\\:/rfc2255.txt> RFC\\ 2255 E<."
"UE .> Компоненты этого URL:"

#. type: IP
#: man-pages/man7/uri.7:389
#, no-wrap
msgid "hostport"
msgstr "узел_порт"

#. type: Plain text
#: man-pages/man7/uri.7:394
msgid ""
"the LDAP server to query, written as a hostname optionally followed by a "
"colon and the port number.  The default LDAP port is TCP port 389.  If "
"empty, the client determines which the LDAP server to use."
msgstr ""
"запрашиваемый сервер LDAP, записывается как имя машины, двоеточие, номер "
"порта (необязательно). По умолчанию в LDAP используется TCP-порт 389. Если "
"компонент не указан, то клиент сам определяет, какой из LDAP-серверов "
"запрашивать."

#. type: IP
#: man-pages/man7/uri.7:394
#, no-wrap
msgid "dn"
msgstr "dn"

#. type: Plain text
#: man-pages/man7/uri.7:401
msgid ""
"the LDAP Distinguished Name, which identifies the base object of the LDAP "
"search (see E<.UR http://www.ietf.org\\:/rfc\\:/rfc2253.txt> RFC\\ 2253 E<."
"UE> section 3)."
msgstr ""
"отличительное имя LDAP, которое определяет базовый объект поиска LDAP "
"(смотрите E<.UR http://www.ietf.org\\:/rfc\\:/rfc2253.txt> RFC\\ 2253 E<.UE> "
"раздел 3)."

#. type: IP
#: man-pages/man7/uri.7:401
#, no-wrap
msgid "attributes"
msgstr "атрибуты"

#. type: Plain text
#: man-pages/man7/uri.7:405
msgid ""
"a comma-separated list of attributes to be returned; see RFC\\ 2251 section "
"4.1.5.  If omitted, all attributes should be returned."
msgstr ""
"возвращаемый список атрибутов, разделённых запятой; смотрите RFC\\ 2251, "
"раздел 4.1.5. Если данный компонент не задан, то возвращаются все атрибуты."

#. type: IP
#: man-pages/man7/uri.7:405
#, no-wrap
msgid "scope"
msgstr "область"

#. type: Plain text
#: man-pages/man7/uri.7:410
msgid ""
"specifies the scope of the search, which can be one of \"base\" (for a base "
"object search), \"one\" (for a one-level search), or \"sub\" (for a subtree "
"search).  If scope is omitted, \"base\" is assumed."
msgstr ""
"область поиска, значениями могут быть: «base» (для поиска по базовому "
"объекту), «one» (для поиска на одном уровне) или «sub» (для поиска по "
"ветвям). Если область поиска не указывается, то по умолчанию используется "
"«base»."

#. type: IP
#: man-pages/man7/uri.7:410
#, no-wrap
msgid "filter"
msgstr "фильтр"

#. type: Plain text
#: man-pages/man7/uri.7:419
msgid ""
"specifies the search filter (subset of entries to return).  If omitted, all "
"entries should be returned.  See E<.UR http://www.ietf.org\\:/rfc\\:/rfc2254."
"txt> RFC\\ 2254 E<.UE> section 4."
msgstr ""
"фильтр поиска (набор возвращаемых записей). Если компонент не задан, то "
"возвращаются все записи. Смотрите E<.UR http://www.ietf.org\\:/rfc\\:/"
"rfc2254.txt> RFC\\ 2254 E<.UE> раздел 4."

#. type: IP
#: man-pages/man7/uri.7:419
#, no-wrap
msgid "extensions"
msgstr "расширения"

#. type: Plain text
#: man-pages/man7/uri.7:425
msgid ""
"a comma-separated list of type=value pairs, where the =value portion may be "
"omitted for options not requiring it.  An extension prefixed with a \\(aq!"
"\\(aq is critical (must be supported to be valid), otherwise it is "
"noncritical (optional)."
msgstr ""
"список пар тип=значение (через запятую), где часть =значение (в случаях, "
"когда это не требуется) может не употребляться. Расширение с приставкой «!» "
"обязательно; если этот значок отсутствует, то необязательно."

#. type: Plain text
#: man-pages/man7/uri.7:429
msgid ""
"LDAP queries are easiest to explain by example.  Here's a query that asks "
"ldap.itd.umich.edu for information about the University of Michigan in the U."
"S.:"
msgstr ""
"Приведём примеры запросов LDAP. Запрос к ldap.itd.umich.edu информации о "
"Мичиганском университете США:"

#. type: Plain text
#: man-pages/man7/uri.7:432
#, no-wrap
msgid "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US\n"
msgstr "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US\n"

#. type: Plain text
#: man-pages/man7/uri.7:435
msgid "To just get its postal address attribute, request:"
msgstr "Для того, чтобы получить атрибут почтового адреса, введите запрос:"

#. type: Plain text
#: man-pages/man7/uri.7:438
#, no-wrap
msgid "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US?postalAddress\n"
msgstr "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US?postalAddress\n"

#. type: Plain text
#: man-pages/man7/uri.7:442
msgid ""
"To ask a host.com at port 6666 for information about the person with common "
"name (cn) \"Babs Jensen\" at University of Michigan, request:"
msgstr ""
"Для того, чтобы запросить у host.com (порт 6666) информацию о человеке по "
"имени (cn) «Babs Jensen» в Мичиганском университете, введите строку:"

#. type: Plain text
#: man-pages/man7/uri.7:445
#, no-wrap
msgid "ldap://host.com:6666/o=University%20of%20Michigan,c=US??sub?(cn=Babs%20Jensen)\n"
msgstr "ldap://host.com:6666/o=University%20of%20Michigan,c=US??sub?(cn=Babs%20Jensen)\n"

#. type: Plain text
#: man-pages/man7/uri.7:448
msgid "B<wais - Wide Area Information Servers>"
msgstr ""
"B<wais — глобальная сеть информационных серверов (Wide Area Information "
"Servers)>"

#. type: Plain text
#: man-pages/man7/uri.7:450
msgid "wais://I<hostport>/I<database>"
msgstr "wais://I<узел_порт>/I<база_данных>"

#. type: Plain text
#: man-pages/man7/uri.7:452
msgid "wais://I<hostport>/I<database>?I<search>"
msgstr "wais://I<узел_порт>/I<база_данных>?I<поиск>"

#. type: Plain text
#: man-pages/man7/uri.7:454
msgid "wais://I<hostport>/I<database>/I<wtype>/I<wpath>"
msgstr "wais://I<узел_порт>/I<база_данных>/I<wtype>/I<wpath>"

#. type: Plain text
#: man-pages/man7/uri.7:463
msgid ""
"This scheme designates a WAIS database, search, or document (see E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc1625.txt> IETF RFC\\ 1625 E<.UE> for more "
"information on WAIS).  Hostport is the hostname, optionally followed by a "
"colon and port number (the default port number is 210)."
msgstr ""
"Эта схема предназначена для базы данных WAIS, поиска или документа (более "
"подробную информацию о WAIS смотрите E<.UR http://www.ietf.org\\:/rfc\\:/"
"rfc1625.txt> IETF RFC\\ 1625 E<.UE>). Узел_порт — это название машины, в "
"некоторых случаях сопровождающееся номером порта (после двоеточия). "
"Используемый порт по умолчанию — 210."

#. type: Plain text
#: man-pages/man7/uri.7:473
msgid ""
"The first form designates a WAIS database for searching.  The second form "
"designates a particular search of the WAIS database I<database>.  The third "
"form designates a particular document within a WAIS database to be "
"retrieved.  I<wtype> is the WAIS designation of the type of the object and "
"I<wpath> is the WAIS document-id."
msgstr ""
"Первая форма определяет базу данных WAIS для поиска. Вторая форма — это "
"определённой поиск в I<базе данных> WAIS. Третья форма предназначена для "
"поиска конкретного документа в базе данных WAIS. Значение I<wtype> служит "
"для обозначения объекта в WAIS, а I<wpath> — это document-id WAIS."

#. type: Plain text
#: man-pages/man7/uri.7:475
msgid "B<other schemes>"
msgstr "B<другие схемы>"

#. type: Plain text
#: man-pages/man7/uri.7:489
msgid ""
"There are many other URI schemes.  Most tools that accept URIs support a set "
"of internal URIs (e.g., Mozilla has the about: scheme for internal "
"information, and the GNOME help browser has the toc: scheme for various "
"starting locations).  There are many schemes that have been defined but are "
"not as widely used at the current time (e.g., prospero).  The nntp: scheme "
"is deprecated in favor of the news: scheme.  URNs are to be supported by the "
"urn: scheme, with a hierarchical name space (e.g., urn:ietf:... would "
"identify IETF documents); at this time URNs are not widely implemented.  Not "
"all tools support all schemes."
msgstr ""
"Существует множество других схем URI. Большинство программ, использующих "
"URI, поддерживают свои собственные схемы URI (например, Mozilla имеет схему "
"about: для работы с внутренней информацией; браузер справки GNOME имеет "
"схему toc: для работы с разными разделами). Есть схемы, которые в данный "
"момент не распространены (например, prospero). Схема news: предпочтительнее "
"схемы nntp:. URN поддерживаются схемой urn: (например, urn:ietf:… означает "
"документы IETF); в настоящее время URN широко не используются. Не все "
"приложения поддерживают все схемы."

#. type: SS
#: man-pages/man7/uri.7:489
#, no-wrap
msgid "Character encoding"
msgstr "Кодирование символов"

#. type: Plain text
#: man-pages/man7/uri.7:493
msgid ""
"URIs use a limited number of characters so that they can be typed in and "
"used in a variety of situations."
msgstr ""
"В URI используется ограниченный набор символов с учётом того, чтобы их можно "
"было набирать в различных ситуациях."

#. type: Plain text
#: man-pages/man7/uri.7:497
msgid ""
"The following characters are reserved, that is, they may appear in a URI but "
"their use is limited to their reserved purpose (conflicting data must be "
"escaped before forming the URI):"
msgstr ""
"Следующие символы зарегистрированы, то есть они могут появляться в URI, но "
"только в определённых для них целях (эти символы в данных должны быть "
"экранированы перед созданием URI):"

#. type: Plain text
#: man-pages/man7/uri.7:499
#, no-wrap
msgid "   ; / ? : @ & = + $ ,\n"
msgstr "   ; / ? : @ & = + $ ,\n"

#. type: Plain text
#: man-pages/man7/uri.7:505
msgid ""
"Unreserved characters may be included in a URI.  Unreserved characters "
"include uppercase and lowercase English letters, decimal digits, and the "
"following limited set of punctuation marks and symbols:"
msgstr ""
"Незарезервированные символы могут быть использованы в URI. "
"Незарезервированные символы — это английские буквы верхнего и нижнего "
"регистров, цифры и следующий набор знаков пунктуации и символов:"

#. type: Plain text
#: man-pages/man7/uri.7:507
#, no-wrap
msgid " - _ . ! ~ * ' ( )\n"
msgstr " - _ . ! ~ * ' ( )\n"

#. type: Plain text
#: man-pages/man7/uri.7:522
msgid ""
"All other characters must be escaped.  An escaped octet is encoded as a "
"character triplet, consisting of the percent character \"%\" followed by the "
"two hexadecimal digits representing the octet code (you can use uppercase or "
"lowercase letters for the hexadecimal digits).  For example, a blank space "
"must be escaped as \"%20\", a tab character as \"%09\", and the \"&\" as "
"\"%26\".  Because the percent \"%\" character always has the reserved "
"purpose of being the escape indicator, it must be escaped as \"%25\".  It is "
"common practice to escape space characters as the plus symbol (+)  in query "
"text; this practice isn't uniformly defined in the relevant RFCs (which "
"recommend %20 instead) but any tool accepting URIs with query text should be "
"prepared for them.  A URI is always shown in its \"escaped\" form."
msgstr ""
"Все остальные символы должны экранироваться. Экранированный октет кодируется "
"тремя символами: символом процента «%» и двумя шестнадцатеричными цифрами, "
"представляющими код октета (для ввода шестнадцатеричных цифр можно "
"использовать буквы верхнего и нижнего регистров). Например, пробел "
"обозначается как «%20», символ табуляции (tab) обозначается как «%09», а «&» "
"как «%26». Так как символ «%» зарезервирован, он всегда обозначаться только "
"как «%25». Обычно в запросах пробельные символы заменяют знаком плюс (+); "
"этот способ не определён в RFC (где рекомендуется использовать %20), но "
"любое приложение, принимающее запросы URI, должно его воспринимать. URI "
"всегда показываются в своём «экранированном» виде."

#. type: Plain text
#: man-pages/man7/uri.7:528
msgid ""
"Unreserved characters can be escaped without changing the semantics of the "
"URI, but this should not be done unless the URI is being used in a context "
"that does not allow the unescaped character to appear.  For example, \"%7e\" "
"is sometimes used instead of \"~\" in an HTTP URL path, but the two are "
"equivalent for an HTTP URL."
msgstr ""
"Незарезервированные символы можно экранировать без изменения семантики URI, "
"но это нельзя делать в случаях, когда URI не используется в контексте, не "
"допускающем появления неэкранированных символов. Например, «%7e» иногда "
"используется вместо «~» в пути HTTP URL, но обе формы воспринимаются в HTTP "
"URL одинаково."

#. type: Plain text
#: man-pages/man7/uri.7:532
msgid ""
"For URIs which must handle characters outside the US ASCII character set, "
"the HTML 4.01 specification (section B.2) and IETF RFC\\ 2718 (section "
"2.2.5) recommend the following approach:"
msgstr ""
"Для URI, обрабатывающих символы, не входящих в набор US-ASCII, в главе В.2 "
"документации по HTML 4.01 и в главе 2.2.5 IETF RFC\\  2718 приводится "
"рекомендуемое рациональное решение:"

#. type: Plain text
#: man-pages/man7/uri.7:536
msgid ""
"translate the character sequences into UTF-8 (IETF RFC\\ 2279)\\(emsee "
"B<utf-8>(7)\\(emand then"
msgstr ""
"Переводить последовательность символов в кодировку UTF-8 (IETF RFC\\ 2279) — "
"смотрите B<utf-8>(7) — затем"

#. type: Plain text
#: man-pages/man7/uri.7:539
msgid ""
"use the URI escaping mechanism, that is, use the %HH encoding for unsafe "
"octets."
msgstr ""
"использовать механизм экранирования URI, то есть, использовать конвертацию "
"%HH для небезопасных октетов."

#. type: SS
#: man-pages/man7/uri.7:539
#, no-wrap
msgid "Writing a URI"
msgstr "Запись URI"

#. type: Plain text
#: man-pages/man7/uri.7:562
msgid ""
"When written, URIs should be placed inside double quotes (e.g., \"http://www."
"kernel.org\"), enclosed in angle brackets (e.g., E<lt>http://lwn.netE<gt>), "
"or placed on a line by themselves.  A warning for those who use double-"
"quotes: B<never> move extraneous punctuation (such as the period ending a "
"sentence or the comma in a list)  inside a URI, since this will change the "
"value of the URI.  Instead, use angle brackets instead, or switch to a "
"quoting system that never includes extraneous characters inside quotation "
"marks.  This latter system, called the 'new' or 'logical' quoting system by "
"\"Hart's Rules\" and the \"Oxford Dictionary for Writers and Editors\", is "
"preferred practice in Great Britain and hackers worldwide (see the Jargon "
"File's section on Hacker Writing Style, E<.UR http://www.fwi.uva.nl\\:/~mes"
"\\:/jargon\\:/h\\:/HackerWritingStyle.html> E<.UE ,> for more information).  "
"Older documents suggested inserting the prefix \"URL:\" just before the URI, "
"but this form has never caught on."
msgstr ""
"При записи URI должны помещаться в двойные кавычки (например, \"http://www."
"kernel.org\"), закрываться в угловые скобки (например, E<lt>http://lwn."
"netE<gt>) или помещаться на отдельной строке. Предупреждение для "
"использующих двойные кавычки: B<никогда> не помещайте лишнюю пунктуацию "
"(например, точку в конце фразы или запятую в списке) внутрь URI, так как они "
"изменят значение URI. Вместо этого используйте угловые скобки, или перейдите "
"к системе цитирования, в которой никогда не встречаются дополнительные "
"символы внутри цитат. В качестве такой системы можно предложить «новую» или "
"«логическую» систему цитирования от «Hart's Rules» и «Oxford Dictionary for "
"Writers and Editors», используемую в Великобритании и хакерами по всему миру "
"(смотрите раздел Jargon File в Hacker Writing Style, E<.UR http://www.fwi."
"uva.nl\\:/~mes\\:/jargon\\:/h\\:/HackerWritingStyle.html> E<.UE>). Старые "
"документы предполагают вставку префикса «URL:» сразу перед URI, но такая "
"форма никогда не была популярной."

#. type: Plain text
#: man-pages/man7/uri.7:584
msgid ""
"The URI syntax was designed to be unambiguous.  However, as URIs have become "
"commonplace, traditional media (television, radio, newspapers, billboards, "
"etc.) have increasingly used abbreviated URI references consisting of only "
"the authority and path portions of the identified resource (e.g., E<lt>www."
"w3.org/AddressingE<gt>).  Such references are primarily intended for human "
"interpretation rather than machine, with the assumption that context-based "
"heuristics are sufficient to complete the URI (e.g., hostnames beginning "
"with \"www\" are likely to have a URI prefix of \"http://\" and hostnames "
"beginning with \"ftp\" likely to have a prefix of \"ftp://\").  Many client "
"implementations heuristically resolve these references.  Such heuristics may "
"change over time, particularly when new schemes are introduced.  Since an "
"abbreviated URI has the same syntax as a relative URL path, abbreviated URI "
"references cannot be used where relative URIs are permitted, and can be used "
"only when there is no defined base (such as in dialog boxes).  Don't use "
"abbreviated URIs as hypertext links inside a document; use the standard "
"format as described here."
msgstr ""
"Синтаксис URI разрабатывался как однозначный. Однако когда URI стали "
"использовать повсеместно, традиционные средства массовой информации "
"(телевидение, радио, газеты и т.д.) стали применять сокращённые ссылки URI, "
"состоящие из названия домена и пути к конкретному ресурсу (например, "
"E<lt>www.w3.org/AddressingE<gt>). Такие ссылки больше предназначены для "
"человеческого восприятия, а не для считывания машиной в предположении, что "
"для полного понимания URI будет достаточно контекста применения (например, "
"имена узлов, начинающиеся с «www», скорее всего, имеют в URI префикс "
"«http://», а имена узлов, начинающиеся с «ftp», скорее всего, имеют префикс "
"«ftp://»). Много реализаций клиентов «додумывают» такие ссылки. Такие "
"предположения могут иногда меняться, в частности при появлении новых схем. "
"Так как сокращённые URI имеют тот же синтаксис, что и путь относительных "
"URL, сокращённые URI не могут быть использованы в тех случаях, где "
"используются относительные URI; они могут использоваться только когда нет "
"определённой основы (например, в диалоговых окнах). Не используйте "
"сокращённые URI как гипертекстовые ссылки в документах, используйте "
"стандартный формат, как описано в данном документе."

#. type: Plain text
#: man-pages/man7/uri.7:592
msgid ""
"E<.UR http://www.ietf.org\\:/rfc\\:/rfc2396.txt> (IETF RFC\\ 2396)  E<.UE ,> "
"E<.UR http://www.w3.org\\:/TR\\:/REC-html40> (HTML 4.0)  E<.UE .>"
msgstr ""
"E<.UR http://www.ietf.org\\:/rfc\\:/rfc2396.txt> (IETF RFC\\ 2396)  E<.UE ,> "
"E<.UR http://www.w3.org\\:/TR\\:/REC-html40> (HTML 4.0)  E<.UE .>"

#. type: Plain text
#: man-pages/man7/uri.7:598
msgid ""
"Any tool accepting URIs (e.g., a web browser) on a Linux system should be "
"able to handle (directly or indirectly) all of the schemes described here, "
"including the man: and info: schemes.  Handling them by invoking some other "
"program is fine and in fact encouraged."
msgstr ""
"Любое приложение, использующее URI (например, веб-браузер) в Linux, должно "
"поддерживать (непосредственно или косвенно) все схемы, описанные здесь, "
"включая схемы man: и info:. Для обработки предлагается вызывать стороннюю "
"программу."

#. type: Plain text
#: man-pages/man7/uri.7:600
msgid "Technically the fragment isn't part of the URI."
msgstr "Технически, фрагмент не является частью URI."

#. type: Plain text
#: man-pages/man7/uri.7:609
msgid ""
"For information on how to embed URIs (including URLs) in a data format, see "
"documentation on that format.  HTML uses the format E<lt>A HREF=\"I<uri>"
"\"E<gt> I<text> E<lt>/AE<gt>.  Texinfo files use the format @uref{I<uri>}.  "
"Man and mdoc have the recently added UR macro, or just include the URI in "
"the text (viewers should be able to detect :// as part of a URI)."
msgstr ""
"Для получения информации о том, как включить URI (включая URL) в формат "
"данных, прочтите соответствующую документацию. HTML использует формат E<lt>A "
"HREF=\"I<uri>\"E<gt> I<text> E<lt>/AE<gt>. Файлы texinfo используют формат "
"@uref{I<uri>}. Man и mdoc имеют недавно добавленный макрос UR или просто "
"включают URI в текст (программы просмотра должны распознавать, что :// это "
"часть URI)."

#. type: Plain text
#: man-pages/man7/uri.7:630
msgid ""
"The GNOME and KDE desktop environments currently vary in the URIs they "
"accept, in particular in their respective help browsers.  To list man pages, "
"GNOME uses E<lt>toc:manE<gt> while KDE uses E<lt>man:(index)E<gt>, and to "
"list info pages, GNOME uses E<lt>toc:infoE<gt> while KDE uses E<lt>info:"
"(dir)E<gt> (the author of this man page prefers the KDE approach here, "
"though a more regular format would be even better).  In general, KDE uses "
"E<lt>file:/cgi-bin/E<gt> as a prefix to a set of generated files.  KDE "
"prefers documentation in HTML, accessed via the E<lt>file:/cgi-bin/"
"helpindexE<gt>.  GNOME prefers the ghelp scheme to store and find "
"documentation.  Neither browser handles file: references to directories at "
"the time of this writing, making it difficult to refer to an entire "
"directory with a browsable URI.  As noted above, these environments differ "
"in how they handle the info: scheme, probably the most important variation.  "
"It is expected that GNOME and KDE will converge to common URI formats, and a "
"future version of this man page will describe the converged result.  Efforts "
"to aid this convergence are encouraged."
msgstr ""
"В настоящее время окружения рабочего стола GNOME и KDE используют различные "
"URI, в частности в своих справочных системах. Для справочных страниц в GNOME "
"используется E<lt>toc:manE<gt>, а в KDE — E<lt>man:(index)E<gt>; для страниц "
"info в GNOME используется E<lt>toc:infoE<gt>, а в KDE — E<lt>info:(dir)E<gt> "
"(автору данной справочной страницы нравится выбор KDE, так как он больше "
"похож на обычно используемый формат). В общем случае, в KDE используется "
"E<lt>file:/cgi-bin/E<gt> в качестве приставки к набору генерируемых файлов. "
"В KDE предпочитают использовать документацию в HTML, доступную как "
"E<lt>file:/cgi-bin/helpindexE<gt>. В GNOME для хранения и поиска "
"документации предпочитают использовать схему ghelp. Ни один обозреватель в "
"момент написания этого документа не поддерживал схему ссылок на каталоги "
"file:, что затрудняет ссылку на весь каталог с помощью просматриваемого URI. "
"Как говорилось ранее, эти окружения различаются по способу поддержки схемы "
"info:. В перспективе GNOME и KDE должны прийти к единому формату URI, и "
"будущая версия системы войдёт в эту справочную страницу. Помогите достичь "
"этого единства."

#. type: Plain text
#: man-pages/man7/uri.7:640
msgid ""
"A URI does not in itself pose a security threat.  There is no general "
"guarantee that a URL, which at one time located a given resource, will "
"continue to do so.  Nor is there any guarantee that a URL will not locate a "
"different resource at some later point in time; such a guarantee can be "
"obtained only from the person(s) controlling that namespace and the resource "
"in question."
msgstr ""
"Сам по себе URI не создаёт никакой угрозы безопасности. Но нет никакой "
"гарантии, что URL, который однажды указывал на конкретный ресурс, в "
"дальнейшем будет делать то же самое. Так же нет никаких гарантий, что этот "
"же URL позднее не будет ссылаться на совершенно другой ресурс. Такие "
"гарантии можно получить лишь от лица, ответственного за эти ресурсы и их "
"пространство имён."

#. type: Plain text
#: man-pages/man7/uri.7:655
msgid ""
"It is sometimes possible to construct a URL such that an attempt to perform "
"a seemingly harmless operation, such as the retrieval of an entity "
"associated with the resource, will in fact cause a possibly damaging remote "
"operation to occur.  The unsafe URL is typically constructed by specifying a "
"port number other than that reserved for the network protocol in question.  "
"The client unwittingly contacts a site that is in fact running a different "
"protocol.  The content of the URL contains instructions that, when "
"interpreted according to this other protocol, cause an unexpected "
"operation.  An example has been the use of a gopher URL to cause an "
"unintended or impersonating message to be sent via a SMTP server."
msgstr ""
"Существует возможность составить URL таким образом, что попытка произвести "
"обыкновенную, «безобидную» операцию, такую, как получение информации с "
"определённого ресурса, возможно, вызовет сбой в её выполнении. Небезопасный "
"URL, обычно, создаётся следующим образом: в запросе указывается номер порта, "
"не совпадающий с номером зарезервированного порта сетевого протокола. Клиент "
"неосознанно заходит на сайт, но используя другой протокол. В URL содержатся "
"команды, которые при их считывании (в соответствии с другим протоколом) "
"производят непредвиденную операцию. Примером может послужить использование "
"gopher URL для создания ненужного и безадресного сообщения, которое "
"отправится через сервер SMTP."

#. type: Plain text
#: man-pages/man7/uri.7:659
msgid ""
"Caution should be used when using any URL that specifies a port number other "
"than the default for the protocol, especially when it is a number within the "
"reserved space."
msgstr ""
"Нужно быть осторожным с URL, в которых указан номер порта, отличный от "
"стандартного порта для протокола, в особенности, если этот номер находится в "
"зарезервированной области."

#. type: Plain text
#: man-pages/man7/uri.7:667
msgid ""
"Care should be taken when a URI contains escaped delimiters for a given "
"protocol (for example, CR and LF characters for telnet protocols) that these "
"are not unescaped before transmission.  This might violate the protocol, but "
"avoids the potential for such characters to be used to simulate an extra "
"operation or parameter in that protocol, which might lead to an unexpected "
"and possibly harmful remote operation to be performed."
msgstr ""
"Надо быть очень внимательным и в тех случаях, когда URI содержит "
"экранированные разделители протокола (например, символы CR и LF для "
"протокола telnet), с которых экранирование не будет снято перед передачей. "
"Это могло бы нарушить протокол, но само отключение возможностей таких "
"символов может вызвать возникновение дополнительных действий этого "
"протокола, которые могут привести к выполнению непредвиденных и не совсем "
"безобидных операций."

#. type: Plain text
#: man-pages/man7/uri.7:673
msgid ""
"It is clearly unwise to use a URI that contains a password which is intended "
"to be secret.  In particular, the use of a password within the \"userinfo\" "
"component of a URI is strongly recommended against except in those rare "
"cases where the \"password\" parameter is intended to be public."
msgstr ""
"Также довольно не предусмотрительно использовать пароль в URI. В частности, "
"рекомендуется использовать пароль внутри URI-компонента «userinfo», за "
"исключением редких случаев, когда параметр «password» может быть показан "
"всем."

#. type: Plain text
#: man-pages/man7/uri.7:695
msgid ""
"Documentation may be placed in a variety of locations, so there currently "
"isn't a good URI scheme for general online documentation in arbitrary "
"formats.  References of the form E<lt>file:///usr/doc/ZZZE<gt> don't work "
"because different distributions and local installation requirements may "
"place the files in different directories (it may be in /usr/doc, or /usr/"
"local/doc, or /usr/share, or somewhere else).  Also, the directory ZZZ "
"usually changes when a version changes (though filename globbing could "
"partially overcome this).  Finally, using the file: scheme doesn't easily "
"support people who dynamically load documentation from the Internet (instead "
"of loading the files onto a local filesystem).  A future URI scheme may be "
"added (e.g., \"userdoc:\") to permit programs to include cross-references to "
"more detailed documentation without having to know the exact location of "
"that documentation.  Alternatively, a future version of the filesystem "
"specification may specify file locations sufficiently so that the file: "
"scheme will be able to locate documentation."
msgstr ""
"Документация может быть расположена в различных местах, поэтому не "
"существует схемы URI для просмотра документации в различных форматах. Ссылки "
"типа E<lt>file:///usr/doc/ZZZE<gt> не работают по причине различных "
"требований дистрибутивов и установочных требований, согласно которым "
"документация может быть размещена в разных каталогах (она может быть в /usr/"
"doc, /usr/local/doc, /usr/share или где-нибудь ещё). К тому же, содержимое "
"каталога ZZZ, обычно, изменяется с каждой версией (хотя, частично это можно "
"решить использованием шаблонов имён файлов). А людям, которые получают "
"документацию по Интернет (вместо того, чтобы хранить её в своей системе), "
"схема file: вообще ничем не будет полезна. В будущем может быть добавлена "
"новая схема URI (например, «userdoc:»), которая позволит программам включать "
"перекрёстные ссылки на дополнительную документацию и, при этом, не учитывать "
"точное расположение такой документации. Или же в новой версии файловой "
"системы можно будет указывать расположения файлов так, что можно будет "
"находить документацию прямо по схеме file:."

#. type: Plain text
#: man-pages/man7/uri.7:698
msgid ""
"Many programs and file formats don't include a way to incorporate or "
"implement links using URIs."
msgstr ""
"Многие программы и форматы файлов не имеют возможности включать ссылки с "
"помощью URI."

#.  .SH AUTHOR
#.  David A. Wheeler (dwheeler@dwheeler.com) wrote this man page.
#. type: Plain text
#: man-pages/man7/uri.7:706
msgid ""
"Many programs can't handle all of these different URI formats; there should "
"be a standard mechanism to load an arbitrary URI that automatically detects "
"the users' environment (e.g., text or graphics, desktop environment, local "
"user preferences, and currently executing tools) and invokes the right tool "
"for any URI."
msgstr ""
"Так как не все программы поддерживают различные форматы URI, то должен "
"существовать стандартный механизм загрузки произвольного URI, который "
"автоматически определит пользовательскую среду (например, текстовую или "
"графическую, рабочий стол, локальные предпочтения пользователя и "
"используемые инструменты) и запустит правильное приложение для любого URI."

#. type: Plain text
#: man-pages/man7/uri.7:711
msgid "B<lynx>(1), B<man2html>(1), B<mailaddr>(7), B<utf-8>(7)"
msgstr "B<lynx>(1), B<man2html>(1), B<mailaddr>(7), B<utf-8>(7)"

#. type: Plain text
#: man-pages/man7/uri.7:714
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc2255.txt> IETF RFC\\ 2255 E<.UE>"
msgstr ""
"E<.UR http://www.ietf.org\\:/rfc\\:/rfc2255.txt> IETF RFC\\ 2255 E<.UE>"

#. type: TH
#: man-pages/man7/udp.7:12
#, no-wrap
msgid "UDP"
msgstr "UDP"

#. type: Plain text
#: man-pages/man7/udp.7:15
msgid "udp - User Datagram Protocol for IPv4"
msgstr "udp - протокол UDP (User Datagram Protocol) для IPv4"

#. type: Plain text
#: man-pages/man7/udp.7:19
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr "B<#include E<lt>netinet/in.hE<gt>>"

#. type: Plain text
#: man-pages/man7/udp.7:21
msgid "B<#include E<lt>netinet/udp.hE<gt>>"
msgstr "B<#include E<lt>netinet/udp.hE<gt>>"

#. type: Plain text
#: man-pages/man7/udp.7:23
msgid "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"

#. type: Plain text
#: man-pages/man7/udp.7:29
msgid ""
"This is an implementation of the User Datagram Protocol described in RFC\\ "
"768.  It implements a connectionless, unreliable datagram packet service.  "
"Packets may be reordered or duplicated before they arrive.  UDP generates "
"and checks checksums to catch transmission errors."
msgstr ""
"Это реализация протокола пользовательских датаграмм (User Datagram Protocol, "
"UDP), который описан в RFC\\ 768. Он обеспечивает ненадежную передачу "
"датаграмм без установления соединения. При пересылке пакеты могут "
"дублироваться, а их порядок может быть нарушен. UDP генерирует и проверяет "
"контрольные суммы, чтобы отловить ошибки передачи."

#. type: Plain text
#: man-pages/man7/udp.7:58
msgid ""
"When a UDP socket is created, its local and remote addresses are "
"unspecified.  Datagrams can be sent immediately using B<sendto>(2)  or "
"B<sendmsg>(2)  with a valid destination address as an argument.  When "
"B<connect>(2)  is called on the socket, the default destination address is "
"set and datagrams can now be sent using B<send>(2)  or B<write>(2)  without "
"specifying a destination address.  It is still possible to send to other "
"destinations by passing an address to B<sendto>(2)  or B<sendmsg>(2).  In "
"order to receive packets, the socket can be bound to a local address first "
"by using B<bind>(2).  Otherwise, the socket layer will automatically assign "
"a free local port out of the range defined by I</proc/sys/net/ipv4/"
"ip_local_port_range> and bind the socket to B<INADDR_ANY>."
msgstr ""
"При создании UDP-сокета его локальный и удалённый адрес не указываются. "
"Датаграммы могут быть посланы немедленно с помощью B<sendto>(2) или "
"B<sendmsg>(2) с правильным адресом назначения в качестве аргумента. Когда "
"для сокета вызывается B<connect>(2), то устанавливается адрес назначения по "
"умолчанию и с этого момента датаграммы могут отсылаться с помощью B<send>(2) "
"или B<write>(2) без указания адреса назначения. При этом всё ещё сохраняется "
"возможность послать пакет другому адресату, передавая его адрес через вызовы "
"B<sendto>(2) или B<sendmsg>(2). Для получения пакетов сокет сначала можно "
"привязать к локальному адресу с помощью B<bind>(2). В противном случае "
"сокетный уровень автоматически присвоит свободный локальный порт из "
"диапазона, заданного в I</proc/sys/net/ipv4/ip_local_port_range>, и привяжет "
"сокет к B<INADDR_ANY>."

#. type: Plain text
#: man-pages/man7/udp.7:66
msgid ""
"All receive operations return only one packet.  When the packet is smaller "
"than the passed buffer, only that much data is returned; when it is bigger, "
"the packet is truncated and the B<MSG_TRUNC> flag is set.  B<MSG_WAITALL> is "
"not supported."
msgstr ""
"Все операции приёма возвращают только один пакет. Если пакет меньше, чем "
"размер буфера приема, то он возвращается целиком; если пакет больше, то он "
"обрезается и устанавливается флаг B<MSG_TRUNC>. Флаг B<MSG_WAITALL> не "
"поддерживается."

#. type: Plain text
#: man-pages/man7/udp.7:75
msgid ""
"IP options may be sent or received using the socket options described in "
"B<ip>(7).  They are processed by the kernel only when the appropriate I</"
"proc> parameter is enabled (but still passed to the user even when it is "
"turned off).  See B<ip>(7)."
msgstr ""
"Параметры IP могут быть посланы или получены при помощи параметров сокета, "
"описанных в B<ip>(7). Они обрабатываются ядром, только если включён "
"соответствующий параметр в I</proc> (но даже если он отключен, параметры всё "
"равно передаются пользователю). Смотрите B<ip>(7)."

#. type: Plain text
#: man-pages/man7/udp.7:80
msgid ""
"When the B<MSG_DONTROUTE> flag is set on sending, the destination address "
"must refer to a local interface address and the packet is sent only to that "
"interface."
msgstr ""
"Если при отсылке установлен флаг B<MSG_DONTROUTE>, то адрес назначения "
"должен указывать на адрес локального интерфейса, и пакеты посылаются только "
"на этот интерфейс."

#. type: Plain text
#: man-pages/man7/udp.7:98
msgid ""
"By default, Linux UDP does path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a UDP packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file; see B<ip>(7)  for "
"details.  When turned off, UDP will fragment outgoing UDP packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""
"По умолчанию, Linux UDP выполняет обнаружение MTU (Maximum Transmission "
"Unit) пути. Это означает, что ядро будет следить за MTU до IP-адреса "
"назначения и возвращать B<EMSGSIZE>, если запись пакета UDP превысит это "
"значение. Когда это происходит, приложение должно уменьшить размер пакета. "
"Также обнаружение MTU пути можно выключить с помощью параметра сокета "
"B<IP_MTU_DISCOVER> или в файле I</proc/sys/net/ipv4/ip_no_pmtu_disc>; "
"подробней смотрите в B<ip>(7). При отключении обнаружения UDP фрагментирует "
"исходящий пакет, если его общий размер превышает MTU интерфейса. Однако по "
"соображениям производительности и надёжности отключение не рекомендуется."

#. type: Plain text
#: man-pages/man7/udp.7:103
msgid "UDP uses the IPv4 I<sockaddr_in> address format described in B<ip>(7)."
msgstr ""
"В UDP используется формат адреса IPv4 I<sockaddr_in>, который описан в "
"B<ip>(7)."

#. type: SS
#: man-pages/man7/udp.7:103
#, no-wrap
msgid "Error handling"
msgstr "Обработка ошибок"

#. type: Plain text
#: man-pages/man7/udp.7:114
msgid ""
"All fatal errors will be passed to the user as an error return even when the "
"socket is not connected.  This includes asynchronous errors received from "
"the network.  You may get an error for an earlier packet that was sent on "
"the same socket.  This behavior differs from many other BSD socket "
"implementations which don't pass any errors unless the socket is connected.  "
"Linux's behavior is mandated by B<RFC\\ 1122>."
msgstr ""
"Все критические ошибки передаются пользователю в виде кода ошибки, который "
"возвращается, даже если сокет не был соединен. Это относится также и к "
"асинхронным ошибкам, при работе с сетью. Вы можете получить ошибку, "
"относящуюся к предыдущим пакетам, посланным на том же сокете. Такое "
"поведение отличается от поведения многих других реализаций BSD-сокетов, "
"которые никогда не передают коды ошибок, если на сокете не установлено "
"соединение. Поведение Linux в этом случае соответствует B<RFC\\ 1122>."

#. type: Plain text
#: man-pages/man7/udp.7:128
msgid ""
"For compatibility with legacy code, in Linux 2.0 and 2.2 it was possible to "
"set the B<SO_BSDCOMPAT> B<SOL_SOCKET> option to receive remote errors only "
"when the socket has been connected (except for B<EPROTO> and B<EMSGSIZE>).  "
"Locally generated errors are always passed.  Support for this socket option "
"was removed in later kernels; see B<socket>(7)  for further information."
msgstr ""
"Для совместимости со старым кодом в Linux 2.0 и 2.2 можно установить "
"параметр B<SOL_SOCKET> равным B<SO_BSDCOMPAT>, чтобы получать ошибки при "
"работе с сетью, только если сокет был соединён (кроме ошибок B<EPROTO> и "
"B<EMSGSIZE>). Ошибки, возникшие локально, передаются всегда. Поддержка "
"данного параметра сокета была удалена в более новых ядрах; подробней "
"смотрите в B<socket>(7)."

#. type: Plain text
#: man-pages/man7/udp.7:137
msgid ""
"When the B<IP_RECVERR> option is enabled, all errors are stored in the "
"socket error queue, and can be received by B<recvmsg>(2)  with the "
"B<MSG_ERRQUEUE> flag set."
msgstr ""
"Если включён параметр B<IP_RECVERR>, то все ошибки хранятся в очереди ошибок "
"сокета и могут быть получены с помощью вызова B<recvmsg>(2) с установленным "
"флагом B<MSG_ERRQUEUE>."

#. type: SS
#: man-pages/man7/udp.7:137
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейс /proc"

#. type: Plain text
#: man-pages/man7/udp.7:140
msgid ""
"System-wide UDP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>."
msgstr ""
"Системные настройки параметров UDP доступны через файлы в каталоге I</proc/"
"sys/net/ipv4/>."

#. type: TP
#: man-pages/man7/udp.7:140
#, no-wrap
msgid "I<udp_mem> (since Linux 2.6.25)"
msgstr "I<udp_mem> (начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man7/udp.7:144
msgid ""
"This is a vector of three integers governing the number of pages allowed for "
"queueing by all UDP sockets."
msgstr ""
"Вектор из трёх значений, управляющий количеством страниц, выделенных для "
"очереди под все сокеты UDP."

#. type: TP
#: man-pages/man7/udp.7:145
#, no-wrap
msgid "I<min>"
msgstr "I<min>"

#. type: Plain text
#: man-pages/man7/udp.7:151
msgid ""
"Below this number of pages, UDP is not bothered about its memory appetite.  "
"When the amount of memory allocated by UDP exceeds this number, UDP starts "
"to moderate memory usage."
msgstr ""
"При значении ниже этого количества страниц UDP не беспокоится о том, как "
"потребляется память. Когда количество памяти, выделенной для UDP, превышает "
"это значение, UDP начинает регулировать расход памяти."

#. type: TP
#: man-pages/man7/udp.7:151
#, no-wrap
msgid "I<pressure>"
msgstr "I<pressure>"

#. type: Plain text
#: man-pages/man7/udp.7:157
msgid ""
"This value was introduced to follow the format of I<tcp_mem> (see B<tcp>(7))."
msgstr "Формат этого значения совпадает с I<tcp_mem> (смотрите B<tcp>(7))."

#. type: TP
#: man-pages/man7/udp.7:157
#, no-wrap
msgid "I<max>"
msgstr "I<max>"

#. type: Plain text
#: man-pages/man7/udp.7:160
msgid "Number of pages allowed for queueing by all UDP sockets."
msgstr "Количество страниц, выделенных для очереди под все сокеты UDP."

#. type: Plain text
#: man-pages/man7/udp.7:164
msgid ""
"Defaults values for these three items are calculated at boot time from the "
"amount of available memory."
msgstr ""
"Значения по умолчанию этих трёх параметров вычисляются при запуске ОС исходя "
"из количества имеющейся памяти."

#. type: TP
#: man-pages/man7/udp.7:164
#, no-wrap
msgid "I<udp_rmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr "I<udp_rmem_min> (integer; значение по умолчанию: PAGE_SIZE; начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man7/udp.7:171
msgid ""
"Minimal size, in bytes, of receive buffers used by UDP sockets in "
"moderation.  Each UDP socket is able to use the size for receiving data, "
"even if total pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""
"Минимальный размер (в байтах) буферов приёма, используемых сокетами UDP в "
"режиме регулирования. Каждый сокет UDP может использовать этот объём "
"принимаемых данных, даже если общее количество страниц сокетов UDP превышает "
"ограничение I<udp_mem>."

#. type: TP
#: man-pages/man7/udp.7:171
#, no-wrap
msgid "I<udp_wmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr "I<udp_wmem_min> (integer; значение по умолчанию: PAGE_SIZE; начиная с Linux 2.6.25)"

#. type: Plain text
#: man-pages/man7/udp.7:178
msgid ""
"Minimal size, in bytes, of send buffer used by UDP sockets in moderation.  "
"Each UDP socket is able to use the size for sending data, even if total "
"pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""
"Минимальный размер (в байтах) буферов отправки, используемых сокетами UDP в "
"режиме регулирования. Каждый сокет UDP может использовать этот объём "
"отправляемых данных, даже если общее количество страниц сокетов UDP "
"превышает ограничение I<udp_mem>."

#. type: Plain text
#: man-pages/man7/udp.7:189
msgid ""
"To set or get a UDP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDP>.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr ""
"Для получения и задания параметров сокетов UDP используйте вызовы "
"B<getsockopt>(2) и B<setsockopt>(2), соответственно. Значение аргумента "
"уровня параметров должно быть равно B<IPPROTO_UDP>. Если не указано "
"обратного, значение I<optval> является указателем на I<int>."

#. type: Plain text
#: man-pages/man7/udp.7:194
msgid ""
"Following is a list of UDP-specific socket options.  For details of some "
"other socket options that are also applicable for UDP sockets, see "
"B<socket>(7)."
msgstr ""
"В следующем списке представлены параметры только для сокетов UDP. О других "
"параметрах, применимых к сокетам UDP, читайте в B<socket>(7)."

#. type: TP
#: man-pages/man7/udp.7:194
#, no-wrap
msgid "B<UDP_CORK> (since Linux 2.5.44)"
msgstr "B<UDP_CORK> (начиная с Linux 2.5.44)"

#.  FIXME document UDP_ENCAP (new in kernel 2.5.67)
#.  From include/linux/udp.h:
#.      UDP_ENCAP_ESPINUDP_NON_IKE draft-ietf-ipsec-nat-t-ike-00/01
#.      UDP_ENCAP_ESPINUDP draft-ietf-ipsec-udp-encaps-06
#.      UDP_ENCAP_L2TPINUDP rfc2661
#.  FIXME Document UDP_NO_CHECK6_TX and UDP_NO_CHECK6_RX, added in Linux 3.16
#. type: Plain text
#: man-pages/man7/udp.7:207
msgid ""
"If this option is enabled, then all data output on this socket is "
"accumulated into a single datagram that is transmitted when the option is "
"disabled.  This option should not be used in code intended to be portable."
msgstr ""
"Если этот параметр установлен, то все выходные данные сокета накапливаются в "
"одной датаграмме, которая отправляется после того, как параметр "
"сбрасывается. Данный параметр не должен использоваться в переносимом коде."

#. type: Plain text
#: man-pages/man7/udp.7:211
msgid "These ioctls can be accessed using B<ioctl>(2).  The correct syntax is:"
msgstr "Данные ioctl доступны через вызов B<ioctl>(2). Синтаксис:"

#. type: Plain text
#: man-pages/man7/udp.7:216
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: TP
#: man-pages/man7/udp.7:218
#, no-wrap
msgid "B<FIONREAD> (B<SIOCINQ>)"
msgstr "B<FIONREAD> (B<SIOCINQ>)"

#.  See http://www.securiteam.com/unixfocus/5KP0I15IKO.html
#.  "GNUnet DoS (UDP Socket Unreachable)", 14 May 2006
#. type: Plain text
#: man-pages/man7/udp.7:236
msgid ""
"Gets a pointer to an integer as argument.  Returns the size of the next "
"pending datagram in the integer in bytes, or 0 when no datagram is pending.  "
"B<Warning:> Using B<FIONREAD>, it is impossible to distinguish the case "
"where no datagram is pending from the case where the next pending datagram "
"contains zero bytes of data.  It is safer to use B<select>(2), B<poll>(2), "
"or B<epoll>(7)  to distinguish these cases."
msgstr ""
"В качестве параметра ожидается указатель на integer. Возвращает размер (в "
"байтах) следующей ожидающей датаграммы, помещая его по указанному адресу, "
"или 0, если нет ожидающей датаграммы. B<Предупреждение:> при использовании "
"B<FIONREAD> невозможно понять, есть ли ожидающие датаграммы или просто "
"следующая датаграмма не содержит данных. В этих случаях безопасней "
"использовать B<select>(2), B<poll>(2), или B<epoll>(7)."

#. type: TP
#: man-pages/man7/udp.7:236
#, no-wrap
msgid "B<TIOCOUTQ> (B<SIOCOUTQ>)"
msgstr "B<TIOCOUTQ> (B<SIOCOUTQ>)"

#. type: Plain text
#: man-pages/man7/udp.7:240
msgid ""
"Returns the number of data bytes in the local send queue.  Supported only "
"with Linux 2.4 and above."
msgstr ""
"Возвращает количество байт данных в локальной очереди отправки. "
"Поддерживается только в Linux 2.4 и выше."

#. type: Plain text
#: man-pages/man7/udp.7:246
msgid ""
"In addition, all ioctls documented in B<ip>(7)  and B<socket>(7)  are "
"supported."
msgstr ""
"Дополнительно поддерживаются все ioctl, описанные в B<ip>(7) и B<socket>(7)."

#. type: Plain text
#: man-pages/man7/udp.7:252
msgid ""
"All errors documented for B<socket>(7)  or B<ip>(7)  may be returned by a "
"send or receive on a UDP socket."
msgstr ""
"При отправке или приёме на сокете UDP могут быть получены все коды ошибок, "
"описанные в B<socket>(7) или B<ip>(7)."

#. type: Plain text
#: man-pages/man7/udp.7:256
msgid ""
"No receiver was associated with the destination address.  This might be "
"caused by a previous packet sent over the socket."
msgstr ""
"С адресом назначения не связан ни один получатель. Эта ошибка может быть "
"вызвана предыдущим пакетом, посланным через этот сокет."

#.  .SH CREDITS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: man-pages/man7/udp.7:261
msgid "B<IP_RECVERR> is a new feature in Linux 2.2."
msgstr "Параметр B<IP_RECVERR> появился в Linux 2.2."

#. type: Plain text
#: man-pages/man7/udp.7:266
msgid "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"
msgstr "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"

#. type: Plain text
#: man-pages/man7/udp.7:268
msgid "RFC\\ 768 for the User Datagram Protocol."
msgstr "Протокол пользовательских датаграмм описан в RFC\\ 768."

#. type: Plain text
#: man-pages/man7/udp.7:270
msgid "RFC\\ 1122 for the host requirements."
msgstr "В RFC\\ 1122 описаны требования к узлу."

#. type: Plain text
#: man-pages/man7/udp.7:271
msgid "RFC\\ 1191 for a description of path MTU discovery."
msgstr "В RFC\\ 1191 описан процесс обнаружения MTU маршрута."

#. type: TH
#: man-pages/man7/user-session-keyring.7:12
#, no-wrap
msgid "USER-SESSION-KEYRING"
msgstr "USER-SESSION-KEYRING"

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:15
msgid "user-session-keyring - per-user default session keyring"
msgstr ""
"user-session-keyring - пользовательская сеансовая связка ключей по умолчанию"

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:24
msgid ""
"The user session keyring is a keyring used to anchor keys on behalf of a "
"user.  Each UID the kernel deals with has its own user session keyring that "
"is shared by all processes with that UID.  The user session keyring has a "
"name (description) of the form I<_uid_ses.E<lt>UIDE<gt>> where "
"I<E<lt>UIDE<gt>> is the user ID of the corresponding user."
msgstr ""
"Пользовательская сеансовая связка ключей используется для хранения ключей "
"пользователя. Для каждого UID у ядра есть своя пользовательская сеансовая "
"связка ключей, которая доступна из всех процессов с этим UID. "
"Пользовательская сеансовая связка ключей имеет имя (описание) в виде "
"I<_uid_ses.E<lt>UIDE<gt>>, где I<E<lt>UIDE<gt>> идентификатор пользователя "
"соответствующего пользователя."

#.  Davis Howells: the user and user-session keyrings are managed as a pair.
#. type: Plain text
#: man-pages/man7/user-session-keyring.7:37
msgid ""
"The user session keyring is associated with the record that the kernel "
"maintains for the UID.  It comes into existence upon the first attempt to "
"access either the user session keyring, the B<user-keyring>(7), or the "
"B<session-keyring>(7).  The keyring remains pinned in existence so long as "
"there are processes running with that real UID or files opened by those "
"processes remain open.  (The keyring can also be pinned indefinitely by "
"linking it into another keyring.)"
msgstr ""
"Пользовательская сеансовая связка ключей связана с записью, которая "
"обслуживается ядром для UID. Она начинает существовать при попытке первого "
"обращения к пользовательской сеансовой связке ключей, к B<user-keyring>(7) "
"или к B<session-keyring>(7). Связка ключей существует привязанной всё время "
"пока выполняются процессы с этим реальным UID или остаются открытыми файлы, "
"открытые этими процессами (связка ключей также может быть привязана "
"бесконечно, если её прицепить к другой связке ключей)."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:45
msgid ""
"The user session keyring is created on demand when a thread requests it or "
"when a thread asks for its B<session-keyring>(7)  and that keyring doesn't "
"exist.  In the latter case, a user session keyring will be created and, if "
"the session keyring wasn't to be created, the user session keyring will be "
"set as the process's actual session keyring."
msgstr ""
"Пользовательская сеансовая связка ключей создаётся когда этого запросит нить "
"или когда нить запросит свою B<session-keyring>(7) и эта связка ключей не "
"существует. В последнем случае, пользовательская сеансовая связка ключей "
"будет создана и, если сеансовая связка ключей не была создана, то  "
"пользовательская сеансовая связка ключей будет использована как действующая "
"сеансовая связка ключей процесса."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:49
msgid ""
"The user session keyring is searched by B<request_key>(2)  if the actual "
"session keyring does not exist and is ignored otherwise."
msgstr ""
"В пользовательской сеансовой связке ключей выполняется поиск "
"B<request_key>(2), если не существует реальная связка ключей сеанса и не "
"выполняется в противном случае."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:55
msgid ""
"A special serial number value, B<KEY_SPEC_USER_SESSION_KEYRING>, is defined "
"that can be used in lieu of the actual serial number of the calling "
"process's user session keyring."
msgstr ""
"Существует специальный серийный номер, B<KEY_SPEC_USER_SESSION_KEYRING>, "
"который можно указывать вместо реального серийного номера пользовательской "
"связки ключей сеанса вызывающего процесса."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:60
msgid ""
"From the B<keyctl>(1)  utility, 'B<@us>' can be used instead of a numeric "
"key ID in much the same way."
msgstr ""
"В утилите B<keyctl>(1) подобным образом можно использовать «B<@us>» вместо "
"числового идентификатора ключа."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:70
msgid ""
"User session keyrings are independent of B<clone>(2), B<fork>(2), "
"B<vfork>(2), B<execve>(2), and B<_exit>(2)  excepting that the keyring is "
"destroyed when the UID record is destroyed when the last process pinning it "
"exits."
msgstr ""
"Пользовательские сеансовые связки ключей не зависят от B<clone>(2), "
"B<fork>(2), B<vfork>(2), B<execve>(2) и B<_exit>(2) за исключением того, что "
"эта связка ключей уничтожается когда запись UID уничтожается при завершении "
"последнего привязанного процесса."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:73
msgid ""
"If a user session keyring does not exist when it is accessed, it will be "
"created."
msgstr ""
"Если сеансовая связка ключей пользователя не существует на момент доступа, "
"то она создаётся."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:80
msgid ""
"Rather than relying on the user session keyring, it is strongly recommended"
"\\(emespecially if the process is running as root\\(emthat a B<session-"
"keyring>(7)  be set explicitly, for example by B<pam_keyinit>(8)."
msgstr ""
"Лучше не полагаться на пользовательскую сеансовую связку ключей; "
"настоятельно рекомендуется, особенно если процесс выполняется с правами "
"суперпользователя, задавать B<session-keyring>(7) явным образом, например с "
"помощью B<pam_keyinit>(8)."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:88
msgid ""
"The user session keyring was added to support situations where a process "
"doesn't have a session keyring, perhaps because it was created via a pathway "
"that didn't involve PAM (e.g., perhaps it was a daemon started by "
"B<inetd>(8)).  In such a scenario, the user session keyring acts as a "
"substitute for the B<session-keyring>(7)."
msgstr ""
"Поддержка пользовательской сеансовой связки ключей была добавлена для "
"ситуаций, когда процесс не имеет сеансовой связки ключей, возможно из-за "
"того, что был создан способом, не включающим PAM (например, служба, "
"запущенная B<inetd>(8)). В этом случае, пользовательская сеансовая связка "
"ключей подставляется вместо B<session-keyring>(7)."

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:98
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7)"
msgstr ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7)"

#. type: TH
#: man-pages/man2/umask.2:34
#, no-wrap
msgid "UMASK"
msgstr "UMASK"

#. type: Plain text
#: man-pages/man2/umask.2:37
msgid "umask - set file mode creation mask"
msgstr "umask - устанавливает маску создания режима доступа к файлу"

#. type: Plain text
#: man-pages/man2/umask.2:39
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/umask.2:41
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr "B<#include E<lt>sys/stat.hE<gt>>"

#. type: Plain text
#: man-pages/man2/umask.2:43
msgid "B<mode_t umask(mode_t >I<mask>B<);>"
msgstr "B<mode_t umask(mode_t >I<mask>B<);>"

#. type: Plain text
#: man-pages/man2/umask.2:50
msgid ""
"B<umask>()  sets the calling process's file mode creation mask (umask) to "
"I<mask> & 0777 (i.e., only the file permission bits of I<mask> are used), "
"and returns the previous value of the mask."
msgstr ""
"B<umask>() устанавливает в вызывающем процессе значение маски (umask) "
"создания режима доступа к файлу равным I<mask> & 0777 (т.е. из I<mask> "
"используются только биты прав доступа к файлу) и возвращает предыдущее "
"значение маски."

#.  e.g., mkfifo(), creat(), mknod(), sem_open(), mq_open(), shm_open()
#.  but NOT the System V IPC *get() calls
#. type: Plain text
#: man-pages/man2/umask.2:65
msgid ""
"The umask is used by B<open>(2), B<mkdir>(2), and other system calls that "
"create files to modify the permissions placed on newly created files or "
"directories.  Specifically, permissions in the umask are turned off from the "
"I<mode> argument to B<open>(2)  and B<mkdir>(2)."
msgstr ""
"Значение umask используется в B<open>(2), B<mkdir>(2) и других системных "
"вызовах, которые создают файлы, для изменения прав, назначаемых на "
"создаваемые файлы или каталоги. В частности, права в umask исключаются из "
"аргумента I<mode> у вызовов B<open>(2) и B<mkdir>(2)."

#. type: Plain text
#: man-pages/man2/umask.2:74
msgid ""
"Alternatively, if the parent directory has a default ACL (see B<acl>(5)), "
"the umask is ignored, the default ACL is inherited, the permission bits are "
"set based on the inherited ACL, and permission bits absent in the I<mode> "
"argument are turned off.  For example, the following default ACL is "
"equivalent to a umask of 022:"
msgstr ""
"Также, если у родительского каталога указан ACL по умолчанию (смотрите "
"B<acl>(5)), то umask игнорируется, выполняется наследование ACL по "
"умолчанию, бита прав назначаются согласно унаследованному ACL, а биты прав, "
"отсутствующие в аргументе I<mode>, выключаются. Например, следующий ACL по "
"умолчанию эквивалентен umask 022:"

#. type: Plain text
#: man-pages/man2/umask.2:76
#, no-wrap
msgid "    u::rwx,g::r-x,o::r-x\n"
msgstr "    u::rwx,g::r-x,o::r-x\n"

#. type: Plain text
#: man-pages/man2/umask.2:81
msgid ""
"Combining the effect of this default ACL with a I<mode> argument of 0666 (rw-"
"rw-rw-), the resulting file permissions would be 0644 (rw-r--r--)."
msgstr ""
"Объединение эффекта этого ACL по умолчанию с аргументом I<mode> 0666 (rw-rw-"
"rw-) приводит установке прав на файл 0644 (rw-r--r--)."

#. type: Plain text
#: man-pages/man2/umask.2:86
msgid ""
"The constants that should be used to specify I<mask> are described in "
"B<inode>(7)."
msgstr ""
"Константы, которые нужно использовать в I<mask>, описаны в B<inode>(7)."

#. type: Plain text
#: man-pages/man2/umask.2:95
msgid ""
"The typical default value for the process umask is I<S_IWGRP\\ |\\ S_IWOTH> "
"(octal 022).  In the usual case where the I<mode> argument to B<open>(2)  is "
"specified as:"
msgstr ""
"Типичным значением umask в процессе является I<S_IWGRP\\ |\\ S_IWOTH> "
"(восьмеричное 022). Обычно, когда аргумент I<mode> у B<open>(2) задаётся как:"

#. type: Plain text
#: man-pages/man2/umask.2:99
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"
msgstr "S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"

#. type: Plain text
#: man-pages/man2/umask.2:104
msgid ""
"(octal 0666) when creating a new file, the permissions on the resulting file "
"will be:"
msgstr ""
"(восьмеричное 0666) при создании файла, права получившегося файла будут:"

#. type: Plain text
#: man-pages/man2/umask.2:108
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"
msgstr "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"

#. type: Plain text
#: man-pages/man2/umask.2:112
msgid "(because 0666 & ~022 = 0644; i.e., rw-r--r--)."
msgstr "(так как 0666 & ~022 = 0644; т.е., rw-r--r--)."

#. type: SH
#: man-pages/man2/umask.2:112
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/umask.2:115
msgid ""
"This system call always succeeds and the previous value of the mask is "
"returned."
msgstr ""
"Данный системный вызов всегда выполняется успешно и возвращает предыдущее "
"значение маски."

#. type: Plain text
#: man-pages/man2/umask.2:117
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man2/umask.2:123
msgid ""
"A child process created via B<fork>(2)  inherits its parent's umask.  The "
"umask is left unchanged by B<execve>(2)."
msgstr ""
"Дочерний процесс, созданный с помощью B<fork>(2), наследует umask родителя. "
"Значение umask не изменяется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/umask.2:132
msgid ""
"It is impossible to use B<umask>()  to fetch a process's umask without at "
"the same time changing it.  A second call to B<umask>()  would then be "
"needed to restore the umask.  The nonatomicity of these two steps provides "
"the potential for races in multithreaded programs."
msgstr ""
"Невозможно использовать B<umask>() для получения umask процесса без её "
"изменения. Для восстановления umask требуется второй вызов B<umask>(). "
"Неатомарность этих двух шагов приводит к появлению состязательности в "
"многонитевых программах."

#. type: Plain text
#: man-pages/man2/umask.2:140
msgid ""
"Since Linux 4.7, the umask of any process can be viewed via the I<Umask> "
"field of I</proc/[pid]/status>.  Inspecting this field in I</proc/self/"
"status> allows a process to retrieve its umask without at the same time "
"changing it."
msgstr ""
"Начиная с Linux 4.7 значение umask любого процесса доступно в поле I<Umask> "
"файла I</proc/[pid]/status>. Просмотр этого поля в I</proc/self/status> "
"позволяет процессу узнать свою umask без её изменения."

#. type: Plain text
#: man-pages/man2/umask.2:155
msgid ""
"The umask setting also affects the permissions assigned to POSIX IPC objects "
"(B<mq_open>(3), B<sem_open>(3), B<shm_open>(3)), FIFOs (B<mkfifo>(3)), and "
"UNIX domain sockets (B<unix>(7))  created by the process.  The umask does "
"not affect the permissions assigned to System\\ V IPC objects created by the "
"process (using B<msgget>(2), B<semget>(2), B<shmget>(2))."
msgstr ""
"Настройка umask также влияет на права, назначаемые IPC-объектам POSIX "
"(B<mq_open>(3), B<sem_open>(3), B<shm_open>(3)), FIFO (B<mkfifo>(3)) и "
"доменным сокетам UNIX (B<unix>(7)), создаваемых процессом. Значение umask не "
"влияет на права, назначаемые IPC-объектам System\\ V, создаваемых процессом "
"(с помощью B<msgget>(2), B<semget>(2), B<shmget>(2))."

#. type: Plain text
#: man-pages/man2/umask.2:160
msgid "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"
msgstr "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"

#. type: TH
#: man-pages/man2/unshare.2:20
#, no-wrap
msgid "UNSHARE"
msgstr "UNSHARE"

#. type: Plain text
#: man-pages/man2/unshare.2:23
msgid "unshare - disassociate parts of the process execution context"
msgstr "unshare - отделяет части процесса контекста выполнения"

#. type: Plain text
#: man-pages/man2/unshare.2:27
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/unshare.2:29
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr "B<int unshare(int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/unshare.2:42
msgid ""
"B<unshare>()  allows a process (or thread) to disassociate parts of its "
"execution context that are currently being shared with other processes (or "
"threads).  Part of the execution context, such as the mount namespace, is "
"shared implicitly when a new process is created using B<fork>(2)  or "
"B<vfork>(2), while other parts, such as virtual memory, may be shared by "
"explicit request when creating a process or thread using B<clone>(2)."
msgstr ""
"Вызов B<unshare>() позволяет процессу (или потоку) отделить части своего "
"контекста выполнения, которые используются совместно с другими процессами "
"(или потоками). Часть контекста выполнения, например пространство имён "
"монтирования, неявно делается общей при создании нового процесса с помощью "
"B<fork>(2) или B<vfork>(2), в то время как другие части, такие как "
"виртуальная память, могут стать общими по явному запросу при создании "
"процесса или потока с помощью B<clone>(2)."

#. type: Plain text
#: man-pages/man2/unshare.2:47
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""
"Основное предназначение B<unshare>() \\(em позволить процессу контролировать "
"свой общий контекст выполнения без создания нового процесса."

#. type: Plain text
#: man-pages/man2/unshare.2:54
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""
"Значение аргумента I<flags> представляет собой битовую маску, в которой "
"указывается какие части контекста выполнения должны перестать быть общими. "
"Значение составляется из нескольких следующих констант (через OR):"

#. type: TP
#: man-pages/man2/unshare.2:54
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr "B<CLONE_FILES>"

#. type: Plain text
#: man-pages/man2/unshare.2:62
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""
"Обратный эффект флагу B<CLONE_FILES> для B<clone>(2). Отделяет таблицу "
"файловых дескрипторов таким образом, что вызывающий процесс больше не имеет "
"общих файловых дескрипторов с другими процессами."

#. type: TP
#: man-pages/man2/unshare.2:62
#, no-wrap
msgid "B<CLONE_FS>"
msgstr "B<CLONE_FS>"

#. type: Plain text
#: man-pages/man2/unshare.2:76
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare filesystem "
"attributes, so that the calling process no longer shares its root directory "
"(B<chroot>(2)), current directory (B<chdir>(2)), or umask (B<umask>(2))  "
"attributes with any other process."
msgstr ""
"Обратный эффект флагу B<CLONE_FS> для B<clone>(2). Отделяет атрибуты "
"файловой системы таким образом, что вызывающий процесс больше не имеет общих "
"атрибутов корневого каталога (B<chroot>(2)), текущего каталога (B<chdir>(2)) "
"и umask (B<umask>(2)) с другими процессами."

#. type: TP
#: man-pages/man2/unshare.2:76
#, no-wrap
msgid "B<CLONE_NEWCGROUP> (since Linux 4.6)"
msgstr "B<CLONE_NEWCGROUP> (начиная с Linux 4.6)"

#. type: Plain text
#: man-pages/man2/unshare.2:88
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWCGROUP> flag.  "
"Unshare the cgroup namespace.  Use of B<CLONE_NEWCGROUP> requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""
"Этот флаг имеет действие подобное флагу B<CLONE_NEWCGROUP> для B<clone>(2). "
"Отделяет пространство имён cgroup. Для использования B<CLONE_NEWCGROUP> "
"требуется мандат B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/unshare.2:88
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWIPC> (начиная с Linux 2.6.19)"

#. type: Plain text
#: man-pages/man2/unshare.2:105
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the IPC namespace, so that the calling process has a private copy of "
"the IPC namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_SYSVSEM> as well.  Use of "
"B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"Этот флаг имеет действие подобное флагу B<CLONE_NEWIPC> для B<clone>(2). "
"Отделяет пространство имён IPC таким образом, что вызывающий процесс будет "
"иметь свою личную копию пространства имён IPC, неиспользуемую другими "
"процессами. Задание данного флага автоматически устанавливает флаг "
"B<CLONE_SYSVSEM>. Для использования B<CLONE_NEWIPC> требуется мандат "
"B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/unshare.2:105
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWNET> (начиная с Linux 2.6.24)"

#. type: Plain text
#: man-pages/man2/unshare.2:120
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  Use of B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"Этот флаг имеет действие подобное флагу B<CLONE_NEWNET> для B<clone>(2). "
"Отделяет сетевое пространство имён таким образом, что вызывающий процесс "
"будет иметь свою личную копию сетевого пространства имён, неиспользуемую "
"другими процессами. Для использования B<CLONE_NEWNET> требуется мандат "
"B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/unshare.2:120
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr "B<CLONE_NEWNS>"

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: man-pages/man2/unshare.2:143
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<mount_namespaces>(7)."
msgstr ""
"Этот флаг имеет действие подобное флагу B<CLONE_NEWNS> для B<clone>(2). "
"Отделяет пространство имён монтирования таким образом, что вызывающий "
"процесс будет иметь свою личную копию данного пространства имён, "
"неиспользуемую другими процессами. Задание данного флага автоматически "
"устанавливает флаг B<CLONE_FS>. Для использования B<CLONE_NEWNS> требуется "
"мандат B<CAP_SYS_ADMIN>. Дополнительная информация доступна в "
"B<mount_namespaces>(7)."

#. type: TP
#: man-pages/man2/unshare.2:143
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 3.8)"
msgstr "B<CLONE_NEWPID> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/unshare.2:170
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWPID> flag.  "
"Unshare the PID namespace, so that the calling process has a new PID "
"namespace for its children which is not shared with any previously existing "
"process.  The calling process is I<not> moved into the new namespace.  The "
"first child created by the calling process will have the process ID 1 and "
"will assume the role of B<init>(1)  in the new namespace.  B<CLONE_NEWPID> "
"automatically implies B<CLONE_THREAD> as well.  Use of B<CLONE_NEWPID> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<pid_namespaces>(7)."
msgstr ""
"Данный флаг позволяет то же что и B<CLONE_NEWPID> у B<clone>(2). Выполняется "
"отключение от пространства имён PID; вызывающий процесс создаёт новое "
"пространство имён PID для своих потомков, которые до этого не были "
"объединены с существующим процессом. Вызывающий процесс I<не> перемещается в "
"новое пространство имён. Первый потомок, созданный вызывающим процессом, "
"будет иметь ID процесса 1 и считаться B<init>(1) в новом пространстве имён. "
"Также флаг B<CLONE_NEWPID> автоматически подразумевает B<CLONE_THREAD>. Для "
"использования B<CLONE_NEWPID> требуется мандат B<CAP_SYS_ADMIN>. Подробней "
"смотрите B<pid_namespaces>(7)."

#. type: TP
#: man-pages/man2/unshare.2:170
#, no-wrap
msgid "B<CLONE_NEWUSER> (since Linux 3.8)"
msgstr "B<CLONE_NEWUSER> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/unshare.2:184
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUSER> flag.  "
"Unshare the user namespace, so that the calling process is moved into a new "
"user namespace which is not shared with any previously existing process.  As "
"with the child process created by B<clone>(2)  with the B<CLONE_NEWUSER> "
"flag, the caller obtains a full set of capabilities in the new namespace."
msgstr ""
"Данный флаг позволяет то же что и B<CLONE_NEWUSER> у B<clone>(2). "
"Выполняется отключение от пользовательского пространства имён; вызывающий "
"процесс перемещается в новое пользовательское пространство имён, которое до "
"этого не был общим для существующего процесса. Как потомок процесса, "
"созданный B<clone>(2) с флагом B<CLONE_NEWUSER>, вызывающий получает полный "
"набор мандатов в новом пользовательском пространстве имён."

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: man-pages/man2/unshare.2:200
msgid ""
"B<CLONE_NEWUSER> requires that the calling process is not threaded; "
"specifying B<CLONE_NEWUSER> automatically implies B<CLONE_THREAD>.  Since "
"Linux 3.9, B<CLONE_NEWUSER> also automatically implies B<CLONE_FS>.  "
"B<CLONE_NEWUSER> requires that the user ID and group ID of the calling "
"process are mapped to user IDs and group IDs in the user namespace of the "
"calling process at the time of the call."
msgstr ""
"Для B<CLONE_NEWUSER> требуется, чтобы вызывающий процесс не имел нитей; "
"указание B<CLONE_NEWUSER> автоматически подразумевает B<CLONE_THREAD>. "
"Начиная с Linux 3.9, B<CLONE_NEWUSER> также автоматически подразумевает "
"B<CLONE_FS>. Для B<CLONE_NEWUSER> требуется, чтобы ID пользователя и группы "
"вызывающего процесса отображались в ID пользователя и группы в "
"пользовательском пространстве имён вызывающего процесса на момент вызова."

#. type: Plain text
#: man-pages/man2/unshare.2:203
msgid "For further information on user namespaces, see B<user_namespaces>(7)."
msgstr ""
"Дополнительную информацию о пространствах имён пользователя смотрите в "
"B<user_namespaces>(7)."

#. type: TP
#: man-pages/man2/unshare.2:203
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWUTS> (начиная с Linux 2.6.19)"

#. type: Plain text
#: man-pages/man2/unshare.2:217
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"Этот флаг имеет действие подобное флагу B<CLONE_NEWUTS> для B<clone>(2). "
"Отделяет пространство имён UTS IPC таким образом, что вызывающий процесс "
"будет иметь свою личную копию пространства имён UTS, неиспользуемую другими "
"процессами. Для использования B<CLONE_NEWUTS> требуется мандат "
"B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/unshare.2:217
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr "B<CLONE_SYSVSEM> (начиная с Linux 2.6.26)"

#.  commit 9edff4ab1f8d82675277a04e359d0ed8bf14a7b7
#.  CLONE_NEWNS If CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#. type: Plain text
#: man-pages/man2/unshare.2:237
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System\\ V semaphore adjustment (I<semadj>)  values, so that the "
"calling process has a new empty I<semadj> list that is not shared with any "
"other process.  If this is the last process that has a reference to the "
"process's current I<semadj> list, then the adjustments in that list are "
"applied to the corresponding semaphores, as described in B<semop>(2)."
msgstr ""
"С данным флагом выполняется обратное действие B<clone>(2) с флагом "
"B<CLONE_SYSVSEM>. Выполняется отмена изменения значений семафоров System\\ V "
"(I<semadj>) таким образом, что вызывающий процесс получает новый пустой "
"список I<semadj>, который не является общим ни с одним другим процессом. "
"Если это последний процесс, который ссылается на текущий список I<semadj> "
"процесса, то изменения (adjustments) в этом списке применяются к "
"соответствующим семафорам как описано в B<semop>(2)."

#.  As at 3.9, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#.  See kernel/fork.c::check_unshare_flags()
#. type: Plain text
#: man-pages/man2/unshare.2:264
msgid ""
"In addition, B<CLONE_THREAD>, B<CLONE_SIGHAND>, and B<CLONE_VM> can be "
"specified in I<flags> if the caller is single threaded (i.e., it is not "
"sharing its address space with another process or thread).  In this case, "
"these flags have no effect.  (Note also that specifying B<CLONE_THREAD> "
"automatically implies B<CLONE_VM>, and specifying B<CLONE_VM> automatically "
"implies B<CLONE_SIGHAND>.)  If the process is multithreaded, then the use of "
"these flags results in an error."
msgstr ""
"Также в I<flags> могут быть указаны флаги B<CLONE_THREAD>, B<CLONE_SIGHAND> "
"и B<CLONE_VM>, если вызывающий состоит из одной нити (т. е., он не делит "
"своё адресное пространство с другим процессом или нитью). Иначе данные флаги "
"не работают (также заметим, что указание B<CLONE_THREAD> автоматически "
"подразумевает B<CLONE_VM>, а указание B<CLONE_VM> автоматически "
"подразумевает B<CLONE_SIGHAND>). Если процесс состоит из нескольких нитей, "
"то использование данных флагов приведёт к ошибке."

#. type: Plain text
#: man-pages/man2/unshare.2:271
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""
"Если значение I<flags> равно нулю, то B<unshare>() ничего не делает, то есть "
"в контексте выполнения вызывающего процесса ничего не изменяется."

#. type: Plain text
#: man-pages/man2/unshare.2:276
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""
"При успешном выполнении возвращается 0. При ошибке возвращается -1, а "
"I<errno> присваивается значение ошибки."

#. type: Plain text
#: man-pages/man2/unshare.2:281
msgid "An invalid bit was specified in I<flags>."
msgstr "В значении I<flags> установлен недопустимый бит."

#. type: Plain text
#: man-pages/man2/unshare.2:290
msgid ""
"B<CLONE_THREAD>, B<CLONE_SIGHAND>, or B<CLONE_VM> was specified in I<flags>, "
"and the caller is multithreaded."
msgstr ""
"В I<flags> указан B<CLONE_THREAD>, B<CLONE_SIGHAND> или B<CLONE_VM>, а "
"вызывающий состоит из нескольких нитей."

#. type: Plain text
#: man-pages/man2/unshare.2:300
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""
"Указан флаг B<CLONE_NEWIPC> в I<flags>, но ядро собрано без параметров "
"B<CONFIG_SYSVIPC> и B<CONFIG_IPC_NS>."

#. type: Plain text
#: man-pages/man2/unshare.2:308
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""
"Указан флаг B<CLONE_NEWNET> в I<flags>, но ядро собрано без параметра "
"B<CONFIG_NET_NS>."

#. type: Plain text
#: man-pages/man2/unshare.2:316
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""
"Указан флаг B<CLONE_NEWPID> в I<flags>, но ядро собрано без параметра "
"B<CONFIG_PID_NS>."

#. type: Plain text
#: man-pages/man2/unshare.2:324
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but the kernel was not "
"configured with the B<CONFIG_USER_NS> option."
msgstr ""
"Указан флаг B<CLONE_NEWUSER> в I<flags>, но ядро собрано без параметра "
"B<CONFIG_USER_NS>."

#. type: Plain text
#: man-pages/man2/unshare.2:332
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS_NS> option."
msgstr ""
"Указан флаг B<CLONE_NEWUTS> в I<flags>, но ядро собрано без параметра "
"B<CONFIG_UTS_NS>."

#. type: Plain text
#: man-pages/man2/unshare.2:342
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the process has previously "
"called B<unshare>()  with the B<CLONE_NEWPID> flag."
msgstr ""
"Указан флаг B<CLONE_NEWPID> в I<flags>, но процесс был ранее вызван "
"B<unshare>() с флагом B<CLONE_NEWPID>."

#. type: Plain text
#: man-pages/man2/unshare.2:346
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""
"Не удалось выделить достаточно памяти для копирования части контекста "
"вызывающего, которая должна быть отделена."

#. type: TP
#: man-pages/man2/unshare.2:346
#, no-wrap
msgid "B<ENOSPC> (since Linux 3.7)"
msgstr "B<ENOSPC> (начиная с Linux 3.7)"

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
#: man-pages/man2/unshare.2:354
msgid ""
"B<CLONE_NEWPID> was specified in flags, but the limit on the nesting depth "
"of PID namespaces would have been exceeded; see B<pid_namespaces>(7)."
msgstr ""
"В флагах указан B<CLONE_NEWPID>, но вызов привёл бы к превышению ограничения "
"на количество вложенных имён PID; смотрите B<pid_namespaces>(7)."

#. type: TP
#: man-pages/man2/unshare.2:354
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9; beforehand B<EUSERS>)"
msgstr "B<ENOSPC> (начиная с Linux 4.9; до этого B<EUSERS>)"

#. type: Plain text
#: man-pages/man2/unshare.2:363
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
"limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr ""
"Флаг B<CLONE_NEWUSER> указан в I<flags>, и вызов привёл бы к превышению "
"ограничения на количество вложенных пользовательских пространств имён. "
"Смотрите B<user_namespaces>(7)."

#. type: Plain text
#: man-pages/man2/unshare.2:366
msgid ""
"From Linux 3.11 to Linux 4.8, the error diagnosed in this case was B<EUSERS>."
msgstr "В этом случае в Linux 3.11 по Linux 4.8 возвращалась ошибка B<EUSERS>."

#. type: TP
#: man-pages/man2/unshare.2:366
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9)"
msgstr "B<ENOSPC> (начиная с Linux 4.9)"

#. type: Plain text
#: man-pages/man2/unshare.2:376
msgid ""
"One of the values in I<flags> specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""
"Одним из значений в I<flags> задаётся создание нового пространства "
"пространства имён пользователя, но это превысило бы ограничение, "
"определённое в соответствующем файле в каталоге I</proc/sys/user>. "
"Дополнительную информацию смотрите в B<namespaces>(7)."

#. type: Plain text
#: man-pages/man2/unshare.2:379
msgid ""
"The calling process did not have the required privileges for this operation."
msgstr "Вызывающий процесс не имеет требуемых привилегий для этой операции."

#. type: Plain text
#: man-pages/man2/unshare.2:387
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but either the effective user ID "
"or the effective group ID of the caller does not have a mapping in the "
"parent namespace (see B<user_namespaces>(7))."
msgstr ""
"Флаг B<CLONE_NEWUSER> указан в I<flags>, но эффективный пользовательский ID "
"или эффективный ID группы вызывающего не отображён в родительское "
"пространство имён (смотрите B<user_namespaces>(7))."

#. type: TP
#: man-pages/man2/unshare.2:387
#, no-wrap
msgid "B<EPERM> (since Linux 3.9)"
msgstr "B<EPERM> (начиная с Linux 3.9)"

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
#: man-pages/man2/unshare.2:397
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags> and the caller is in a chroot "
"environment (i.e., the caller's root directory does not match the root "
"directory of the mount namespace in which it resides)."
msgstr ""
"В I<flags> был указан флаг B<CLONE_NEWUSER> и вызывающий выполняется в "
"окружении chroot (т. е. корневой каталог вызывающего не совпадает с корневым "
"каталогом пространства имён монтирования, в котором он находится)."

#. type: TP
#: man-pages/man2/unshare.2:397
#, no-wrap
msgid "B<EUSERS> (from Linux 3.11 to Linux 4.8)"
msgstr "B<EUSERS> (Linux 3.11 по Linux 4.8)"

#. type: Plain text
#: man-pages/man2/unshare.2:406
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the limit on the number of "
"nested user namespaces would be exceeded.  See the discussion of the "
"B<ENOSPC> error above."
msgstr ""
"Флаг B<CLONE_NEWUSER> указан в I<flags>, и вызов привёл бы к превышению "
"ограничения на количество вложенных пользовательских пространств имён. "
"Смотрите описание ошибки B<ENOSPC>, представленное выше."

#. type: Plain text
#: man-pages/man2/unshare.2:410
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr "Системный вызов B<unshare>() был добавлен в ядро Linux версии 2.6.16."

#. type: Plain text
#: man-pages/man2/unshare.2:414
msgid "The B<unshare>()  system call is Linux-specific."
msgstr "Системный вызов B<unshare>() есть только в Linux."

#.  FIXME all of the following needs to be reviewed for the current kernel
#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  However, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: man-pages/man2/unshare.2:448
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 3.8, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_THREAD>, or B<CLONE_VM>.  "
"Such functionality may be added in the future, if required."
msgstr ""
"Не все атрибуты процесса, которые могут использоваться совместно при "
"создании нового процесса с помощью B<clone>(2), могут быть отделены с "
"помощью B<unshare>(). В частности, начиная с ядра 3.8 в B<unshare>() не "
"реализована поддержка флагов, которые были имели обратное действие "
"B<CLONE_SIGHAND>, B<CLONE_THREAD> или B<CLONE_VM>. Эти возможности могут "
"быть добавлены позднее, если потребуется."

#. type: Plain text
#: man-pages/man2/unshare.2:457
msgid ""
"The program below provides a simple implementation of the B<unshare>(1)  "
"command, which unshares one or more namespaces and executes the command "
"supplied in its command-line arguments.  Here's an example of the use of "
"this program, running a shell in a new mount namespace, and verifying that "
"the original shell and the new shell are in separate mount namespaces:"
msgstr ""
"Программа, представленная далее, предоставляет простую реализацию команды "
"B<unshare>(1), которая отключает использование одного или более пространств "
"имён и выполняет команду, переданную в аргументах командной строки. Вот "
"пример использования этой программы; запускается оболочка в новом "
"пространстве имён монтирования и проверяется, что первоначальная оболочка и "
"новая оболочка находятся в разных пространствах имён монтирования:"

#. type: Plain text
#: man-pages/man2/unshare.2:465
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026531840]\n"
"$ B<sudo ./unshare -m /bin/bash>\n"
"# B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026532325]\n"
msgstr ""
"$ B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026531840]\n"
"$ B<sudo ./unshare -m /bin/bash>\n"
"# B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026532325]\n"

#. type: Plain text
#: man-pages/man2/unshare.2:471
msgid ""
"The differing output of the two B<readlink>(1)  commands shows that the two "
"shells are in different mount namespaces."
msgstr ""
"Различающийся вывод двух команд B<readlink>(1) показывает, что две оболочки "
"находятся в разных пространствах имён монтирования."

#. type: Plain text
#: man-pages/man2/unshare.2:475
#, no-wrap
msgid "/* unshare.c\n"
msgstr "/* unshare.c\n"

#. type: Plain text
#: man-pages/man2/unshare.2:484
#, no-wrap
msgid ""
"   A simple implementation of the unshare(1) command: unshare\n"
"   namespaces and execute a command.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"   Простая реализация команды unshare(1): отключение от\n"
"   пространств имён и выполнение команды.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/unshare.2:504
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] program [arg...]\\en\", pname);\n"
"    fprintf(stderr, \"Options can be:\\en\");\n"
"    fprintf(stderr, \"    -i   unshare IPC namespace\\en\");\n"
"    fprintf(stderr, \"    -m   unshare mount namespace\\en\");\n"
"    fprintf(stderr, \"    -n   unshare network namespace\\en\");\n"
"    fprintf(stderr, \"    -p   unshare PID namespace\\en\");\n"
"    fprintf(stderr, \"    -u   unshare UTS namespace\\en\");\n"
"    fprintf(stderr, \"    -U   unshare user namespace\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Использование: %s [параметры] программа [аргументы…]\\en\", pname);\n"
"    fprintf(stderr, \"Параметры:\\en\");\n"
"    fprintf(stderr, \"    -i   отключиться от пространства имён IPC\\en\");\n"
"    fprintf(stderr, \"    -m   отключиться от пространства имён монтирования\\en\");\n"
"    fprintf(stderr, \"    -n   отключиться от сетевого пространства имён\\en\");\n"
"    fprintf(stderr, \"    -p   отключиться от пространства имён PID\\en\");\n"
"    fprintf(stderr, \"    -u   отключиться от пространства имён UTS\\en\");\n"
"    fprintf(stderr, \"    -U   отключиться от пользовательского пространства имён\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/unshare.2:509
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"

#. type: Plain text
#: man-pages/man2/unshare.2:511
#, no-wrap
msgid "    flags = 0;\n"
msgstr "    flags = 0;\n"

#. type: Plain text
#: man-pages/man2/unshare.2:523
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"imnpuU\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"imnpuU\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/unshare.2:526
#, no-wrap
msgid ""
"    if (optind E<gt>= argc)\n"
"        usage(argv[0]);\n"
msgstr ""
"    if (optind E<gt>= argc)\n"
"        usage(argv[0]);\n"

#. type: Plain text
#: man-pages/man2/unshare.2:529
#, no-wrap
msgid ""
"    if (unshare(flags) == -1)\n"
"        errExit(\"unshare\");\n"
msgstr ""
"    if (unshare(flags) == -1)\n"
"        errExit(\"unshare\");\n"

#. type: Plain text
#: man-pages/man2/unshare.2:533
#, no-wrap
msgid ""
"    execvp(argv[optind], &argv[optind]);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""
"    execvp(argv[optind], &argv[optind]);\n"
"    errExit(\"execvp\");\n"
"}\n"

#. type: Plain text
#: man-pages/man2/unshare.2:542
msgid ""
"B<unshare>(1), B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), "
"B<vfork>(2), B<namespaces>(7)"
msgstr ""
"B<unshare>(1), B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), "
"B<vfork>(2), B<namespaces>(7)"

#.  commit f504d47be5e8fa7ecf2bf660b18b42e6960c0eb2
#. type: Plain text
#: man-pages/man2/unshare.2:548
msgid ""
"I<Documentation/userspace-api/unshare.rst> in the Linux kernel source tree "
"(or I<Documentation/unshare.txt> before Linux 4.12)"
msgstr ""
"Файл I<Documentation/userspace-api/unshare.rst> из дерева исходного кода "
"ядра Linux (или I<Documentation/unshare.txt> до Linux 4.12)"

#. type: TH
#: man-pages/man2/ustat.2:30
#, no-wrap
msgid "USTAT"
msgstr "USTAT"

#. type: Plain text
#: man-pages/man2/ustat.2:33
msgid "ustat - get filesystem statistics"
msgstr "ustat - получить статистику по файловой системе"

#. type: Plain text
#: man-pages/man2/ustat.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
"B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
"B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"

#. type: Plain text
#: man-pages/man2/ustat.2:40
#, no-wrap
msgid "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"
msgstr "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"

#. type: Plain text
#: man-pages/man2/ustat.2:52
msgid ""
"B<ustat>()  returns information about a mounted filesystem.  I<dev> is a "
"device number identifying a device containing a mounted filesystem.  I<ubuf> "
"is a pointer to a I<ustat> structure that contains the following members:"
msgstr ""
"B<ustat>() возвращает информацию о смонтированной файловой системе. В I<dev> "
"указывается номер, который идентифицирует устройство, содержащее нужную "
"файловую систему. Аргумент I<ubuf> является указателем на структуру "
"I<ustat>, которая имеет следующий вид:"

#. type: Plain text
#: man-pages/man2/ustat.2:59
#, no-wrap
msgid ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"
msgstr ""
"daddr_t f_tfree;      /* всего свободных блоков */\n"
"ino_t   f_tinode;     /* количество свободных индексных дескрипторов */\n"
"char    f_fname[6];   /* имя Filsys */\n"
"char    f_fpack[6];   /* имя Filsys pack */\n"

#. type: Plain text
#: man-pages/man2/ustat.2:68
msgid ""
"The last two fields, I<f_fname> and I<f_fpack>, are not implemented and will "
"always be filled with null bytes (\\(aq\\e0\\(aq)."
msgstr ""
"Обработка последних двух полей, I<f_fname> и I<f_fpack>, не реализована, и "
"они всегда будут заполнены нулевыми символами (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man2/ustat.2:77
msgid ""
"On success, zero is returned and the I<ustat> structure pointed to by "
"I<ubuf> will be filled in.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"В случае успешного завершения возвращается ноль и структура I<ustat>, на "
"которую указывает I<ubuf>, будет заполнена значениями. В случае ошибки "
"возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/ustat.2:82
msgid "I<ubuf> points outside of your accessible address space."
msgstr "I<ubuf> указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/ustat.2:86
msgid "I<dev> does not refer to a device containing a mounted filesystem."
msgstr ""
"I<dev> не указывает на устройство, содержащее смонтированную файловую "
"систему."

#. type: TP
#: man-pages/man2/ustat.2:86
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/ustat.2:92
msgid ""
"The mounted filesystem referenced by I<dev> does not support this operation, "
"or any version of Linux before 1.3.16."
msgstr ""
"Смонтированная файловая система, на которую ссылается I<dev>, не "
"поддерживает данную операцию или версия Linux меньше, чем 1.3.16."

#. type: Plain text
#: man-pages/man2/ustat.2:94
msgid ""
"Since version 2.28, glibc no longer provides a wrapper for this system call."
msgstr ""
"Начиная с версии 2.28, в glibc удалена обёрточная функция этого устаревшего "
"системного вызова."

#.  SVr4 documents additional error conditions ENOLINK, ECOMM, and EINTR
#.  but has no ENOSYS condition.
#. type: Plain text
#: man-pages/man2/ustat.2:98
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man2/ustat.2:104
msgid ""
"B<ustat>()  is deprecated and has been provided only for compatibility.  All "
"new programs should use B<statfs>(2)  instead."
msgstr ""
"Вызов B<ustat>() устарел и предоставляется только для совместимости. Во всех "
"новых программах вместо него нужно использовать вызов B<statfs>(2)."

#. type: SS
#: man-pages/man2/ustat.2:104
#, no-wrap
msgid "HP-UX notes"
msgstr "Замечания, касающиеся HP-UX"

#.  Some software tries to use this in order to test whether the
#.  underlying filesystem is NFS.
#. type: Plain text
#: man-pages/man2/ustat.2:118
msgid ""
"The HP-UX version of the I<ustat> structure has an additional field, "
"I<f_blksize>, that is unknown elsewhere.  HP-UX warns: For some filesystems, "
"the number of free inodes does not change.  Such filesystems will return -1 "
"in the field I<f_tinode>.  For some filesystems, inodes are dynamically "
"allocated.  Such filesystems will return the current number of free inodes."
msgstr ""
"Версия структуры I<ustat> в HP-UX содержит дополнительное поле I<f_blksize>, "
"которого в других версиях нет. HP предупреждает: в некоторых файловых "
"системах количество свободных индексных дескрипторов (inodes) не изменяется. "
"Для таких файловых систем в поле I<f_tinode> возвращается значение -1. В "
"некоторых файловых системах индексные дескрипторы выделяются динамически. "
"Для таких файловых систем будет возвращено текущее количество свободных "
"индексных дескрипторов."

#. type: Plain text
#: man-pages/man2/ustat.2:120
msgid "B<stat>(2), B<statfs>(2)"
msgstr "B<stat>(2), B<statfs>(2)"

#. type: TH
#: man-pages/man2/utime.2:31
#, no-wrap
msgid "UTIME"
msgstr "UTIME"

#. type: Plain text
#: man-pages/man2/utime.2:34
msgid "utime, utimes - change file last access and modification times"
msgstr "utime, utimes - изменить последнее время доступа и изменения к inode"

#. type: Plain text
#: man-pages/man2/utime.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>utime.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>utime.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/utime.2:40
#, no-wrap
msgid "B<int utime(const char *>I<filename>B<, const struct utimbuf *>I<times>B<);>\n"
msgstr "B<int utime(const char *>I<filename>B<, const struct utimbuf *>I<times>B<);>\n"

#. type: Plain text
#: man-pages/man2/utime.2:42
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/utime.2:44
#, no-wrap
msgid "B<int utimes(const char *>I<filename>B<, const struct timeval >I<times>B<[2]);>\n"
msgstr "B<int utimes(const char *>I<filename>B<, const struct timeval >I<times>B<[2]);>\n"

#. type: Plain text
#: man-pages/man2/utime.2:49
msgid ""
"B<Note:> modern applications may prefer to use the interfaces described in "
"B<utimensat>(2)."
msgstr ""
"B<Замечание:> современным приложениям лучше использовать интерфейсы, "
"описанные в B<utimensat>(2)."

#. type: Plain text
#: man-pages/man2/utime.2:60
msgid ""
"The B<utime>()  system call changes the access and modification times of the "
"inode specified by I<filename> to the I<actime> and I<modtime> fields of "
"I<times> respectively."
msgstr ""
"Системный вызов B<utime>() изменяет время доступа и изменения у inode, "
"указанного в I<filename> на значения полей I<actime> и I<modtime> из "
"структуры I<times>, соответственно."

#. type: Plain text
#: man-pages/man2/utime.2:65
msgid ""
"If I<times> is NULL, then the access and modification times of the file are "
"set to the current time."
msgstr ""
"Если значение I<times> равно NULL, то время доступа и изменения файла "
"устанавливаются в текущее время."

#. type: Plain text
#: man-pages/man2/utime.2:72
msgid ""
"Changing timestamps is permitted when: either the process has appropriate "
"privileges, or the effective user ID equals the user ID of the file, or "
"I<times> is NULL and the process has write permission for the file."
msgstr ""
"Изменение временных меток разрешено если: процесс имеет соответствующие "
"права или эффективный пользовательский идентификатор равен пользовательскому "
"идентификатору файла, или значение I<times> равно NULL и процесс имеет права "
"на запись в файл."

#. type: Plain text
#: man-pages/man2/utime.2:76
msgid "The I<utimbuf> structure is:"
msgstr "Структура I<utimbuf> выглядит так:"

#. type: Plain text
#: man-pages/man2/utime.2:83
#, no-wrap
msgid ""
"struct utimbuf {\n"
"    time_t actime;       /* access time */\n"
"    time_t modtime;      /* modification time */\n"
"};\n"
msgstr ""
"struct utimbuf {\n"
"    time_t actime;       /* время доступа */\n"
"    time_t modtime;      /* время изменения */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/utime.2:90
msgid ""
"The B<utime>()  system call allows specification of timestamps with a "
"resolution of 1 second."
msgstr ""
"Системный вызов B<utime>() позволяет указывать временные метки с точностью "
"до 1 секунды."

#. type: Plain text
#: man-pages/man2/utime.2:103
msgid ""
"The B<utimes>()  system call is similar, but the I<times> argument refers to "
"an array rather than a structure.  The elements of this array are I<timeval> "
"structures, which allow a precision of 1 microsecond for specifying "
"timestamps.  The I<timeval> structure is:"
msgstr ""
"Системный вызов B<utimes>() выполняет подобное  действие, но аргумент "
"I<times> указывает на массив, а не на структуру. Элементы массива "
"представляют собой структуры I<timeval>, с помощью которых можно указывать "
"временные метки с точностью до 1 микросекунды . Структура I<timeval>:"

#. type: Plain text
#: man-pages/man2/utime.2:110
#, no-wrap
msgid ""
"struct timeval {\n"
"    long tv_sec;        /* seconds */\n"
"    long tv_usec;       /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    long tv_sec;        /* секунды */\n"
"    long tv_usec;       /* микросекунды */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/utime.2:123
msgid ""
"I<times>[0] specifies the new access time, and I<times>[1] specifies the new "
"modification time.  If I<times> is NULL, then analogously to B<utime>(), the "
"access and modification times of the file are set to the current time."
msgstr ""
"В I<times>[0] задаётся новое время доступа, а в I<times>[1] новое время "
"изменения. Если значение I<times> равно NULL, то аналогично B<utime>(), "
"время доступа и изменения файла устанавливаются в текущее время."

#. type: Plain text
#: man-pages/man2/utime.2:128
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а "
"I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/utime.2:129 man-pages/man2/utime.2:136
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/utime.2:136
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<path> (see also B<path_resolution>(7))."
msgstr ""
"Запрещён поиск в одном из каталогов пути I<path> (см. также "
"B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/utime.2:148
msgid ""
"I<times> is NULL, the caller's effective user ID does not match the owner of "
"the file, the caller does not have write access to the file, and the caller "
"is not privileged (Linux: does not have either the B<CAP_DAC_OVERRIDE> or "
"the B<CAP_FOWNER> capability)."
msgstr ""
"Значение I<times> равно NULL, эффективный пользовательский идентификатор "
"вызывающего процесса не совпадает с владельцем файла, вызывающий не имеет "
"права на запись в файл, и у вызывающего нет привилегий (Linux: не имеет "
"мандата B<CAP_DAC_OVERRIDE> или B<CAP_FOWNER>)."

#. type: Plain text
#: man-pages/man2/utime.2:152
msgid "I<filename> does not exist."
msgstr "Файл I<filename> не существует."

#. type: Plain text
#: man-pages/man2/utime.2:161
msgid ""
"I<times> is not NULL, the caller's effective UID does not match the owner of "
"the file, and the caller is not privileged (Linux: does not have the "
"B<CAP_FOWNER> capability)."
msgstr ""
"Значение I<times> не равно NULL, эффективный пользовательский идентификатор "
"вызывающего процесса не совпадает с владельцем файла и у вызывающего нет "
"привилегий (Linux: не имеет мандата B<CAP_FOWNER>)."

#. type: TP
#: man-pages/man2/utime.2:161
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man2/utime.2:165
msgid "I<path> resides on a read-only filesystem."
msgstr ""
"I<path> располагается на файловой системе, доступной только для чтения."

#. type: Plain text
#: man-pages/man2/utime.2:171
msgid ""
"B<utime>(): SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<utime>()  as obsolete."
msgstr ""
"B<utime>(): SVr4, POSIX.1-2001. В POSIX.1-2008 вызов B<utime>() помечен как "
"устаревший."

#. type: Plain text
#: man-pages/man2/utime.2:174
msgid "B<utimes>(): 4.3BSD, POSIX.1-2001."
msgstr "B<utimes>(): 4.3BSD, POSIX.1-2001."

#.  In libc4 and libc5,
#.  .BR utimes ()
#.  is just a wrapper for
#.  .BR utime ()
#.  and hence does not allow a subsecond resolution.
#. type: Plain text
#: man-pages/man2/utime.2:184
msgid ""
"Linux does not allow changing the timestamps on an immutable file, or "
"setting the timestamps to something other than the current time on an append-"
"only file."
msgstr ""
"В Linux нельзя изменять временные метки у недосягаемых (immutable) файлов "
"или задавать временные метки, отличные от текущего времени для файлов, в "
"которые можно только дописывать."

#. type: Plain text
#: man-pages/man2/utime.2:192
msgid ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<stat>(2), B<utimensat>(2), "
"B<futimens>(3), B<futimes>(3), B<inode>(7)"
msgstr ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<stat>(2), B<utimensat>(2), "
"B<futimens>(3), B<futimes>(3), B<inode>(7)"

#. type: TH
#: man-pages/man2/utimensat.2:26
#, no-wrap
msgid "UTIMENSAT"
msgstr "UTIMENSAT"

#. type: Plain text
#: man-pages/man2/utimensat.2:29
msgid "utimensat, futimens - change file timestamps with nanosecond precision"
msgstr ""
"utimensat, futimens - изменение временных меток файла с наносекундной "
"точностью"

#. type: Plain text
#: man-pages/man2/utimensat.2:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt> /* Definition of AT_* constants */>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt> /* определения констант AT_* */>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/utimensat.2:36
#, no-wrap
msgid ""
"B<int utimensat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timespec >I<times>B<[2], int >I<flags>B<);>\n"
msgstr ""
"B<int utimensat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timespec >I<times>B<[2], int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/utimensat.2:38
#, no-wrap
msgid "B<int futimens(int >I<fd>B<, const struct timespec >I<times>B<[2]);>\n"
msgstr "B<int futimens(int >I<fd>B<, const struct timespec >I<times>B<[2]);>\n"

#. type: Plain text
#: man-pages/man2/utimensat.2:43
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. "
"B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/utimensat.2:48
msgid "B<utimensat>():"
msgstr "B<utimensat>():"

#. type: TP
#: man-pages/man2/utimensat.2:49 man-pages/man2/utimensat.2:59
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man2/utimensat.2:52 man-pages/man2/utimensat.2:62
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man2/utimensat.2:52 man-pages/man2/utimensat.2:62
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man2/utimensat.2:55
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: man-pages/man2/utimensat.2:58
msgid "B<futimens>():"
msgstr "B<futimens>():"

#. type: Plain text
#: man-pages/man2/utimensat.2:65
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/utimensat.2:79
msgid ""
"B<utimensat>()  and B<futimens>()  update the timestamps of a file with "
"nanosecond precision.  This contrasts with the historical B<utime>(2)  and "
"B<utimes>(2), which permit only second and microsecond precision, "
"respectively, when setting file timestamps."
msgstr ""
"Вызовы B<utimensat>() и B<futimens>() обновляют временные метки файла с "
"наносекундной точностью. Этим они отличаются от B<utime>(2) и B<utimes>(2), "
"которые имеют секундную и микросекундную точность, соответственно."

#. type: Plain text
#: man-pages/man2/utimensat.2:89
msgid ""
"With B<utimensat>()  the file is specified via the pathname given in "
"I<pathname>.  With B<futimens>()  the file whose timestamps are to be "
"updated is specified via an open file descriptor, I<fd>."
msgstr ""
"В вызове B<utimensat>() файл задаётся в I<pathname> по имени. В вызове "
"B<futimens>() файл указывается в виде открытого файлового дескриптора в "
"I<fd>."

#. type: Plain text
#: man-pages/man2/utimensat.2:101
msgid ""
"For both calls, the new file timestamps are specified in the array I<times>: "
"I<times>[0] specifies the new \"last access time\" (I<atime>); I<times>[1] "
"specifies the new \"last modification time\" (I<mtime>).  Each of the "
"elements of I<times> specifies a time as the number of seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This "
"information is conveyed in a structure of the following form:"
msgstr ""
"У обоих вызовов новые временные метки файла указываются в массиве I<times>: "
"в I<times>[0] задаётся новое «время последнего доступа» (I<atime>); в "
"I<times>[1] задаётся новое «время последнего изменения» (I<mtime>). В каждом "
"элементе I<times> указывается время в виде количества секунд и наносекунд, "
"прошедших с начала эпохи (1970-01-01 00:00:00 +0000 (UTC)). Эта информация "
"представляет собой структуру следующего формата:"

#. type: Plain text
#: man-pages/man2/utimensat.2:108
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;        /* секунды */\n"
"    long   tv_nsec;       /* наносекунды */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/utimensat.2:113
msgid ""
"Updated file timestamps are set to the greatest value supported by the "
"filesystem that is not greater than the specified time."
msgstr ""
"Обновлённые временные метки файла устанавливаются в самое большое значение, "
"поддерживаемое файловой системой, но не больше чем указанное время."

#.  2.6.22 was broken: it is not ignored
#. type: Plain text
#: man-pages/man2/utimensat.2:132
msgid ""
"If the I<tv_nsec> field of one of the I<timespec> structures has the special "
"value B<UTIME_NOW>, then the corresponding file timestamp is set to the "
"current time.  If the I<tv_nsec> field of one of the I<timespec> structures "
"has the special value B<UTIME_OMIT>, then the corresponding file timestamp "
"is left unchanged.  In both of these cases, the value of the corresponding "
"I<tv_sec> field is ignored."
msgstr ""
"Если в поле I<tv_nsec> одной из структур I<timespec> указано специальное "
"значение B<UTIME_NOW>, то соответствующая временная метка файла "
"устанавливается в значение текущего времени. Если в поле I<tv_nsec> одной из "
"структур I<timespec> указано специальное значение B<UTIME_OMIT>, то "
"соответствующая временная метка файла не изменяется. В обоих случаях "
"значение поля I<tv_sec> игнорируется."

#. type: Plain text
#: man-pages/man2/utimensat.2:137
msgid "If I<times> is NULL, then both timestamps are set to the current time."
msgstr ""
"Если значение I<times> равно NULL, то значение обеих временных меток "
"становится равным текущему времени."

#. type: SS
#: man-pages/man2/utimensat.2:137
#, no-wrap
msgid "Permissions requirements"
msgstr "Права доступа"

#. type: Plain text
#: man-pages/man2/utimensat.2:145
msgid ""
"To set both file timestamps to the current time (i.e., I<times> is NULL, or "
"both I<tv_nsec> fields specify B<UTIME_NOW>), either:"
msgstr ""
"Чтобы установить временные метки файла равными текущему времени (т.е., "
"значение I<times> равно NULL, или оба значения поля I<tv_nsec> равно "
"B<UTIME_NOW>) требуется одно из:"

#.  2.6.22 was broken here -- for futimens() the check is
#.  based on whether or not the file descriptor is writable,
#.  not on whether the caller's effective UID has write
#.  permission for the file referred to by the descriptor.
#. type: Plain text
#: man-pages/man2/utimensat.2:151
msgid "the caller must have write access to the file;"
msgstr "вызывающий должен иметь право на запись в файл;"

#. type: Plain text
#: man-pages/man2/utimensat.2:153
msgid "the caller's effective user ID must match the owner of the file; or"
msgstr ""
"эффективный пользовательский идентификатор вызывающего должен совпадать с "
"идентификатором владельца файла;"

#. type: Plain text
#: man-pages/man2/utimensat.2:155
msgid "the caller must have appropriate privileges."
msgstr "вызывающий должен иметь соответствующие права."

#.  2.6.22 was broken here:
#.  both must be something other than *either* UTIME_OMIT *or* UTIME_NOW.
#. type: Plain text
#: man-pages/man2/utimensat.2:170
msgid ""
"To make any change other than setting both timestamps to the current time (i."
"e., I<times> is not NULL, and neither I<tv_nsec> field is B<UTIME_NOW> and "
"neither I<tv_nsec> field is B<UTIME_OMIT>), either condition 2 or 3 above "
"must apply."
msgstr ""
"Чтобы установить временные метки файла равными не текущему времени (т. е., "
"значение I<times> не равно NULL, или оба значения поля I<tv_nsec> не равны "
"B<UTIME_NOW> или B<UTIME_OMIT>) требуется выполнение условия 2 или 3."

#. type: Plain text
#: man-pages/man2/utimensat.2:180
msgid ""
"If both I<tv_nsec> fields are specified as B<UTIME_OMIT>, then no file "
"ownership or permission checks are performed, and the file timestamps are "
"not modified, but other error conditions may still be detected."
msgstr ""
"Если в обоих значениях поле I<tv_nsec> равно B<UTIME_OMIT>, то проверки "
"владения файлом и права доступа к нему не выполняются, и временные метки "
"файла не изменяются, но всё равно могут проверяться другие условия "
"возникновения ошибок."

#. type: SS
#: man-pages/man2/utimensat.2:180
#, no-wrap
msgid "utimensat() specifics"
msgstr "Особенности utimensat()"

#. type: Plain text
#: man-pages/man2/utimensat.2:193
msgid ""
"If I<pathname> is relative, then by default it is interpreted relative to "
"the directory referred to by the open file descriptor, I<dirfd> (rather than "
"relative to the current working directory of the calling process, as is done "
"by B<utimes>(2)  for a relative pathname).  See B<openat>(2)  for an "
"explanation of why this can be useful."
msgstr ""
"Если в I<pathname> указано относительное значение имени, то по умолчанию оно "
"отсчитывается от каталога, на который ссылается открытый файловый "
"дескриптор, I<dirfd> (а не от текущего рабочего каталога вызывающего "
"процесса, как это делается в B<utimes>(2) для относительных имён). В "
"B<openat>(2) объяснено почему это может быть полезно."

#. type: Plain text
#: man-pages/man2/utimensat.2:205
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<utimes>(2))."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<utimes>(2))."

#. type: Plain text
#: man-pages/man2/utimensat.2:211
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/utimensat.2:217
msgid ""
"The I<flags> field is a bit mask that may be 0, or include the following "
"constant, defined in I<E<lt>fcntl.hE<gt>>:"
msgstr ""
"Значение поля I<flags> представляет собой битовую маску и может равняться 0 "
"или содержать следующую константу (определена в I<E<lt>fcntl.hE<gt>>):"

#. type: TP
#: man-pages/man2/utimensat.2:217
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr "B<AT_SYMLINK_NOFOLLOW>"

#. type: Plain text
#: man-pages/man2/utimensat.2:223
msgid ""
"If I<pathname> specifies a symbolic link, then update the timestamps of the "
"link, rather than the file to which it refers."
msgstr ""
"Если I<pathname> указывает на символьную ссылку, то обновляются временные "
"метки ссылки, а не файла, на который она ссылается."

#. type: Plain text
#: man-pages/man2/utimensat.2:232
msgid ""
"On success, B<utimensat>()  and B<futimens>()  return 0.  On error, -1 is "
"returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<utimensat>() и B<futimens>() возвращается 0. При "
"ошибке возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/utimensat.2:242
msgid ""
"I<times> is NULL, or both I<tv_nsec> values are B<UTIME_NOW>, and either:"
msgstr ""
"Значение I<times> равно NULL, или в обоих значениях поле I<tv_nsec> равно "
"B<UTIME_NOW> или:"

#.  But Linux 2.6.22 was broken here.
#.  Traditionally, utime()/utimes() gives the error EACCES for the case
#.  where the timestamp pointer argument is NULL (i.e., set both timestamps
#.  to the current time), and the file is owned by a user other than the
#.  effective UID of the caller, and the file is not writable by the
#.  effective UID of the program.  utimensat() also gives this error in the
#.  same case.  However, in the same circumstances, when utimensat() is
#.  given a 'times' array in which both tv_nsec fields are UTIME_NOW, which
#.  provides equivalent functionality to specifying 'times' as NULL, the
#.  call succeeds.  It should fail with the error EACCES in this case.
#.  POSIX.1-2008 has the following:
#.  .TP
#.  .B EACCES
#.  .RB ( utimensat ())
#.  .I fd
#.  was not opened with
#.  .B O_SEARCH
#.  and the permissions of the directory to which
#.  .I fd
#.  refers do not allow searches.
#. type: Plain text
#: man-pages/man2/utimensat.2:274
msgid ""
"the effective user ID of the caller does not match the owner of the file, "
"the caller does not have write access to the file, and the caller is not "
"privileged (Linux: does not have either the B<CAP_FOWNER> or the "
"B<CAP_DAC_OVERRIDE> capability); or,"
msgstr ""
"эффективный пользовательский идентификатор вызывающего процесса не совпадает "
"с идентификатором владельца файла, вызывающий не имеет права на запись в "
"файл, и у вызывающего нет привилегий (Linux: не имеет мандата B<CAP_FOWNER> "
"или B<CAP_DAC_OVERRIDE>); "

#.  EXT2_IMMUTABLE_FL and similar flags for other filesystems.
#. type: Plain text
#: man-pages/man2/utimensat.2:278
msgid "the file is marked immutable (see B<chattr>(1))."
msgstr "файл помечен как неизменяемый (immutable) (см. B<chattr>(1))."

#. type: Plain text
#: man-pages/man2/utimensat.2:284
msgid "(B<futimens>())  I<fd> is not a valid file descriptor."
msgstr ""
"(B<futimens>()) Значение I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/utimensat.2:293
msgid ""
"(B<utimensat>())  I<pathname> is a relative pathname, but I<dirfd> is "
"neither B<AT_FDCWD> nor a valid file descriptor."
msgstr ""
"(B<utimensat>()) В I<pathname> содержится относительный путь, но значение "
"I<dirfd> не равно B<AT_FDCWD> и не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/utimensat.2:303
msgid ""
"I<times> pointed to an invalid address; or, I<dirfd> was B<AT_FDCWD>, and "
"I<pathname> is NULL or an invalid address."
msgstr ""
"Значение I<times> указывает на некорректный адрес; или I<dirfd> равно "
"B<AT_FDCWD> и I<pathname> равно NULL или содержит некорректный адрес."

#. type: Plain text
#: man-pages/man2/utimensat.2:307
msgid "Invalid value in I<flags>."
msgstr "Некорректное значение I<flags>."

#. type: Plain text
#: man-pages/man2/utimensat.2:318
msgid ""
"Invalid value in one of the I<tv_nsec> fields (value outside range 0 to "
"999,999,999, and not B<UTIME_NOW> or B<UTIME_OMIT>); or an invalid value in "
"one of the I<tv_sec> fields."
msgstr ""
"Некорректное значение в одном из полей I<tv_nsec> (значение вне диапазона от "
"0 до 999999999 и не равно B<UTIME_NOW> или B<UTIME_OMIT>) или некорректное "
"значение в одном из полей I<tv_sec>."

#.  SUSv4 does not specify this error.
#. type: Plain text
#: man-pages/man2/utimensat.2:330
msgid ""
"I<pathname> is NULL, I<dirfd> is not B<AT_FDCWD>, and I<flags> contains "
"B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"Значение I<pathname> равно NULL, I<dirfd> не равно B<AT_FDCWD> и I<flags> "
"содержит B<AT_SYMLINK_NOFOLLOW>."

#. type: TP
#: man-pages/man2/utimensat.2:330
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/utimensat.2:335
msgid ""
"(B<utimensat>())  Too many symbolic links were encountered in resolving "
"I<pathname>."
msgstr ""
"(B<utimensat>()) Во время определения I<pathname> встретилось слишком много "
"символьных ссылок."

#. type: TP
#: man-pages/man2/utimensat.2:335
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/utimensat.2:340
msgid "(B<utimensat>())  I<pathname> is too long."
msgstr "(B<utimensat>()) Слишком длинное значение аргумента I<pathname>."

#. type: Plain text
#: man-pages/man2/utimensat.2:349
msgid ""
"(B<utimensat>())  A component of I<pathname> does not refer to an existing "
"directory or file, or I<pathname> is an empty string."
msgstr ""
"(B<utimensat>()) Компонент пути I<pathname> не ссылается на существующий "
"каталог или файл, или в I<pathname> указана пустая строка."

#. type: TP
#: man-pages/man2/utimensat.2:349
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/utimensat.2:361
msgid ""
"(B<utimensat>())  I<pathname> is a relative pathname, but I<dirfd> is "
"neither B<AT_FDCWD> nor a file descriptor referring to a directory; or, one "
"of the prefix components of I<pathname> is not a directory."
msgstr ""
"(B<utimensat>()) В I<pathname> содержится относительный путь, но значение "
"I<dirfd> не равно B<AT_FDCWD> или не является файловым дескриптором, "
"ссылающимся на каталог; или один из компонентов I<pathname> не является "
"каталогом."

#. type: Plain text
#: man-pages/man2/utimensat.2:378
msgid ""
"The caller attempted to change one or both timestamps to a value other than "
"the current time, or to change one of the timestamps to the current time "
"while leaving the other timestamp unchanged, (i.e., I<times> is not NULL, "
"neither I<tv_nsec> field is B<UTIME_NOW>, and neither I<tv_nsec> field is "
"B<UTIME_OMIT>)  and either:"
msgstr ""
"Вызывающий пытается изменить одну или обе временные метки на значение, "
"отличное от текущего времени, или изменить одну из временных меток на "
"текущее время, а другую оставить неизменной (т. е., значение I<times> не "
"равно NULL, у обоих значений поле I<tv_nsec> не равно B<UTIME_NOW>, и у "
"обоих значений поле I<tv_nsec> не равно B<UTIME_OMIT>) и:"

#. type: Plain text
#: man-pages/man2/utimensat.2:385
msgid ""
"the caller's effective user ID does not match the owner of file, and the "
"caller is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or,"
msgstr ""
"эффективный пользовательский идентификатор не совпадает с идентификатором "
"владельца файла, а вызывающий не имеет привилегий (Linux: не имеет мандата "
"B<CAP_FOWNER>);"

#.  Linux 2.6.22 was broken here:
#.  it was not consistent with the old utimes() implementation,
#.  since the case when both tv_nsec fields are UTIME_NOW, was not
#.  treated like the (times == NULL) case.
#.  EXT2_IMMUTABLE_FL EXT_APPPEND_FL and similar flags for
#.  other filesystems.
#.  Why the inconsistency (which is described under NOTES) between
#.  EACCES and EPERM, where only EPERM tests for append-only.
#.  (This was also so for the older utimes() implementation.)
#. type: Plain text
#: man-pages/man2/utimensat.2:398
msgid "the file is marked append-only or immutable (see B<chattr>(1))."
msgstr ""
"файл помечен как только для добавления или как неизменяемый (см. "
"B<chattr>(1))."

#. type: Plain text
#: man-pages/man2/utimensat.2:402
msgid "The file is on a read-only filesystem."
msgstr "Файл расположен в файловой системе, доступной только для чтения."

#. type: TP
#: man-pages/man2/utimensat.2:402
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/utimensat.2:407
msgid ""
"(B<utimensat>())  Search permission is denied for one of the prefix "
"components of I<pathname>."
msgstr ""
"(B<utimensat>()) В одном из каталогов префикса I<pathname> не разрешён поиск."

#. type: Plain text
#: man-pages/man2/utimensat.2:411
msgid ""
"B<utimensat>()  was added to Linux in kernel 2.6.22; glibc support was added "
"with version 2.6."
msgstr ""
"Вызов B<utimensat>() был добавлен в ядро Linux версии 2.6.22; поддержка в "
"glibc доступна с версии 2.6."

#. type: Plain text
#: man-pages/man2/utimensat.2:415
msgid "Support for B<futimens>()  first appeared in glibc 2.6."
msgstr "Поддержка B<futimens>() появилась в glibc 2.6."

#. type: SH
#: man-pages/man2/utimensat.2:415
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man2/utimensat.2:418
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man2/utimensat.2:422
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man2/utimensat.2:422
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man2/utimensat.2:426
#, no-wrap
msgid ""
"B<utimensat>(),\n"
"B<futimens>()"
msgstr ""
"B<utimensat>(),\n"
"B<futimens>()"

#. type: tbl table
#: man-pages/man2/utimensat.2:426
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man2/utimensat.2:426
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: man-pages/man2/utimensat.2:434
msgid "B<futimens>()  and B<utimensat>()  are specified in POSIX.1-2008."
msgstr "Вызовы B<futimens>() и B<utimensat>() определены в POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/utimensat.2:438
msgid "B<utimensat>()  obsoletes B<futimesat>(2)."
msgstr "Вызов B<utimensat>() заменяет устаревший B<futimesat>(2)."

#. type: Plain text
#: man-pages/man2/utimensat.2:447
msgid ""
"On Linux, timestamps cannot be changed for a file marked immutable, and the "
"only change permitted for files marked append-only is to set the timestamps "
"to the current time.  (This is consistent with the historical behavior of "
"B<utime>(2)  and B<utimes>(2)  on Linux.)"
msgstr ""
"В Linux, временные метки нельзя изменять у файлов, помеченных как "
"неизменяемые (immutable), а у файлов, помеченных как только для добавления, "
"можно изменить метку только на значение текущего времени (это соответствует "
"сложившемуся исторически поведению в Linux вызовов B<utime>(2) и "
"B<utimes>(2))."

#. type: Plain text
#: man-pages/man2/utimensat.2:459
msgid ""
"If both I<tv_nsec> fields are specified as B<UTIME_OMIT>, then the Linux "
"implementation of B<utimensat>()  succeeds even if the file referred to by "
"I<dirfd> and I<pathname> does not exist."
msgstr ""
"Если оба поля I<tv_nsec> равны B<UTIME_OMIT>, то вызов B<utimensat>() "
"реализации Linux завершается без ошибки, даже, если файл, на который "
"ссылается I<dirfd> и I<pathname>, не существует."

#. type: SS
#: man-pages/man2/utimensat.2:459
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr "Отличия между библиотекой C и ABI ядра"

#. type: Plain text
#: man-pages/man2/utimensat.2:476
msgid ""
"On Linux, B<futimens>()  is a library function implemented on top of the "
"B<utimensat>()  system call.  To support this, the Linux B<utimensat>()  "
"system call implements a nonstandard feature: if I<pathname> is NULL, then "
"the call modifies the timestamps of the file referred to by the file "
"descriptor I<dirfd> (which may refer to any type of file).  Using this "
"feature, the call I<futimens(fd,\\ times)> is implemented as:"
msgstr ""
"В Linux, B<futimens>() представляет собой библиотечную функцию на основе "
"системного вызова B<utimensat>(). Для этого в Linux-версии системного вызова "
"B<utimensat>() реализовано нестандартное свойство: если значение I<pathname> "
"равно NULL, то вызов изменяет временные метки файла на который ссылается "
"файловый дескриптор I<dirfd> (который может указывать на файл любого типа). "
"С помощью этого свойства вызов I<futimens(fd,\\ times)> реализован как:"

#. type: Plain text
#: man-pages/man2/utimensat.2:480
#, no-wrap
msgid "utimensat(fd, NULL, times, 0);\n"
msgstr "utimensat(fd, NULL, times, 0);\n"

#. type: Plain text
#: man-pages/man2/utimensat.2:490
msgid ""
"Note, however, that the glibc wrapper for B<utimensat>()  disallows passing "
"NULL as the value for I<pathname>: the wrapper function returns the error "
"I<EINVAL> in this case."
msgstr ""
"Однако заметим, что обёрточная функция glibc для B<utimensat>() не позволяет "
"передачу NULL в качестве значения I<pathname> — в этом случае возвращается "
"ошибка I<EINVAL>."

#. type: Plain text
#: man-pages/man2/utimensat.2:498
msgid ""
"Several bugs afflict B<utimensat>()  and B<futimens>()  on kernels before "
"2.6.26.  These bugs are either nonconformances with the POSIX.1 draft "
"specification or inconsistencies with historical Linux behavior."
msgstr ""
"В ядрах до версии 2.6.26 в B<utimensat>() и B<futimens>() есть несколько "
"дефектов. Эти дефекты приводят к несоответствию с черновиком спецификации "
"POSIX.1 или к рассогласованию со старым поведением в Linux."

#. type: Plain text
#: man-pages/man2/utimensat.2:513
msgid ""
"POSIX.1 specifies that if one of the I<tv_nsec> fields has the value "
"B<UTIME_NOW> or B<UTIME_OMIT>, then the value of the corresponding I<tv_sec> "
"field should be ignored.  Instead, the value of the I<tv_sec> field is "
"required to be 0 (or the error B<EINVAL> results)."
msgstr ""
"В POSIX.1 определено, что если в одном из значений времени поле I<tv_nsec> "
"содержит значение B<UTIME_NOW> или B<UTIME_OMIT>, то значение "
"соответствующего поля I<tv_sec> должно игнорироваться. Вместо этого "
"требуется, чтобы значение поля I<tv_sec> равнялось 0 (иначе выдаётся ошибка "
"B<EINVAL>)."

#.  Below, the long description of the errors from the previous bullet
#.  point (abridged because it's too much detail for a man page).
#.  .IP *
#.  If one of the
#.  .I tv_nsec
#.  fields is
#.  .BR UTIME_OMIT
#.  and the other is
#.  .BR UTIME_NOW ,
#.  then the error
#.  .B EPERM
#.  should occur if the process's effective user ID does not match
#.  the file owner and the process is not privileged.
#.  Instead, the call successfully changes one of the timestamps.
#.  .IP *
#.  If file is not writable by the effective user ID of the process and
#.  the process's effective user ID does not match the file owner and
#.  the process is not privileged,
#.  and
#.  .I times
#.  is NULL, then the error
#.  .B EACCES
#.  results.
#.  This error should also occur if
#.  .I times
#.  points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead the call succeeds.
#.  .IP *
#.  If a file is marked as append-only (see
#.  .BR chattr (1)),
#.  then Linux traditionally
#.  (i.e.,
#.  .BR utime (2),
#.  .BR utimes (2)),
#.  permits a NULL
#.  .I times
#.  argument to be used in order to update both timestamps to the current time.
#.  For consistency,
#.  .BR utimensat ()
#.  and
#.  .BR futimens ()
#.  should also produce the same result when given a
#.  .I times
#.  argument that points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead, the call fails with the error
#.  .BR EPERM .
#.  .IP *
#.  If a file is marked as immutable (see
#.  .BR chattr (1)),
#.  then Linux traditionally
#.  (i.e.,
#.  .BR utime (2),
#.  .BR utimes (2)),
#.  gives an
#.  .B EACCES
#.  error if
#.  .I times
#.  is NULL.
#.  For consistency,
#.  .BR utimensat ()
#.  and
#.  .BR futimens ()
#.  should also produce the same result when given a
#.  .I times
#.  that points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead, the call fails with the error
#.  .BR EPERM .
#. type: Plain text
#: man-pages/man2/utimensat.2:615
msgid ""
"Various bugs mean that for the purposes of permission checking, the case "
"where both I<tv_nsec> fields are set to B<UTIME_NOW> isn't always treated "
"the same as specifying I<times> as NULL, and the case where one I<tv_nsec> "
"value is B<UTIME_NOW> and the other is B<UTIME_OMIT> isn't treated the same "
"as specifying I<times> as a pointer to an array of structures containing "
"arbitrary time values.  As a result, in some cases: a) file timestamps can "
"be updated by a process that shouldn't have permission to perform updates; "
"b) file timestamps can't be updated by a process that should have permission "
"to perform updates; and c) the wrong I<errno> value is returned in case of "
"an error."
msgstr ""
"Различные дефекты возникают при рассмотрении имеющихся прав и значений: "
"случай, когда у обоих значений поле I<tv_nsec> равно B<UTIME_NOW>, не всегда "
"рассматривается равным указанию в I<times> значения NULL, и случай, когда "
"одно значение I<tv_nsec> равно B<UTIME_NOW>, а другое — B<UTIME_OMIT>, не "
"рассматривается равным указанию в I<times> указателя на массив структур, "
"содержащий произвольные значения времени. В результате в некоторых случаях: "
"а) временные метки файлов могут быть обновлены процессом, который не имеет "
"прав на это; б) временные метки файлов не могут быть обновлены процессом, "
"хотя он имеет на это право; в) в случае ошибки возвращается неправильное "
"значение в I<errno>."

#.  This means that a process with a file descriptor that allows
#.  writing could change the timestamps of a file for which it
#.  does not have write permission;
#.  conversely, a process with a read-only file descriptor won't
#.  be able to update the timestamps of a file,
#.  even if it has write permission on the file.
#. type: Plain text
#: man-pages/man2/utimensat.2:636
msgid ""
"POSIX.1 says that a process that has I<write access to the file> can make a "
"call with I<times> as NULL, or with I<times> pointing to an array of "
"structures in which both I<tv_nsec> fields are B<UTIME_NOW>, in order to "
"update both timestamps to the current time.  However, B<futimens>()  instead "
"checks whether the I<access mode of the file descriptor allows writing>."
msgstr ""
"В POSIX.1 сказано, что процесс имеющий I<права на запись в файл>, для "
"установки временных меток в текущее время может выполнить вызов со значением "
"I<times> равным NULL, или с I<times>, указывающим на массив структур, в "
"котором у обоих значений времени поле I<tv_nsec> равно B<UTIME_NOW>. Однако "
"B<futimens>() вместо этого проверяет I<права на запись у файлового "
"дескриптора>."

#. type: Plain text
#: man-pages/man2/utimensat.2:646
msgid ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<openat>(2), B<stat>(2), "
"B<utimes>(2), B<futimes>(3), B<inode>(7), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<openat>(2), B<stat>(2), "
"B<utimes>(2), B<futimes>(3), B<inode>(7), B<path_resolution>(7), "
"B<symlink>(7)"

#. type: TH
#: man-pages/man2/unimplemented.2:26
#, no-wrap
msgid "UNIMPLEMENTED"
msgstr "UNIMPLEMENTED"

#. type: Plain text
#: man-pages/man2/unimplemented.2:31
msgid ""
"afs_syscall, break, fattach, fdetach, ftime, getmsg, getpmsg, gtty, "
"isastream, lock, madvise1, mpx, prof, profil, putmsg, putpmsg, security, "
"stty, tuxcall, ulimit, vserver - unimplemented system calls"
msgstr ""
"afs_syscall, break, fattach, fdetach, ftime, getmsg, getpmsg, gtty, "
"isastream, lock, madvise1, mpx, prof, profil, putmsg, putpmsg, security, "
"stty, tuxcall, ulimit, vserver - нереализованные системные вызовы"

#. type: Plain text
#: man-pages/man2/unimplemented.2:33
msgid "Unimplemented system calls."
msgstr "Нереализованные системные вызовы."

#. type: Plain text
#: man-pages/man2/unimplemented.2:35
msgid "These system calls are not implemented in the Linux kernel."
msgstr "Данные системные вызовы не реализованы в ядре Linux."

#. type: Plain text
#: man-pages/man2/unimplemented.2:40
msgid "These system calls always return -1 and set I<errno> to B<ENOSYS>."
msgstr ""
"Эти системные вызовы всегда возвращают -1 и устанавливают для I<errno> "
"значение B<ENOSYS>."

#. type: Plain text
#: man-pages/man2/unimplemented.2:47
msgid ""
"Note that B<ftime>(3), B<profil>(3), and B<ulimit>(3)  are implemented as "
"library functions."
msgstr ""
"Заметим, что B<ftime>(3), B<profil>(3) и B<ulimit>(3) реализованы в виде "
"библиотечных функций."

#. type: Plain text
#: man-pages/man2/unimplemented.2:56
msgid ""
"Some system calls, like B<alloc_hugepages>(2), B<free_hugepages>(2), "
"B<ioperm>(2), B<iopl>(2), and B<vm86>(2)  exist only on certain "
"architectures."
msgstr ""
"Некоторые системные вызовы, такие как B<alloc_hugepages>(2), "
"B<free_hugepages>(2), B<ioperm>(2), B<iopl>(2) и B<vm86>(2), существуют "
"только для некоторых архитектур."

#. type: Plain text
#: man-pages/man2/unimplemented.2:64
msgid ""
"Some system calls, like B<ipc>(2), B<create_module>(2), B<init_module>(2), "
"and B<delete_module>(2)  exist only when the Linux kernel was built with "
"support for them."
msgstr ""
"Некоторые системные вызовы, такие как B<ipc>(2), B<create_module>(2), "
"B<init_module>(2) и B<delete_module>(2), существуют в ядре Linux только, "
"если при сборке ядра включена их поддержка."

#. type: Plain text
#: man-pages/man2/unimplemented.2:65
msgid "B<syscalls>(2)"
msgstr "B<syscalls>(2)"

#. type: TH
#: man-pages/man2/uname.2:27
#, no-wrap
msgid "UNAME"
msgstr "UNAME"

#. type: Plain text
#: man-pages/man2/uname.2:30
msgid "uname - get name and information about current kernel"
msgstr "uname - получает название и информацию о текущем ядре"

#. type: Plain text
#: man-pages/man2/uname.2:32
msgid "B<#include E<lt>sys/utsname.hE<gt>>"
msgstr "B<#include E<lt>sys/utsname.hE<gt>>"

#. type: Plain text
#: man-pages/man2/uname.2:34
msgid "B<int uname(struct utsname *>I<buf>B<);>"
msgstr "B<int uname(struct utsname *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/uname.2:42
msgid ""
"B<uname>()  returns system information in the structure pointed to by "
"I<buf>.  The I<utsname> struct is defined in I<E<lt>sys/utsname.hE<gt>>:"
msgstr ""
"B<uname>() возвращает информацию о системе в структуру с адресом I<buf>. "
"Структура I<utsname> определена в I<E<lt>sys/utsname.hE<gt>>:"

#. type: Plain text
#: man-pages/man2/uname.2:56
#, no-wrap
msgid ""
"struct utsname {\n"
"    char sysname[];    /* Operating system name (e.g., \"Linux\") */\n"
"    char nodename[];   /* Name within \"some implementation-defined\n"
"                          network\" */\n"
"    char release[];    /* Operating system release (e.g., \"2.6.28\") */\n"
"    char version[];    /* Operating system version */\n"
"    char machine[];    /* Hardware identifier */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* NIS or YP domain name */\n"
"#endif\n"
"};\n"
msgstr ""
"struct utsname {\n"
"    char sysname[];    /* название операционной системы\n"
"                          (например, «Linux») */\n"
"    char nodename[];   /* имя в сети, зависящее от реализации */\n"
"    char release[];    /* идентификатор выпуска ОС (например, «2.6.28») */\n"
"    char version[];    /* версия ОС */\n"
"    char machine[];    /* идентификатор аппаратного обеспечения */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* доменное имя NIS или YP */\n"
"#endif\n"
"};\n"

#. type: Plain text
#: man-pages/man2/uname.2:63
msgid ""
"The length of the arrays in a I<struct utsname> is unspecified (see NOTES); "
"the fields are terminated by a null byte (\\(aq\\e0\\(aq)."
msgstr ""
"Размеры массивов в I<struct utsname> не определены (см. ЗАМЕЧАНИЯ); поля "
"завершаются байтом с null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man2/uname.2:73
msgid "I<buf> is not valid."
msgstr "Значение I<buf> не определено."

#. type: Plain text
#: man-pages/man2/uname.2:78
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  There is no B<uname>()  call in 4.3BSD."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, SVr4. Вызов B<uname>() отсутствует в 4.3BSD."

#. type: Plain text
#: man-pages/man2/uname.2:82
msgid ""
"The I<domainname> member (the NIS or YP domain name) is a GNU extension."
msgstr "Поле I<domainname> (доменное имя NIS или YP) является расширением GNU."

#. type: Plain text
#: man-pages/man2/uname.2:98
msgid ""
"This is a system call, and the operating system presumably knows its name, "
"release and version.  It also knows what hardware it runs on.  So, four of "
"the fields of the struct are meaningful.  On the other hand, the field "
"I<nodename> is meaningless: it gives the name of the present machine in some "
"undefined network, but typically machines are in more than one network and "
"have several names.  Moreover, the kernel has no way of knowing about such "
"things, so it has to be told what to answer here.  The same holds for the "
"additional I<domainname> field."
msgstr ""
"Это системный вызов, и операционная система, предположительно, знает своё "
"имя, номер выпуска и версию. Она также знает, на каком аппаратном "
"обеспечении она работает. Таким образом, четыре поля структуры несут "
"полезную информацию. С другой стороны, поле I<nodename> её не несет: оно "
"указывает имя машины в некой неопределённой сети, но обычно машины находятся "
"в более чем одной сети и имеют несколько имён. Более того, ядро не может "
"каким-либо образом получить информацию о таких вещах, поэтому ему необходимо "
"сообщить что же возвращать в этом поле. То же относится и к дополнительному "
"полю I<domainname>."

#. type: Plain text
#: man-pages/man2/uname.2:116
msgid ""
"To this end, Linux uses the system calls B<sethostname>(2)  and "
"B<setdomainname>(2).  Note that there is no standard that says that the "
"hostname set by B<sethostname>(2)  is the same string as the I<nodename> "
"field of the struct returned by B<uname>()  (indeed, some systems allow a "
"256-byte hostname and an 8-byte nodename), but this is true on Linux.  The "
"same holds for B<setdomainname>(2)  and the I<domainname> field."
msgstr ""
"С этой целью в Linux используются системные вызовы B<sethostname>(2) и "
"B<setdomainname>(2). Обратите внимание, что хотя не существует стандарта, "
"который бы указывал, что имя машины, установленное B<sethostname>(2), "
"является той же строкой, что возвращается в поле I<nodename> при вызове "
"B<uname>(), для Linux это именно так (в действительности некоторые системы "
"позволяют 256-символьное имя машины и 8-символьное имя узла). То же "
"относится и к B<setdomainname>(2) и полю I<domainname>."

#. type: Plain text
#: man-pages/man2/uname.2:131
msgid ""
"The length of the fields in the struct varies.  Some operating systems or "
"libraries use a hardcoded 9 or 33 or 65 or 257.  Other systems use "
"B<SYS_NMLN> or B<_SYS_NMLN> or B<UTSLEN> or B<_UTSNAME_LENGTH>.  Clearly, it "
"is a bad idea to use any of these constants; just use sizeof(...).  Often "
"257 is chosen in order to have room for an internet hostname."
msgstr ""
"Длина полей в структуре может быть различна. Некоторые операционные системы "
"или библиотеки используют жёстко заданные значения 9, 33, 65 или 257. Другие "
"используют константы B<SYS_NMLN>, B<_SYS_NMLN>, B<UTSLEN> и "
"B<_UTSNAME_LENGTH>. Несомненно, идея использовать эти константы не очень "
"хороша \\(em можно просто использовать sizeof(...). Часто выбирается 257 для "
"того, чтобы имелось достаточно места для хранения имени машины в сети "
"интернет."

#. type: Plain text
#: man-pages/man2/uname.2:138
msgid ""
"Part of the utsname information is also accessible via I</proc/sys/kernel/"
">{I<ostype>, I<hostname>, I<osrelease>, I<version>, I<domainname>}."
msgstr ""
"Часть информации из структуры utsname может быть получена также через I</"
"proc/sys/kernel/> {I<ostype>, I<hostname>, I<osrelease>, I<version>, "
"I<domainname>}. "

#. type: SS
#: man-pages/man2/uname.2:138
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#.  That was back before Linux 1.0
#.  That was also back before Linux 1.0
#. type: Plain text
#: man-pages/man2/uname.2:167
msgid ""
"Over time, increases in the size of the I<utsname> structure have led to "
"three successive versions of B<uname>(): I<sys_olduname>()  (slot "
"I<__NR_oldolduname>), I<sys_uname>()  (slot I<__NR_olduname>), and "
"I<sys_newuname>()  (slot I<__NR_uname)>.  The first one used length 9 for "
"all fields; the second used 65; the third also uses 65 but adds the "
"I<domainname> field.  The glibc B<uname>()  wrapper function hides these "
"details from applications, invoking the most recent version of the system "
"call provided by the kernel."
msgstr ""
"Со временем, увеличение размера структуры I<utsname> последовательно привело "
"к трём версиям B<uname>(): I<sys_olduname>() (слот I<__NR_oldolduname>), "
"I<sys_uname>() (слот I<__NR_olduname>) и I<sys_newuname>() (слот "
"I<__NR_uname)>. В первой длина каждого поля равна 9; во второй 65; в третьей "
"также 65, но добавилось поле I<domainname>. Обёрточная функция B<uname>() в "
"glibc скрывает эти подробности от приложений, вызывая самую новую версию "
"системного вызова, предоставляемого ядром."

#. type: Plain text
#: man-pages/man2/uname.2:171
msgid "B<uname>(1), B<getdomainname>(2), B<gethostname>(2), B<namespaces>(7)"
msgstr "B<uname>(1), B<getdomainname>(2), B<gethostname>(2), B<namespaces>(7)"

#. type: TH
#: man-pages/man2/uselib.2:31
#, no-wrap
msgid "USELIB"
msgstr "USELIB"

#. type: Plain text
#: man-pages/man2/uselib.2:34
msgid "uselib - load shared library"
msgstr "uselib - загрузить динамическую библиотеку"

#. type: Plain text
#: man-pages/man2/uselib.2:36
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/uselib.2:38
msgid "B<int uselib(const char *>I<library>B<);>"
msgstr "B<int uselib(const char *>I<library>B<);>"

#. type: Plain text
#: man-pages/man2/uselib.2:41
msgid ""
"I<Note>: No declaration of this system call is provided in glibc headers; "
"see NOTES."
msgstr ""
"I<Замечание>: В заголовочных файлах glibc этой системный вызов отсутствует; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/uselib.2:51
msgid ""
"The system call B<uselib>()  serves to load a shared library to be used by "
"the calling process.  It is given a pathname.  The address where to load is "
"found in the library itself.  The library can have any recognized binary "
"format."
msgstr ""
"Системный вызов B<uselib>() выполняет загрузку динамической библиотеки для "
"использования в вызывающем процессе. Она задаётся именем файла. Адрес "
"загрузки находится в ней самой. Библиотека может быть в любом распознаваемом "
"формате."

#. type: Plain text
#: man-pages/man2/uselib.2:62
msgid ""
"In addition to all of the error codes returned by B<open>(2)  and "
"B<mmap>(2), the following may also be returned:"
msgstr ""
"В дополнении к тем кодам ошибок, которые возвращаются вызовами B<open>(2) и "
"B<mmap>(2), также могут быть следующие коды ошибок:"

#. type: Plain text
#: man-pages/man2/uselib.2:70
msgid ""
"The library specified by I<library> does not have read or execute "
"permission, or the caller does not have search permission for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""
"На библиотеку, заданную I<library>, нет прав на чтение или исполнение, или "
"вызывающий не имеет прав на поиск в одном из каталогов, указанных в пути. "
"(Смотрите также B<path_resolution>(7).)"

#. type: TP
#: man-pages/man2/uselib.2:70
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man2/uselib.2:73
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: TP
#: man-pages/man2/uselib.2:73
#, no-wrap
msgid "B<ENOEXEC>"
msgstr "B<ENOEXEC>"

#. type: Plain text
#: man-pages/man2/uselib.2:79
msgid ""
"The file specified by I<library> is not an executable of a known type; for "
"example, it does not have the correct magic numbers."
msgstr ""
"Библиотека, заданная I<library>, имеет неизвестный исполняемый тип; "
"например, в ней нет корректных идентификационных чисел (magic numbers)."

#. type: Plain text
#: man-pages/man2/uselib.2:83
msgid ""
"B<uselib>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"Вызов B<uselib>() применяется только в Linux и поэтому не должен "
"использоваться в программах, предназначенных для переноса на другие "
"платформы."

#. type: Plain text
#: man-pages/man2/uselib.2:91
msgid ""
"This obsolete system call is not supported by glibc.  No declaration is "
"provided in glibc headers, but, through a quirk of history, glibc versions "
"before 2.23 did export an ABI for this system call.  Therefore, in order to "
"employ this system call, it was sufficient to manually declare the interface "
"in your code; alternatively, you could invoke the system call using "
"B<syscall>(2)."
msgstr ""
"Устаревший системный вызов, не поддерживается glibc. В заголовочных файлах "
"glibc он не объявлен, но в недавнем прошлом версии glibc до 2.23 "
"экспортировали ABI для этого системного вызова. Поэтому, чтобы получить "
"данный системный вызов достаточно вручную объявить интерфейс в своём коде; "
"или же можно вызвать его через B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/uselib.2:97
msgid ""
"In ancient libc versions, B<uselib>()  was used to load the shared libraries "
"with names found in an array of names in the binary."
msgstr ""
"В очень старых версиях libc вызов B<uselib>() использовался для загрузки "
"динамических библиотек по именам из массива имён, находящегося в исполняемом "
"файле."

#.  libc 4.3.1f - changelog 1993-03-02
#.  libc 4.3.4 - changelog 1993-04-21
#. type: Plain text
#: man-pages/man2/uselib.2:107
msgid ""
"Since libc 4.3.2, startup code tries to prefix these names with \"/usr/lib"
"\", \"/lib\" and \"\" before giving up.  In libc 4.3.4 and later these names "
"are looked for in the directories found in B<LD_LIBRARY_PATH>, and if not "
"found there, prefixes \"/usr/lib\", \"/lib\" and \"/\" are tried."
msgstr ""
"Начиная с libc 4.3.2, код запуска дополняется эти имена \"/usr/lib\", \"/lib"
"\" и \"\" перед тем как отказаться от загрузки. В libc 4.3.4 и более поздних "
"эти имена ищутся в каталогах, содержащихся в переменной окружения "
"B<LD_LIBRARY_PATH>, и если они не находятся, то выполняется попытка поиска с "
"добавлением \"/usr/lib\", \"/lib\" и \"/\"."

#. type: Plain text
#: man-pages/man2/uselib.2:112
msgid ""
"From libc 4.4.4 on only the library \"/lib/ld.so\" is loaded, so that this "
"dynamic library can load the remaining libraries needed (again using this "
"call).  This is also the state of affairs in libc5."
msgstr ""
"Начиная libc 4.4.4 загружается только библиотека \"/lib/ld.so\" для того, "
"чтобы она смогла загрузить оставшиеся необходимые библиотеки (используя этот "
"системный вызов). То же происходит и в libc5."

#. type: Plain text
#: man-pages/man2/uselib.2:114
msgid "glibc2 does not use this call."
msgstr "В glibc2 не используется этот вызов."

#.  commit 69369a7003735d0d8ef22097e27a55a8bad9557a
#. type: Plain text
#: man-pages/man2/uselib.2:120
msgid ""
"Since Linux 3.15, this system call is available only when the kernel is "
"configured with the B<CONFIG_USELIB> option."
msgstr ""
"Начиная с Linux 3.15 данный системный вызов доступен только, если ядро "
"собрано с параметром B<CONFIG_USELIB>."

#. type: Plain text
#: man-pages/man2/uselib.2:129
msgid ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), "
"B<dlopen>(3), B<capabilities>(7), B<ld.so>(8)"
msgstr ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), "
"B<dlopen>(3), B<capabilities>(7), B<ld.so>(8)"

#. type: TH
#: man-pages/man2/userfaultfd.2:27
#, no-wrap
msgid "USERFAULTFD"
msgstr "USERFAULTFD"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:30
msgid ""
"userfaultfd - create a file descriptor for handling page faults in user space"
msgstr ""
"userfaultfd - создаёт файловый дескриптор для обработки страничных ошибок в "
"пользовательском пространстве"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>linux/userfaultfd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>linux/userfaultfd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:36
#, no-wrap
msgid "B<int userfaultfd(int >I<flags>B<);>\n"
msgstr "B<int userfaultfd(int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<Замечание>: В glibc нет обёрточной функции для данного системного вызова; "
"смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:47
msgid ""
"B<userfaultfd>()  creates a new userfaultfd object that can be used for "
"delegation of page-fault handling to a user-space application, and returns a "
"file descriptor that refers to the new object.  The new userfaultfd object "
"is configured using B<ioctl>(2)."
msgstr ""
"Вызов B<userfaultfd>() создаёт новый объект userfaultfd, который можно "
"использовать для передачи обработки страничных ошибок приложению "
"пользовательского пространства, и возвращает файловый дескриптор, "
"ссылающийся на новый объект. Новый объект userfaultfd настраивается с "
"помощью B<ioctl>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:56
msgid ""
"Once the userfaultfd object is configured, the application can use "
"B<read>(2)  to receive userfaultfd notifications.  The reads from "
"userfaultfd may be blocking or non-blocking, depending on the value of "
"I<flags> used for the creation of the userfaultfd or subsequent calls to "
"B<fcntl>(2)."
msgstr ""
"После настройки объекта userfaultfd приложение может использовать вызов "
"B<read>(2) для получения уведомлений userfaultfd. Чтение из userfaultfd "
"может быть блокирующим и не блокирующим, в зависимости от использованного "
"при создании userfaultfd значения I<flags> или последующих вызовов "
"B<fcntl>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:61
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<userfaultfd>():"
msgstr ""
"Для изменения поведения B<userfaultfd>() можно использовать следующие  "
"значения I<flags> (через OR):"

#. type: TP
#: man-pages/man2/userfaultfd.2:61
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr "B<O_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:68
msgid ""
"Enable the close-on-exec flag for the new userfaultfd file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""
"Включить флаг close-on-exec для нового открытого файлового дескриптора "
"userfaultfd. Смотрите описание флага B<O_CLOEXEC> в B<open>(2)."

#. type: TP
#: man-pages/man2/userfaultfd.2:68
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:75
msgid ""
"Enables non-blocking operation for the userfaultfd object.  See the "
"description of the B<O_NONBLOCK> flag in B<open>(2)."
msgstr ""
"Включить не блокирующую работу с объектом userfaultfd. Смотрите описание "
"флага B<O_NONBLOCK> в B<open>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:80
msgid ""
"When the last file descriptor referring to a userfaultfd object is closed, "
"all memory ranges that were registered with the object are unregistered and "
"unread events are flushed."
msgstr ""
"Когда закрывается последний ссылающийся на объект userfaultfd файловый "
"дескриптор, для всех диапазонов памяти, зарегистрированных в этом объекте, "
"снимается регистрация, а все непрочитанные события очищаются."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:92
msgid ""
"The userfaultfd mechanism is designed to allow a thread in a multithreaded "
"program to perform user-space paging for the other threads in the process.  "
"When a page fault occurs for one of the regions registered to the "
"userfaultfd object, the faulting thread is put to sleep and an event is "
"generated that can be read via the userfaultfd file descriptor.  The fault-"
"handling thread reads events from this file descriptor and services them "
"using the operations described in B<ioctl_userfaultfd>(2).  When servicing "
"the page fault events, the fault-handling thread can trigger a wake-up for "
"the sleeping thread."
msgstr ""
"Механизм userfaultfd разработан для того, чтобы позволить нити в "
"многонитевой программе выполнять деление на страницы пользовательского "
"пространства других нитей процесса. При возникновении страничной ошибки в "
"одной из зарегистрированных в объекте userfaultfd областей нить с ошибкой "
"засыпает и генерируется событие, которое можно прочитать через файловый "
"дескриптор userfaultfd. Нить обработки страничных ошибок читает сообщения из "
"этого файлового дескриптора и обслуживает из с помощью операций, описанных в "
"B<ioctl_userfaultfd>(2). В время этого нить обработки страничных ошибок "
"может привести в действие механизм пробуждения спящей нити."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:102
msgid ""
"It is possible for the faulting threads and the fault-handling threads to "
"run in the context of different processes.  In this case, these threads may "
"belong to different programs, and the program that executes the faulting "
"threads will not necessarily cooperate with the program that handles the "
"page faults.  In such non-cooperative mode, the process that monitors "
"userfaultfd and handles page faults needs to be aware of the changes in the "
"virtual memory layout of the faulting process to avoid memory corruption."
msgstr ""
"Нити с ошибкой и нити обработки страничных ошибок могут быть запущены в "
"контексте различных процессов. В этом случае данные нити могут принадлежать "
"разным программам, а программам, выполняющим нити с ошибкой, не обязательно "
"взаимодействовать с программой, обрабатывающей страничные ошибки. В таком "
"разобщённом режиме процессу, следящему за userfaultfd и обрабатывающему "
"страничные ошибки, необходимо знать об изменениях в раскладке виртуальной "
"памяти процесса с ошибкой, чтобы не допустить повреждение памяти."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:126
msgid ""
"Starting from Linux 4.11, userfaultfd can also notify the fault-handling "
"threads about changes in the virtual memory layout of the faulting process.  "
"In addition, if the faulting process invokes B<fork>(2), the userfaultfd "
"objects associated with the parent may be duplicated into the child process "
"and the userfaultfd monitor will be notified (via the B<UFFD_EVENT_FORK> "
"described below)  about the file descriptor associated with the userfault "
"objects created for the child process, which allows the userfaultfd monitor "
"to perform user-space paging for the child process.  Unlike page faults "
"which have to be synchronous and require an explicit or implicit wakeup, all "
"other events are delivered asynchronously and the non-cooperative process "
"resumes execution as soon as the userfaultfd manager executes B<read>(2).  "
"The userfaultfd manager should carefully synchronize calls to B<UFFDIO_COPY> "
"with the processing of events."
msgstr ""
"Начиная с Linux 4.11, userfaultfd также уведомляет нити обработки страничных "
"ошибок об изменениях в раскладке виртуальной памяти процесса с ошибкой. "
"Также, если процесс с ошибкой вызывает B<fork>(2), то для объекта "
"userfaultfd, связанного с родителем, в дочернем процессе может быть создать "
"дубликат, и отслеживающий userfaultfd также будет уведомлён (смотрите "
"описание B<UFFD_EVENT_FORK> ниже) о файловом дескрипторе, связанном с "
"объектом userfault, который был создан для дочернего процесса, что позволяет "
"отслеживающему userfaultfd выполнять деление на страницы пользовательское "
"пространство дочернего процесса. В отличие от страничных ошибок, которые "
"происходят синхронно и требуют явного или неявного пробуждения, все "
"остальные события доставляются асинхронно и не взаимодействующий процесс "
"возобновляет выполнение сразу же после того как отслеживающий userfaultfd "
"выполняет B<read>(2). Отслеживающий userfaultfd должен корректно "
"синхронизировать вызовы B<UFFDIO_COPY> при обработке событий."

#.  Regarding the preceding sentence, Mike Rapoport says:
#.      The major point here is that current events delivery model could be
#.      problematic for multi-threaded monitor. I even suspect that it would be
#.      impossible to ensure synchronization between page faults and non-page
#.      fault events in multi-threaded monitor.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:134
msgid ""
"The current asynchronous model of the event delivery is optimal for single "
"threaded non-cooperative userfaultfd manager implementations."
msgstr ""
"Имеющаяся асинхронная модель доставки событий оптимальна для реализации "
"однонитевой не взаимодействующей отслеживающей userfaultfd программы."

#.  FIXME elaborate about non-cooperating mode, describe its limitations
#.  for kernels before 4.11, features added in 4.11
#.  and limitations remaining in 4.11
#.  Maybe it's worth adding a dedicated sub-section...
#. type: SS
#: man-pages/man2/userfaultfd.2:140
#, no-wrap
msgid "Userfaultfd operation"
msgstr "Работа с userfaultfd"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:154
msgid ""
"After the userfaultfd object is created with B<userfaultfd>(), the "
"application must enable it using the B<UFFDIO_API> B<ioctl>(2)  operation.  "
"This operation allows a handshake between the kernel and user space to "
"determine the API version and supported features.  This operation must be "
"performed before any of the other B<ioctl>(2)  operations described below "
"(or those operations fail with the B<EINVAL> error)."
msgstr ""
"После создания объекта userfaultfd с помощью B<userfaultfd>() приложение "
"должно включить его с помощью операции B<UFFDIO_API> вызова B<ioctl>(2). "
"Данная операция позволяет согласовать между ядром и пользовательским "
"пространством версию программного интерфейса поддерживаемых свойств. Эта "
"операция должна быть выполнено самой первой среди других операций "
"B<ioctl>(2), описываемых ниже (в противном случае эти операции завершаются "
"ошибкой B<EINVAL>)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:174
msgid ""
"After a successful B<UFFDIO_API> operation, the application then registers "
"memory address ranges using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation.  "
"After successful completion of a B<UFFDIO_REGISTER> operation, a page fault "
"occurring in the requested memory range, and satisfying the mode defined at "
"the registration time, will be forwarded by the kernel to the user-space "
"application.  The application can then use the B<UFFDIO_COPY> or "
"B<UFFDIO_ZEROPAGE> B<ioctl>(2)  operations to resolve the page fault."
msgstr ""
"После успешного выполнения B<UFFDIO_API> приложение должно зарегистрировать "
"диапазоны адресов памяти с помощью операции B<UFFDIO_REGISTER> вызова "
"B<ioctl>(2). После успешного выполнения B<UFFDIO_REGISTER> страничная "
"ошибка, возникающая в запрошенном диапазоне и удовлетворяющая режиму, "
"определённому в момент регистрации, будет переслана ядром приложению в "
"пользовательском пространстве. Для решения страничной ошибки приложение "
"может использовать операцию B<UFFDIO_COPY> или B<UFFDIO_ZEROPAGE> вызова "
"B<ioctl>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:193
msgid ""
"Starting from Linux 4.14, if the application sets the B<UFFD_FEATURE_SIGBUS> "
"feature bit using the B<UFFDIO_API> B<ioctl>(2), no page-fault notification "
"will be forwarded to user space.  Instead a B<SIGBUS> signal is delivered to "
"the faulting process.  With this feature, userfaultfd can be used for "
"robustness purposes to simply catch any access to areas within the "
"registered address range that do not have pages allocated, without having to "
"listen to userfaultfd events.  No userfaultfd monitor will be required for "
"dealing with such memory accesses.  For example, this feature can be useful "
"for applications that want to prevent the kernel from automatically "
"allocating pages and filling holes in sparse files when the hole is accessed "
"through a memory mapping."
msgstr ""
"Начиная с Linux 4.14, если приложение устанавливает бит свойства "
"B<UFFD_FEATURE_SIGBUS> с помощью B<UFFDIO_API> B<ioctl>(2), то уведомления о "
"страничных ошибках не пересылаются в пользовательское пространство. Вместо "
"этого в ошибшийся процесс посылается сигнал B<SIGBUS>. С данным свойством "
"userfaultfd можно использовать в целях надёжности, просто ловя все попытки "
"доступа к областях внутри зарегистрированного адресного диапазона, в котором "
"нет выделенных страниц, не слушая при этом события userfaultfd. При таком "
"доступе к памяти не потребуется процесс слежения за userfaultfd. Например, "
"данное свойство может оказаться полезным приложениям, которые хотят не "
"давать ядру выполнять автоматическое выделение страниц и заполнение дыр в "
"разреженных файлах при обращении к дыре через отображение в памяти."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:200
msgid ""
"The B<UFFD_FEATURE_SIGBUS> feature is implicitly inherited through "
"B<fork>(2)  if used in combination with B<UFFD_FEATURE_FORK>."
msgstr ""
"Свойство B<UFFD_FEATURE_SIGBUS> неявно наследуется при B<fork>(2), если "
"используется вместе с B<UFFD_FEATURE_FORK>."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:205
msgid ""
"Details of the various B<ioctl>(2)  operations can be found in "
"B<ioctl_userfaultfd>(2)."
msgstr ""
"Подробности о различных операциях B<ioctl>(2) можно найти в "
"B<ioctl_userfaultfd>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:209
msgid ""
"Since Linux 4.11, events other than page-fault may enabled during "
"B<UFFDIO_API> operation."
msgstr ""
"Начиная с Linux 4.11 при операции B<UFFDIO_API> можно включить не только "
"события страничной ошибки."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:214
msgid ""
"Up to Linux 4.11, userfaultfd can be used only with anonymous private memory "
"mappings.  Since Linux 4.11, userfaultfd can be also used with hugetlbfs and "
"shared memory mappings."
msgstr ""
"До Linux 4.11 объект userfaultfd мог быть использован только с анонимными "
"частными отображениями памяти. Начиная с Linux 4.11 объект userfaultfd может "
"также использоваться с отображениями общей памяти и hugetlbfs."

#. type: SS
#: man-pages/man2/userfaultfd.2:216
#, no-wrap
msgid "Reading from the userfaultfd structure"
msgstr "Чтение из структуры userfaultfd"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:223
msgid ""
"Each B<read>(2)  from the userfaultfd file descriptor returns one or more "
"I<uffd_msg> structures, each of which describes a page-fault event or an "
"event required for the non-cooperative userfaultfd usage:"
msgstr ""
"Каждый вызов B<read>(2) из файлового дескриптора userfaultfd возвращает одну "
"или более структур I<uffd_msg>, каждая из которых описывает событие "
"страничной ошибки или событие, требуемое для использования userfaultfd в "
"разобщённом режиме:"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:234
#, no-wrap
msgid ""
"struct uffd_msg {\n"
"    __u8  event;            /* Type of event */\n"
"    ...\n"
"    union {\n"
"        struct {\n"
"            __u64 flags;    /* Flags describing fault */\n"
"            __u64 address;  /* Faulting address */\n"
"        } pagefault;\n"
msgstr ""
"struct uffd_msg {\n"
"    __u8  event;            /* тип события */\n"
"    ...\n"
"    union {\n"
"        struct {\n"
"            __u64 flags;    /* флаги, описывающие ошибку */\n"
"            __u64 address;  /* ошибочный адрес */\n"
"        } pagefault;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:239
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u32 ufd;      /* Userfault file descriptor\n"
"                               of the child process */\n"
"        } fork;\n"
msgstr ""
"        struct {            /* начиная с Linux 4.11 */\n"
"            __u32 ufd;      /* файловый дескриптор userfault\n"
"                               дочернего процесса */\n"
"        } fork;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:245
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 from;     /* Old address of remapped area */\n"
"            __u64 to;       /* New address of remapped area */\n"
"            __u64 len;      /* Original mapping length */\n"
"        } remap;\n"
msgstr ""
"        struct {            /* начиная с Linux 4.11 */\n"
"            __u64 from;     /* старый адрес переотображаемой области */\n"
"            __u64 to;       /* новый адрес переотображаемой области */\n"
"            __u64 len;      /* начальный размер отображения */\n"
"        } remap;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:252
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 start;    /* Start address of removed area */\n"
"            __u64 end;      /* End address of removed area */\n"
"        } remove;\n"
"        ...\n"
"    } arg;\n"
msgstr ""
"        struct {            /* начиная с Linux 4.11 */\n"
"            __u64 start;    /* начальный адрес удаляемой области */\n"
"            __u64 end;      /* конечный адрес удаляемой области */\n"
"        } remove;\n"
"        ...\n"
"    } arg;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:255
#, no-wrap
msgid ""
"    /* Padding fields omitted */\n"
"} __packed;\n"
msgstr ""
"    /* поля-заполнители не показаны */\n"
"} __packed;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:269
msgid ""
"If multiple events are available and the supplied buffer is large enough, "
"B<read>(2)  returns as many events as will fit in the supplied buffer.  If "
"the buffer supplied to B<read>(2)  is smaller than the size of the "
"I<uffd_msg> structure, the B<read>(2)  fails with the error B<EINVAL>."
msgstr ""
"Если доступно несколько событий и переданный буфер достаточного размера, то "
"B<read>(2) возвращает столько событий сколько влезает в буфер. Если буфер, "
"указанный B<read>(2), меньше размера структуры I<uffd_msg>, то B<read>(2) "
"завершается ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:273
msgid "The fields set in the I<uffd_msg> structure are as follows:"
msgstr "Поля структуры I<uffd_msg>:"

#. type: TP
#: man-pages/man2/userfaultfd.2:273
#, no-wrap
msgid "I<event>"
msgstr "I<event>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:284
msgid ""
"The type of event.  Depending of the event type, different fields of the "
"I<arg> union represent details required for the event processing.  The non-"
"page-fault events are generated only when appropriate feature is enabled "
"during API handshake with B<UFFDIO_API> B<ioctl>(2)."
msgstr ""
"Тип события. Тип события влияет на заполняемые поля объединения I<arg>, "
"представляющего детали, требуемые для обработки события. События, не "
"относящиеся к страничным ошибкам, генерируются только когда включено "
"соответствующее свойство при согласовании программного интерфейса с помощью "
"операции B<UFFDIO_API> вызова B<ioctl>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:288
msgid "The following values can appear in the I<event> field:"
msgstr "В поле I<event> могут появляться следующие значения:"

#. type: TP
#: man-pages/man2/userfaultfd.2:289
#, no-wrap
msgid "B<UFFD_EVENT_PAGEFAULT> (since Linux 4.3)"
msgstr "B<UFFD_EVENT_PAGEFAULT> (начиная с Linux 4.3)"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:295
msgid ""
"A page-fault event.  The page-fault details are available in the "
"I<pagefault> field."
msgstr "Событие страничной ошибки. Детали ошибки доступны в поле I<pagefault>."

#. type: TP
#: man-pages/man2/userfaultfd.2:295
#, no-wrap
msgid "B<UFFD_EVENT_FORK> (since Linux 4.11)"
msgstr "B<UFFD_EVENT_FORK> (начиная с Linux 4.11)"

#.  FIXME describe duplication of userfault file descriptor during fork
#. type: Plain text
#: man-pages/man2/userfaultfd.2:308
msgid ""
"Generated when the faulting process invokes B<fork>(2)  (or B<clone>(2)  "
"without the B<CLONE_VM> flag).  The event details are available in the "
"I<fork> field."
msgstr ""
"Генерируется, когда процесс с ошибкой вызывает B<fork>(2) (или B<clone>(2) "
"без флага B<CLONE_VM>). Детали ошибки доступны в поле I<fork>."

#. type: TP
#: man-pages/man2/userfaultfd.2:308
#, no-wrap
msgid "B<UFFD_EVENT_REMAP> (since Linux 4.11)"
msgstr "B<UFFD_EVENT_REMAP> (начиная с Linux 4.11)"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:315
msgid ""
"Generated when the faulting process invokes B<mremap>(2).  The event details "
"are available in the I<remap> field."
msgstr ""
"Генерируется, когда процесс с ошибкой вызывает B<mremap>(2). Детали ошибки "
"доступны в поле I<remap>."

#. type: TP
#: man-pages/man2/userfaultfd.2:315
#, no-wrap
msgid "B<UFFD_EVENT_REMOVE> (since Linux 4.11)"
msgstr "B<UFFD_EVENT_REMOVE> (начиная с Linux 4.11)"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:327
msgid ""
"Generated when the faulting process invokes B<madvise>(2)  with "
"B<MADV_DONTNEED> or B<MADV_REMOVE> advice.  The event details are available "
"in the I<remove> field."
msgstr ""
"Генерируется, когда процесс с ошибкой вызывает B<madvise>(2) с советом "
"B<MADV_DONTNEED> или B<MADV_REMOVE>. Детали ошибки доступны в поле I<remove>."

#. type: TP
#: man-pages/man2/userfaultfd.2:327
#, no-wrap
msgid "B<UFFD_EVENT_UNMAP> (since Linux 4.11)"
msgstr "B<UFFD_EVENT_UNMAP> (начиная с Linux 4.11)"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:339
msgid ""
"Generated when the faulting process unmaps a memory range, either explicitly "
"using B<munmap>(2)  or implicitly during B<mmap>(2)  or B<mremap>(2).  The "
"event details are available in the I<remove> field."
msgstr ""
"Генерируется, когда процесс с ошибкой отменяет проецирование диапазона "
"памяти явным образом с помощью B<munmap>(2) или неявно при вызове B<mmap>(2) "
"или B<mremap>(2). Детали ошибки доступны в поле I<remove>."

#. type: TP
#: man-pages/man2/userfaultfd.2:340
#, no-wrap
msgid "I<pagefault.address>"
msgstr "I<pagefault.address>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:343
msgid "The address that triggered the page fault."
msgstr "Адрес, из-за которого возникла страничная ошибка."

#. type: TP
#: man-pages/man2/userfaultfd.2:343
#, no-wrap
msgid "I<pagefault.flags>"
msgstr "I<pagefault.flags>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:349
msgid ""
"A bit mask of flags that describe the event.  For B<UFFD_EVENT_PAGEFAULT>, "
"the following flag may appear:"
msgstr ""
"Битовая маска флагов, описывающих событие. Для B<UFFD_EVENT_PAGEFAULT> может "
"появляться следующий флаг:"

#. type: TP
#: man-pages/man2/userfaultfd.2:350
#, no-wrap
msgid "B<UFFD_PAGEFAULT_FLAG_WRITE>"
msgstr "B<UFFD_PAGEFAULT_FLAG_WRITE>"

#.  UFFD_PAGEFAULT_FLAG_WP is not yet supported.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:360
msgid ""
"If the address is in a range that was registered with the "
"B<UFFDIO_REGISTER_MODE_MISSING> flag (see B<ioctl_userfaultfd>(2))  and this "
"flag is set, this a write fault; otherwise it is a read fault."
msgstr ""
"Если адрес в диапазоне, который был зарегистрирован с флагом "
"B<UFFDIO_REGISTER_MODE_MISSING> (смотрите B<ioctl_userfaultfd>(2)) и этот "
"флаг установлен, то это ошибка записи; в противном случае это ошибка чтения."

#. type: TP
#: man-pages/man2/userfaultfd.2:361
#, no-wrap
msgid "I<fork.ufd>"
msgstr "I<fork.ufd>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:366
msgid ""
"The file descriptor associated with the userfault object created for the "
"child created by B<fork>(2)."
msgstr ""
"С помощью B<fork>(2) был создан потомок, для которого был создан файловый "
"дескриптор, связанный с объектом userfault."

#. type: TP
#: man-pages/man2/userfaultfd.2:366
#, no-wrap
msgid "I<remap.from>"
msgstr "I<remap.from>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:370
msgid ""
"The original address of the memory range that was remapped using "
"B<mremap>(2)."
msgstr ""
"Первоначальный адрес диапазона памяти, который был переотображён с помощью "
"B<mremap>(2)."

#. type: TP
#: man-pages/man2/userfaultfd.2:370
#, no-wrap
msgid "I<remap.to>"
msgstr "I<remap.to>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:374
msgid ""
"The new address of the memory range that was remapped using B<mremap>(2)."
msgstr ""
"Новый адрес диапазона памяти, который был переотображён с помощью "
"B<mremap>(2)."

#. type: TP
#: man-pages/man2/userfaultfd.2:374
#, no-wrap
msgid "I<remap.len>"
msgstr "I<remap.len>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:378
msgid ""
"The original length of the memory range that was remapped using B<mremap>(2)."
msgstr ""
"Первоначальный размер диапазона памяти, который был переотображён с помощью "
"B<mremap>(2)."

#. type: TP
#: man-pages/man2/userfaultfd.2:378
#, no-wrap
msgid "I<remove.start>"
msgstr "I<remove.start>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:383
msgid ""
"The start address of the memory range that was freed using B<madvise>(2)  or "
"unmapped"
msgstr ""
"Начальный адрес диапазона памяти, который был освобождён с помощью "
"B<madvise>(2) или было отменено проецирование."

#. type: TP
#: man-pages/man2/userfaultfd.2:383
#, no-wrap
msgid "I<remove.end>"
msgstr "I<remove.end>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:388
msgid ""
"The end address of the memory range that was freed using B<madvise>(2)  or "
"unmapped"
msgstr ""
"Конечный адрес диапазона памяти, который был освобождён с помощью "
"B<madvise>(2) или было отменено проецирование."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:392
msgid ""
"A B<read>(2)  on a userfaultfd file descriptor can fail with the following "
"errors:"
msgstr ""
"Вызов B<read>(2) с файловым дескриптором userfaultfd может завершиться "
"следующими ошибками:"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:398
msgid ""
"The userfaultfd object has not yet been enabled using the B<UFFDIO_API> "
"B<ioctl>(2)  operation"
msgstr ""
"Объект userfaultfd не был включён с помощью операции B<UFFDIO_API> вызова "
"B<ioctl>(2)."

#.  FIXME What is the reason for this seemingly odd behavior with respect
#.  to the O_NONBLOCK flag? (see userfaultfd_poll() in fs/userfaultfd.c).
#.  Something needs to be said about this.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:420
msgid ""
"If the B<O_NONBLOCK> flag is enabled in the associated open file "
"description, the userfaultfd file descriptor can be monitored with "
"B<poll>(2), B<select>(2), and B<epoll>(7).  When events are available, the "
"file descriptor indicates as readable.  If the B<O_NONBLOCK> flag is not "
"enabled, then B<poll>(2)  (always) indicates the file as having a B<POLLERR> "
"condition, and B<select>(2)  indicates the file descriptor as both readable "
"and writable."
msgstr ""
"Если в связанном открытом файловом описании указан флаг B<O_NONBLOCK>, то "
"файловый дескриптор userfaultfd можно отслеживать с помощью B<poll>(2), "
"B<select>(2) и B<epoll>(7). При возникновении событий, файловый дескриптор "
"помечается как доступный на чтение. Если флаг B<O_NONBLOCK> не задан, то "
"B<poll>(2) (всегда) показывает, что файл находится в состоянии B<POLLERR>, а "
"B<select>(2) показывает, что файловый дескриптор доступен на чтение и запись."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:427
msgid ""
"On success, B<userfaultfd>()  returns a new file descriptor that refers to "
"the userfaultfd object.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"При успешном выполнении B<userfaultfd>() возвращает новый файловый "
"дескриптор, который ссылается на объект userfaultfd. При ошибке возвращается "
"-1, и I<errno> изменяется соответствующим образом."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:432
msgid "An unsupported value was specified in I<flags>."
msgstr "В I<flags> указано неподдерживаемое значение."

#. type: TP
#: man-pages/man2/userfaultfd.2:432
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:436
msgid ""
"The per-process limit on the number of open file descriptors has been reached"
msgstr ""
"Было достигнуто ограничение по количеству открытых файловых дескрипторов на "
"процесс."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:443
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:447
msgid "The B<userfaultfd>()  system call first appeared in Linux 4.3."
msgstr "Системный вызов B<userfaultfd>() впервые появился в Linux 4.3."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:450
msgid ""
"The support for hugetlbfs and shared memory areas and non-page-fault events "
"was added in Linux 4.11"
msgstr ""
"Поддержка hugetlbfs и общих областей памяти, а также событий, не относящихся "
"к страничным ошибкам, была добавлена в Linux 4.11."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:454
msgid ""
"B<userfaultfd>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"Вызов B<userfaultfd>() есть только в Linux и поэтому не должен "
"использоваться в программах, предназначенных для переноса на другие "
"платформы."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:457
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"В glibc нет обёртки для данного системного вызова; запускайте его с помощью "
"B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:468
msgid ""
"The userfaultfd mechanism can be used as an alternative to traditional user-"
"space paging techniques based on the use of the B<SIGSEGV> signal and "
"B<mmap>(2).  It can also be used to implement lazy restore for checkpoint/"
"restore mechanisms, as well as post-copy migration to allow (nearly) "
"uninterrupted execution when transferring virtual machines and Linux "
"containers from one host to another."
msgstr ""
"Механизм userfaultfd может быть использован как альтернатива обычному "
"страничному делению пользовательского пространства на основе использования "
"сигнала B<SIGSEGV> и B<mmap>(2). Также он может быть использован для "
"реализации отложенного (lazy) восстановления checkpoint/restore mechanisms, "
"as well as post-copy migration to allow (почти) не прерываемого выполнения "
"при переносе виртуальных машин и контейнеров Linux с одного узла на другой."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:478
msgid ""
"If the B<UFFD_FEATURE_EVENT_FORK> is enabled and a system call from the "
"B<fork>(2)  family is interrupted by a signal or failed, a stale userfaultfd "
"descriptor might be created.  In this case, a spurious B<UFFD_EVENT_FORK> "
"will be delivered to the userfaultfd monitor."
msgstr ""
"Если указано B<UFFD_FEATURE_EVENT_FORK> и системный вызов из семейства "
"B<fork>(2) прерывается по сигналу или завершается ошибкой, то может быть "
"создан повисший дескриптор userfaultfd. В этом случае программе слежения за "
"userfaultfd может быть доставлен ложный B<UFFD_EVENT_FORK>."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:484
msgid ""
"The program below demonstrates the use of the userfaultfd mechanism.  The "
"program creates two threads, one of which acts as the page-fault handler for "
"the process, for the pages in a demand-page zero region created using "
"B<mmap>(2)."
msgstr ""
"Программа, представленная далее, показывает использование механизма "
"userfaultfd. Она создаёт две нити, одна служит обработчиком страничных "
"ошибок процесса для страниц в режиме выделения при необходимости, созданных "
"B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:496
msgid ""
"The program takes one command-line argument, which is the number of pages "
"that will be created in a mapping whose page faults will be handled via "
"userfaultfd.  After creating a userfaultfd object, the program then creates "
"an anonymous private mapping of the specified size and registers the address "
"range of that mapping using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation.  "
"The program then creates a second thread that will perform the task of "
"handling page faults."
msgstr ""
"Программа имеет один параметр командной строки, определяющий количество "
"страниц, которые будут созданы в отображении, чьи страничные ошибки будут "
"обработаны userfaultfd. После создания объекта userfaultfd программа создаёт "
"анонимное частное отображение указанного размера и регистрирует адресный "
"диапазон отображения с помощью операции B<UFFDIO_REGISTER> вызовом "
"B<ioctl>(2). После этого программа создаёт вторую нить, которая будет "
"выполнять задачу по обработке страничных ошибок."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:502
msgid ""
"The main thread then walks through the pages of the mapping fetching bytes "
"from successive pages.  Because the pages have not yet been accessed, the "
"first access of a byte in each page will trigger a page-fault event on the "
"userfaultfd file descriptor."
msgstr ""
"После этого главная нить обходит страницы отображения запрашивая байты "
"следующей страницы. Так как к страницам ещё не обращались, первый доступ к "
"байту в каждой странице будет вызывать событие страничной ошибки в файловом "
"дескрипторе userfaultfd."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:517
msgid ""
"Each of the page-fault events is handled by the second thread, which sits in "
"a loop processing input from the userfaultfd file descriptor.  In each loop "
"iteration, the second thread first calls B<poll>(2)  to check the state of "
"the file descriptor, and then reads an event from the file descriptor.  All "
"such events should be B<UFFD_EVENT_PAGEFAULT> events, which the thread "
"handles by copying a page of data into the faulting region using the "
"B<UFFDIO_COPY> B<ioctl>(2)  operation."
msgstr ""
"Каждое событие страничной ошибки обрабатывается второй нитью, которая "
"выполняет цикл обработки ввода из файлового дескриптора userfaultfd. При "
"каждом проходе цикла вторая нить сначала вызывает B<poll>(2) для проверки "
"состояния файлового дескриптора, затем читает событие из файлового "
"дескриптора. Все события должны быть B<UFFD_EVENT_PAGEFAULT>, для их "
"обработки нить копирует страницу данных в ошибочную область с помощью "
"операции B<UFFDIO_COPY> вызова B<ioctl>(2)."

#. type: Plain text
#: man-pages/man2/userfaultfd.2:519
msgid "The following is an example of what we see when running the program:"
msgstr "Результат работы программы:"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:524
#, no-wrap
msgid ""
"$ B<./userfaultfd_demo 3>\n"
"Address returned by mmap() = 0x7fd30106c000\n"
msgstr ""
"$ B<./userfaultfd_demo 3>\n"
"Адрес, возвращённый mmap() = 0x7fd30106c000\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:533
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106c00f in main(): A\n"
"Read address 0x7fd30106c40f in main(): A\n"
"Read address 0x7fd30106c80f in main(): A\n"
"Read address 0x7fd30106cc0f in main(): A\n"
msgstr ""
"fault_handler_thread():\n"
"    poll() вернул: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    событие UFFD_EVENT_PAGEFAULT: флаги = 0; адрес = 7fd30106c00f\n"
"        (uffdio_copy.copy равно 4096)\n"
"Чтение по адресу 0x7fd30106c00f в main(): A\n"
"Чтение по адресу 0x7fd30106c40f в main(): A\n"
"Чтение по адресу 0x7fd30106c80f в main(): A\n"
"Чтение по адресу 0x7fd30106cc0f в main(): A\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:542
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106d00f in main(): B\n"
"Read address 0x7fd30106d40f in main(): B\n"
"Read address 0x7fd30106d80f in main(): B\n"
"Read address 0x7fd30106dc0f in main(): B\n"
msgstr ""
"fault_handler_thread():\n"
"    poll() вернул: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    событие UFFD_EVENT_PAGEFAULT: флаги = 0; адрес = 7fd30106d00f\n"
"        (uffdio_copy.copy равно 4096)\n"
"Чтение по адресу 0x7fd30106d00f в main(): B\n"
"Чтение по адресу 0x7fd30106d40f в main(): B\n"
"Чтение по адресу 0x7fd30106d80f в main(): B\n"
"Чтение по адресу 0x7fd30106dc0f в main(): B\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:551
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106e00f in main(): C\n"
"Read address 0x7fd30106e40f in main(): C\n"
"Read address 0x7fd30106e80f in main(): C\n"
"Read address 0x7fd30106ec0f in main(): C\n"
msgstr ""
"fault_handler_thread():\n"
"    poll() вернул: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    событие UFFD_EVENT_PAGEFAULT: флаги = 0; адрес = 7fd30106e00f\n"
"        (uffdio_copy.copy равно 4096)\n"
"Чтение по адресу 0x7fd30106e00f в main(): C\n"
"Чтение по адресу 0x7fd30106e40f в main(): C\n"
"Чтение по адресу 0x7fd30106e80f в main(): C\n"
"Чтение по адресу 0x7fd30106ec0f в main(): C\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:557
#, no-wrap
msgid "/* userfaultfd_demo.c\n"
msgstr "/* userfaultfd_demo.c\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:576
#, no-wrap
msgid ""
"   Licensed under the GNU General Public License version 2 or later.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>linux/userfaultfd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
msgstr ""
"   распространяется по лицензии GNU General Public License version 2 и новее.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>linux/userfaultfd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:581
#, no-wrap
msgid "static int page_size;\n"
msgstr "static int page_size;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:591
#, no-wrap
msgid ""
"static void *\n"
"fault_handler_thread(void *arg)\n"
"{\n"
"    static struct uffd_msg msg;   /* Data read from userfaultfd */\n"
"    static int fault_cnt = 0;     /* Number of faults so far handled */\n"
"    long uffd;                    /* userfaultfd file descriptor */\n"
"    static char *page = NULL;\n"
"    struct uffdio_copy uffdio_copy;\n"
"    ssize_t nread;\n"
msgstr ""
"static void *\n"
"fault_handler_thread(void *arg)\n"
"{\n"
"    static struct uffd_msg msg;   /* данные, прочитанные из userfaultfd */\n"
"    static int fault_cnt = 0;     /* количество обработанных ошибок */\n"
"    long uffd;                    /* файловый дескриптор userfaultfd */\n"
"    static char *page = NULL;\n"
"    struct uffdio_copy uffdio_copy;\n"
"    ssize_t nread;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:593
#, no-wrap
msgid "    uffd = (long) arg;\n"
msgstr "    uffd = (long) arg;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:595
#, no-wrap
msgid "    /* Create a page that will be copied into the faulting region */\n"
msgstr "    /* создаём страницу, которая будет копироваться в ошибочную область */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:602
#, no-wrap
msgid ""
"    if (page == NULL) {\n"
"        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n"
"                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"        if (page == MAP_FAILED)\n"
"            errExit(\"mmap\");\n"
"    }\n"
msgstr ""
"    if (page == NULL) {\n"
"        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n"
"                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"        if (page == MAP_FAILED)\n"
"            errExit(\"mmap\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:605
#, no-wrap
msgid ""
"    /* Loop, handling incoming events on the userfaultfd\n"
"       file descriptor */\n"
msgstr ""
"    /* циклически обрабатываем входные сообщения в\n"
"       файловом дескрипторе userfaultfd */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:609
#, no-wrap
msgid "        /* See what poll() tells us about the userfaultfd */\n"
msgstr "        /* С помощью poll() проверяем userfaultfd */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:617
#, no-wrap
msgid ""
"        struct pollfd pollfd;\n"
"        int nready;\n"
"        pollfd.fd = uffd;\n"
"        pollfd.events = POLLIN;\n"
"        nready = poll(&pollfd, 1, -1);\n"
"        if (nready == -1)\n"
"            errExit(\"poll\");\n"
msgstr ""
"        struct pollfd pollfd;\n"
"        int nready;\n"
"        pollfd.fd = uffd;\n"
"        pollfd.events = POLLIN;\n"
"        nready = poll(&pollfd, 1, -1);\n"
"        if (nready == -1)\n"
"            errExit(\"poll\");\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:623
#, no-wrap
msgid ""
"        printf(\"\\enfault_handler_thread():\\en\");\n"
"        printf(\"    poll() returns: nready = %d; \"\n"
"                \"POLLIN = %d; POLLERR = %d\\en\", nready,\n"
"                (pollfd.revents & POLLIN) != 0,\n"
"                (pollfd.revents & POLLERR) != 0);\n"
msgstr ""
"        printf(\"\\enfault_handler_thread():\\en\");\n"
"        printf(\"    poll() вернул: nready = %d; \"\n"
"                \"POLLIN = %d; POLLERR = %d\\en\", nready,\n"
"                (pollfd.revents & POLLIN) != 0,\n"
"                (pollfd.revents & POLLERR) != 0);\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:625
#, no-wrap
msgid "        /* Read an event from the userfaultfd */\n"
msgstr "        /* читаем событие из userfaultfd */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:631
#, no-wrap
msgid ""
"        nread = read(uffd, &msg, sizeof(msg));\n"
"        if (nread == 0) {\n"
"            printf(\"EOF on userfaultfd!\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        nread = read(uffd, &msg, sizeof(msg));\n"
"        if (nread == 0) {\n"
"            printf(\"EOF в userfaultfd!\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:634
#, no-wrap
msgid ""
"        if (nread == -1)\n"
"            errExit(\"read\");\n"
msgstr ""
"        if (nread == -1)\n"
"            errExit(\"read\");\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:636
#, no-wrap
msgid "        /* We expect only one kind of event; verify that assumption */\n"
msgstr "        /* ожидаем только один тип событий; проверяем, что это так */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:641
#, no-wrap
msgid ""
"        if (msg.event != UFFD_EVENT_PAGEFAULT) {\n"
"            fprintf(stderr, \"Unexpected event on userfaultfd\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (msg.event != UFFD_EVENT_PAGEFAULT) {\n"
"            fprintf(stderr, \"Неожидаемый тип события в userfaultfd\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:643
#, no-wrap
msgid "        /* Display info about the page-fault event */\n"
msgstr "        /* показываем информацию о событии страничной ошибки */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:647
#, no-wrap
msgid ""
"        printf(\"    UFFD_EVENT_PAGEFAULT event: \");\n"
"        printf(\"flags = %llx; \", msg.arg.pagefault.flags);\n"
"        printf(\"address = %llx\\en\", msg.arg.pagefault.address);\n"
msgstr ""
"        printf(\"    событие UFFD_EVENT_PAGEFAULT: \");\n"
"        printf(\"флаги = %llx; \", msg.arg.pagefault.flags);\n"
"        printf(\"адрес = %llx\\en\", msg.arg.pagefault.address);\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:651
#, no-wrap
msgid ""
"        /* Copy the page pointed to by \\(aqpage\\(aq into the faulting\n"
"           region. Vary the contents that are copied in, so that it\n"
"           is more obvious that each fault is handled separately. */\n"
msgstr ""
"        /* копируем страницу, на которую указывает \\(aqpage\\(aq, в ошибочную\n"
"           область. Меняем содержимое, которое копируем для того, чтобы\n"
"           было более очевидно, что каждая ошибка обрабатывается отдельно. */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:654
#, no-wrap
msgid ""
"        memset(page, \\(aqA\\(aq + fault_cnt % 20, page_size);\n"
"        fault_cnt++;\n"
msgstr ""
"        memset(page, \\(aqA\\(aq + fault_cnt % 20, page_size);\n"
"        fault_cnt++;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:656
#, no-wrap
msgid "        uffdio_copy.src = (unsigned long) page;\n"
msgstr "        uffdio_copy.src = (unsigned long) page;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:659
#, no-wrap
msgid ""
"        /* We need to handle page faults in units of pages(!).\n"
"           So, round faulting address down to page boundary */\n"
msgstr ""
"        /* мы должны обрабатывать страничные ошибки в единицах страниц(!).\n"
"           поэтому округляем адрес ошибки по нижней границы страницы */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:667
#, no-wrap
msgid ""
"        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &\n"
"                                           ~(page_size - 1);\n"
"        uffdio_copy.len = page_size;\n"
"        uffdio_copy.mode = 0;\n"
"        uffdio_copy.copy = 0;\n"
"        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)\n"
"            errExit(\"ioctl-UFFDIO_COPY\");\n"
msgstr ""
"        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &\n"
"                                           ~(page_size - 1);\n"
"        uffdio_copy.len = page_size;\n"
"        uffdio_copy.mode = 0;\n"
"        uffdio_copy.copy = 0;\n"
"        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)\n"
"            errExit(\"ioctl-UFFDIO_COPY\");\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:672
#, no-wrap
msgid ""
"        printf(\"        (uffdio_copy.copy returned %lld)\\en\",\n"
"                uffdio_copy.copy);\n"
"    }\n"
"}\n"
msgstr ""
"        printf(\"        (uffdio_copy.copy равно %lld)\\en\",\n"
"                uffdio_copy.copy);\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:683
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    long uffd;          /* userfaultfd file descriptor */\n"
"    char *addr;         /* Start of region handled by userfaultfd */\n"
"    unsigned long len;  /* Length of region handled by userfaultfd */\n"
"    pthread_t thr;      /* ID of thread that handles page faults */\n"
"    struct uffdio_api uffdio_api;\n"
"    struct uffdio_register uffdio_register;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    long uffd;          /* файловый дескриптор userfaultfd */\n"
"    char *addr;         /* Начало области, обрабатываемое userfaultfd */\n"
"    unsigned long len;  /* Размер области, обрабатываемой userfaultfd */\n"
"    pthread_t thr;      /* ID нити, обрабатывающей страничные ошибки */\n"
"    struct uffdio_api uffdio_api;\n"
"    struct uffdio_register uffdio_register;\n"
"    int s;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:688
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s num-pages\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s количество-страниц\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:691
#, no-wrap
msgid ""
"    page_size = sysconf(_SC_PAGE_SIZE);\n"
"    len = strtoul(argv[1], NULL, 0) * page_size;\n"
msgstr ""
"    page_size = sysconf(_SC_PAGE_SIZE);\n"
"    len = strtoul(argv[1], NULL, 0) * page_size;\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:693
#, no-wrap
msgid "    /* Create and enable userfaultfd object */\n"
msgstr "    /* создаём и включаем объект userfaultfd */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:697
#, no-wrap
msgid ""
"    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n"
"    if (uffd == -1)\n"
"        errExit(\"userfaultfd\");\n"
msgstr ""
"    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n"
"    if (uffd == -1)\n"
"        errExit(\"userfaultfd\");\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:702
#, no-wrap
msgid ""
"    uffdio_api.api = UFFD_API;\n"
"    uffdio_api.features = 0;\n"
"    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)\n"
"        errExit(\"ioctl-UFFDIO_API\");\n"
msgstr ""
"    uffdio_api.api = UFFD_API;\n"
"    uffdio_api.features = 0;\n"
"    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)\n"
"        errExit(\"ioctl-UFFDIO_API\");\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:707
#, no-wrap
msgid ""
"    /* Create a private anonymous mapping. The memory will be\n"
"       demand-zero paged--that is, not yet allocated. When we\n"
"       actually touch the memory, it will be allocated via\n"
"       the userfaultfd. */\n"
msgstr ""
"    /* Копируем частное анонимное отображение. Память будет\n"
"       выделена по требованию, то есть реально не выделяется. Когда мы\n"
"       обратимся к памяти, она будет выделена с помощью\n"
"       userfaultfd. */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:712
#, no-wrap
msgid ""
"    addr = mmap(NULL, len, PROT_READ | PROT_WRITE,\n"
"                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"    if (addr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""
"    addr = mmap(NULL, len, PROT_READ | PROT_WRITE,\n"
"                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"    if (addr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:714
#, no-wrap
msgid "    printf(\"Address returned by mmap() = %p\\en\", addr);\n"
msgstr "    printf(\"Адрес, возвращённый mmap() = %p\\en\", addr);\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:718
#, no-wrap
msgid ""
"    /* Register the memory range of the mapping we just created for\n"
"       handling by the userfaultfd object. In mode, we request to track\n"
"       missing pages (i.e., pages that have not yet been faulted in). */\n"
msgstr ""
"    /* Регистрируем в объекте userfaultfd область памяти отображения\n"
"       которое мы только что создали. Запрашиваем режим слежения\n"
"       за отсутствующими страницами (т. е., которые пока не\n"
"       были заполнены). */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:724
#, no-wrap
msgid ""
"    uffdio_register.range.start = (unsigned long) addr;\n"
"    uffdio_register.range.len = len;\n"
"    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n"
"    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)\n"
"        errExit(\"ioctl-UFFDIO_REGISTER\");\n"
msgstr ""
"    uffdio_register.range.start = (unsigned long) addr;\n"
"    uffdio_register.range.len = len;\n"
"    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n"
"    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)\n"
"        errExit(\"ioctl-UFFDIO_REGISTER\");\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:726
#, no-wrap
msgid "    /* Create a thread that will process the userfaultfd events */\n"
msgstr "    /* Создаём нить, которая будет обрабатывать события  userfaultfd */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:732
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);\n"
"    if (s != 0) {\n"
"        errno = s;\n"
"        errExit(\"pthread_create\");\n"
"    }\n"
msgstr ""
"    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);\n"
"    if (s != 0) {\n"
"        errno = s;\n"
"        errExit(\"pthread_create\");\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:736
#, no-wrap
msgid ""
"    /* Main thread now touches memory in the mapping, touching\n"
"       locations 1024 bytes apart. This will trigger userfaultfd\n"
"       events for all pages in the region. */\n"
msgstr ""
"    /* Теперь главная нить обращается к памяти в отображении c\n"
"       интервалом в 1024 байта. Это создаст события в userfaultfd\n"
"       для всех страниц в области. */\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:748
#, no-wrap
msgid ""
"    int l;\n"
"    l = 0xf;    /* Ensure that faulting address is not on a page\n"
"                   boundary, in order to test that we correctly\n"
"                   handle that case in fault_handling_thread() */\n"
"    while (l E<lt> len) {\n"
"        char c = addr[l];\n"
"        printf(\"Read address %p in main(): \", addr + l);\n"
"        printf(\"%c\\en\", c);\n"
"        l += 1024;\n"
"        usleep(100000);         /* Slow things down a little */\n"
"    }\n"
msgstr ""
"    int l;\n"
"    l = 0xf;    /* Гарантируем, что ошибочный адрес не на границе\n"
"                   страницы, чтобы протестировать что, мы правильно\n"
"                   обрабатываем этот случай в fault_handling_thread() */\n"
"    while (l E<lt> len) {\n"
"        char c = addr[l];\n"
"        printf(\"Чтение по адресу %p в main(): \", addr + l);\n"
"        printf(\"%c\\en\", c);\n"
"        l += 1024;\n"
"        usleep(100000);         /* замедлим программу */\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:758
msgid ""
"B<fcntl>(2), B<ioctl>(2), B<ioctl_userfaultfd>(2), B<madvise>(2), B<mmap>(2)"
msgstr ""
"B<fcntl>(2), B<ioctl>(2), B<ioctl_userfaultfd>(2), B<madvise>(2), B<mmap>(2)"

#. type: Plain text
#: man-pages/man2/userfaultfd.2:761
msgid ""
"I<Documentation/admin-guide/mm/userfaultfd.rst> in the Linux kernel source "
"tree"
msgstr ""
"Файл I<Documentation/admin-guide/mm/userfaultfd.rst> из дерева исходного "
"кода ядра Linux"

#. type: TH
#: man-pages/man2/umount.2:30
#, no-wrap
msgid "UMOUNT"
msgstr "UMOUNT"

#. type: Plain text
#: man-pages/man2/umount.2:33
msgid "umount, umount2 - unmount filesystem"
msgstr "umount, umount2 - размонтирует файловую систему"

#. type: Plain text
#: man-pages/man2/umount.2:36
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mount.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/umount.2:38
#, no-wrap
msgid "B<int umount(const char *>I<target>B<);>\n"
msgstr "B<int umount(const char *>I<target>B<);>\n"

#. type: Plain text
#: man-pages/man2/umount.2:40
#, no-wrap
msgid "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"
msgstr "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"

#.  Note: the kernel naming differs from the glibc naming
#.  umount2 is the glibc name for what the kernel now calls umount
#.  and umount is the glibc name for oldumount
#. type: Plain text
#: man-pages/man2/umount.2:50
msgid ""
"B<umount>()  and B<umount2>()  remove the attachment of the (topmost) "
"filesystem mounted on I<target>."
msgstr ""
"Вызовы B<umount>() и B<umount2>() удаляют подключение (самого верхнего "
"уровня) к файловой системе, примонтированной к I<target>."

#. type: Plain text
#: man-pages/man2/umount.2:54
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to unmount filesystems."
msgstr ""
"Для размонтирования файловых систем требуются права (Linux: мандат "
"B<CAP_SYS_ADMIN>)."

#. type: Plain text
#: man-pages/man2/umount.2:62
msgid ""
"Linux 2.1.116 added the B<umount2>()  system call, which, like B<umount>(), "
"unmounts a target, but allows additional I<flags> controlling the behavior "
"of the operation:"
msgstr ""
"В Linux 2.1.116 добавлен системный вызов B<umount2>(), который, подобно "
"B<umount>(), размонтирует заданный объект, но позволяет указать "
"дополнительные флаги I<flags>, контролирующие поведение операции:"

#. type: TP
#: man-pages/man2/umount.2:62
#, no-wrap
msgid "B<MNT_FORCE> (since Linux 2.1.116)"
msgstr "B<MNT_FORCE> (начиная с Linux 2.1.116)"

#. type: Plain text
#: man-pages/man2/umount.2:80
msgid ""
"Ask the filesystem to abort pending requests before attempting the unmount.  "
"This may allow the unmount to complete without waiting for an inaccessible "
"server, but could cause data loss.  If, after aborting requests, some "
"processes still have active references to the filesystem, the unmount will "
"still fail.  As at Linux 4.12, B<MNT_FORCE> is supported only on the "
"following filesystems: 9p (since Linux 2.6.16), ceph (since Linux 2.6.34), "
"cifs (since Linux 2.6.12), fuse (since Linux 2.6.16), lustre (since Linux "
"3.11), and NFS (since Linux 2.1.116)."
msgstr ""
"Попросить файловую систему прервать ожидающие запросы перед попыткой "
"размонтирования. Это может позволить выполнить размонтирование без ожидания "
"недоступного сервера, но может привести к потере данных. Если после "
"прерывания запросов некоторые процессы продолжат обращаться к файловой "
"системе, размонтирование не будет выполнено. В Linux 4.12 B<MNT_FORCE> "
"поддерживается только в следующих файловых системах: 9p (начиная с Linux "
"2.6.16), ceph (начиная с Linux 2.6.34), cifs (начиная с Linux 2.6.12), fuse "
"(начиная с Linux 2.6.16), lustre (начиная с Linux 3.11) и NFS (начиная с "
"Linux 2.1.116)."

#. type: TP
#: man-pages/man2/umount.2:80
#, no-wrap
msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgstr "B<MNT_DETACH> (начиная с Linux 2.4.11)"

#. type: Plain text
#: man-pages/man2/umount.2:86
msgid ""
"Perform a lazy unmount: make the mount point unavailable for new accesses, "
"immediately disconnect the filesystem and all filesystems mounted below it "
"from each other and from the mount table, and actually perform the unmount "
"when the mount point ceases to be busy."
msgstr ""
"Выполнить отложенное размонтирование: сделать точку монтирования недоступной "
"для новых подключений, немедленно размонтировать файловую систему и все "
"файловые системы, смонтированные ниже по дереву и по таблице монтирования, и "
"выполнить настоящее размонтирование только когда точка доступа станет "
"свободной."

#. type: TP
#: man-pages/man2/umount.2:86
#, no-wrap
msgid "B<MNT_EXPIRE> (since Linux 2.6.8)"
msgstr "B<MNT_EXPIRE> (начиная Linux 2.6.8)"

#. type: Plain text
#: man-pages/man2/umount.2:105
msgid ""
"Mark the mount point as expired.  If a mount point is not currently in use, "
"then an initial call to B<umount2>()  with this flag fails with the error "
"B<EAGAIN>, but marks the mount point as expired.  The mount point remains "
"expired as long as it isn't accessed by any process.  A second B<umount2>()  "
"call specifying B<MNT_EXPIRE> unmounts an expired mount point.  This flag "
"cannot be specified with either B<MNT_FORCE> or B<MNT_DETACH>."
msgstr ""
"Пометить точку монтирования как недействительную. Если точка монтирования в "
"это время не используется, то первоначальный вызов B<umount2>() с этим "
"флагом завершится с ошибкой B<EAGAIN>, но пометит точку монтирования как "
"недействительную. Точка монтирования остаётся недействительной до тех пор, "
"пока какой-нибудь процесс не запросит к ней доступ. Второй вызов "
"B<umount2>() с флагом B<MNT_EXPIRE> размонтирует недействительную точку "
"монтирования. Этот флаг нельзя указывать вместе с B<MNT_FORCE> или "
"B<MNT_DETACH>."

#. type: TP
#: man-pages/man2/umount.2:105
#, no-wrap
msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgstr "B<UMOUNT_NOFOLLOW> (начиная с Linux 2.6.34)"

#.  Later added to 2.6.33-stable
#. type: Plain text
#: man-pages/man2/umount.2:113
msgid ""
"Don't dereference I<target> if it is a symbolic link.  This flag allows "
"security problems to be avoided in set-user-ID-I<root> programs that allow "
"unprivileged users to unmount filesystems."
msgstr ""
"Не следовать по ссылке, если I<target> является символьной ссылкой. Это флаг "
"помогает избежать проблем с безопасностью в программах принадлежащих root и "
"с установленным битом set-user-ID, которые позволяют непривилегированным "
"пользователям размонтировать файловые системы."

#. type: Plain text
#: man-pages/man2/umount.2:124
msgid ""
"The error values given below result from filesystem type independent "
"errors.  Each filesystem type may have its own special errors and its own "
"special behavior.  See the Linux kernel source code for details."
msgstr ""
"Коды ошибок, описанные ниже, не зависят от типа файловой системы. У каждой "
"файловой системы могут быть свои коды ошибок и своё собственное поведение. "
"Подробности смотрите в исходном коде ядра Linux."

#. type: TP
#: man-pages/man2/umount.2:124
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/umount.2:131
msgid ""
"A call to B<umount2>()  specifying B<MNT_EXPIRE> successfully marked an "
"unbusy filesystem as expired."
msgstr ""
"Вызов B<umount2>() с флагом B<MNT_EXPIRE> успешно пометил незанятую файловую "
"систему как недействительную."

#. type: TP
#: man-pages/man2/umount.2:131
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/umount.2:135
msgid "I<target> could not be unmounted because it is busy."
msgstr "Объект I<target> не может быть размонтирован, так как он занят."

#. type: Plain text
#: man-pages/man2/umount.2:139
msgid "I<target> points outside the user address space."
msgstr ""
"Объект I<target> указывает вне адресного пространства, доступного "
"пользователю."

#. type: Plain text
#: man-pages/man2/umount.2:143
msgid "I<target> is not a mount point."
msgstr "Значение I<target> не является точкой монтирования."

#. type: Plain text
#: man-pages/man2/umount.2:152
msgid ""
"B<umount2>()  was called with B<MNT_EXPIRE> and either B<MNT_DETACH> or "
"B<MNT_FORCE>."
msgstr ""
"Вызов B<umount2>() был вызван с флагом B<MNT_EXPIRE> и с B<MNT_DETACH> или "
"B<MNT_FORCE>."

#. type: TP
#: man-pages/man2/umount.2:152
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.34)"
msgstr "B<EINVAL> (начиная с Linux 2.6.34)"

#. type: Plain text
#: man-pages/man2/umount.2:157
msgid "B<umount2>()  was called with an invalid flag value in I<flags>."
msgstr "Вызов B<umount2>() был сделан с неверным значением флага I<flags>."

#. type: Plain text
#: man-pages/man2/umount.2:161
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr "Значение пути длиннее чем B<MAXPATHLEN>."

#. type: Plain text
#: man-pages/man2/umount.2:164
msgid "A pathname was empty or had a nonexistent component."
msgstr "Указан пустой путь или одна из его частей не существует."

#. type: Plain text
#: man-pages/man2/umount.2:167
msgid ""
"The kernel could not allocate a free page to copy filenames or data into."
msgstr ""
"Ядро не может выделить свободную страницу для копирования имени файла или "
"данных."

#. type: Plain text
#: man-pages/man2/umount.2:170
msgid "The caller does not have the required privileges."
msgstr "Вызывающий процесс не имеет требуемых привилегий."

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=10092
#. type: Plain text
#: man-pages/man2/umount.2:176
msgid ""
"B<MNT_DETACH> and B<MNT_EXPIRE> are available in glibc since version 2.11."
msgstr ""
"Флаги B<MNT_DETACH> и B<MNT_EXPIRE> доступны в glibc начиная с версии 2.11."

#. type: Plain text
#: man-pages/man2/umount.2:179
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"Эти функции есть только в Linux, и они не должны использоваться в "
"переносимых программах."

#. type: SS
#: man-pages/man2/umount.2:180
#, no-wrap
msgid "umount() and shared mount points"
msgstr "Вызов umount() и общие точки монтирования"

#. type: Plain text
#: man-pages/man2/umount.2:189
msgid ""
"Shared mount points cause any mount activity on a mount point, including "
"B<umount>()  operations, to be forwarded to every shared mount point in the "
"peer group and every slave mount of that peer group.  This means that "
"B<umount>()  of any peer in a set of shared mounts will cause all of its "
"peers to be unmounted and all of their slaves to be unmounted as well."
msgstr ""
"Действия на точку монтирования, являющуюся общей, включая операции "
"B<umount>(), будут переданы каждой общей точке монтирования в этой группе и "
"каждой подчинённой точке монтирования в этой группе. Это означает, что "
"B<umount>() члена из набора общих точек монтирования приведёт к "
"размонтированию всех в его членов, а также всех их подчинённых."

#. type: Plain text
#: man-pages/man2/umount.2:197
msgid ""
"This propagation of unmount activity can be particularly surprising on "
"systems where every mount point is shared by default.  On such systems, "
"recursively bind mounting the root directory of the filesystem onto a "
"subdirectory and then later unmounting that subdirectory with B<MNT_DETACH> "
"will cause every mount in the mount namespace to be lazily unmounted."
msgstr ""
"Это распространение действия размонтирования может быть особенно "
"удивительным в системах, где каждая точка монтирования является общей по "
"умолчанию. В таких системах рекурсивно привязываемое монтирование корневого "
"каталога файловой системы в подкаталог, а затем размонтирование этого "
"подкаталога с B<MNT_DETACH> приведёт к тому, что каждая точка монтирования в "
"пространстве имён монтирования будет размонтирована в отложенном режиме."

#. type: Plain text
#: man-pages/man2/umount.2:212
msgid ""
"To ensure B<umount>()  does not propagate in this fashion, the mount point "
"may be remounted using a B<mount>()  call with a I<mount_flags> argument "
"that includes both B<MS_REC> and B<MS_PRIVATE> prior to B<umount>()  being "
"called."
msgstr ""
"Чтобы B<umount>() также не делал, перед вызовом B<umount>() точка "
"монтирования может быть перемонтирована с помощью вызова B<mount>() с "
"аргументом I<mount_flags>, в который добавлены B<MS_REC> и B<MS_PRIVATE>."

#. type: SS
#: man-pages/man2/umount.2:212
#, no-wrap
msgid "Historical details"
msgstr "Историческая справка"

#. type: Plain text
#: man-pages/man2/umount.2:223
msgid ""
"The original B<umount>()  function was called as I<umount(device)> and would "
"return B<ENOTBLK> when called with something other than a block device.  In "
"Linux 0.98p4, a call I<umount(dir)> was added, in order to support anonymous "
"devices.  In Linux 2.3.99-pre7, the call I<umount(device)> was removed, "
"leaving only I<umount(dir)> (since now devices can be mounted in more than "
"one place, so specifying the device does not suffice)."
msgstr ""
"Изначально функция B<umount>() вызывалась как I<umount(device)> и возвращала "
"B<ENOTBLK> при попытке работы с любым не блочным устройством. В Linux 0.98p4 "
"был добавлен вызов I<umount(dir)> для поддержки анонимных устройств. В Linux "
"2.3.99-pre7 был убран вызов I<umount(device)>, остался только I<umount(dir)> "
"(теперь устройства могут быть подключены более чем к одной точке, поэтому "
"указания только устройства недостаточно)."

#. type: Plain text
#: man-pages/man2/umount.2:228
msgid ""
"B<mount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<mount>(8), "
"B<umount>(8)"
msgstr ""
"B<mount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<mount>(8), "
"B<umount>(8)"

#. type: TH
#: man-pages/man2/unlink.2:33
#, no-wrap
msgid "UNLINK"
msgstr "UNLINK"

#. type: Plain text
#: man-pages/man2/unlink.2:36
msgid "unlink, unlinkat - delete a name and possibly the file it refers to"
msgstr ""
"unlink, unlinkat - удаляет имя и, возможно, файл, на который оно ссылается"

#. type: Plain text
#: man-pages/man2/unlink.2:39
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/unlink.2:41
#, no-wrap
msgid "B<int unlink(const char *>I<pathname>B<);>\n"
msgstr "B<int unlink(const char *>I<pathname>B<);>\n"

#. type: Plain text
#: man-pages/man2/unlink.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант of AT_* */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/unlink.2:46
#, no-wrap
msgid "B<int unlinkat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<);>\n"
msgstr "B<int unlinkat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/unlink.2:54
msgid "B<unlinkat>():"
msgstr "B<unlinkat>():"

#. type: Plain text
#: man-pages/man2/unlink.2:72
msgid ""
"B<unlink>()  deletes a name from the filesystem.  If that name was the last "
"link to a file and no processes have the file open, the file is deleted and "
"the space it was using is made available for reuse."
msgstr ""
"B<unlink>() удаляет имя из файловой системы. Если это имя было последней "
"ссылкой на файл и больше нет процессов, которые держат этот файл открытым, "
"данный файл удаляется и место, которое он занимает, освобождается для "
"дальнейшего использования."

#. type: Plain text
#: man-pages/man2/unlink.2:76
msgid ""
"If the name was the last link to a file but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""
"Если имя было последней ссылкой на файл, но какие-либо процессы всё ещё "
"держат этот файл открытым, файл будет оставлен, пока последний файловый "
"дескриптор, указывающий на него, не будет закрыт."

#. type: Plain text
#: man-pages/man2/unlink.2:78
msgid "If the name referred to a symbolic link, the link is removed."
msgstr "Если имя указывает на символьную ссылку, то будет удалена ссылка."

#. type: Plain text
#: man-pages/man2/unlink.2:82
msgid ""
"If the name referred to a socket, FIFO, or device, the name for it is "
"removed but processes which have the object open may continue to use it."
msgstr ""
"Если имя указывает на сокет, FIFO или устройство, то имя будет удалено, но "
"процессы, которые открыли любой из этих объектов могут продолжать его "
"использовать."

#. type: SS
#: man-pages/man2/unlink.2:82
#, no-wrap
msgid "unlinkat()"
msgstr "unlinkat()"

#. type: Plain text
#: man-pages/man2/unlink.2:95
msgid ""
"The B<unlinkat>()  system call operates in exactly the same way as either "
"B<unlink>()  or B<rmdir>(2)  (depending on whether or not I<flags> includes "
"the B<AT_REMOVEDIR> flag)  except for the differences described here."
msgstr ""
"Системный вызов B<unlinkat>() работает также как B<unlink>() или B<rmdir>(2) "
"(в зависимости от того, есть ли флаг B<AT_REMOVEDIR> во I<flags>), за "
"исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/unlink.2:107
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<unlink>()  and B<rmdir>(2)  for a relative "
"pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<unlink>() и B<rmdir>(2))."

#. type: Plain text
#: man-pages/man2/unlink.2:121
msgid ""
"If the pathname given in I<pathname> is relative and I<dirfd> is the special "
"value B<AT_FDCWD>, then I<pathname> is interpreted relative to the current "
"working directory of the calling process (like B<unlink>()  and B<rmdir>(2))."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<unlink>() и B<rmdir>(2))."

#. type: Plain text
#: man-pages/man2/unlink.2:127
msgid ""
"If the pathname given in I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/unlink.2:133
msgid ""
"I<flags> is a bit mask that can either be specified as 0, or by ORing "
"together flag values that control the operation of B<unlinkat>().  "
"Currently, only one such flag is defined:"
msgstr ""
"Аргумент I<flags> представляет собой битовую маску, значение которой может "
"быть 0, или объединённым значением флагов с помощью OR, определяющих "
"операцию B<unlinkat>(). В настоящее время определён только один флаг:"

#. type: TP
#: man-pages/man2/unlink.2:133
#, no-wrap
msgid "B<AT_REMOVEDIR>"
msgstr "B<AT_REMOVEDIR>"

#. type: Plain text
#: man-pages/man2/unlink.2:148
msgid ""
"By default, B<unlinkat>()  performs the equivalent of B<unlink>()  on "
"I<pathname>.  If the B<AT_REMOVEDIR> flag is specified, then performs the "
"equivalent of B<rmdir>(2)  on I<pathname>."
msgstr ""
"По умолчанию, B<unlinkat>() выполняет действие, эквивалентное B<unlink>() с "
"параметром I<pathname>. Если указан флаг B<AT_REMOVEDIR>, то выполняется "
"действие, эквивалентное B<rmdir>(2) с параметром I<pathname>."

#. type: Plain text
#: man-pages/man2/unlink.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<unlinkat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<unlinkat>()."

#. type: Plain text
#: man-pages/man2/unlink.2:169
msgid ""
"Write access to the directory containing I<pathname> is not allowed for the "
"process's effective UID, or one of the directories in I<pathname> did not "
"allow search permission.  (See also B<path_resolution>(7).)"
msgstr ""
"Для эффективного UID процесса нет прав на запись в каталог, содержащийся в "
"I<pathname>, или в одном из каталогов в I<pathname> не разрешён поиск "
"(смотрите также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/unlink.2:178
msgid ""
"The file I<pathname> cannot be unlinked because it is being used by the "
"system or another process; for example, it is a mount point or the NFS "
"client software created it to represent an active but otherwise nameless "
"inode (\"NFS silly renamed\")."
msgstr ""
"Файл I<pathname> не может быть удалён, так как он ещё используется системой "
"или другим процессом; например, это точка монтирования или его создал клиент "
"NFS для представления активной, но пока безымянной inode («NFS silly "
"renamed»)."

#. type: Plain text
#: man-pages/man2/unlink.2:182
msgid "I<pathname> points outside your accessible address space."
msgstr ""
"Аргумент I<pathname> указывает за пределы доступного адресного пространства."

#. type: TP
#: man-pages/man2/unlink.2:182
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/unlink.2:185
msgid "An I/O error occurred."
msgstr "Произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/unlink.2:185 man-pages/man2/unlink.2:261
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: man-pages/man2/unlink.2:190
msgid ""
"I<pathname> refers to a directory.  (This is the non-POSIX value returned by "
"Linux since 2.1.132.)"
msgstr ""
"I<pathname> ссылается на каталог. (Этого значения нет в POSIX, возвращается "
"в Linux начиная с 2.1.132.)"

#. type: Plain text
#: man-pages/man2/unlink.2:194
msgid "Too many symbolic links were encountered in translating I<pathname>."
msgstr ""
"Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/unlink.2:197
msgid "I<pathname> was too long."
msgstr "I<pathname> слишком длинен."

#. type: Plain text
#: man-pages/man2/unlink.2:204
msgid ""
"A component in I<pathname> does not exist or is a dangling symbolic link, or "
"I<pathname> is empty."
msgstr ""
"Компонент I<pathname> не существует, является повисшей ссылкой или "
"I<pathname> пуст."

#. type: Plain text
#: man-pages/man2/unlink.2:212
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr ""
"Компонент пути, использованный как каталог в I<pathname>, в действительности "
"таковым не является."

#. type: Plain text
#: man-pages/man2/unlink.2:221
msgid ""
"The system does not allow unlinking of directories, or unlinking of "
"directories requires privileges that the calling process doesn't have.  "
"(This is the POSIX prescribed error return; as noted above, Linux returns "
"B<EISDIR> for this case.)"
msgstr ""
"Система не разрешает удаление каталогов или для удаления каталогов требуются "
"права, которыми не обладает вызвавший процесс. (Этот код ошибки предусмотрен "
"в POSIX; как описано выше, в Linux в этом случае возвращается B<EISDIR>.)"

#. type: TP
#: man-pages/man2/unlink.2:221
#, no-wrap
msgid "B<EPERM> (Linux only)"
msgstr "B<EPERM> (только в Linux)"

#. type: Plain text
#: man-pages/man2/unlink.2:224
msgid "The filesystem does not allow unlinking of files."
msgstr "Файловая система не позволяет удаление файлов."

#. type: TP
#: man-pages/man2/unlink.2:224
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr "B<EPERM> или B<EACCES>"

#. type: Plain text
#: man-pages/man2/unlink.2:235
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective UID is neither the UID of the file to be deleted "
"nor that of the directory containing it, and the process is not privileged "
"(Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""
"На каталоге, содержащемся в I<pathname>, установлен закрепляющий бит "
"(B<S_ISVTX>) и эффективный UID процесса не совпадает ни с UID удаляемого "
"файла, ни с каталогом, в котором он содержится, и у процесса нет прав "
"(Linux: нет мандата B<CAP_FOWNER>)."

#. type: Plain text
#: man-pages/man2/unlink.2:240
msgid ""
"The file to be unlinked is marked immutable or append-only.  (See "
"B<ioctl_iflags>(2).)"
msgstr ""
"Файл для удаления помечен как неизменяемый (immutable) или только для "
"добавления (смотрите B<ioctl_iflags>(2))."

#. type: Plain text
#: man-pages/man2/unlink.2:244
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr ""
"I<pathname> указывает на файл в файловой системе, доступной только для "
"чтения."

#. type: Plain text
#: man-pages/man2/unlink.2:253
msgid ""
"The same errors that occur for B<unlink>()  and B<rmdir>(2)  can also occur "
"for B<unlinkat>().  The following additional errors can occur for "
"B<unlinkat>():"
msgstr ""
"В B<unlinkat>() могут возникнуть те же ошибки, что и в B<unlink>() и "
"B<rmdir>(2). Также, в B<unlinkat>() могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/unlink.2:257
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/unlink.2:261
msgid "An invalid flag value was specified in I<flags>."
msgstr "В I<flags> указано неверное значение флага."

#. type: Plain text
#: man-pages/man2/unlink.2:268
msgid ""
"I<pathname> refers to a directory, and B<AT_REMOVEDIR> was not specified in "
"I<flags>."
msgstr ""
"Значение I<pathname> ссылается на каталог и в I<flags> не указан "
"B<AT_REMOVEDIR>."

#. type: Plain text
#: man-pages/man2/unlink.2:274
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/unlink.2:278
msgid ""
"B<unlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Системный вызов B<unlinkat>() был добавлен в ядро Linux версии 2.6.16; "
"поддержка в glibc доступна с версии 2.4."

#.  SVr4 documents additional error
#.  conditions EINTR, EMULTIHOP, ETXTBSY, ENOLINK.
#. type: Plain text
#: man-pages/man2/unlink.2:283
msgid "B<unlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<unlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/unlink.2:286
msgid "B<unlinkat>(): POSIX.1-2008."
msgstr "B<unlinkat>(): POSIX.1-2008."

#. type: SS
#: man-pages/man2/unlink.2:287
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#. type: Plain text
#: man-pages/man2/unlink.2:302
msgid ""
"On older kernels where B<unlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<unlink>()  or B<rmdir>(2).  When "
"I<pathname> is a relative pathname, glibc constructs a pathname based on the "
"symbolic link in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""
"В старых ядрах, где B<unlinkat>() отсутствует, обёрточная функция glibc "
"использует B<unlink>(2) или B<rmdir>(2). Если I<pathname> является "
"относительным путём, то glibc собирает путь относительно символической "
"ссылки в I</proc/self/fd>, которая соответствует аргументу I<dirfd>."

#. type: Plain text
#: man-pages/man2/unlink.2:305
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""
"Неточности в протоколе NFS могут приводить к неожиданному исчезновению "
"файлов, которые всё ещё используются."

#. type: Plain text
#: man-pages/man2/unlink.2:317
msgid ""
"B<rm>(1), B<unlink>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), "
"B<rename>(2), B<rmdir>(2), B<mkfifo>(3), B<remove>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<rm>(1), B<unlink>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), "
"B<rename>(2), B<rmdir>(2), B<mkfifo>(3), B<remove>(3), "
"B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man5/utmp.5:30
#, no-wrap
msgid "UTMP"
msgstr "UTMP"

#. type: Plain text
#: man-pages/man5/utmp.5:33
msgid "utmp, wtmp - login records"
msgstr "utmp, wtmp - записи о входах в систему"

#. type: Plain text
#: man-pages/man5/utmp.5:35
msgid "B<#include E<lt>utmp.hE<gt>>"
msgstr "B<#include E<lt>utmp.hE<gt>>"

#. type: Plain text
#: man-pages/man5/utmp.5:42
msgid ""
"The I<utmp> file allows one to discover information about who is currently "
"using the system.  There may be more users currently using the system, "
"because not all programs use utmp logging."
msgstr ""
"Файл I<utmp> позволяет получать информацию о том, кто в данный момент "
"работает в системе. Пользователей, в данное время использующих систему, "
"может быть большое количество, поскольку не все программы используют "
"протоколирование через utmp."

#. type: Plain text
#: man-pages/man5/utmp.5:52
msgid ""
"B<Warning:> I<utmp> must not be writable by the user class \"other\", "
"because many system programs (foolishly)  depend on its integrity.  You risk "
"faked system logfiles and modifications of system files if you leave I<utmp> "
"writable to any user other than the owner and group owner of the file."
msgstr ""
"B<Предупреждение:> I<utmp> не должен быть доступен на запись классу "
"пользователей \"остальные\", так как многие системные программы (что очень "
"глупо) зависят от его целостности. Вы рискуете получить фиктивные системные "
"файлы статистики и изменения в системных файлах, если предоставите любому "
"пользователю возможность писать в файл I<utmp> кроме владельца и группы, "
"которой принадлежит файл."

#. type: Plain text
#: man-pages/man5/utmp.5:60
msgid ""
"The file is a sequence of I<utmp> structures, declared as follows in "
"I<E<lt>utmp.hE<gt>> (note that this is only one of several definitions "
"around; details depend on the version of libc):"
msgstr ""
"Файл состоит из списка записей с типом структуры I<utmp>, объявленной в "
"I<E<lt>utmp.hE<gt>> (заметим, что в данном случае указано только один из "
"вариантов; детали зависят от версии libc):"

#. type: Plain text
#: man-pages/man5/utmp.5:64
#, no-wrap
msgid "/* Values for ut_type field, below */\n"
msgstr "/* Значения поля ut_type приведены далее */\n"

#. type: Plain text
#: man-pages/man5/utmp.5:79
#, no-wrap
msgid ""
"#define EMPTY         0 /* Record does not contain valid info\n"
"                           (formerly known as UT_UNKNOWN on Linux) */\n"
"#define RUN_LVL       1 /* Change in system run-level (see\n"
"                           B<init>(8)) */\n"
"#define BOOT_TIME     2 /* Time of system boot (in I<ut_tv>) */\n"
"#define NEW_TIME      3 /* Time after system clock change\n"
"                           (in I<ut_tv>) */\n"
"#define OLD_TIME      4 /* Time before system clock change\n"
"                           (in I<ut_tv>) */\n"
"#define INIT_PROCESS  5 /* Process spawned by B<init>(8) */\n"
"#define LOGIN_PROCESS 6 /* Session leader process for user login */\n"
"#define USER_PROCESS  7 /* Normal process */\n"
"#define DEAD_PROCESS  8 /* Terminated process */\n"
"#define ACCOUNTING    9 /* Not implemented */\n"
msgstr ""
"#define EMPTY         0 /* запись не содержит корректной информации\n"
"                           (также называемая UT_UNKNOWN в Linux) */\n"
"#define RUN_LVL       1 /* изменение уровня выполнения (см.\n"
"                           B<init>(8)) */\n"
"#define BOOT_TIME     2 /* время загрузки системы (в I<ut_tv>) */\n"
"#define NEW_TIME      3 /* время после изменения часов системы\n"
"                           (в I<ut_tv>) */\n"
"#define OLD_TIME      4 /* время до изменения часов в системе\n"
"                           (в I<ut_tv>) */\n"
"#define INIT_PROCESS  5 /* процесс запущен B<init>(8) */\n"
"#define LOGIN_PROCESS 6 /* процесс-лидер сеанса для пользовательского входа */\n"
"#define USER_PROCESS  7 /* нормальный процесс */\n"
"#define DEAD_PROCESS  8 /* завершённый процесс */\n"
"#define ACCOUNTING    9 /* не реализовано */\n"

#. type: Plain text
#: man-pages/man5/utmp.5:83
#, no-wrap
msgid ""
"#define UT_LINESIZE      32\n"
"#define UT_NAMESIZE      32\n"
"#define UT_HOSTSIZE     256\n"
msgstr ""
"#define UT_LINESIZE      32\n"
"#define UT_NAMESIZE      32\n"
"#define UT_HOSTSIZE     256\n"

#. type: Plain text
#: man-pages/man5/utmp.5:88
#, no-wrap
msgid ""
"struct exit_status {              /* Type for ut_exit, below */\n"
"    short int e_termination;      /* Process termination status */\n"
"    short int e_exit;             /* Process exit status */\n"
"};\n"
msgstr ""
"struct exit_status {              /* тип для ut_exit, описан далее */\n"
"    short int e_termination;      /* код завершения процесса */\n"
"    short int e_exit;             /* код выхода процесса */\n"
"};\n"

#. type: Plain text
#: man-pages/man5/utmp.5:116
#, no-wrap
msgid ""
"struct utmp {\n"
"    short   ut_type;              /* Type of record */\n"
"    pid_t   ut_pid;               /* PID of login process */\n"
"    char    ut_line[UT_LINESIZE]; /* Device name of tty - \"/dev/\" */\n"
"    char    ut_id[4];             /* Terminal name suffix,\n"
"                                     or inittab(5) ID */\n"
"    char    ut_user[UT_NAMESIZE]; /* Username */\n"
"    char    ut_host[UT_HOSTSIZE]; /* Hostname for remote login, or\n"
"                                     kernel version for run-level\n"
"                                     messages */\n"
"    struct  exit_status ut_exit;  /* Exit status of a process\n"
"                                     marked as DEAD_PROCESS; not\n"
"                                     used by Linux init (1 */\n"
"    /* The ut_session and ut_tv fields must be the same size when\n"
"       compiled 32- and 64-bit.  This allows data files and shared\n"
"       memory to be shared between 32- and 64-bit applications. */\n"
"#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32\n"
"    int32_t ut_session;           /* Session ID (B<getsid>(2)),\n"
"                                     used for windowing */\n"
"    struct {\n"
"        int32_t tv_sec;           /* Seconds */\n"
"        int32_t tv_usec;          /* Microseconds */\n"
"    } ut_tv;                      /* Time entry was made */\n"
"#else\n"
"     long   ut_session;           /* Session ID */\n"
"     struct timeval ut_tv;        /* Time entry was made */\n"
"#endif\n"
msgstr ""
"struct utmp {\n"
"    short   ut_type;              /* тип записи */\n"
"    pid_t   ut_pid;               /* PID процесса входа в систему */\n"
"    char    ut_line[UT_LINESIZE]; /* имя устройства tty - \"/dev/\" */\n"
"    char    ut_id[4];             /* суффикс имени терминала\n"
"                                     или inittab(5) ID */\n"
"    char    ut_user[UT_NAMESIZE]; /* имя пользователя */\n"
"    char    ut_host[UT_HOSTSIZE]; /* имя узла при удалённом входе или\n"
"                                     версия ядра для сообщений\n"
"                                     уровня выполнения */\n"
"    struct  exit_status ut_exit;  /* код выхода процесса,\n"
"                                     помеченного как DEAD_PROCESS; не\n"
"                                     используется Linux init(1) */\n"
"    /* Поля ut_session и ut_tv должны быть одинакового размера и при\n"
"       32- и при 64-битной компиляции. Это позволяет использовать файлы\n"
"       данных и память одновременно и в 32- и в 64-битных приложениях. */\n"
"#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32\n"
"    int32_t ut_session;           /* ID сеанса (B<getsid>(2)),\n"
"                                     используемый при работе с окнами */\n"
"    struct {\n"
"        int32_t tv_sec;           /* секунды */\n"
"        int32_t tv_usec;          /* микросекунды */\n"
"    } ut_tv;                      /* время создания элемента */\n"
"#else\n"
"     long   ut_session;           /* ID сеанса */\n"
"     struct timeval ut_tv;        /* время создания элемента */\n"
"#endif\n"

#. type: Plain text
#: man-pages/man5/utmp.5:122
#, no-wrap
msgid ""
"    int32_t ut_addr_v6[4];        /* Internet address of remote\n"
"                                     host; IPv4 address uses\n"
"                                     just ut_addr_v6[0] */\n"
"    char __unused[20];            /* Reserved for future use */\n"
"};\n"
msgstr ""
"    int32_t ut_addr_v6[4];        /* интернет-адрес удалённого\n"
"                                     узла; для адреса IPv4 используется\n"
"                                     только ut_addr_v6[0] */\n"
"    char __unused[20];            /* зарезервировано для будущего\n"
"                                     использования */\n"
"};\n"

#. type: Plain text
#: man-pages/man5/utmp.5:130
#, no-wrap
msgid ""
"/* Backward compatibility hacks */\n"
"#define ut_name ut_user\n"
"#ifndef _NO_UT_TIME\n"
"#define ut_time ut_tv.tv_sec\n"
"#endif\n"
"#define ut_xtime ut_tv.tv_sec\n"
"#define ut_addr ut_addr_v6[0]\n"
msgstr ""
"/* разное для обратной совместимости */\n"
"#define ut_name ut_user\n"
"#ifndef _NO_UT_TIME\n"
"#define ut_time ut_tv.tv_sec\n"
"#endif\n"
"#define ut_xtime ut_tv.tv_sec\n"
"#define ut_addr ut_addr_v6[0]\n"

#. type: Plain text
#: man-pages/man5/utmp.5:140
msgid ""
"This structure gives the name of the special file associated with the user's "
"terminal, the user's login name, and the time of login in the form of "
"B<time>(2).  String fields are terminated by a null byte (\\(aq\\e0\\(aq)  "
"if they are shorter than the size of the field."
msgstr ""
"Эта структура дает имя специальному файлу, связанному с терминалом "
"пользователя, именем входа пользователя и временем входа в виде как у "
"B<time>(2). Поля строк заканчиваются байтом null (\\(aq\\e\\(aq), если они "
"короче, чем размер поля."

#. type: Plain text
#: man-pages/man5/utmp.5:157
msgid ""
"The first entries ever created result from B<init>(1)  processing "
"B<inittab>(5).  Before an entry is processed, though, B<init>(1)  cleans up "
"utmp by setting I<ut_type> to B<DEAD_PROCESS>, clearing I<ut_user>, "
"I<ut_host>, and I<ut_time> with null bytes for each record which I<ut_type> "
"is not B<DEAD_PROCESS> or B<RUN_LVL> and where no process with PID I<ut_pid> "
"exists.  If no empty record with the needed I<ut_id> can be found, "
"B<init>(1)  creates a new one.  It sets I<ut_id> from the inittab, I<ut_pid> "
"and I<ut_time> to the current values, and I<ut_type> to B<INIT_PROCESS>."
msgstr ""
"Самые первые записи создаются B<init>(1) после обработки B<inittab>(5). Хотя "
"перед тем, как элемент обрабатывается, B<init>(1) очищает utmp, устанавливая "
"I<ut_type> равным B<DEAD_PROCESS>, заполняя I<ut_user>, I<ut_host> и "
"I<ut_time> нулевыми байтами в записях, в которых I<ut_type> не равен "
"B<DEAD_PROCESS> или B<RUN_LVL> и для которых не существует процессов с PID, "
"равным I<ut_pid>. Если не найдено ни одной пустой записи с нужным I<ut_id>, "
"то B<init>(1) создает новую. Он устанавливает значение I<ut_id> из inittab, "
"I<ut_pid> и I<ut_time> из текущих значений и I<ut_type> в B<INIT_PROCESS>."

#. type: Plain text
#: man-pages/man5/utmp.5:176
msgid ""
"B<mingetty>(8)  (or B<agetty>(8))  locates the entry by the PID, changes "
"I<ut_type> to B<LOGIN_PROCESS>, changes I<ut_time>, sets I<ut_line>, and "
"waits for connection to be established.  B<login>(1), after a user has been "
"authenticated, changes I<ut_type> to B<USER_PROCESS>, changes I<ut_time>, "
"and sets I<ut_host> and I<ut_addr>.  Depending on B<mingetty>(8)  (or "
"B<agetty>(8))  and B<login>(1), records may be located by I<ut_line> instead "
"of the preferable I<ut_pid>."
msgstr ""
"B<mingetty>(8) (или B<agetty>(8)) находит элементы по их идентификатору PID, "
"меняет I<ut_type> на B<LOGIN_PROCESS>, изменяет I<ut_time>, устанавливает "
"I<ut_line> и ожидает установки соединения.B<login>(1), после того как "
"пользователь был идентифицирован, меняет I<ut_type> на B<USER_PROCESS>, "
"изменяет I<ut_time> и устанавливает I<ut_host> и I<ut_addr>. В зависимости "
"от B<mingetty>(8) (или B<agetty>(8)) и B<login>(1), записи могут быть "
"расположены в соответствии с I<ut_line>, вместо более предпочитаемого "
"I<ut_pid>."

#. type: Plain text
#: man-pages/man5/utmp.5:182
msgid ""
"When B<init>(1)  finds that a process has exited, it locates its utmp entry "
"by I<ut_pid>, sets I<ut_type> to B<DEAD_PROCESS>, and clears I<ut_user>, "
"I<ut_host> and I<ut_time> with null bytes."
msgstr ""
"Когда B<init>(1) обнаруживает, что процесс завершился, он находит его запись "
"в utmp по I<ut_pid>, устанавливает I<ut_type> в B<DEAD_PROCESS>, и затирает "
"I<ut_user>, I<ut_host> и I<ut_time> нулями."

#. type: Plain text
#: man-pages/man5/utmp.5:194
msgid ""
"B<xterm>(1)  and other terminal emulators directly create a B<USER_PROCESS> "
"record and generate the I<ut_id> by using the string that suffix part of the "
"terminal name (the characters following I</dev/[pt]ty>).  If they find a "
"B<DEAD_PROCESS> for this ID, they recycle it, otherwise they create a new "
"entry.  If they can, they will mark it as B<DEAD_PROCESS> on exiting and it "
"is advised that they null I<ut_line>, I<ut_time>, I<ut_user>, and I<ut_host> "
"as well."
msgstr ""
"B<xterm>(1) и другие эмуляторы терминалов самостоятельно создают запись "
"B<USER_PROCESS> и генерируют I<ut_id>, используя последние две буквы имени "
"из имени терминала (символы после I</dev/[pt]ty>). Если они обнаруживают "
"B<DEAD_PROCESS> для этого ID, то они удаляют его или создают новый элемент. "
"Если возможно, они пометят его как B<DEAD_PROCESS> при выходе; "
"предполагается, что они также обнуляют I<ut_line>, I<ut_time>, I<ut_user> и "
"I<ut_host>."

#. type: Plain text
#: man-pages/man5/utmp.5:202
msgid ""
"B<telnetd>(8)  sets up a B<LOGIN_PROCESS> entry and leaves the rest to "
"B<login>(1)  as usual.  After the telnet session ends, B<telnetd>(8)  cleans "
"up utmp in the described way."
msgstr ""
"B<telnetd>(8)  устанавливает элемент B<LOGIN_PROCESS> и оставляет остальное, "
"как обычно, аргументу для B<login>(1). После завершения сеанса telnet, "
"B<telnetd>(8) очищает utmp вышеописанным путем."

#. type: Plain text
#: man-pages/man5/utmp.5:224
msgid ""
"The I<wtmp> file records all logins and logouts.  Its format is exactly like "
"I<utmp> except that a null username indicates a logout on the associated "
"terminal.  Furthermore, the terminal name B<~> with username B<shutdown> or "
"B<reboot> indicates a system shutdown or reboot and the pair of terminal "
"names B<|>/B<}> logs the old/new system time when B<date>(1)  changes it.  "
"I<wtmp> is maintained by B<login>(1), B<init>(1), and some versions of "
"B<getty>(8)  (e.g., B<mingetty>(8)  or B<agetty>(8)).  None of these "
"programs creates the file, so if it is removed, record-keeping is turned off."
msgstr ""
"В файл I<wtmp> записываются все входы и выходы в систему. Его формат в "
"точности похож на формат I<utmp>, за исключением того, что пустое имя "
"пользователя означает выход из системы через связанный терминал. Кроме того, "
"название терминала B<~> с именем пользователя B<shutdown> или B<reboot> "
"означает выключение системы или её перезагрузку, а пара названий терминала "
"B<|>/B<}> означает старое/новое системное время в случае, когда B<date>(1) "
"меняет их. В I<wtmp> пишут B<login>(1), B<init>(1) и некоторые версии "
"B<getty>(8) (например, B<mingetty>(8) или B<agetty>(8)). Ни одна из этих "
"программ не создает файл, поэтому если он удалён, то ведение записей "
"заканчивается."

#. type: Plain text
#: man-pages/man5/utmp.5:226
msgid "I</var/run/utmp>"
msgstr "I</var/run/utmp>"

#. type: Plain text
#: man-pages/man5/utmp.5:228
msgid "I</var/log/wtmp>"
msgstr "I</var/log/wtmp>"

#. type: Plain text
#: man-pages/man5/utmp.5:247
msgid ""
"POSIX.1 does not specify a I<utmp> structure, but rather one named I<utmpx>, "
"with specifications for the fields I<ut_type>, I<ut_pid>, I<ut_line>, "
"I<ut_id>, I<ut_user>, and I<ut_tv>.  POSIX.1 does not specify the lengths of "
"the I<ut_line> and I<ut_user> fields."
msgstr ""
"В POSIX.1 структура I<utmp> не определена, но есть похожая с именем I<utmpx> "
"и полями I<ut_type>, I<ut_pid>, I<ut_line>, I<ut_id>, I<ut_user> и I<ut_tv>. "
"В POSIX.1 не указан размер полей I<ut_line> и I<ut_user>."

#. type: Plain text
#: man-pages/man5/utmp.5:253
msgid ""
"Linux defines the I<utmpx> structure to be the same as the I<utmp> structure."
msgstr "В Linux структура I<utmpx> совпадает со структурой I<utmp>."

#. type: SS
#: man-pages/man5/utmp.5:253
#, no-wrap
msgid "Comparison with historical systems"
msgstr "Сравнение со старыми системами"

#. type: Plain text
#: man-pages/man5/utmp.5:256
msgid ""
"Linux utmp entries conform neither to v7/BSD nor to System V; they are a mix "
"of the two."
msgstr ""
"В Linux записи utmp не следуют форматам ни v7/BSD ни System V; они содержат "
"поля из обоих форматов."

#. type: Plain text
#: man-pages/man5/utmp.5:263
msgid ""
"v7/BSD has fewer fields; most importantly it lacks I<ut_type>, which causes "
"native v7/BSD-like programs to display (for example) dead or login entries.  "
"Further, there is no configuration file which allocates slots to sessions.  "
"BSD does so because it lacks I<ut_id> fields."
msgstr ""
"v7/BSD имеет меньшее количество полей; важнее всего то, что в нём нет "
"I<ut_type>, который заставляет v7/BSD-совместимые программы выводить, к "
"примеру, отработавшие записи или записи о входе систему. Также в этой версии "
"отсутствует файл настройки, который определяет места для сеансов. Всё это "
"делается в BSD из-за отсутствия поля I<ut_id>."

#. type: Plain text
#: man-pages/man5/utmp.5:275
msgid ""
"In Linux (as in System V), the I<ut_id> field of a record will never change "
"once it has been set, which reserves that slot without needing a "
"configuration file.  Clearing I<ut_id> may result in race conditions leading "
"to corrupted utmp entries and potential security holes.  Clearing the "
"abovementioned fields by filling them with null bytes is not required by "
"System V semantics, but makes it possible to run many programs which assume "
"BSD semantics and which do not modify utmp.  Linux uses the BSD conventions "
"for line contents, as documented above."
msgstr ""
"В Linux (как в System V) поле I<ut_id> записи никогда не меняется после "
"того, как один раз установлено, что позволяет резервировать место без "
"необходимости в файле настройки. Очищение I<ut_id> может привести к "
"соперничеству, приводящему к повреждению элементов utmp и нарушению "
"безопасности системы. Очистка вышеупомянутых полей нулями не требуется "
"согласно семантике System V, но позволяет запускать многие программы, "
"которые используют семантику BSD и которые не изменяют utmp. Linux "
"использует соглашение BSD при работе с содержимым строк, как описано ранее."

#.  mtk: What is the referrent of "them" in the following sentence?
#.  System V only uses the type field to mark them and logs
#.  informative messages such as \fB"new time"\fP in the line field.
#. type: Plain text
#: man-pages/man5/utmp.5:280
msgid "System V has no I<ut_host> or I<ut_addr_v6> fields."
msgstr "В System V нет полей I<ut_host> и I<ut_addr_v6>."

#. type: Plain text
#: man-pages/man5/utmp.5:288
msgid ""
"Unlike various other systems, where utmp logging can be disabled by removing "
"the file, utmp must always exist on Linux.  If you want to disable "
"B<who>(1), then do not make utmp world readable."
msgstr ""
"В отличии от других систем, где протоколирование сообщений utmp может быть "
"выключено простым удалением файла, в Linux файл utmp всегда должен "
"существовать. Если вы хотите отключить B<who>(1), то просто сделайте чтение "
"utmp недоступным всем остальным."

#. type: Plain text
#: man-pages/man5/utmp.5:291
msgid ""
"The file format is machine-dependent, so it is recommended that it be "
"processed only on the machine architecture where it was created."
msgstr ""
"Формат файла зависит от архитектуры, поэтому рекомендуется, чтобы он "
"обрабатывался только на машинах с одинаковой архитектурой."

#. type: Plain text
#: man-pages/man5/utmp.5:312
msgid ""
"Note that on I<biarch> platforms, that is, systems which can run both 32-bit "
"and 64-bit applications (x86-64, ppc64, s390x, etc.), I<ut_tv> is the same "
"size in 32-bit mode as in 64-bit mode.  The same goes for I<ut_session> and "
"I<ut_time> if they are present.  This allows data files and shared memory to "
"be shared between 32-bit and 64-bit applications.  This is achieved by "
"changing the type of I<ut_session> to I<int32_t>, and that of I<ut_tv> to a "
"struct with two I<int32_t> fields I<tv_sec> and I<tv_usec>.  Since I<ut_tv> "
"may not be the same as I<struct timeval>, then instead of the call:"
msgstr ""
"Заметим, что на I<двуархитектурных> платформах, то есть системах, которые "
"позволяют запускать сразу 32- и 64-битные приложения (x86-64, ppc64, s390x и "
"т.д.), поле I<ut_tv> имеет одинаковый размер в 32- и 64-битном режиме. Это "
"же относится к I<ut_session> и I<ut_time>, если они есть. Это позволяет "
"использовать файлы данных и память одновременно и в 32- и в 64-битных "
"приложениях. Данная возможность достигается сменой типа I<ut_session> на "
"I<int32_t> и I<ut_tv> на структуру с двумя полями I<int32_t> \\(em I<tv_sec> "
"и I<tv_usec>. Так как I<ut_tv> не может быть одинакова с I<struct timeval>, "
"то вместо вызова:"

#. type: Plain text
#: man-pages/man5/utmp.5:316
#, no-wrap
msgid "gettimeofday((struct timeval *) &ut.ut_tv, NULL);\n"
msgstr "gettimeofday((struct timeval *) &ut.ut_tv, NULL);\n"

#. type: Plain text
#: man-pages/man5/utmp.5:320
msgid "the following method of setting this field is recommended:"
msgstr "для установки значения этого поля рекомендуется использовать:"

#. type: Plain text
#: man-pages/man5/utmp.5:325
#, no-wrap
msgid ""
"struct utmp ut;\n"
"struct timeval tv;\n"
msgstr ""
"struct utmp ut;\n"
"struct timeval tv;\n"

#. type: Plain text
#: man-pages/man5/utmp.5:329
#, no-wrap
msgid ""
"gettimeofday(&tv, NULL);\n"
"ut.ut_tv.tv_sec = tv.tv_sec;\n"
"ut.ut_tv.tv_usec = tv.tv_usec;\n"
msgstr ""
"gettimeofday(&tv, NULL);\n"
"ut.ut_tv.tv_sec = tv.tv_sec;\n"
"ut.ut_tv.tv_usec = tv.tv_usec;\n"

#. type: Plain text
#: man-pages/man5/utmp.5:354
msgid ""
"B<ac>(1), B<date>(1), B<init>(1), B<last>(1), B<login>(1), B<logname>(1), "
"B<lslogins>(1), B<users>(1), B<utmpdump>(1), B<who>(1), B<getutent>(3), "
"B<getutmp>(3), B<login>(3), B<logout>(3), B<logwtmp>(3), B<updwtmp>(3)"
msgstr ""
"B<ac>(1), B<date>(1), B<init>(1), B<last>(1), B<login>(1), B<logname>(1), "
"B<lslogins>(1), B<users>(1), B<utmpdump>(1), B<who>(1), B<getutent>(3), "
"B<getutmp>(3), B<login>(3), B<logout>(3), B<logwtmp>(3), B<updwtmp>(3)"

#. type: TH
#: man-pages/man3/usleep.3:33
#, no-wrap
msgid "USLEEP"
msgstr "USLEEP"

#. type: Plain text
#: man-pages/man3/usleep.3:36
msgid "usleep - suspend execution for microsecond intervals"
msgstr "usleep - задерживает выполнение на определенное количество микросекунд"

#. type: Plain text
#: man-pages/man3/usleep.3:41
#, no-wrap
msgid "B<int usleep(useconds_t >I<usec>B<);>\n"
msgstr "B<int usleep(useconds_t >I<usec>B<);>\n"

#. type: Plain text
#: man-pages/man3/usleep.3:49
msgid "B<usleep>():"
msgstr "B<usleep>():"

#. type: TP
#: man-pages/man3/usleep.3:52
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/usleep.3:58
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версиях glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/usleep.3:63
msgid "Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "До glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/usleep.3:74
msgid ""
"The B<usleep>()  function suspends execution of the calling thread for (at "
"least) I<usec> microseconds.  The sleep may be lengthened slightly by any "
"system activity or by the time spent processing the call or by the "
"granularity of system timers."
msgstr ""
"Функция B<usleep>() приостанавливает выполнение вызвавшей нити на (не менее) "
"I<usec> микросекунд. Остановка может продлиться слегка больше при большой "
"загруженности системы, из-за, собственно, времени обработки этого вызова или "
"из-за неточности хода системных часов."

#. type: Plain text
#: man-pages/man3/usleep.3:81
msgid ""
"The B<usleep>()  function returns 0 on success.  On error, -1 is returned, "
"with I<errno> set to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<usleep>() возвращается 0. При ошибке возвращается "
"-1, а в I<errno> содержится код ошибки."

#. type: TP
#: man-pages/man3/usleep.3:82
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man3/usleep.3:86
msgid "Interrupted by a signal; see B<signal>(7)."
msgstr "Прервано сигналом; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man3/usleep.3:90
msgid ""
"I<usec> is greater than or equal to 1000000.  (On systems where that is "
"considered an error.)"
msgstr ""
"Значение I<usec> больше или равно 1000000 (в тех системах, где это считается "
"ошибкой)."

#. type: tbl table
#: man-pages/man3/usleep.3:100
#, no-wrap
msgid "B<usleep>()"
msgstr "B<usleep>()"

#. type: Plain text
#: man-pages/man3/usleep.3:109
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 declares this function obsolete; use "
"B<nanosleep>(2)  instead.  POSIX.1-2008 removes the specification of "
"B<usleep>()."
msgstr ""
"4.3BSD, POSIX.1-2001. В POSIX.1-2001 эта функция объявлена устаревшей; "
"вместо неё используйте B<nanosleep>(2). Из POSIX.1-2008 описание B<usleep>() "
"было удалено."

#. type: Plain text
#: man-pages/man3/usleep.3:116
msgid ""
"On the original BSD implementation, and in glibc before version 2.2.2, the "
"return type of this function is I<void>.  The POSIX version returns I<int>, "
"and this is also the prototype used since glibc 2.2.2."
msgstr ""
"В первоначальной реализации BSD и в glibc до версии 2.2.2 типом "
"возвращаемого значение функции был I<void>. В версии POSIX возвращается "
"I<int>, и этот прототип также используется в glibc начиная с версии 2.2.2."

#. type: Plain text
#: man-pages/man3/usleep.3:120
msgid ""
"Only the B<EINVAL> error return is documented by SUSv2 and POSIX.1-2001."
msgstr ""
"Возвращаемая ошибка B<EINVAL> определена только в SUSv2 и POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/usleep.3:128
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  Programs will be more portable if they "
"never mention this type explicitly.  Use"
msgstr ""
"Тип I<useconds_t> является беззнаковым целым типом, способным хранить целые "
"числа в диапазоне [0,1000000]. Программы будут иметь более высокий уровень "
"переносимости на другие ОС, если они никогда не будут явно упоминать этот "
"тип. Используйте"

#. type: Plain text
#: man-pages/man3/usleep.3:136
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"\\&...\n"
"    unsigned int usecs;\n"
"\\&...\n"
"    usleep(usecs);\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"\\&...\n"
"    unsigned int usecs;\n"
"\\&...\n"
"    usleep(usecs);\n"

#. type: Plain text
#: man-pages/man3/usleep.3:153
msgid ""
"The interaction of this function with the B<SIGALRM> signal, and with other "
"timer functions such as B<alarm>(2), B<sleep>(3), B<nanosleep>(2), "
"B<setitimer>(2), B<timer_create>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_gettime>(2), B<timer_settime>(2), "
"B<ualarm>(3)  is unspecified."
msgstr ""
"Взаимодействие этой функции с сигналом B<SIGALRM> и другими функциями "
"таймера, такими как B<alarm>(2), B<sleep>(3), B<nanosleep>(2), "
"B<setitimer>(2), B<timer_create>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_gettime>(2), B<timer_settime>(2), "
"B<ualarm>(3), не определено."

#. type: Plain text
#: man-pages/man3/usleep.3:161
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<sleep>(3), B<ualarm>(3), B<time>(7)"
msgstr ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<sleep>(3), B<ualarm>(3), B<time>(7)"

#. type: TH
#: man-pages/man3/unlockpt.3:5
#, no-wrap
msgid "UNLOCKPT"
msgstr "UNLOCKPT"

#. type: TH
#: man-pages/man3/unlockpt.3:5
#, no-wrap
msgid "2017-07-13"
msgstr "2017-07-13"

#. type: Plain text
#: man-pages/man3/unlockpt.3:8
msgid "unlockpt - unlock a pseudoterminal master/slave pair"
msgstr "unlockpt - разблокирует пару основной/подчинённый псевдо-терминал"

#. type: Plain text
#: man-pages/man3/unlockpt.3:10
msgid "B<#define _XOPEN_SOURCE>"
msgstr "B<#define _XOPEN_SOURCE>"

#. type: Plain text
#: man-pages/man3/unlockpt.3:12
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/unlockpt.3:14
msgid "B<int unlockpt(int >I<fd>B<);>"
msgstr "B<int unlockpt(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man3/unlockpt.3:22
msgid "B<unlockpt>():"
msgstr "B<unlockpt>():"

#. type: Plain text
#: man-pages/man3/unlockpt.3:27
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"
msgstr ""
"начиная с glibc 2.24:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"

#. type: Plain text
#: man-pages/man3/unlockpt.3:30
#, no-wrap
msgid ""
"Glibc 2.23 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr ""
"glibc 2.23 и старее:\n"
"    _XOPEN_SOURCE\n"

#. type: Plain text
#: man-pages/man3/unlockpt.3:38
msgid ""
"The B<unlockpt>()  function unlocks the slave pseudoterminal device "
"corresponding to the master pseudoterminal referred to by I<fd>."
msgstr ""
"Функция B<unlockpt>() разблокирует устройство подчиненного псевдо-терминала "
"соответствующего основному псевдо-терминалу, на который ссылается I<fd>."

#. type: Plain text
#: man-pages/man3/unlockpt.3:41
msgid ""
"B<unlockpt>()  should be called before opening the slave side of a "
"pseudoterminal."
msgstr ""
"Функция B<unlockpt>() должна вызываться перед открытием подчинённой стороны "
"псевдо-терминала."

#. type: Plain text
#: man-pages/man3/unlockpt.3:48
msgid ""
"When successful, B<unlockpt>()  returns 0.  Otherwise, it returns -1 and "
"sets I<errno> appropriately."
msgstr ""
"При успешном выполнении B<unlockpt>() возвращает 0. Иначе возвращается -1 и "
"переменная I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man3/unlockpt.3:54
msgid "The I<fd> argument is not a file descriptor open for writing."
msgstr ""
"Значение I<fd> не является правильным файловым дескриптором, открытым для "
"записи."

#. type: Plain text
#: man-pages/man3/unlockpt.3:59
msgid "The I<fd> argument is not associated with a master pseudoterminal."
msgstr "Значение I<fd> не связано с основным псевдо-терминалом."

#. type: Plain text
#: man-pages/man3/unlockpt.3:62
msgid "B<unlockpt>()  is provided in glibc since version 2.1."
msgstr "Функция B<unlockpt>() появилась в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/unlockpt.3:72
#, no-wrap
msgid "B<unlockpt>()"
msgstr "B<unlockpt>()"

#. type: Plain text
#: man-pages/man3/unlockpt.3:76
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/unlockpt.3:81
msgid "B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<pts>(4), B<pty>(7)"
msgstr "B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<pts>(4), B<pty>(7)"

#. type: TH
#: man-pages/man3/unlocked_stdio.3:25
#, no-wrap
msgid "UNLOCKED_STDIO"
msgstr "UNLOCKED_STDIO"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:29
msgid ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - "
"nonlocking stdio functions"
msgstr ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - "
"неблокирующие функции стандартного ввода-вывода"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:32
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:37
#, no-wrap
msgid ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"
msgstr ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:49
#, no-wrap
msgid ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
msgstr ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:52
#, no-wrap
msgid ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:54
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:63
#, no-wrap
msgid ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:75
msgid ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"
msgstr ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:79
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:90
msgid ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"
msgstr ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:93
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версиях glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:104
msgid ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"
msgstr ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:115
msgid ""
"Each of these functions has the same behavior as its counterpart without the "
"\"_unlocked\" suffix, except that they do not use locking (they do not set "
"locks themselves, and do not test for the presence of locks set by others) "
"and hence are thread-unsafe.  See B<flockfile>(3)."
msgstr ""
"Все эти функции ведут себя так же, как и их аналоги без суффикса "
"«_unlocked», за исключением того, что они не используют блокировку (они не "
"устанавливают блокировки самостоятельно и не проверяют наличие других "
"блокировок) и, таким образом, не являются нитебезопасными. Смотрите "
"B<flockfile>(3)."

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:141
#, no-wrap
msgid ""
"B<getc_unlocked>(),\n"
"B<putc_unlocked>(),\n"
"B<clearerr_unlocked>(),\n"
"B<fflush_unlocked>(),\n"
"B<fgetc_unlocked>(),\n"
"B<fputc_unlocked>(),\n"
"B<fread_unlocked>(),\n"
"B<fwrite_unlocked>(),\n"
"B<fgets_unlocked>(),\n"
"B<fputs_unlocked>(),\n"
"B<getwc_unlocked>(),\n"
"B<fgetwc_unlocked>(),\n"
"B<fputwc_unlocked>(),\n"
"B<putwc_unlocked>(),\n"
"B<fgetws_unlocked>(),\n"
"B<fputws_unlocked>()"
msgstr ""
"B<getc_unlocked>(),\n"
"B<putc_unlocked>(),\n"
"B<clearerr_unlocked>(),\n"
"B<fflush_unlocked>(),\n"
"B<fgetc_unlocked>(),\n"
"B<fputc_unlocked>(),\n"
"B<fread_unlocked>(),\n"
"B<fwrite_unlocked>(),\n"
"B<fgets_unlocked>(),\n"
"B<fputs_unlocked>(),\n"
"B<getwc_unlocked>(),\n"
"B<fgetwc_unlocked>(),\n"
"B<fputwc_unlocked>(),\n"
"B<putwc_unlocked>(),\n"
"B<fgetws_unlocked>(),\n"
"B<fputws_unlocked>()"

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:141
#, no-wrap
msgid "MT-Safe race:stream"
msgstr "MT-Safe race:stream"

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:145
#, no-wrap
msgid ""
"B<getchar_unlocked>(),\n"
"B<getwchar_unlocked>()"
msgstr ""
"B<getchar_unlocked>(),\n"
"B<getwchar_unlocked>()"

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:145
#, no-wrap
msgid "MT-Unsafe race:stdin"
msgstr "MT-Unsafe race:stdin"

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:149
#, no-wrap
msgid ""
"B<putchar_unlocked>(),\n"
"B<putwchar_unlocked>()"
msgstr ""
"B<putchar_unlocked>(),\n"
"B<putwchar_unlocked>()"

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:149
#, no-wrap
msgid "MT-Unsafe race:stdout"
msgstr "MT-Unsafe race:stdout"

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:154
#, no-wrap
msgid ""
"B<feof_unlocked>(),\n"
"B<ferror_unlocked>(),\n"
"B<fileno_unlocked>()"
msgstr ""
"B<feof_unlocked>(),\n"
"B<ferror_unlocked>(),\n"
"B<fileno_unlocked>()"

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:164
msgid ""
"The four functions B<getc_unlocked>(), B<getchar_unlocked>(), "
"B<putc_unlocked>(), B<putchar_unlocked>()  are in POSIX.1-2001 and "
"POSIX.1-2008."
msgstr ""
"Четыре функции B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>() "
"и B<putchar_unlocked>() являются частью стандартов POSIX.1-2001 и "
"POSIX.1-2008."

#.  E.g., in HP-UX 10.0. In HP-UX 10.30 they are called obsolescent, and
#.  moved to a compatibility library.
#.  Available in HP-UX 10.0: clearerr_unlocked, fclose_unlocked,
#.  feof_unlocked, ferror_unlocked, fflush_unlocked, fgets_unlocked,
#.  fgetwc_unlocked, fgetws_unlocked, fileno_unlocked, fputs_unlocked,
#.  fputwc_unlocked, fputws_unlocked, fread_unlocked, fseek_unlocked,
#.  ftell_unlocked, fwrite_unlocked, getc_unlocked, getchar_unlocked,
#.  getw_unlocked, getwc_unlocked, getwchar_unlocked, putc_unlocked,
#.  putchar_unlocked, puts_unlocked, putws_unlocked, putw_unlocked,
#.  putwc_unlocked, putwchar_unlocked, rewind_unlocked, setvbuf_unlocked,
#.  ungetc_unlocked, ungetwc_unlocked.
#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:180
msgid ""
"The nonstandard B<*_unlocked>()  variants occur on a few UNIX systems, and "
"are available in recent glibc.  They should probably not be used."
msgstr ""
"В некоторых систем UNIX и последних версиях glibc встречаются нестандартные "
"варианты функций B<*_unlocked>(). Вероятно, не стоит их использовать."

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:182
msgid "B<flockfile>(3), B<stdio>(3)"
msgstr "B<flockfile>(3), B<stdio>(3)"

#. type: TH
#: man-pages/man3/ungetwc.3:16
#, no-wrap
msgid "UNGETWC"
msgstr "UNGETWC"

#. type: TH
#: man-pages/man3/ungetwc.3:16
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: man-pages/man3/ungetwc.3:19
msgid "ungetwc - push back a wide character onto a FILE stream"
msgstr "ungetwc - отправка широкого символа обратно в поток FILE"

#. type: Plain text
#: man-pages/man3/ungetwc.3:24
#, no-wrap
msgid "B<wint_t ungetwc(wint_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr "B<wint_t ungetwc(wint_t >I<wc>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/ungetwc.3:34
msgid ""
"The B<ungetwc>()  function is the wide-character equivalent of the "
"B<ungetc>(3)  function.  It pushes back a wide character onto I<stream> and "
"returns it."
msgstr ""
"Функция B<ungetwc>() — это эквивалент функции B<ungetc>(3) для широких "
"символов. Она отправляет широкий символ обратно в поток I<stream> и "
"возвращает его."

#. type: Plain text
#: man-pages/man3/ungetwc.3:50
msgid ""
"If I<wc> is B<WEOF>, it returns B<WEOF>.  If I<wc> is an invalid wide "
"character, it sets I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""
"Если I<wc> равно B<WEOF>, то возвращается B<WEOF>. Если I<wc> — это "
"некорректный широкий символ, то значение I<errno> устанавливается в "
"B<EILSEQ> и возвращается B<WEOF>."

#. type: Plain text
#: man-pages/man3/ungetwc.3:59
msgid ""
"If I<wc> is a valid wide character, it is pushed back onto the stream and "
"thus becomes available for future wide-character read operations.  The file-"
"position indicator is decremented by one or more.  The end-of-file indicator "
"is cleared.  The backing storage of the file is not affected."
msgstr ""
"Если I<wc> — это корректный широкий символ, то он отправляется обратно в "
"поток и, таким образом, становится доступным для последующих операций чтения "
"широких символов. Индикатор позиции в файле уменьшается на единицу или "
"более. Индикатор конца файла очищается. Непосредственный носитель файла при "
"этой операции не задействуется."

#. type: Plain text
#: man-pages/man3/ungetwc.3:64
msgid ""
"Note: I<wc> need not be the last wide-character read from the stream; it can "
"be any other valid wide character."
msgstr ""
"Замечание: I<wc> не должен быть последним широким символом в потоке; он "
"может быть любым другим корректным широким символом."

#. type: Plain text
#: man-pages/man3/ungetwc.3:68
msgid ""
"If the implementation supports multiple push-back operations in a row, the "
"pushed-back wide characters will be read in reverse order; however, only one "
"level of push-back is guaranteed."
msgstr ""
"Если реализация поддерживает несколько последовательных операций возвращения "
"подряд, то возвращённые широкие символы будут прочитаны в обратном порядке; "
"однако гарантированно работает только однократный возврат."

#. type: Plain text
#: man-pages/man3/ungetwc.3:77
msgid ""
"The B<ungetwc>()  function returns I<wc> when successful, or B<WEOF> upon "
"failure."
msgstr ""
"При успешном выполнении функция B<ungetwc> возвращает I<wc> или B<WEOF> в "
"случае ошибки."

#. type: tbl table
#: man-pages/man3/ungetwc.3:87
#, no-wrap
msgid "B<ungetwc>()"
msgstr "B<ungetwc>()"

#. type: Plain text
#: man-pages/man3/ungetwc.3:91
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/ungetwc.3:98
msgid ""
"The behavior of B<ungetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""
"Поведение B<ungetwc>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/ungetwc.3:99
msgid "B<fgetwc>(3)"
msgstr "B<fgetwc>(3)"

#. type: TH
#: man-pages/man3/ulimit.3:27
#, no-wrap
msgid "ULIMIT"
msgstr "ULIMIT"

#. type: Plain text
#: man-pages/man3/ulimit.3:30
msgid "ulimit - get and set user limits"
msgstr "ulimit - установка или получение пользовательских ограничений"

#. type: Plain text
#: man-pages/man3/ulimit.3:32
msgid "B<#include E<lt>ulimit.hE<gt>>"
msgstr "B<#include E<lt>ulimit.hE<gt>>"

#. type: Plain text
#: man-pages/man3/ulimit.3:34
msgid "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"
msgstr "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"

#. type: Plain text
#: man-pages/man3/ulimit.3:46
msgid ""
"Warning: this routine is obsolete.  Use B<getrlimit>(2), B<setrlimit>(2), "
"and B<sysconf>(3)  instead.  For the shell command B<ulimit>(), see "
"B<bash>(1)."
msgstr ""
"Предупреждение: эта функция устарела. Вместо неё используйте "
"B<getrlimit>(2), B<setrlimit>(2) и B<sysconf>(3). Справку по вызову "
"B<ulimit> из командной строки смотрите в B<bash>(1)."

#. type: Plain text
#: man-pages/man3/ulimit.3:53
msgid ""
"The B<ulimit>()  call will get or set some limit for the calling process.  "
"The I<cmd> argument can have one of the following values."
msgstr ""
"Вызов B<ulimit> позволяет получить или установить ограничения вызывающего "
"процесса. Аргумент I<cmd> может принимать следующие значения:"

#. type: TP
#: man-pages/man3/ulimit.3:53
#, no-wrap
msgid "B<UL_GETFSIZE>"
msgstr "B<UL_GETFSIZE>"

#. type: Plain text
#: man-pages/man3/ulimit.3:56
msgid "Return the limit on the size of a file, in units of 512 bytes."
msgstr "Возвращается ограничение на размер файла (в блоках по 512 байтов)."

#. type: TP
#: man-pages/man3/ulimit.3:56
#, no-wrap
msgid "B<UL_SETFSIZE>"
msgstr "B<UL_SETFSIZE>"

#. type: Plain text
#: man-pages/man3/ulimit.3:59
msgid "Set the limit on the size of a file."
msgstr "Устанавливается ограничение размера файла."

#. type: TP
#: man-pages/man3/ulimit.3:59
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: man-pages/man3/ulimit.3:63
msgid ""
"(Not implemented for Linux.)  Return the maximum possible address of the "
"data segment."
msgstr ""
"Возвращается максимально возможный адрес сегмента данных (не реализовано в "
"Linux)."

#. type: TP
#: man-pages/man3/ulimit.3:63
#, no-wrap
msgid "B<4>"
msgstr "B<4>"

#. type: Plain text
#: man-pages/man3/ulimit.3:67
msgid ""
"(Implemented but no symbolic constant provided.)  Return the maximum number "
"of files that the calling process can open."
msgstr ""
"Возвращается максимальное количество файлов, которое может открыть "
"вызывающий процесс (реализовано, но нет символической константы)."

#. type: Plain text
#: man-pages/man3/ulimit.3:74
msgid ""
"On success, B<ulimit>()  returns a nonnegative value.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<ulimit> возвращает неотрицательное число. В случае "
"ошибки возвращается -1, а значение I<errno> устанавливается соответствующим "
"образом."

#. type: Plain text
#: man-pages/man3/ulimit.3:78
msgid "An unprivileged process tried to increase a limit."
msgstr "Непривилегированный процесс пытается увеличить лимит."

#. type: tbl table
#: man-pages/man3/ulimit.3:88
#, no-wrap
msgid "B<ulimit>()"
msgstr "B<ulimit>()"

#. type: Plain text
#: man-pages/man3/ulimit.3:96
msgid "SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<ulimit>()  as obsolete."
msgstr ""
"SVr4, POSIX.1-2001. В POSIX.1-2008 функция B<ulimit>() помечена как "
"устаревшая."

#. type: Plain text
#: man-pages/man3/ulimit.3:100
msgid "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"
msgstr "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"

#. type: TH
#: man-pages/man3/uselocale.3:26
#, no-wrap
msgid "USELOCALE"
msgstr "USELOCALE"

#. type: Plain text
#: man-pages/man3/uselocale.3:29
msgid "uselocale - set/get the locale for the calling thread"
msgstr "uselocale - задаёт/получает локаль для вызывающей нити"

#. type: Plain text
#: man-pages/man3/uselocale.3:32
#, no-wrap
msgid "B<#include E<lt>locale.hE<gt>>\n"
msgstr "B<#include E<lt>locale.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/uselocale.3:34
#, no-wrap
msgid "B<locale_t uselocale(locale_t >I<newloc>B<);>\n"
msgstr "B<locale_t uselocale(locale_t >I<newloc>B<);>\n"

#. type: Plain text
#: man-pages/man3/uselocale.3:42
msgid "B<uselocale>():"
msgstr "B<uselocale>():"

#. type: Plain text
#: man-pages/man3/uselocale.3:47
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700"

#. type: Plain text
#: man-pages/man3/uselocale.3:62
msgid ""
"The B<uselocale>()  function sets the current locale for the calling thread, "
"and returns the thread's previously current locale.  After a successful call "
"to B<uselocale>(), any calls by this thread to functions that depend on the "
"locale will operate as though the locale has been set to I<newloc>."
msgstr ""
"Функция B<uselocale>() задаёт текущую локаль в вызвавшей нити и возвращает "
"использовавшуюся локаль в этой нити ранее. После успешного выполнения "
"B<uselocale>() любые выполняемые нитью вызовы функций, зависящие от локали, "
"будут работать с учётом установленной локали I<newloc>."

#. type: Plain text
#: man-pages/man3/uselocale.3:66
msgid "The I<newloc> argument can have one of the following values:"
msgstr "В аргументе I<newloc> можно указать одно из следующих значений:"

#. type: TP
#: man-pages/man3/uselocale.3:66
#, no-wrap
msgid "A handle returned by a call to B<newlocale>(3) or B<duplocale>(3)"
msgstr "Обработчик, полученный от вызовов B<newlocale>(3) или B<duplocale>(3)"

#. type: Plain text
#: man-pages/man3/uselocale.3:69
msgid "The calling thread's current locale is set to the specified locale."
msgstr "Текущая локаль вызвавшей нити будет равна указанной локали."

#. type: TP
#: man-pages/man3/uselocale.3:69
#, no-wrap
msgid "The special locale object handle B<LC_GLOBAL_LOCALE>"
msgstr "Специальный обработчик объекта локали B<LC_GLOBAL_LOCALE>"

#. type: Plain text
#: man-pages/man3/uselocale.3:73
msgid ""
"The calling thread's current locale is set to the global locale determined "
"by B<setlocale>(3)."
msgstr ""
"Текущая локаль вызвавшей нити будет равна глобальной локали, установленной "
"B<setlocale>(3)."

#. type: TP
#: man-pages/man3/uselocale.3:73
#, no-wrap
msgid "I<(locale_t) 0>"
msgstr "I<(locale_t) 0>"

#. type: Plain text
#: man-pages/man3/uselocale.3:77
msgid ""
"The calling thread's current locale is left unchanged (and the current "
"locale is returned as the function result)."
msgstr ""
"Текущая локаль вызвавшей нити останется неизменной (и текущая локаль "
"возвращается как результат работы функции)."

#. type: Plain text
#: man-pages/man3/uselocale.3:90
msgid ""
"On success, B<uselocale>()  returns the locale handle that was set by the "
"previous call to B<uselocale>()  in this thread, or B<LC_GLOBAL_LOCALE> if "
"there was no such previous call.  On error, it returns I<(locale_t)\\ 0>, "
"and sets I<errno> to indicate the cause of the error."
msgstr ""
"При успешном выполнении B<uselocale>() возвращает обработчик локали, который "
"был установлен предыдущим вызовом B<uselocale>() в этой нити или "
"B<LC_GLOBAL_LOCALE>, если это первый вызов. При ошибке возвращается "
"I<(locale_t)\\ 0>, а I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/uselocale.3:95
msgid "I<newloc> does not refer to a valid locale object."
msgstr "Значение I<newloc> не указывает на допустимый объект локали."

#. type: Plain text
#: man-pages/man3/uselocale.3:99
msgid ""
"The B<uselocale>()  function first appeared in version 2.3 of the GNU C "
"library."
msgstr ""
"Функция B<uselocale>() впервые появилась в версии 2.3 библиотеки GNU C."

#. type: Plain text
#: man-pages/man3/uselocale.3:101
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/uselocale.3:113
msgid ""
"Unlike B<setlocale>(3), B<uselocale>()  does not allow selective replacement "
"of individual locale categories.  To employ a locale that differs in only a "
"few categories from the current locale, use calls to B<duplocale>(3)  and "
"B<newlocale>(3)  to obtain a locale object equivalent to the current locale "
"and modify the desired categories in that object."
msgstr ""
"В отличие от B<setlocale>(3), B<uselocale>() не позволяет выборочно "
"указывать отдельные категории локали. Для задания локали, которая отличается "
"только отдельными категориями от текущей локали, используйте вызов "
"B<duplocale>(3) и B<newlocale>(3) для получения эквивалента объекта локали "
"для текущей локали и измените желаемые категории в этом объекте."

#. type: Plain text
#: man-pages/man3/uselocale.3:118
msgid "See B<newlocale>(3)  and B<duplocale>(3)."
msgstr "Смотрите B<newlocale>(3) и B<duplocale>(3)."

#. type: Plain text
#: man-pages/man3/uselocale.3:125
msgid ""
"B<locale>(1), B<duplocale>(3), B<freelocale>(3), B<newlocale>(3), "
"B<setlocale>(3), B<locale>(5), B<locale>(7)"
msgstr ""
"B<locale>(1), B<duplocale>(3), B<freelocale>(3), B<newlocale>(3), "
"B<setlocale>(3), B<locale>(5), B<locale>(7)"

#. type: TH
#: man-pages/man3/ualarm.3:24
#, no-wrap
msgid "UALARM"
msgstr "UALARM"

#. type: Plain text
#: man-pages/man3/ualarm.3:27
msgid "ualarm - schedule signal after given number of microseconds"
msgstr "ualarm - планирует отправку сигнала через заданное число микросекунд"

#. type: Plain text
#: man-pages/man3/ualarm.3:32
#, no-wrap
msgid "B<useconds_t ualarm(useconds_t >I<usecs>B<, useconds_t >I<interval>B<);>\n"
msgstr "B<useconds_t ualarm(useconds_t >I<usecs>B<, useconds_t >I<interval>B<);>\n"

#. type: Plain text
#: man-pages/man3/ualarm.3:40
msgid "B<ualarm>():"
msgstr "B<ualarm>():"

#. type: Plain text
#: man-pages/man3/ualarm.3:68
msgid ""
"The B<ualarm>()  function causes the signal B<SIGALRM> to be sent to the "
"invoking process after (not less than)  I<usecs> microseconds.  The delay "
"may be lengthened slightly by any system activity or by the time spent "
"processing the call or by the granularity of system timers."
msgstr ""
"Функция B<ualarm>() планирует отправку сигнала B<SIGALRM> вызывающему "
"процессу (не менее чем) через I<usecs> микросекунд. Задержка может быть "
"слегка больше при большой загруженности системы, из-за, собственно, времени "
"обработки этого вызова или из-за неточности хода системных часов."

#. type: Plain text
#: man-pages/man3/ualarm.3:72
msgid ""
"Unless caught or ignored, the B<SIGALRM> signal will terminate the process."
msgstr ""
"Если сигнал не будет пойман или проигнорирован, то B<SIGALRM> уничтожит "
"процесс."

#. type: Plain text
#: man-pages/man3/ualarm.3:80
msgid ""
"If the I<interval> argument is nonzero, further B<SIGALRM> signals will be "
"sent every I<interval> microseconds after the first."
msgstr ""
"Если аргумент I<interval> не равен нулю, то сигналы B<SIGALRM> будут "
"отправляться повторно каждые I<interval> микросекунд после первого."

#. type: Plain text
#: man-pages/man3/ualarm.3:83
msgid ""
"This function returns the number of microseconds remaining for any alarm "
"that was previously set, or 0 if no alarm was pending."
msgstr ""
"Эта функция возвращает число микросекунд, оставшихся от любого ранее "
"установленного сигнала, или 0, если сигналов не запланировано."

#. type: Plain text
#: man-pages/man3/ualarm.3:92
msgid ""
"I<usecs> or I<interval> is not smaller than 1000000.  (On systems where that "
"is considered an error.)"
msgstr ""
"Значение I<usec> или I<interval> больше 1000000 (в тех системах, где это "
"считается ошибкой)."

#. type: tbl table
#: man-pages/man3/ualarm.3:102
#, no-wrap
msgid "B<ualarm>()"
msgstr "B<ualarm>()"

#. type: Plain text
#: man-pages/man3/ualarm.3:112
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 marks B<ualarm>()  as obsolete.  "
"POSIX.1-2008 removes the specification of B<ualarm>().  4.3BSD, SUSv2, and "
"POSIX do not define any errors."
msgstr ""
"4.3BSD, POSIX.1-2001. В POSIX.1-2001 функция B<ualarm>() помечена как "
"устаревшая. В POSIX.1-2008 описание B<ualarm>() было удалено. В 4.3BSD, "
"SUSv2 и POSIX нет описания ошибок."

#.  This case is not documented in HP-US, Solar, FreeBSD, NetBSD, or OpenBSD!
#. type: Plain text
#: man-pages/man3/ualarm.3:119
msgid ""
"POSIX.1-2001 does not specify what happens if the I<usecs> argument is 0.  "
"On Linux (and probably most other systems), the effect is to cancel any "
"pending alarm."
msgstr ""
"В POSIX.1-2001 не указано, что случится, если значение I<usecs> равно 0. В "
"Linux (и, вероятно, в большинстве систем) произойдёт отмена любого "
"взведённого будильника."

#. type: Plain text
#: man-pages/man3/ualarm.3:132
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  On the original BSD implementation, and "
"in glibc before version 2.1, the arguments to B<ualarm>()  were instead "
"typed as I<unsigned int>.  Programs will be more portable if they never "
"mention I<useconds_t> explicitly."
msgstr ""
"Тип I<useconds_t> является беззнаковым целым типом, способным хранить целые "
"числа в диапазоне [0,1000000]. В первоначальной реализации BSD и glibc до "
"версии 2.1, аргументы B<ualarm>() имели тип I<unsigned int>. Программы будут "
"более переносимы, если они никогда не будут явно упоминать тип I<useconds_t>."

#. type: Plain text
#: man-pages/man3/ualarm.3:146
msgid ""
"The interaction of this function with other timer functions such as "
"B<alarm>(2), B<sleep>(3), B<nanosleep>(2), B<setitimer>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_getoverrun>(2), "
"B<timer_gettime>(2), B<timer_settime>(2), B<usleep>(3)  is unspecified."
msgstr ""
"Взаимодействие этой функции с другими функциями таймера, такими как "
"B<alarm>(2), B<sleep>(3), B<nanosleep>(2), B<setitimer>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_getoverrun>(2), "
"B<timer_gettime>(2), B<timer_settime>(2), B<usleep>(3) не определено."

#. type: Plain text
#: man-pages/man3/ualarm.3:154
msgid ""
"This function is obsolete.  Use B<setitimer>(2)  or POSIX interval timers "
"(B<timer_create>(2), etc.)  instead."
msgstr ""
"Эта функция устарела. Используйте вместо неё B<setitimer>(2) или "
"интервальные таймеры POSIX (B<timer_create>(2) и т.д.)."

#. type: Plain text
#: man-pages/man3/ualarm.3:161
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<usleep>(3), B<time>(7)"
msgstr ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<usleep>(3), B<time>(7)"

#. type: TH
#: man-pages/man3/updwtmp.3:29
#, no-wrap
msgid "UPDWTMP"
msgstr "UPDWTMP"

#. type: Plain text
#: man-pages/man3/updwtmp.3:32
msgid "updwtmp, logwtmp - append an entry to the wtmp file"
msgstr "updwtmp, logwtmp - добавляет запись в файл wtmp"

#. type: Plain text
#: man-pages/man3/updwtmp.3:35
#, no-wrap
msgid "B<#include E<lt>utmp.hE<gt>>\n"
msgstr "B<#include E<lt>utmp.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/updwtmp.3:39
#, no-wrap
msgid ""
"B<void updwtmp(const char *>I<wtmp_file>B<, const struct utmp *>I<ut>B<);>\n"
"B<void logwtmp(const char *>I<line>B<, const char *>I<name>B<, const char *>I<host>B<);>\n"
msgstr ""
"B<void updwtmp(const char *>I<wtmp_file>B<, const struct utmp *>I<ut>B<);>\n"
"B<void logwtmp(const char *>I<line>B<, const char *>I<name>B<, const char *>I<host>B<);>\n"

#. type: Plain text
#: man-pages/man3/updwtmp.3:44
msgid "For B<logwtmp>(), link with I<-lutil>."
msgstr "Для B<logwtmp>(): компонуется при указании параметра I<-lutil>."

#. type: Plain text
#: man-pages/man3/updwtmp.3:49
msgid "B<updwtmp>()  appends the utmp structure I<ut> to the wtmp file."
msgstr "Функция B<updwtmp>() добавляет структуру utmp I<ut> в файл wtmp."

#. type: Plain text
#: man-pages/man3/updwtmp.3:57
msgid ""
"B<logwtmp>()  constructs a utmp structure using I<line>, I<name>, I<host>, "
"current time and current process ID.  Then it calls B<updwtmp>()  to append "
"the structure to the wtmp file."
msgstr ""
"Функция B<logwtmp>() создаёт структуру utmp из I<line>, I<name>, I<host>, "
"текущего времени и текущего идентификатора процесса. После этого вызывается "
"B<updwtmp>() для добавления структуры в файл wtmp."

#. type: Plain text
#: man-pages/man3/updwtmp.3:61
msgid "database of past user logins"
msgstr "база данных предыдущих пользовательских входов в систему"

#. type: tbl table
#: man-pages/man3/updwtmp.3:71
#, no-wrap
msgid "B<updwtmp>(),\n"
msgstr "B<updwtmp>(),\n"

#. type: tbl table
#: man-pages/man3/updwtmp.3:71
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man3/updwtmp.3:73
#, no-wrap
msgid "B<logwtmp>()"
msgstr "B<logwtmp>()"

#. type: tbl table
#: man-pages/man3/updwtmp.3:73
#, no-wrap
msgid "MT-Unsafe sig:ALRM timer"
msgstr "MT-Unsafe sig:ALRM timer"

#. type: Plain text
#: man-pages/man3/updwtmp.3:79
msgid "Not in POSIX.1.  Present on Solaris, NetBSD, and perhaps other systems."
msgstr ""
"Отсутствует в POSIX.1. Имеется в Solaris, NetBSD и, возможно, в других "
"системах."

#. type: Plain text
#: man-pages/man3/updwtmp.3:83
msgid ""
"For consistency with the other \"utmpx\" functions (see B<getutxent>(3)), "
"glibc provides (since version 2.1):"
msgstr ""
"Для схожести с другими функциями «utmpx» (смотрите B<getutxent>(3)), в glibc "
"(начиная с версии 2.1) имеется:"

#. type: Plain text
#: man-pages/man3/updwtmp.3:88
#, no-wrap
msgid ""
"B<#include E<lt>utmpx.hE<gt>>\n"
"B<void updwtmpx (const char *>I<wtmpx_file>B<, const struct utmpx *>I<utx>B<);>\n"
msgstr ""
"B<#include E<lt>utmpx.hE<gt>>\n"
"B<void updwtmpx (const char *>I<wtmpx_file>B<, const struct utmpx *>I<utx>B<);>\n"

#. type: Plain text
#: man-pages/man3/updwtmp.3:96
msgid ""
"This function performs the same task as B<updwtmp>(), but differs in that it "
"takes a I<utmpx> structure as its last argument."
msgstr ""
"Эта функция выполняет ту же задачу что и B<updwtmp>(); отличие в том, что "
"типом последнего аргумента является структура I<utmpx>."

#. type: Plain text
#: man-pages/man3/updwtmp.3:98
msgid "B<getutxent>(3), B<wtmp>(5)"
msgstr "B<getutxent>(3), B<wtmp>(5)"

#. type: TH
#: man-pages/man3/undocumented.3:30
#, no-wrap
msgid "UNDOCUMENTED"
msgstr "UNDOCUMENTED"

#. type: Plain text
#: man-pages/man3/undocumented.3:33
msgid "undocumented - undocumented library functions"
msgstr "undocumented - недокументированные библиотечные функции"

#. type: Plain text
#: man-pages/man3/undocumented.3:35
msgid "Undocumented library functions"
msgstr "Недокументированные библиотечные функции"

#. type: Plain text
#: man-pages/man3/undocumented.3:38
msgid ""
"This man page mentions those library functions which are implemented in the "
"standard libraries but not yet documented in man pages."
msgstr ""
"В этой справочной странице перечислены библиотечные функции, реализованные в "
"стандартных библиотеках, но для которых пока нет справочных страниц."

#. type: SS
#: man-pages/man3/undocumented.3:38
#, no-wrap
msgid "Solicitation"
msgstr "Содействие"

#. type: Plain text
#: man-pages/man3/undocumented.3:44
msgid ""
"If you have information about these functions, please look in the source "
"code, write a man page (using a style similar to that of the other Linux "
"section 3 man pages), and send it to B<mtk.manpages@gmail.com> for inclusion "
"in the next man page release."
msgstr ""
"Если вы располагаете информацией об этих функциях, посмотрите исходный код, "
"напишите справочную страницу (в том же стиле, что и остальные документы "
"Linux в справочном разделе 3) и отправьте её на адрес B<mtk.manpages@gmail."
"com> для того, чтобы она вошла в следующий выпуск страниц."

#. type: SS
#: man-pages/man3/undocumented.3:44
#, no-wrap
msgid "The list"
msgstr "Список"

#.  .BR chflags (3),
#.  .BR fattach (3),
#.  .BR fchflags (3),
#.  .BR fclean (3),
#.  .BR fdetach (3),
#.  .BR obstack stuff (3),
#. type: Plain text
#: man-pages/man3/undocumented.3:178
msgid ""
"B<authdes_create>(3), B<authdes_getucred>(3), B<authdes_pk_create>(3), "
"B<clntunix_create>(3), B<creat64>(3), B<dn_skipname>(3), B<fcrypt>(3), "
"B<fp_nquery>(3), B<fp_query>(3), B<fp_resstat>(3), B<freading>(3), "
"B<freopen64>(3), B<fseeko64>(3), B<ftello64>(3), B<ftw64>(3), B<fwscanf>(3), "
"B<get_avphys_pages>(3), B<getdirentries64>(3), B<getmsg>(3), "
"B<getnetname>(3), B<get_phys_pages>(3), B<getpublickey>(3), "
"B<getsecretkey>(3), B<h_errlist>(3), B<host2netname>(3), B<hostalias>(3), "
"B<inet_nsap_addr>(3), B<inet_nsap_ntoa>(3), B<init_des>(3), "
"B<libc_nls_init>(3), B<mstats>(3), B<netname2host>(3), B<netname2user>(3), "
"B<nlist>(3), B<obstack_free>(3), B<parse_printf_format>(3), B<p_cdname>(3), "
"B<p_cdnname>(3), B<p_class>(3), B<p_fqname>(3), B<p_option>(3), "
"B<p_query>(3), B<printf_size>(3), B<printf_size_info>(3), B<p_rr>(3), "
"B<p_time>(3), B<p_type>(3), B<putlong>(3), B<putshort>(3), "
"B<re_compile_fastmap>(3), B<re_compile_pattern>(3), "
"B<register_printf_function>(3), B<re_match>(3), B<re_match_2>(3), "
"B<re_rx_search>(3), B<re_search>(3), B<re_search_2>(3), "
"B<re_set_registers>(3), B<re_set_syntax>(3), B<res_send_setqhook>(3), "
"B<res_send_setrhook>(3), B<ruserpass>(3), B<setfileno>(3), "
"B<sethostfile>(3), B<svc_exit>(3), B<svcudp_enablecache>(3), B<tell>(3), "
"B<tr_break>(3), B<tzsetwall>(3), B<ufc_dofinalperm>(3), B<ufc_doit>(3), "
"B<user2netname>(3), B<wcschrnul>(3), B<wcsftime>(3), B<wscanf>(3), "
"B<xdr_authdes_cred>(3), B<xdr_authdes_verf>(3), B<xdr_cryptkeyarg>(3), "
"B<xdr_cryptkeyres>(3), B<xdr_datum>(3), B<xdr_des_block>(3), "
"B<xdr_domainname>(3), B<xdr_getcredres>(3), B<xdr_keybuf>(3), "
"B<xdr_keystatus>(3), B<xdr_mapname>(3), B<xdr_netnamestr>(3), "
"B<xdr_netobj>(3), B<xdr_passwd>(3), B<xdr_peername>(3), "
"B<xdr_rmtcall_args>(3), B<xdr_rmtcallres>(3), B<xdr_unixcred>(3), "
"B<xdr_yp_buf>(3), B<xdr_yp_inaddr>(3), B<xdr_ypbind_binding>(3), "
"B<xdr_ypbind_resp>(3), B<xdr_ypbind_resptype>(3), B<xdr_ypbind_setdom>(3), "
"B<xdr_ypdelete_args>(3), B<xdr_ypmaplist>(3), B<xdr_ypmaplist_str>(3), "
"B<xdr_yppasswd>(3), B<xdr_ypreq_key>(3), B<xdr_ypreq_nokey>(3), "
"B<xdr_ypresp_all>(3), B<xdr_ypresp_all_seq>(3), B<xdr_ypresp_key_val>(3), "
"B<xdr_ypresp_maplist>(3), B<xdr_ypresp_master>(3), B<xdr_ypresp_order>(3), "
"B<xdr_ypresp_val>(3), B<xdr_ypstat>(3), B<xdr_ypupdate_args>(3), "
"B<yp_all>(3), B<yp_bind>(3), B<yperr_string>(3), B<yp_first>(3), "
"B<yp_get_default_domain>(3), B<yp_maplist>(3), B<yp_master>(3), "
"B<yp_match>(3), B<yp_next>(3), B<yp_order>(3), B<ypprot_err>(3), "
"B<yp_unbind>(3), B<yp_update>(3)"
msgstr ""
"B<authdes_create>(3), B<authdes_getucred>(3), B<authdes_pk_create>(3), "
"B<clntunix_create>(3), B<creat64>(3), B<dn_skipname>(3), B<fcrypt>(3), "
"B<fp_nquery>(3), B<fp_query>(3), B<fp_resstat>(3), B<freading>(3), "
"B<freopen64>(3), B<fseeko64>(3), B<ftello64>(3), B<ftw64>(3), B<fwscanf>(3), "
"B<get_avphys_pages>(3), B<getdirentries64>(3), B<getmsg>(3), "
"B<getnetname>(3), B<get_phys_pages>(3), B<getpublickey>(3), "
"B<getsecretkey>(3), B<h_errlist>(3), B<host2netname>(3), B<hostalias>(3), "
"B<inet_nsap_addr>(3), B<inet_nsap_ntoa>(3), B<init_des>(3), "
"B<libc_nls_init>(3), B<mstats>(3), B<netname2host>(3), B<netname2user>(3), "
"B<nlist>(3), B<obstack_free>(3), B<parse_printf_format>(3), B<p_cdname>(3), "
"B<p_cdnname>(3), B<p_class>(3), B<p_fqname>(3), B<p_option>(3), "
"B<p_query>(3), B<printf_size>(3), B<printf_size_info>(3), B<p_rr>(3), "
"B<p_time>(3), B<p_type>(3), B<putlong>(3), B<putshort>(3), "
"B<re_compile_fastmap>(3), B<re_compile_pattern>(3), "
"B<register_printf_function>(3), B<re_match>(3), B<re_match_2>(3), "
"B<re_rx_search>(3), B<re_search>(3), B<re_search_2>(3), "
"B<re_set_registers>(3), B<re_set_syntax>(3), B<res_send_setqhook>(3), "
"B<res_send_setrhook>(3), B<ruserpass>(3), B<setfileno>(3), "
"B<sethostfile>(3), B<svc_exit>(3), B<svcudp_enablecache>(3), B<tell>(3), "
"B<tr_break>(3), B<tzsetwall>(3), B<ufc_dofinalperm>(3), B<ufc_doit>(3), "
"B<user2netname>(3), B<wcschrnul>(3), B<wcsftime>(3), B<wscanf>(3), "
"B<xdr_authdes_cred>(3), B<xdr_authdes_verf>(3), B<xdr_cryptkeyarg>(3), "
"B<xdr_cryptkeyres>(3), B<xdr_datum>(3), B<xdr_des_block>(3), "
"B<xdr_domainname>(3), B<xdr_getcredres>(3), B<xdr_keybuf>(3), "
"B<xdr_keystatus>(3), B<xdr_mapname>(3), B<xdr_netnamestr>(3), "
"B<xdr_netobj>(3), B<xdr_passwd>(3), B<xdr_peername>(3), "
"B<xdr_rmtcall_args>(3), B<xdr_rmtcallres>(3), B<xdr_unixcred>(3), "
"B<xdr_yp_buf>(3), B<xdr_yp_inaddr>(3), B<xdr_ypbind_binding>(3), "
"B<xdr_ypbind_resp>(3), B<xdr_ypbind_resptype>(3), B<xdr_ypbind_setdom>(3), "
"B<xdr_ypdelete_args>(3), B<xdr_ypmaplist>(3), B<xdr_ypmaplist_str>(3), "
"B<xdr_yppasswd>(3), B<xdr_ypreq_key>(3), B<xdr_ypreq_nokey>(3), "
"B<xdr_ypresp_all>(3), B<xdr_ypresp_all_seq>(3), B<xdr_ypresp_key_val>(3), "
"B<xdr_ypresp_maplist>(3), B<xdr_ypresp_master>(3), B<xdr_ypresp_order>(3), "
"B<xdr_ypresp_val>(3), B<xdr_ypstat>(3), B<xdr_ypupdate_args>(3), "
"B<yp_all>(3), B<yp_bind>(3), B<yperr_string>(3), B<yp_first>(3), "
"B<yp_get_default_domain>(3), B<yp_maplist>(3), B<yp_master>(3), "
"B<yp_match>(3), B<yp_next>(3), B<yp_order>(3), B<ypprot_err>(3), "
"B<yp_unbind>(3), B<yp_update>(3)"
