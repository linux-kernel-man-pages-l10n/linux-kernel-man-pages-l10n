# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:27+0300\n"
"PO-Revision-Date: 2019-09-30 15:49+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/kruvalig/man-pages/language/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "UNITS"
msgstr ""

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man7/units.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: man-pages/man7/units.7:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:29
msgid "units - decimal and binary prefixes"
msgstr ""

#. type: SH
#: man-pages/man7/units.7:29
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: SS
#: man-pages/man7/units.7:30
#, no-wrap
msgid "Decimal prefixes"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:34
msgid ""
"The SI system of units uses prefixes that indicate powers of ten.  A "
"kilometer is 1000 meter, and a megawatt is 1000000 watt.  Below the standard"
" prefixes."
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:37 man-pages/man7/units.7:79
#, no-wrap
msgid "Prefix"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:37 man-pages/man7/units.7:79
#, no-wrap
msgid "Name"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:37 man-pages/man7/units.7:79
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:38
#, no-wrap
msgid "y"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:38
#, no-wrap
msgid "yocto"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:38
#, no-wrap
msgid "10^-24 = 0.000000000000000000000001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:39
#, no-wrap
msgid "z"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:39
#, no-wrap
msgid "zepto"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:39
#, no-wrap
msgid "10^-21 = 0.000000000000000000001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:40
#, no-wrap
msgid "a"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:40
#, no-wrap
msgid "atto"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:40
#, no-wrap
msgid "10^-18 = 0.000000000000000001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:41
#, no-wrap
msgid "f"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:41
#, no-wrap
msgid "femto"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:41
#, no-wrap
msgid "10^-15 = 0.000000000000001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:42
#, no-wrap
msgid "p"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:42
#, no-wrap
msgid "pico"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:42
#, no-wrap
msgid "10^-12 = 0.000000000001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:43
#, no-wrap
msgid "n"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:43
#, no-wrap
msgid "nano"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:43
#, no-wrap
msgid "10^-9  = 0.000000001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:44
#, no-wrap
msgid "\\(mc"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:44
#, no-wrap
msgid "micro"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:44
#, no-wrap
msgid "10^-6  = 0.000001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:45
#, no-wrap
msgid "m"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:45
#, no-wrap
msgid "milli"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:45
#, no-wrap
msgid "10^-3  = 0.001"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:46
#, no-wrap
msgid "c"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:46
#, no-wrap
msgid "centi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:46
#, no-wrap
msgid "10^-2  = 0.01"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:47
#, no-wrap
msgid "d"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:47
#, no-wrap
msgid "deci"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:47
#, no-wrap
msgid "10^-1  = 0.1"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:48
#, no-wrap
msgid "da"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:48
#, no-wrap
msgid "deka"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:48
#, no-wrap
msgid "10^ 1  = 10"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:49
#, no-wrap
msgid "h"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:49
#, no-wrap
msgid "hecto"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:49
#, no-wrap
msgid "10^ 2  = 100"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:50
#, no-wrap
msgid "k"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:50
#, no-wrap
msgid "kilo"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:50
#, no-wrap
msgid "10^ 3  = 1000"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:51
#, no-wrap
msgid "M"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:51
#, no-wrap
msgid "mega"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:51
#, no-wrap
msgid "10^ 6  = 1000000"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:52
#, no-wrap
msgid "G"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:52
#, no-wrap
msgid "giga"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:52
#, no-wrap
msgid "10^ 9  = 1000000000"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:53
#, no-wrap
msgid "T"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:53
#, no-wrap
msgid "tera"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:53
#, no-wrap
msgid "10^12  = 1000000000000"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:54
#, no-wrap
msgid "P"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:54
#, no-wrap
msgid "peta"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:54
#, no-wrap
msgid "10^15  = 1000000000000000"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:55
#, no-wrap
msgid "E"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:55
#, no-wrap
msgid "exa"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:55
#, no-wrap
msgid "10^18  = 1000000000000000000"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:56
#, no-wrap
msgid "Z"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:56
#, no-wrap
msgid "zetta"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:56
#, no-wrap
msgid "10^21  = 1000000000000000000000"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:57
#, no-wrap
msgid "Y"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:57
#, no-wrap
msgid "yotta"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:57
#, no-wrap
msgid "10^24  = 1000000000000000000000000"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:64
msgid ""
"The symbol for micro is the Greek letter mu, often written u in an ASCII "
"context where this Greek letter is not available.  See also"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:68
msgid "E<.UR http://physics.nist.gov\\:/cuu\\:/Units\\:/prefixes.html> E<.UE>"
msgstr ""

#. type: SS
#: man-pages/man7/units.7:69
#, no-wrap
msgid "Binary prefixes"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:76
msgid ""
"The binary prefixes resemble the decimal ones, but have an additional "
"\\(aqi\\(aq (and \"Ki\" starts with a capital \\(aqK\\(aq).  The names are "
"formed by taking the first syllable of the names of the decimal prefix with "
"roughly the same size, followed by \"bi\" for \"binary\"."
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:80
#, no-wrap
msgid "Ki"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:80
#, no-wrap
msgid "kibi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:80
#, no-wrap
msgid "2^10 = 1024"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:81
#, no-wrap
msgid "Mi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:81
#, no-wrap
msgid "mebi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:81
#, no-wrap
msgid "2^20 = 1048576"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:82
#, no-wrap
msgid "Gi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:82
#, no-wrap
msgid "gibi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:82
#, no-wrap
msgid "2^30 = 1073741824"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:83
#, no-wrap
msgid "Ti"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:83
#, no-wrap
msgid "tebi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:83
#, no-wrap
msgid "2^40 = 1099511627776"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:84
#, no-wrap
msgid "Pi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:84
#, no-wrap
msgid "pebi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:84
#, no-wrap
msgid "2^50 = 1125899906842624"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:85
#, no-wrap
msgid "Ei"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:85
#, no-wrap
msgid "exbi"
msgstr ""

#. type: tbl table
#: man-pages/man7/units.7:85
#, no-wrap
msgid "2^60 = 1152921504606846976"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:90
msgid "See also"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:93
msgid "E<.UR http://physics.nist.gov\\:/cuu\\:/Units\\:/binary.html> E<.UE>"
msgstr ""

#. type: SS
#: man-pages/man7/units.7:93
#, no-wrap
msgid "Discussion"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:98
msgid ""
"Before these binary prefixes were introduced, it was fairly common to use "
"k=1000 and K=1024, just like b=bit, B=byte.  Unfortunately, the M is capital"
" already, and cannot be capitalized to indicate binary-ness."
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:109
msgid ""
"At first that didn't matter too much, since memory modules and disks came in"
" sizes that were powers of two, so everyone knew that in such contexts "
"\"kilobyte\" and \"megabyte\" meant 1024 and 1048576 bytes, respectively.  "
"What originally was a sloppy use of the prefixes \"kilo\" and \"mega\" "
"started to become regarded as the \"real true meaning\" when computers were "
"involved.  But then disk technology changed, and disk sizes became arbitrary"
" numbers.  After a period of uncertainty all disk manufacturers settled on "
"the standard, namely k=1000, M=1000\\ k, G=1000\\ M."
msgstr ""

#.  also common: 14.4k modem
#. type: Plain text
#: man-pages/man7/units.7:116
msgid ""
"The situation was messy: in the 14k4 modems, k=1000; in the 1.44\\ MB "
"diskettes, M=1024000; and so on.  In 1998 the IEC approved the standard that"
" defines the binary prefixes given above, enabling people to be precise and "
"unambiguous."
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:118
msgid "Thus, today, MB = 1000000\\ B and MiB = 1048576\\ B."
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:122
msgid ""
"In the free software world programs are slowly being changed to conform.  "
"When the Linux kernel boots and says"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:126
#, no-wrap
msgid "hda: 120064896 sectors (61473 MB) w/2048KiB Cache\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/units.7:129
msgid "the MB are megabytes and the KiB are kibibytes."
msgstr ""

#. type: TH
#: man-pages/man7/uts_namespaces.7:26
#, no-wrap
msgid "UTS_NAMESPACES"
msgstr ""

#. type: TH
#: man-pages/man7/uts_namespaces.7:26
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: man-pages/man7/uts_namespaces.7:29
msgid "namespaces - overview of Linux UTS namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/uts_namespaces.7:41
msgid ""
"UTS namespaces provide isolation of two system identifiers: the hostname and"
" the NIS domain name.  These identifiers are set using B<sethostname>(2)  "
"and B<setdomainname>(2), and can be retrieved using B<uname>(2), "
"B<gethostname>(2), and B<getdomainname>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/uts_namespaces.7:51
msgid ""
"When a process creates a new UTS namespace using B<clone>(2)  or "
"B<unshare>(2)  with the B<CLONE_NEWUTS> flag, the hostname and domain of the"
" new UTS namespace are copied from the corresponding values in the caller's "
"UTS namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/uts_namespaces.7:55
msgid ""
"Use of UTS namespaces requires a kernel that is configured with the "
"B<CONFIG_UTS_NS> option."
msgstr ""

#. type: SH
#: man-pages/man7/uts_namespaces.7:55
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man7/uts_namespaces.7:64
msgid ""
"B<nsenter>(1), B<unshare>(1), B<clone>(2), B<getdomainname>(2), "
"B<gethostname>(2), B<setns>(2), B<uname>(2), B<unshare>(2), B<namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/unix.7:20
#, no-wrap
msgid "UNIX"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:23
msgid "unix - sockets for local interprocess communication"
msgstr ""

#. type: SH
#: man-pages/man7/unix.7:23
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:25
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:27
msgid "B<#include E<lt>sys/un.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:29
msgid "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:31
msgid "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:42
msgid ""
"The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
"communicate between processes on the same machine efficiently.  "
"Traditionally, UNIX domain sockets can be either unnamed, or bound to a "
"filesystem pathname (marked as being of type socket).  Linux also supports "
"an abstract namespace which is independent of the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:55
msgid ""
"Valid socket types in the UNIX domain are: B<SOCK_STREAM>, for a stream-"
"oriented socket; B<SOCK_DGRAM>, for a datagram-oriented socket that "
"preserves message boundaries (as on most UNIX implementations, UNIX domain "
"datagram sockets are always reliable and don't reorder datagrams); and "
"(since Linux 2.6.4)  B<SOCK_SEQPACKET>, for a sequenced-packet socket that "
"is connection-oriented, preserves message boundaries, and delivers messages "
"in the order that they were sent."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:58
msgid ""
"UNIX domain sockets support passing file descriptors or process credentials "
"to other processes using ancillary data."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:58
#, no-wrap
msgid "Address format"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:60
msgid ""
"A UNIX domain socket address is represented in the following structure:"
msgstr ""

#.  #define UNIX_PATH_MAX    108
#. type: Plain text
#: man-pages/man7/unix.7:69
#, no-wrap
msgid ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* Pathname */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:79
msgid ""
"The I<sun_family> field always contains B<AF_UNIX>.  On Linux, I<sun_path> "
"is 108 bytes in size; see also NOTES, below."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:95
msgid ""
"Various systems calls (for example, B<bind>(2), B<connect>(2), and "
"B<sendto>(2))  take a I<sockaddr_un> argument as input.  Some other system "
"calls (for example, B<getsockname>(2), B<getpeername>(2), B<recvfrom>(2), "
"and B<accept>(2))  return an argument of this type."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:99
msgid ""
"Three types of address are distinguished in the I<sockaddr_un> structure:"
msgstr ""

#. type: IP
#: man-pages/man7/unix.7:99 man-pages/man7/unix.7:124
#: man-pages/man7/unix.7:140 man-pages/man7/unix.7:165
#: man-pages/man7/unix.7:169 man-pages/man7/unix.7:173
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:107
msgid ""
"I<pathname>: a UNIX domain socket can be bound to a null-terminated "
"filesystem pathname using B<bind>(2).  When the address of a pathname socket"
" is returned (by one of the system calls noted above), its length is"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:109
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:122
msgid ""
"and I<sun_path> contains the null-terminated pathname.  (On Linux, the above"
" B<offsetof>()  expression equates to the same value as "
"I<sizeof(sa_family_t)>, but some other implementations include other fields "
"before I<sun_path>, so the B<offsetof>()  expression more portably describes"
" the size of the address structure.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:124
msgid "For further details of pathname sockets, see below."
msgstr ""

#.  There is quite some variation across implementations: FreeBSD
#.  says the length is 16 bytes, HP-UX 11 says it's zero bytes.
#. type: Plain text
#: man-pages/man7/unix.7:140
msgid ""
"I<unnamed>: A stream socket that has not been bound to a pathname using "
"B<bind>(2)  has no name.  Likewise, the two sockets created by "
"B<socketpair>(2)  are unnamed.  When the address of an unnamed socket is "
"returned, its length is I<sizeof(sa_family_t)>, and I<sun_path> should not "
"be inspected."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:162
msgid ""
"I<abstract>: an abstract socket address is distinguished (from a pathname "
"socket)  by the fact that I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  "
"The socket's address in this namespace is given by the additional bytes in "
"I<sun_path> that are covered by the specified length of the address "
"structure.  (Null bytes in the name have no special significance.)  The name"
" has no connection with filesystem pathnames.  When the address of an "
"abstract socket is returned, the returned I<addrlen> is greater than "
"I<sizeof(sa_family_t)> (i.e., greater than 2), and the name of the socket is"
" contained in the first I<(addrlen - sizeof(sa_family_t))> bytes of "
"I<sun_path>."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:162
#, no-wrap
msgid "Pathname sockets"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:165
msgid ""
"When binding a socket to a pathname, a few rules should be observed for "
"maximum portability and ease of coding:"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:169
msgid "The pathname in I<sun_path> should be null-terminated."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:173
msgid ""
"The length of the pathname, including the terminating null byte, should not "
"exceed the size of I<sun_path>."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:179
msgid ""
"The I<addrlen> argument that describes the enclosing I<sockaddr_un> "
"structure should have a value of at least:"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:182
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:188
msgid ""
"or, more simply, I<addrlen> can be specified as I<sizeof(struct "
"sockaddr_un)>."
msgstr ""

#.  Linux does this, including for the case where the supplied path
#.  is 108 bytes
#. type: Plain text
#: man-pages/man7/unix.7:196
msgid ""
"There is some variation in how implementations handle UNIX domain socket "
"addresses that do not follow the above rules.  For example, some (but not "
"all) implementations append a null terminator if none is present in the "
"supplied I<sun_path>."
msgstr ""

#.  HP-UX
#.  Modern BSDs generally have 104, Tru64 and AIX have 104,
#.  Solaris and Irix have 108
#. type: Plain text
#: man-pages/man7/unix.7:205
msgid ""
"When coding portable applications, keep in mind that some implementations "
"have I<sun_path> as short as 92 bytes."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:224
msgid ""
"Various system calls (B<accept>(2), B<recvfrom>(2), B<getsockname>(2), "
"B<getpeername>(2))  return socket address structures.  When applied to UNIX "
"domain sockets, the value-result I<addrlen> argument supplied to the call "
"should be initialized as above.  Upon return, the argument is set to "
"indicate the I<actual> size of the address structure.  The caller should "
"check the value returned in this argument: if the output value exceeds the "
"input value, then there is no guarantee that a null terminator is present in"
" I<sun_path>.  (See BUGS.)"
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:224
#, no-wrap
msgid "Pathname socket ownership and permissions"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:229
msgid ""
"In the Linux implementation, pathname sockets honor the permissions of the "
"directory they are in.  Creation of a new socket fails if the process does "
"not have write and search (execute) permission on the directory in which the"
" socket is created."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:239
msgid ""
"On Linux, connecting to a stream socket object requires write permission on "
"that socket; sending a datagram to a datagram socket likewise requires write"
" permission on that socket.  POSIX does not make any statement about the "
"effect of the permissions on a socket file, and on some systems (e.g., older"
" BSDs), the socket permissions are ignored.  Portable programs should not "
"rely on this feature for security."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:245
msgid ""
"When creating a new socket, the owner and group of the socket file are set "
"according to the usual rules.  The socket file has all permissions enabled, "
"other than those that are turned off by the process B<umask>(2)."
msgstr ""

#.  However, fchown() and fchmod() do not seem to have an effect
#. type: Plain text
#: man-pages/man7/unix.7:252
msgid ""
"The owner, group, and permissions of a pathname socket can be changed (using"
" B<chown>(2)  and B<chmod>(2))."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:252
#, no-wrap
msgid "Abstract sockets"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:262
msgid ""
"Socket permissions have no meaning for abstract sockets: the process "
"B<umask>(2)  has no effect when binding an abstract socket, and changing the"
" ownership and permissions of the object (via B<fchown>(2)  and "
"B<fchmod>(2))  has no effect on the accessibility of the socket."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:265
msgid ""
"Abstract sockets automatically disappear when all open references to the "
"socket are closed."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:268
msgid "The abstract socket namespace is a nonportable Linux extension."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:268
#, no-wrap
msgid "Socket options"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:281
msgid ""
"For historical reasons, these socket options are specified with a "
"B<SOL_SOCKET> type even though they are B<AF_UNIX> specific.  They can be "
"set with B<setsockopt>(2)  and read with B<getsockopt>(2)  by specifying "
"B<SOL_SOCKET> as the socket family."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:281
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:293
msgid ""
"Enabling this socket option causes receipt of the credentials of the sending"
" process in an B<SCM_CREDENTIALS ancillary> message in each subsequently "
"received message.  The returned credentials are those specified by the "
"sender using B<SCM_CREDENTIALS>, or a default that includes the sender's "
"PID, real user ID, and real group ID, if the sender did not specify "
"B<SCM_CREDENTIALS> ancillary data."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:296
msgid ""
"When this option is set and the socket is not yet connected, a unique name "
"in the abstract namespace will be generated automatically."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:302 man-pages/man7/unix.7:314
msgid ""
"The value given as an argument to B<setsockopt>(2)  and returned as the "
"result of B<getsockopt>(2)  is an integer boolean flag."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:302
#, no-wrap
msgid "B<SO_PASSSEC>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:308
msgid ""
"Enables receiving of the SELinux security label of the peer socket in an "
"ancillary message of type B<SCM_SECURITY> (see below)."
msgstr ""

#.  commit 877ce7c1b3afd69a9b1caeb1b9964c992641f52a
#.  commit 37a9a8df8ce9de6ea73349c9ac8bdf6ba4ec4f70
#. type: Plain text
#: man-pages/man7/unix.7:323
msgid ""
"The B<SO_PASSSEC> option is supported for UNIX domain datagram sockets since"
" Linux 2.6.18; support for UNIX domain stream sockets was added in Linux "
"4.2."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:323
#, no-wrap
msgid "B<SO_PEEK_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:327
msgid "See B<socket>(7)."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:327
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:336
msgid ""
"This read-only socket option returns the credentials of the peer process "
"connected to this socket.  The returned credentials are those that were in "
"effect at the time of the call to B<connect>(2)  or B<socketpair>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:345
msgid ""
"The argument to B<getsockopt>(2)  is a pointer to a I<ucred> structure; "
"define the B<_GNU_SOURCE> feature test macro to obtain the definition of "
"that structure from I<E<lt>sys/socket.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:353
msgid ""
"The use of this option is possible only for connected B<AF_UNIX> stream "
"sockets and for B<AF_UNIX> stream and datagram socket pairs created using "
"B<socketpair>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:353
#, no-wrap
msgid "Autobind feature"
msgstr ""

#.  i.e., sizeof(short)
#. type: Plain text
#: man-pages/man7/unix.7:373
msgid ""
"If a B<bind>(2)  call specifies I<addrlen> as I<sizeof(sa_family_t)>, or the"
" B<SO_PASSCRED> socket option was specified for a socket that was not "
"explicitly bound to an address, then the socket is autobound to an abstract "
"address.  The address consists of a null byte followed by 5 bytes in the "
"character set I<[0-9a-f]>.  Thus, there is a limit of 2^20 autobind "
"addresses.  (From Linux 2.1.15, when the autobind feature was added, 8 bytes"
" were used, and the limit was thus 2^32 autobind addresses.  The change to 5"
" bytes came in Linux 2.3.15.)"
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:373
#, no-wrap
msgid "Sockets API"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:376
msgid ""
"The following paragraphs describe domain-specific details and unsupported "
"features of the sockets API for UNIX domain sockets on Linux."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:384
msgid ""
"UNIX domain sockets do not support the transmission of out-of-band data (the"
" B<MSG_OOB> flag for B<send>(2)  and B<recv>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:389
msgid ""
"The B<send>(2)  B<MSG_MORE> flag is not supported by UNIX domain sockets."
msgstr ""

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: man-pages/man7/unix.7:399
msgid ""
"Before Linux 3.4, the use of B<MSG_TRUNC> in the I<flags> argument of "
"B<recv>(2)  was not supported by UNIX domain sockets."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:411
msgid ""
"The B<SO_SNDBUF> socket option does have an effect for UNIX domain sockets, "
"but the B<SO_RCVBUF> option does not.  For datagram sockets, the "
"B<SO_SNDBUF> value imposes an upper limit on the size of outgoing datagrams."
"  This limit is calculated as the doubled (see B<socket>(7))  option value "
"less 32 bytes used for overhead."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:411
#, no-wrap
msgid "Ancillary messages"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:433
msgid ""
"Ancillary data is sent and received using B<sendmsg>(2)  and B<recvmsg>(2)."
"  For historical reasons, the ancillary message types listed below are "
"specified with a B<SOL_SOCKET> type even though they are B<AF_UNIX> "
"specific.  To send them, set the I<cmsg_level> field of the struct "
"I<cmsghdr> to B<SOL_SOCKET> and the I<cmsg_type> field to the type.  For "
"more information, see B<cmsg>(3)."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:433
#, no-wrap
msgid "B<SCM_RIGHTS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:437
msgid ""
"Send or receive a set of open file descriptors from another process.  The "
"data portion contains an integer array of the file descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:448
msgid ""
"Commonly, this operation is referred to as \"passing a file descriptor\" to "
"another process.  However, more accurately, what is being passed is a "
"reference to an open file description (see B<open>(2)), and in the receiving"
" process it is likely that a different file descriptor number will be used."
"  Semantically, this operation is equivalent to duplicating (B<dup>(2))  a "
"file descriptor into the file descriptor table of another process."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:454
msgid ""
"If the buffer used to receive the ancillary data containing file descriptors"
" is too small (or is absent), then the ancillary data is truncated (or "
"discarded)  and the excess file descriptors are automatically closed in the "
"receiving process."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:462
msgid ""
"If the number of file descriptors received in the ancillary data would cause"
" the process to exceed its B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2)), the excess file descriptors are automatically closed in "
"the receiving process."
msgstr ""

#.  commit bba14de98753cb6599a2dae0e520714b2153522d
#. type: Plain text
#: man-pages/man7/unix.7:475
msgid ""
"The kernel constant B<SCM_MAX_FD> defines a limit on the number of file "
"descriptors in the array.  Attempting to send an array larger than this "
"limit causes B<sendmsg>(2)  to fail with the error B<EINVAL>.  B<SCM_MAX_FD>"
" has the value 253 (or 255 in kernels before 2.6.38)."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:475
#, no-wrap
msgid "B<SCM_CREDENTIALS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:485
msgid ""
"Send or receive UNIX credentials.  This can be used for authentication.  The"
" credentials are passed as a I<struct ucred> ancillary message.  Thus "
"structure is defined in I<E<lt>sys/socket.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:493
#, no-wrap
msgid ""
"struct ucred {\n"
"    pid_t pid;    /* Process ID of the sending process */\n"
"    uid_t uid;    /* User ID of the sending process */\n"
"    gid_t gid;    /* Group ID of the sending process */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:502
msgid ""
"Since glibc 2.8, the B<_GNU_SOURCE> feature test macro must be defined "
"(before including I<any> header files) in order to obtain the definition of "
"this structure."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:512
msgid ""
"The credentials which the sender specifies are checked by the kernel.  A "
"privileged process is allowed to specify values that do not match its own.  "
"The sender must specify its own process ID (unless it has the capability "
"B<CAP_SYS_ADMIN>), its real user ID, effective user ID, or saved set-user-ID"
" (unless it has B<CAP_SETUID>), and its real group ID, effective group ID, "
"or saved set-group-ID (unless it has B<CAP_SETGID>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:518
msgid ""
"To receive a I<struct ucred> message, the B<SO_PASSCRED> option must be "
"enabled on the socket."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:518
#, no-wrap
msgid "B<SCM_SECURITY>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:527
msgid ""
"Receive the SELinux security context (the security label)  of the peer "
"socket.  The received ancillary data is a null-terminated string containing "
"the security context.  The receiver should allocate at least B<NAME_MAX> "
"bytes in the data portion of the ancillary message for this data."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:531
msgid ""
"To receive the security context, the B<SO_PASSSEC> option must be enabled on"
" the socket (see above)."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:535
msgid ""
"When sending ancillary data with B<sendmsg>(2), only one item of each of the"
" above types may be included in the sent message."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:543
msgid ""
"At least one byte of real data should be sent when sending ancillary data.  "
"On Linux, this is required to successfully send ancillary data over a UNIX "
"domain stream socket.  When sending ancillary data over a UNIX domain "
"datagram socket, it is not necessary on Linux to send any accompanying real "
"data.  However, portable applications should also include at least one byte "
"of real data when sending ancillary data over a datagram socket."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:547
msgid ""
"When receiving from a stream socket, ancillary data forms a kind of barrier "
"for the received data.  For example, suppose that the sender transmits as "
"follows:"
msgstr ""

#. type: IP
#: man-pages/man7/unix.7:550
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:553 man-pages/man7/unix.7:559
msgid "B<sendmsg>(2)  of four bytes, with no ancillary data."
msgstr ""

#. type: IP
#: man-pages/man7/unix.7:553
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:556
msgid "B<sendmsg>(2)  of one byte, with ancillary data."
msgstr ""

#. type: IP
#: man-pages/man7/unix.7:556
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:570
msgid ""
"Suppose that the receiver now performs B<recvmsg>(2)  calls each with a "
"buffer size of 20 bytes.  The first call will receive five bytes of data, "
"along with the ancillary data sent by the second B<sendmsg>(2)  call.  The "
"next call will receive the remaining five bytes of data."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:591
msgid ""
"If the space allocated for receiving incoming ancillary data is too small "
"then the ancillary data is truncated to the number of headers that will fit "
"in the supplied buffer (or, in the case of an B<SCM_RIGHTS> file descriptor "
"list, the list of file descriptors may be truncated).  If no buffer is "
"provided for incoming ancillary data (i.e., the I<msg_control> field of the "
"I<msghdr> structure supplied to B<recvmsg>(2)  is NULL), then the incoming "
"ancillary data is discarded.  In both of these cases, the B<MSG_CTRUNC> flag"
" will be set in the I<msg.msg_flags> value returned by B<recvmsg>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:591
#, no-wrap
msgid "Ioctls"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:597
msgid ""
"The following B<ioctl>(2)  calls return information in I<value>.  The "
"correct syntax is:"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:602
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:607
msgid "I<ioctl_type> can be:"
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:607
#, no-wrap
msgid "B<SIOCINQ>"
msgstr ""

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#.  SIOCOUTQ also has an effect for UNIX domain sockets, but not
#.  quite what userland might expect. It seems to return the number
#.  of bytes allocated for buffers containing pending output.
#.  That number is normally larger than the number of bytes of pending
#.  output. Since this info is, from userland's point of view, imprecise,
#.  and it may well change, probably best not to document this now.
#. type: Plain text
#: man-pages/man7/unix.7:638
msgid ""
"For B<SOCK_STREAM> sockets, this call returns the number of unread bytes in "
"the receive buffer.  The socket must not be in LISTEN state, otherwise an "
"error (B<EINVAL>)  is returned.  B<SIOCINQ> is defined in "
"I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you can use the synonymous "
"B<FIONREAD>, defined in I<E<lt>sys/ioctl.hE<gt>>.  For B<SOCK_DGRAM> "
"sockets, the returned value is the same as for Internet domain datagram "
"sockets; see B<udp>(7)."
msgstr ""

#. type: SH
#: man-pages/man7/unix.7:638
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:639
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:643
msgid ""
"The specified local address is already in use or the filesystem socket "
"object already exists."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:643
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:652
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above), and indicates that the file descriptor number that is"
" being sent is not valid (e.g., it is not an open file descriptor)."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:652
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:658
msgid ""
"The remote address specified by B<connect>(2)  was not a listening socket.  "
"This error can also occur if the target pathname is not a socket."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:658
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:661
msgid "Remote socket was unexpectedly closed."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:661
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:664
msgid "User memory address was not valid."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:664
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:673
msgid ""
"Invalid argument passed.  A common cause is that the value B<AF_UNIX> was "
"not specified in the I<sun_type> field of passed addresses, or the socket "
"was in an invalid state for the applied operation."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:673
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:678
msgid ""
"B<connect>(2)  called on an already connected socket or a target address was"
" specified on a connected socket."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:678
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:683
msgid ""
"The pathname in the remote address specified to B<connect>(2)  did not "
"exist."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:683
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:686
msgid "Out of memory."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:686
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:689
msgid ""
"Socket operation needs a target address, but the socket is not connected."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:689
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:693
msgid ""
"Stream operation called on non-stream oriented socket or tried to use the "
"out-of-band data option."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:693
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:697
msgid "The sender passed invalid credentials in the I<struct ucred>."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:697
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:709
msgid ""
"Remote socket was closed on a stream socket.  If enabled, a B<SIGPIPE> is "
"sent as well.  This can be avoided by passing the B<MSG_NOSIGNAL> flag to "
"B<send>(2)  or B<sendmsg>(2)."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:709
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:713
msgid "Passed protocol is not B<AF_UNIX>."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:713
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:719
msgid ""
"Remote socket does not match the local socket type (B<SOCK_DGRAM> versus "
"B<SOCK_STREAM>)."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:719
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:722
msgid "Unknown socket type."
msgstr ""

#. type: TP
#: man-pages/man7/unix.7:722
#, no-wrap
msgid "B<ETOOMANYREFS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:739
msgid ""
"This error can occur for B<sendmsg>(2)  when sending a file descriptor as "
"ancillary data over a UNIX domain socket (see the description of "
"B<SCM_RIGHTS>, above).  It occurs if the number of \"in-flight\" file "
"descriptors exceeds the B<RLIMIT_NOFILE> resource limit and the caller does "
"not have the B<CAP_SYS_RESOURCE> capability.  An in-flight file descriptor "
"is one that has been sent using B<sendmsg>(2)  but has not yet been accepted"
" in the recipient process using B<recvmsg>(2)."
msgstr ""

#.  commit 712f4aad406bb1ed67f3f98d04c044191f0ff593
#. type: Plain text
#: man-pages/man7/unix.7:750
msgid ""
"This error is diagnosed since mainline Linux 4.5 (and in some earlier kernel"
" versions where the fix has been backported).  In earlier kernel versions, "
"it was possible to place an unlimited number of file descriptors in flight, "
"by sending each file descriptor with B<sendmsg>(2)  and then closing the "
"file descriptor so that it was not accounted against the B<RLIMIT_NOFILE> "
"resource limit."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:754
msgid ""
"Other errors can be generated by the generic socket layer or by the "
"filesystem while generating a filesystem socket object.  See the appropriate"
" manual pages for more information."
msgstr ""

#. type: SH
#: man-pages/man7/unix.7:754
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:760
msgid ""
"B<SCM_CREDENTIALS> and the abstract namespace were introduced with Linux 2.2"
" and should not be used in portable programs.  (Some BSD-derived systems "
"also support credential passing, but the implementation details differ.)"
msgstr ""

#. type: SH
#: man-pages/man7/unix.7:760
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:768
msgid ""
"Binding to a socket with a filename creates a socket in the filesystem that "
"must be deleted by the caller when it is no longer needed (using "
"B<unlink>(2)).  The usual UNIX close-behind semantics apply; the socket can "
"be unlinked at any time and will be finally removed from the filesystem when"
" the last reference to it is closed."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:777
msgid ""
"To pass file descriptors or credentials over a B<SOCK_STREAM> socket, you "
"must to send or receive at least one byte of nonancillary data in the same "
"B<sendmsg>(2)  or B<recvmsg>(2)  call."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:780
msgid ""
"UNIX domain stream sockets do not support the notion of out-of-band data."
msgstr ""

#. type: SH
#: man-pages/man7/unix.7:780
#, no-wrap
msgid "BUGS"
msgstr ""

#.  The behavior on Solaris is quite similar.
#. type: Plain text
#: man-pages/man7/unix.7:805
msgid ""
"When binding a socket to an address, Linux is one of the implementations "
"that appends a null terminator if none is supplied in I<sun_path>.  In most "
"cases this is unproblematic: when the socket address is retrieved, it will "
"be one byte longer than that supplied when the socket was bound.  However, "
"there is one case where confusing behavior can result: if 108 non-null bytes"
" are supplied when a socket is bound, then the addition of the null "
"terminator takes the length of the pathname beyond I<sizeof(sun_path)>.  "
"Consequently, when retrieving the socket address (for example, via "
"B<accept>(2)), if the input I<addrlen> argument for the retrieving call is "
"specified as I<sizeof(struct sockaddr_un)>, then the returned address "
"structure I<won't> have a null terminator in I<sun_path>."
msgstr ""

#.  i.e., traditional BSD
#. type: Plain text
#: man-pages/man7/unix.7:815
msgid ""
"In addition, some implementations don't require a null terminator when "
"binding a socket (the I<addrlen> argument is used to determine the length of"
" I<sun_path>)  and when the socket address is retrieved on these "
"implementations, there is no null terminator in I<sun_path>."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:820
msgid ""
"Applications that retrieve socket addresses can (portably) code to handle "
"the possibility that there is no null terminator in I<sun_path> by "
"respecting the fact that the number of valid bytes in the pathname is:"
msgstr ""

#.  The following patch to amend kernel behavior was rejected:
#.  http://thread.gmane.org/gmane.linux.kernel.api/2437
#.  Subject: [patch] Fix handling of overlength pathname in AF_UNIX sun_path
#.  2012-04-17
#.  And there was a related discussion in the Austin list:
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/5735
#.  Subject: Having a sun_path with no null terminator
#.  2012-04-18
#.  FIXME . Track http://austingroupbugs.net/view.php?id=561
#. type: Plain text
#: man-pages/man7/unix.7:832
#, no-wrap
msgid "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:844
msgid ""
"Alternatively, an application can retrieve the socket address by allocating "
"a buffer of size I<sizeof(struct sockaddr_un)+1> that is zeroed out before "
"the retrieval.  The retrieving call can specify I<addrlen> as "
"I<sizeof(struct sockaddr_un)>, and the extra zero byte ensures that there "
"will be a null terminator for the string returned in I<sun_path>:"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:848
#, no-wrap
msgid "void *addrp;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:854
#, no-wrap
msgid ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* Handle error */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:857
#, no-wrap
msgid ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* handle error */ ;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:859
#, no-wrap
msgid "printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) addrp)-E<gt>sun_path);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:867
msgid ""
"This sort of messiness can be avoided if it is guaranteed that the "
"applications that I<create> pathname sockets follow the rules outlined above"
" under I<Pathname sockets>."
msgstr ""

#. type: SH
#: man-pages/man7/unix.7:867
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:879
msgid ""
"The following code demonstrates the use of sequenced-packet sockets for "
"local interprocess communication.  It consists of two programs.  The server "
"program waits for a connection from the client program.  The client sends "
"each of its command-line arguments in separate messages.  The server treats "
"the incoming messages as integers and adds them up.  The client sends the "
"command string \"END\".  The server sends back a message containing the sum "
"of the client's integers.  The client prints the sum and exits.  The server "
"waits for the next client to connect.  To stop the server, the client is "
"called with the command-line argument \"DOWN\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:883
msgid ""
"The following output was recorded while running the server in the background"
" and repeatedly executing the client.  Execution of the server program ends "
"when it receives the \"DOWN\" command."
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:883
#, no-wrap
msgid "Example output"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:896
#, no-wrap
msgid ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Result = 7\n"
"$ B<./client 11 -5>\n"
"Result = 6\n"
"$ B<./client DOWN>\n"
"Result = 0\n"
"[1]+  Done                    ./server\n"
"$\n"
msgstr ""

#. type: SS
#: man-pages/man7/unix.7:898
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:904
#, no-wrap
msgid ""
"/*\n"
" * File connection.h\n"
" */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:907
#, no-wrap
msgid ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:911
#, no-wrap
msgid ""
"/*\n"
" * File server.c\n"
" */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:919
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:930
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:935
#, no-wrap
msgid ""
"    /*\n"
"     * In case the program exited inadvertently on the last run,\n"
"     * remove the socket.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:937 man-pages/man7/unix.7:1046
#, no-wrap
msgid "    unlink(SOCKET_NAME);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:939 man-pages/man7/unix.7:1073
#, no-wrap
msgid "    /* Create local socket. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:945
#, no-wrap
msgid ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:951 man-pages/man7/unix.7:1085
#, no-wrap
msgid ""
"    /*\n"
"     * For portability clear the whole structure, since some\n"
"     * implementations have additional (nonstandard) fields in\n"
"     * the structure.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:953
#, no-wrap
msgid "    memset(&name, 0, sizeof(struct sockaddr_un));\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:955
#, no-wrap
msgid "    /* Bind socket to socket name. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:958
#, no-wrap
msgid ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:965
#, no-wrap
msgid ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:971
#, no-wrap
msgid ""
"    /*\n"
"     * Prepare for accepting connections. The backlog size is set\n"
"     * to 20. So while one request is being processed other requests\n"
"     * can be waiting.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:977
#, no-wrap
msgid ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:979
#, no-wrap
msgid "    /* This is the main loop for handling connections. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:981
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:983
#, no-wrap
msgid "        /* Wait for incoming connection. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:989
#, no-wrap
msgid ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (data_socket == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:992
#, no-wrap
msgid ""
"        result = 0;\n"
"        for (;;) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:994
#, no-wrap
msgid "            /* Wait for next data packet. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1000
#, no-wrap
msgid ""
"            ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1002
#, no-wrap
msgid "            /* Ensure buffer is 0-terminated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1004
#, no-wrap
msgid "            buffer[BUFFER_SIZE - 1] = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1006
#, no-wrap
msgid "            /* Handle commands. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1011
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"DOWN\", BUFFER_SIZE)) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1015
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"END\", BUFFER_SIZE)) {\n"
"                break;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1017
#, no-wrap
msgid "            /* Add received summand. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1020
#, no-wrap
msgid ""
"            result += atoi(buffer);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1022
#, no-wrap
msgid "        /* Send result. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1029
#, no-wrap
msgid ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, BUFFER_SIZE);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1031
#, no-wrap
msgid "        /* Close socket. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1033
#, no-wrap
msgid "        close(data_socket);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1035
#, no-wrap
msgid "        /* Quit on DOWN command. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1040
#, no-wrap
msgid ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1042
#, no-wrap
msgid "    close(connection_socket);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1044
#, no-wrap
msgid "    /* Unlink the socket. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1049 man-pages/man7/unix.7:1139
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1053
#, no-wrap
msgid ""
"/*\n"
" * File client.c\n"
" */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1062
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1071
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int i;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1079
#, no-wrap
msgid ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1087
#, no-wrap
msgid "    memset(&addr, 0, sizeof(struct sockaddr_un));\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1089
#, no-wrap
msgid "    /* Connect socket to socket address */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1092
#, no-wrap
msgid ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1099
#, no-wrap
msgid ""
"    ret = connect (data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1101
#, no-wrap
msgid "    /* Send arguments. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1109
#, no-wrap
msgid ""
"    for (i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1111
#, no-wrap
msgid "    /* Request result. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1118
#, no-wrap
msgid ""
"    strcpy (buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1120
#, no-wrap
msgid "    /* Receive result. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1126
#, no-wrap
msgid ""
"    ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1128
#, no-wrap
msgid "    /* Ensure buffer is 0-terminated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1130
#, no-wrap
msgid "    buffer[BUFFER_SIZE - 1] = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1132
#, no-wrap
msgid "    printf(\"Result = %s\\en\", buffer);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1134
#, no-wrap
msgid "    /* Close socket. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1136
#, no-wrap
msgid "    close(data_socket);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1145
msgid "For an example of the use of B<SCM_RIGHTS> see B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/unix.7:1154
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/user-keyring.7:12
#, no-wrap
msgid "USER-KEYRING"
msgstr ""

#. type: TH
#: man-pages/man7/user-keyring.7:12
#, no-wrap
msgid "2017-03-13"
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:15
msgid "user-keyring - per-user keyring"
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:24
msgid ""
"The user keyring is a keyring used to anchor keys on behalf of a user.  Each"
" UID the kernel deals with has its own user keyring that is shared by all "
"processes with that UID.  The user keyring has a name (description) of the "
"form I<_uid.E<lt>UIDE<gt>> where I<E<lt>UIDE<gt>> is the user ID of the "
"corresponding user."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:36
msgid ""
"The user keyring is associated with the record that the kernel maintains for"
" the UID.  It comes into existence upon the first attempt to access either "
"the user keyring, the B<user-session-keyring>(7), or the B<session-"
"keyring>(7).  The keyring remains pinned in existence so long as there are "
"processes running with that real UID or files opened by those processes "
"remain open.  (The keyring can also be pinned indefinitely by linking it "
"into another keyring.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:40
msgid ""
"Typically, the user keyring is created by B<pam_keyinit>(8)  when a user "
"logs in."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:47
msgid ""
"The user keyring is not searched by default by B<request_key>(2).  When "
"B<pam_keyinit>(8)  creates a session keyring, it adds to it a link to the "
"user keyring so that the user keyring will be searched when the session "
"keyring is."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:52
msgid ""
"A special serial number value, B<KEY_SPEC_USER_KEYRING>, is defined that can"
" be used in lieu of the actual serial number of the calling process's user "
"keyring."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:57
msgid ""
"From the B<keyctl>(1)  utility, 'B<@u>' can be used instead of a numeric key"
" ID in much the same way."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:67
msgid ""
"User keyrings are independent of B<clone>(2), B<fork>(2), B<vfork>(2), "
"B<execve>(2), and B<_exit>(2)  excepting that the keyring is destroyed when "
"the UID record is destroyed when the last process pinning it exits."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:74
msgid ""
"If it is necessary for a key associated with a user to exist beyond the UID "
"record being garbage collected\\(emfor example, for use by a B<cron>(8)  "
"script\\(emthen the B<persistent-keyring>(7)  should be used instead."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:76
msgid ""
"If a user keyring does not exist when it is accessed, it will be created."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-keyring.7:87
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), B"
"<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"session-keyring>(7), B<pam_keyinit>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/utf-8.7:29
#, no-wrap
msgid "UTF-8"
msgstr ""

#. type: TH
#: man-pages/man7/utf-8.7:29
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: man-pages/man7/utf-8.7:29
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:32
msgid "UTF-8 - an ASCII compatible multibyte Unicode encoding"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:49
msgid ""
"The Unicode 3.0 character set occupies a 16-bit code space.  The most "
"obvious Unicode encoding (known as UCS-2)  consists of a sequence of 16-bit "
"words.  Such strings can contain\\(emas part of many 16-bit "
"characters\\(embytes such as \\(aq\\e0\\(aq or \\(aq/\\(aq, which have a "
"special meaning in filenames and other C library function arguments.  In "
"addition, the majority of UNIX tools expect ASCII files and can't read "
"16-bit words as characters without major modifications.  For these reasons, "
"UCS-2 is not a suitable external encoding of Unicode in filenames, text "
"files, environment variables, and so on.  The ISO 10646 Universal Character "
"Set (UCS), a superset of Unicode, occupies an even larger code "
"space\\(em31\\ bits\\(emand the obvious UCS-4 encoding for it (a sequence of"
" 32-bit words) has the same problems."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:53
msgid ""
"The UTF-8 encoding of Unicode and UCS does not have these problems and is "
"the common way in which Unicode is used on UNIX-style operating systems."
msgstr ""

#. type: SS
#: man-pages/man7/utf-8.7:53
#, no-wrap
msgid "Properties"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:55
msgid "The UTF-8 encoding has the following nice properties:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:66
msgid ""
"UCS characters 0x00000000 to 0x0000007f (the classic US-ASCII characters) "
"are encoded simply as bytes 0x00 to 0x7f (ASCII compatibility).  This means "
"that files and strings which contain only 7-bit ASCII characters have the "
"same encoding under both ASCII and UTF-8 ."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:72
msgid ""
"All UCS characters greater than 0x7f are encoded as a multibyte sequence "
"consisting only of bytes in the range 0x80 to 0xfd, so no ASCII byte can "
"appear as part of another character and there are no problems with, for "
"example, \\(aq\\e0\\(aq or \\(aq/\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:75
msgid "The lexicographic sorting order of UCS-4 strings is preserved."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:78
msgid "All possible 2^31 UCS codes can be encoded using UTF-8."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:81
msgid ""
"The bytes 0xc0, 0xc1, 0xfe, and 0xff are never used in the UTF-8 encoding."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:90
msgid ""
"The first byte of a multibyte sequence which represents a single non-ASCII "
"UCS character is always in the range 0xc2 to 0xfd and indicates how long "
"this multibyte sequence is.  All further bytes in a multibyte sequence are "
"in the range 0x80 to 0xbf.  This allows easy resynchronization and makes the"
" encoding stateless and robust against missing bytes."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:96
msgid ""
"UTF-8 encoded UCS characters may be up to six bytes long, however the "
"Unicode standard specifies no characters above 0x10ffff, so Unicode "
"characters can be only up to four bytes long in UTF-8."
msgstr ""

#. type: SS
#: man-pages/man7/utf-8.7:96
#, no-wrap
msgid "Encoding"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:99
msgid ""
"The following byte sequences are used to represent a character.  The "
"sequence to be used depends on the UCS code number of the character:"
msgstr ""

#. type: TP
#: man-pages/man7/utf-8.7:99
#, no-wrap
msgid "0x00000000 - 0x0000007F:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:102
msgid "0I<xxxxxxx>"
msgstr ""

#. type: TP
#: man-pages/man7/utf-8.7:102
#, no-wrap
msgid "0x00000080 - 0x000007FF:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:106
msgid "110I<xxxxx> 10I<xxxxxx>"
msgstr ""

#. type: TP
#: man-pages/man7/utf-8.7:106
#, no-wrap
msgid "0x00000800 - 0x0000FFFF:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:111
msgid "1110I<xxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr ""

#. type: TP
#: man-pages/man7/utf-8.7:111
#, no-wrap
msgid "0x00010000 - 0x001FFFFF:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:117
msgid "11110I<xxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr ""

#. type: TP
#: man-pages/man7/utf-8.7:117
#, no-wrap
msgid "0x00200000 - 0x03FFFFFF:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:124
msgid "111110I<xx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr ""

#. type: TP
#: man-pages/man7/utf-8.7:124
#, no-wrap
msgid "0x04000000 - 0x7FFFFFFF:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:132
msgid ""
"1111110I<x> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx> 10I<xxxxxx>"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:139
msgid ""
"The I<xxx> bit positions are filled with the bits of the character code "
"number in binary representation, most significant bit first (big-endian).  "
"Only the shortest possible multibyte sequence which can represent the code "
"number of the character can be used."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:144
msgid ""
"The UCS code values 0xd800\\(en0xdfff (UTF-16 surrogates) as well as 0xfffe "
"and 0xffff (UCS noncharacters) should not appear in conforming UTF-8 "
"streams. According to RFC 3629 no point above U+10FFFF should be used, which"
" limits characters to four bytes."
msgstr ""

#. type: SS
#: man-pages/man7/utf-8.7:144
#, no-wrap
msgid "Example"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:147
msgid ""
"The Unicode character 0xa9 = 1010 1001 (the copyright sign) is encoded in "
"UTF-8 as"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:150
msgid "11000010 10101001 = 0xc2 0xa9"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:154
msgid ""
"and character 0x2260 = 0010 0010 0110 0000 (the \"not equal\" symbol) is "
"encoded as:"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:157
msgid "11100010 10001001 10100000 = 0xe2 0x89 0xa0"
msgstr ""

#. type: SS
#: man-pages/man7/utf-8.7:158
#, no-wrap
msgid "Application notes"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:160
msgid "Users have to select a UTF-8 locale, for example with"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:163
msgid "export LANG=en_GB.UTF-8"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:166
msgid "in order to activate the UTF-8 support in applications."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:169
msgid ""
"Application software that has to be aware of the used character encoding "
"should always set the locale with for example"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:172
msgid "setlocale(LC_CTYPE, \"\")"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:175
msgid "and programmers can then test the expression"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:178
msgid "strcmp(nl_langinfo(CODESET), \"UTF-8\") == 0"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:184
msgid ""
"to determine whether a UTF-8 locale has been selected and whether therefore "
"all plaintext standard input and output, terminal communication, plaintext "
"file content, filenames and environment variables are encoded in UTF-8."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:200
msgid ""
"Programmers accustomed to single-byte encodings such as US-ASCII or ISO 8859"
" have to be aware that two assumptions made so far are no longer valid in "
"UTF-8 locales.  Firstly, a single byte does not necessarily correspond any "
"more to a single character.  Secondly, since modern terminal emulators in "
"UTF-8 mode also support Chinese, Japanese, and Korean double-width "
"characters as well as nonspacing combining characters, outputting a single "
"character does not necessarily advance the cursor by one position as it did "
"in ASCII.  Library functions such as B<mbsrtowcs>(3)  and B<wcswidth>(3)  "
"should be used today to count characters and cursor positions."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:209
msgid ""
"The official ESC sequence to switch from an ISO 2022 encoding scheme (as "
"used for instance by VT100 terminals) to UTF-8 is ESC % G (\"\\ex1b%G\").  "
"The corresponding return sequence from UTF-8 to ISO 2022 is ESC % @ "
"(\"\\ex1b%@\").  Other ISO 2022 sequences (such as for switching the G0 and "
"G1 sets) are not applicable in UTF-8 mode."
msgstr ""

#. type: SS
#: man-pages/man7/utf-8.7:209
#, no-wrap
msgid "Security"
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:221
msgid ""
"The Unicode and UCS standards require that producers of UTF-8 shall use the "
"shortest form possible, for example, producing a two-byte sequence with "
"first byte 0xc0 is nonconforming.  Unicode 3.1 has added the requirement "
"that conforming programs must not accept non-shortest forms in their input."
"  This is for security reasons: if user input is checked for possible "
"security violations, a program might check only for the ASCII version of "
"\"/../\" or \";\" or NUL and overlook that there are many non-ASCII ways to "
"represent these things in a non-shortest UTF-8 encoding."
msgstr ""

#. type: SS
#: man-pages/man7/utf-8.7:221
#, no-wrap
msgid "Standards"
msgstr ""

#.  .SH AUTHOR
#.  Markus Kuhn <mgk25@cl.cam.ac.uk>
#. type: Plain text
#: man-pages/man7/utf-8.7:225
msgid "ISO/IEC 10646-1:2000, Unicode 3.1, RFC\\ 3629, Plan 9."
msgstr ""

#. type: Plain text
#: man-pages/man7/utf-8.7:230
msgid ""
"B<locale>(1), B<nl_langinfo>(3), B<setlocale>(3), B<charsets>(7), "
"B<unicode>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/udplite.7:27
#, no-wrap
msgid "UDPLITE"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:30
msgid "udplite - Lightweight User Datagram Protocol"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:38
msgid "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:41
msgid ""
"This is an implementation of the Lightweight User Datagram Protocol (UDP-"
"Lite), as described in RFC\\ 3828."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:47
msgid ""
"UDP-Lite is an extension of UDP (RFC\\ 768) to support variable-length "
"checksums.  This has advantages for some types of multimedia transport that "
"may be able to make use of slightly damaged datagrams, rather than having "
"them discarded by lower-layer protocols."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:53
msgid ""
"The variable-length checksum coverage is set via a B<setsockopt>(2)  option."
"  If this option is not set, the only difference from UDP is in using a "
"different IP protocol identifier (IANA number 136)."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:58
msgid ""
"The UDP-Lite implementation is a full extension of B<udp>(7)\\(emthat is, it"
" shares the same API and API behavior, and in addition offers two socket "
"options to control the checksum coverage."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:67
msgid ""
"UDP-Litev4 uses the I<sockaddr_in> address format described in B<ip>(7).  "
"UDP-Litev6 uses the I<sockaddr_in6> address format described in B<ipv6>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:80
msgid ""
"To set or get a UDP-Lite socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDPLITE>.  In addition, all B<IPPROTO_UDP> socket options are "
"valid on a UDP-Lite socket.  See B<udp>(7)  for more information."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:82
msgid "The following two options are specific to UDP-Lite."
msgstr ""

#. type: TP
#: man-pages/man7/udplite.7:82
#, no-wrap
msgid "B<UDPLITE_SEND_CSCOV>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:87
msgid ""
"This option sets the sender checksum coverage and takes an I<int> as "
"argument, with a checksum coverage value in the range 0..2^16-1."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:91
msgid ""
"A value of 0 means that the entire datagram is always covered.  Values from "
"1-7 are illegal (RFC\\ 3828, 3.1) and are rounded up to the minimum coverage"
" of 8."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:97
msgid ""
"With regard to IPv6 jumbograms (RFC\\ 2675), the UDP-Litev6 checksum "
"coverage is limited to the first 2^16-1 octets, as per RFC\\ 3828, 3.5.  "
"Higher values are therefore silently truncated to 2^16-1.  If in doubt, the "
"current coverage value can always be queried using B<getsockopt>(2)."
msgstr ""

#. type: TP
#: man-pages/man7/udplite.7:97
#, no-wrap
msgid "B<UDPLITE_RECV_CSCOV>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:108
msgid ""
"This is the receiver-side analogue and uses the same argument format and "
"value range as B<UDPLITE_SEND_CSCOV>.  This option is not required to enable"
" traffic with partial checksum coverage.  Its function is that of a traffic "
"filter: when enabled, it instructs the kernel to drop all packets which have"
" a coverage I<less> than the specified coverage value."
msgstr ""

#.  SO_NO_CHECK exists and is supported by UDPv4, but is
#.  commented out in socket(7), hence also commented out here
#. .PP
#. Since UDP-Lite mandates checksums, checksumming can not be disabled
#. via the
#. .B SO_NO_CHECK
#. option from
#. .BR socket (7).
#. type: Plain text
#: man-pages/man7/udplite.7:121
msgid ""
"When the value of B<UDPLITE_RECV_CSCOV> exceeds the actual packet coverage, "
"incoming packets are silently dropped, but may generate a warning message in"
" the system log."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:126
msgid ""
"All errors documented for B<udp>(7)  may be returned.  UDP-Lite does not add"
" further errors."
msgstr ""

#. type: SH
#: man-pages/man7/udplite.7:126
#, no-wrap
msgid "FILES"
msgstr ""

#. type: TP
#: man-pages/man7/udplite.7:127
#, no-wrap
msgid "I</proc/net/snmp>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:130
msgid "Basic UDP-Litev4 statistics counters."
msgstr ""

#. type: TP
#: man-pages/man7/udplite.7:130
#, no-wrap
msgid "I</proc/net/snmp6>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:133
msgid "Basic UDP-Litev6 statistics counters."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:135
msgid "UDP-Litev4/v6 first appeared in Linux 2.6.20."
msgstr ""

#.  FIXME . remove this section once glibc supports UDP-Lite
#. type: Plain text
#: man-pages/man7/udplite.7:138
msgid "Where glibc support is missing, the following definitions are needed:"
msgstr ""

#.  The following two are defined in the kernel in linux/net/udplite.h
#. type: Plain text
#: man-pages/man7/udplite.7:145
#, no-wrap
msgid ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:152
msgid "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:154
msgid "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)."
msgstr ""

#. type: Plain text
#: man-pages/man7/udplite.7:156
msgid ""
"I<Documentation/networking/udplite.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man7/user_namespaces.7:27
#, no-wrap
msgid "USER_NAMESPACES"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:30
msgid "user_namespaces - overview of Linux user namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:33
msgid "For an overview of namespaces, see B<namespaces>(7)."
msgstr ""

#.  FIXME: This page says very little about the interaction
#.  of user namespaces and keys. Add something on this topic.
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:56
msgid ""
"User namespaces isolate security-related identifiers and attributes, in "
"particular, user IDs and group IDs (see B<credentials>(7)), the root "
"directory, keys (see B<keyrings>(7)), and capabilities (see "
"B<capabilities>(7)).  A process's user and group IDs can be different inside"
" and outside a user namespace.  In particular, a process can have a normal "
"unprivileged user ID outside a user namespace while at the same time having "
"a user ID of 0 inside the namespace; in other words, the process has full "
"privileges for operations inside the user namespace, but is unprivileged for"
" operations outside the namespace."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:56
#, no-wrap
msgid "Nested namespaces, namespace membership"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:69
msgid ""
"User namespaces can be nested; that is, each user namespace\\(emexcept the "
"initial (\"root\")  namespace\\(emhas a parent user namespace, and can have "
"zero or more child user namespaces.  The parent user namespace is the user "
"namespace of the process that creates the user namespace via a call to "
"B<unshare>(2)  or B<clone>(2)  with the B<CLONE_NEWUSER> flag."
msgstr ""

#.  commit 8742f229b635bf1c1c84a3dfe5e47c814c20b5c8
#.  FIXME Explain the rationale for this limit. (What is the rationale?)
#. type: Plain text
#: man-pages/man7/user_namespaces.7:80
msgid ""
"The kernel imposes (since version 3.11) a limit of 32 nested levels of user "
"namespaces.  Calls to B<unshare>(2)  or B<clone>(2)  that would cause this "
"limit to be exceeded fail with the error B<EUSERS>."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:95
msgid ""
"Each process is a member of exactly one user namespace.  A process created "
"via B<fork>(2)  or B<clone>(2)  without the B<CLONE_NEWUSER> flag is a "
"member of the same user namespace as its parent.  A single-threaded process "
"can join another user namespace with B<setns>(2)  if it has the "
"B<CAP_SYS_ADMIN> in that namespace; upon doing so, it gains a full set of "
"capabilities in that namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:107
msgid ""
"A call to B<clone>(2)  or B<unshare>(2)  with the B<CLONE_NEWUSER> flag "
"makes the new child process (for B<clone>(2))  or the caller (for "
"B<unshare>(2))  a member of the new user namespace created by the call."
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:117
msgid ""
"The B<NS_GET_PARENT> B<ioctl>(2)  operation can be used to discover the "
"parental relationship between user namespaces; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:117
#, no-wrap
msgid "Capabilities"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:139
msgid ""
"The child process created by B<clone>(2)  with the B<CLONE_NEWUSER> flag "
"starts out with a complete set of capabilities in the new user namespace.  "
"Likewise, a process that creates a new user namespace using B<unshare>(2)  "
"or joins an existing user namespace using B<setns>(2)  gains a full set of "
"capabilities in that namespace.  On the other hand, that process has no "
"capabilities in the parent (in the case of B<clone>(2))  or previous (in the"
" case of B<unshare>(2)  and B<setns>(2))  user namespace, even if the new "
"namespace is created or joined by the root user (i.e., a process with user "
"ID 0 in the root namespace)."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:149
msgid ""
"Note that a call to B<execve>(2)  will cause a process's capabilities to be "
"recalculated in the usual way (see B<capabilities>(7)).  Consequently, "
"unless the process has a user ID of 0 within the namespace, or the "
"executable file has a nonempty inheritable capabilities mask, the process "
"will lose all capabilities.  See the discussion of user and group ID "
"mappings, below."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:174
msgid ""
"A call to B<clone>(2), B<unshare>(2), or B<setns>(2)  using the "
"B<CLONE_NEWUSER> flag sets the \"securebits\" flags (see B<capabilities>(7))"
"  to their default values (all flags disabled) in the child (for "
"B<clone>(2))  or caller (for B<unshare>(2), or B<setns>(2)).  Note that "
"because the caller no longer has capabilities in its original user namespace"
" after a call to B<setns>(2), it is not possible for a process to reset its "
"\"securebits\" flags while retaining its user namespace membership by using "
"a pair of B<setns>(2)  calls to move to another user namespace and then "
"return to its original user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:177
msgid ""
"The rules for determining whether or not a process has a capability in a "
"particular user namespace are as follows:"
msgstr ""

#.  In the 3.8 sources, see security/commoncap.c::cap_capable():
#. type: Plain text
#: man-pages/man7/user_namespaces.7:193
msgid ""
"A process has a capability inside a user namespace if it is a member of that"
" namespace and it has the capability in its effective capability set.  A "
"process can gain capabilities in its effective capability set in various "
"ways.  For example, it may execute a set-user-ID program or an executable "
"with associated file capabilities.  In addition, a process may gain "
"capabilities via the effect of B<clone>(2), B<unshare>(2), or B<setns>(2), "
"as already described."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:197
msgid ""
"If a process has a capability in a user namespace, then it has that "
"capability in all child (and further removed descendant)  namespaces as "
"well."
msgstr ""

#.  * The owner of the user namespace in the parent of the
#.  * user namespace has all caps.
#.  (and likewise associates the effective group ID of the creating process
#.  with the namespace).
#.  See kernel commit 520d9eabce18edfef76a60b7b839d54facafe1f9 for a fix
#.  on this point
#.      This includes the case where the process executes a set-user-ID
#.      program that confers the effective UID of the creator of the
#. namespace.
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:224
msgid ""
"When a user namespace is created, the kernel records the effective user ID "
"of the creating process as being the \"owner\" of the namespace.  A process "
"that resides in the parent of the user namespace and whose effective user ID"
" matches the owner of the namespace has all capabilities in the namespace.  "
"By virtue of the previous rule, this means that the process has all "
"capabilities in all further removed descendant user namespaces as well.  The"
" B<NS_GET_OWNER_UID> B<ioctl>(2)  operation can be used to discover the user"
" ID of the owner of the namespace; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:224
#, no-wrap
msgid "Effect of capabilities within a user namespace"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:232
msgid ""
"Having a capability inside a user namespace permits a process to perform "
"operations (that require privilege)  only on resources governed by that "
"namespace.  In other words, having a capability in a user namespace permits "
"a process to perform privileged operations on resources that are governed by"
" (nonuser)  namespaces owned by (associated with) the user namespace (see "
"the next subsection)."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:244
msgid ""
"On the other hand, there are many privileged operations that affect "
"resources that are not associated with any namespace type, for example, "
"changing the system time (governed by B<CAP_SYS_TIME>), loading a kernel "
"module (governed by B<CAP_SYS_MODULE>), and creating a device (governed by "
"B<CAP_MKNOD>).  Only a process with privileges in the I<initial> user "
"namespace can perform such operations."
msgstr ""

#.  fs_flags = FS_USERNS_MOUNT in kernel sources
#. type: Plain text
#: man-pages/man7/user_namespaces.7:251
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"mount namespace allows that process to create bind mounts and mount the "
"following types of filesystems:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:257
msgid "I</proc> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:260
msgid "I</sys> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:263
msgid "I<devpts> (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:266
msgid "B<tmpfs>(5)  (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:269
msgid "I<ramfs> (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:272
msgid "I<mqueue> (since Linux 3.9)"
msgstr ""

#.  commit b2197755b2633e164a439682fb05a9b5ea48f706
#. type: Plain text
#: man-pages/man7/user_namespaces.7:276
msgid "I<bpf> (since Linux 4.4)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:288
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's "
"cgroup namespace allows (since Linux 4.6)  that process to the mount the "
"cgroup version 2 filesystem and cgroup version 1 named hierarchies (i.e., "
"cgroup filesystems mounted with the I<\"none,name=\"> option)."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:296
msgid ""
"Holding B<CAP_SYS_ADMIN> within the user namespace that owns a process's PID"
" namespace allows (since Linux 3.8)  that process to mount I</proc> "
"filesystems."
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:304
msgid ""
"Note however, that mounting block-based filesystems can be done only by a "
"process that holds B<CAP_SYS_ADMIN> in the initial user namespace."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:304
#, no-wrap
msgid "Interaction of user namespaces and other types of namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:309
msgid ""
"Starting in Linux 3.8, unprivileged processes can create user namespaces, "
"and the other types of namespaces can be created with just the "
"B<CAP_SYS_ADMIN> capability in the caller's user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:316
msgid ""
"When a nonuser namespace is created, it is owned by the user namespace in "
"which the creating process was a member at the time of the creation of the "
"namespace.  Privileged operations on resources governed by the nonuser "
"namespace require that the process has the necessary capabilities in the "
"user namespace that owns the nonuser namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:333
msgid ""
"If B<CLONE_NEWUSER> is specified along with other B<CLONE_NEW*> flags in a "
"single B<clone>(2)  or B<unshare>(2)  call, the user namespace is guaranteed"
" to be created first, giving the child (B<clone>(2))  or caller "
"(B<unshare>(2))  privileges over the remaining namespaces created by the "
"call.  Thus, it is possible for an unprivileged caller to specify this "
"combination of flags."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:355
msgid ""
"When a new namespace (other than a user namespace) is created via "
"B<clone>(2)  or B<unshare>(2), the kernel records the user namespace of the "
"creating process as the owner of the new namespace.  (This association can't"
" be changed.)  When a process in the new namespace subsequently performs "
"privileged operations that operate on global resources isolated by the "
"namespace, the permission checks are performed according to the process's "
"capabilities in the user namespace that the kernel associated with the new "
"namespace.  For example, suppose that a process attempts to change the "
"hostname (B<sethostname>(2)), a resource governed by the UTS namespace.  In "
"this case, the kernel will determine which user namespace owns the process's"
" UTS namespace, and check whether the process has the required capability "
"(B<CAP_SYS_ADMIN>)  in that user namespace."
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:365
msgid ""
"The B<NS_GET_USERNS> B<ioctl>(2)  operation can be used to discover the user"
" namespace that owns a nonuser namespace; see B<ioctl_ns>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:365
#, no-wrap
msgid "User and group ID mappings: uid_map and gid_map"
msgstr ""

#.  commit 22d917d80e842829d0ca0a561967d728eb1d6303
#. type: Plain text
#: man-pages/man7/user_namespaces.7:380
msgid ""
"When a user namespace is created, it starts out without a mapping of user "
"IDs (group IDs)  to the parent user namespace.  The I</proc/[pid]/uid_map> "
"and I</proc/[pid]/gid_map> files (available since Linux 3.5)  expose the "
"mappings for user and group IDs inside the user namespace for the process "
"I<pid>.  These files can be read to view the mappings in a user namespace "
"and written to (once) to define the mappings."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:386
msgid ""
"The description in the following paragraphs explains the details for "
"I<uid_map>; I<gid_map> is exactly the same, but each instance of \"user ID\""
" is replaced by \"group ID\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:400
msgid ""
"The I<uid_map> file exposes the mapping of user IDs from the user namespace "
"of the process I<pid> to the user namespace of the process that opened "
"I<uid_map> (but see a qualification to this point below).  In other words, "
"processes that are in different user namespaces will potentially see "
"different values when reading from a particular I<uid_map> file, depending "
"on the user ID mappings for the user namespaces of the reading processes."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:412
msgid ""
"Each line in the I<uid_map> file specifies a 1-to-1 mapping of a range of "
"contiguous user IDs between two user namespaces.  (When a user namespace is "
"first created, this file is empty.)  The specification in each line takes "
"the form of three numbers delimited by white space.  The first two numbers "
"specify the starting user ID in each of the two user namespaces.  The third "
"number specifies the length of the mapped range.  In detail, the fields are "
"interpreted as follows:"
msgstr ""

#. type: IP
#: man-pages/man7/user_namespaces.7:412
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:416
msgid ""
"The start of the range of user IDs in the user namespace of the process "
"I<pid>."
msgstr ""

#. type: IP
#: man-pages/man7/user_namespaces.7:416
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:424
msgid ""
"The start of the range of user IDs to which the user IDs specified by field "
"one map.  How field two is interpreted depends on whether the process that "
"opened I<uid_map> and the process I<pid> are in the same user namespace, as "
"follows:"
msgstr ""

#. type: IP
#: man-pages/man7/user_namespaces.7:425
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:430
msgid ""
"If the two processes are in different user namespaces: field two is the "
"start of a range of user IDs in the user namespace of the process that "
"opened I<uid_map>."
msgstr ""

#. type: IP
#: man-pages/man7/user_namespaces.7:430
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:441
msgid ""
"If the two processes are in the same user namespace: field two is the start "
"of the range of user IDs in the parent user namespace of the process I<pid>."
"  This case enables the opener of I<uid_map> (the common case here is "
"opening I</proc/self/uid_map>)  to see the mapping of user IDs into the user"
" namespace of the process that created this user namespace."
msgstr ""

#. type: IP
#: man-pages/man7/user_namespaces.7:442
#, no-wrap
msgid "(3)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:445
msgid ""
"The length of the range of user IDs that is mapped between the two user "
"namespaces."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:452
msgid ""
"System calls that return user IDs (group IDs)\\(emfor example, B<getuid>(2),"
" B<getgid>(2), and the credential fields in the structure returned by "
"B<stat>(2)\\(emreturn the user ID (group ID) mapped into the caller's user "
"namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:460
msgid ""
"When a process accesses a file, its user and group IDs are mapped into the "
"initial user namespace for the purpose of permission checking and assigning "
"IDs when creating a file.  When a process retrieves file user and group IDs "
"via B<stat>(2), the IDs are mapped in the opposite direction, to produce "
"values relative to the process user and group ID mappings."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:469
msgid ""
"The initial user namespace has no parent namespace, but, for consistency, "
"the kernel provides dummy user and group ID mapping files for this "
"namespace.  Looking at the I<uid_map> file (I<gid_map> is the same) from a "
"shell in the initial namespace shows:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:474
#, no-wrap
msgid ""
"$ B<cat /proc/$$/uid_map>\n"
"         0          0 4294967295\n"
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:494
msgid ""
"This mapping tells us that the range starting at user ID 0 in this namespace"
" maps to a range starting at 0 in the (nonexistent) parent namespace, and "
"the length of the range is the largest 32-bit unsigned integer.  This leaves"
" 4294967295 (the 32-bit signed -1 value) unmapped.  This is deliberate: "
"I<(uid_t)\\ -1> is used in several interfaces (e.g., B<setreuid>(2))  as a "
"way to specify \"no user ID\".  Leaving I<(uid_t)\\ -1> unmapped and "
"unusable guarantees that there will be no confusion when using these "
"interfaces."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:494
#, no-wrap
msgid "Defining user and group ID mappings: writing to uid_map and gid_map"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:510
msgid ""
"After the creation of a new user namespace, the I<uid_map> file of I<one> of"
" the processes in the namespace may be written to I<once> to define the "
"mapping of user IDs in the new user namespace.  An attempt to write more "
"than once to a I<uid_map> file in a user namespace fails with the error "
"B<EPERM>.  Similar rules apply for I<gid_map> files."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:515
msgid ""
"The lines written to I<uid_map> (I<gid_map>)  must conform to the following "
"rules:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:518
msgid ""
"The three fields must be valid numbers, and the last field must be greater "
"than 0."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:520
msgid "Lines are terminated by newline characters."
msgstr ""

#.  5*12-byte records could fit in a 64B cache line
#.  commit 6397fac4915ab3002dc15aae751455da1a852f25
#. type: Plain text
#: man-pages/man7/user_namespaces.7:535
msgid ""
"There is a limit on the number of lines in the file.  In Linux 4.14 and "
"earlier, this limit was (arbitrarily)  set at 5 lines.  Since Linux 4.15, "
"the limit is 340 lines.  In addition, the number of bytes written to the "
"file must be less than the system page size, and the write must be performed"
" at the start of the file (i.e., B<lseek>(2)  and B<pwrite>(2)  can't be "
"used to write to nonzero offsets in the file)."
msgstr ""

#.  commit 0bd14b4fd72afd5df41e9fd59f356740f22fceba
#. type: Plain text
#: man-pages/man7/user_namespaces.7:548
msgid ""
"The range of user IDs (group IDs)  specified in each line cannot overlap "
"with the ranges in any other lines.  In the initial implementation (Linux "
"3.8), this requirement was satisfied by a simplistic implementation that "
"imposed the further requirement that the values in both field 1 and field 2 "
"of successive lines must be in ascending numerical order, which prevented "
"some otherwise valid maps from being created.  Linux 3.9 and later fix this "
"limitation, allowing any valid set of nonoverlapping maps."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:550
msgid "At least one line must be written to the file."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:553
msgid "Writes that violate the above rules fail with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:558
msgid ""
"In order for a process to write to the I</proc/[pid]/uid_map> "
"(I</proc/[pid]/gid_map>)  file, all of the following requirements must be "
"met:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:564
msgid ""
"The writing process must have the B<CAP_SETUID> (B<CAP_SETGID>)  capability "
"in the user namespace of the process I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:569
msgid ""
"The writing process must either be in the user namespace of the process "
"I<pid> or be in the parent user namespace of the process I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:572
msgid ""
"The mapped user IDs (group IDs) must in turn have a mapping in the parent "
"user namespace."
msgstr ""

#. type: IP
#: man-pages/man7/user_namespaces.7:572
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:574
msgid "One of the following two cases applies:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:583
msgid ""
"I<Either> the writing process has the B<CAP_SETUID> (B<CAP_SETGID>)  "
"capability in the I<parent> user namespace."
msgstr ""

#. type: IP
#: man-pages/man7/user_namespaces.7:584 man-pages/man7/user_namespaces.7:593
#: man-pages/man7/user_namespaces.7:601 man-pages/man7/user_namespaces.7:604
#, no-wrap
msgid "+"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:588
msgid ""
"No further restrictions apply: the process can make mappings to arbitrary "
"user IDs (group IDs)  in the parent user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:592
msgid "I<Or> otherwise all of the following restrictions apply:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:601
msgid ""
"The data written to I<uid_map> (I<gid_map>)  must consist of a single line "
"that maps the writing process's effective user ID (group ID) in the parent "
"user namespace to a user ID (group ID)  in the user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:604
msgid ""
"The writing process must have the same effective user ID as the process that"
" created the user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:615
msgid ""
"In the case of I<gid_map>, use of the B<setgroups>(2)  system call must "
"first be denied by writing \"I<deny>\" to the I</proc/[pid]/setgroups> file "
"(see below) before writing to I<gid_map>."
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:623
msgid "Writes that violate the above rules fail with the error B<EPERM>."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:623
#, no-wrap
msgid "Interaction with system calls that change process UIDs or GIDs"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:636
msgid ""
"In a user namespace where the I<uid_map> file has not been written, the "
"system calls that change user IDs will fail.  Similarly, if the I<gid_map> "
"file has not been written, the system calls that change group IDs will fail."
"  After the I<uid_map> and I<gid_map> files have been written, only the "
"mapped values may be used in system calls that change user and group IDs."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:650
msgid ""
"For user IDs, the relevant system calls include B<setuid>(2), "
"B<setfsuid>(2), B<setreuid>(2), and B<setresuid>(2).  For group IDs, the "
"relevant system calls include B<setgid>(2), B<setfsgid>(2), B<setregid>(2), "
"B<setresgid>(2), and B<setgroups>(2)."
msgstr ""

#.  Things changed in Linux 3.19
#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:671
msgid ""
"Writing \"I<deny>\" to the I</proc/[pid]/setgroups> file before writing to "
"I</proc/[pid]/gid_map> will permanently disable B<setgroups>(2)  in a user "
"namespace and allow writing to I</proc/[pid]/gid_map> without having the "
"B<CAP_SETGID> capability in the parent user namespace."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:671
#, no-wrap
msgid "The /proc/[pid]/setgroups file"
msgstr ""

#.  commit 9cc46516ddf497ea16e8d7cb986ae03a0f6b92f8
#.  commit 66d2f338ee4c449396b6f99f5e75cd18eb6df272
#.  http://lwn.net/Articles/626665/
#.  http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-8989
#. type: Plain text
#: man-pages/man7/user_namespaces.7:698
msgid ""
"The I</proc/[pid]/setgroups> file displays the string \"I<allow>\" if "
"processes in the user namespace that contains the process I<pid> are "
"permitted to employ the B<setgroups>(2)  system call; it displays "
"\"I<deny>\" if B<setgroups>(2)  is not permitted in that user namespace.  "
"Note that regardless of the value in the I</proc/[pid]/setgroups> file (and "
"regardless of the process's capabilities), calls to B<setgroups>(2)  are "
"also not permitted if I</proc/[pid]/gid_map> has not yet been set."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:714
msgid ""
"A privileged process (one with the B<CAP_SYS_ADMIN> capability in the "
"namespace) may write either of the strings \"I<allow>\" or \"I<deny>\" to "
"this file I<before> writing a group ID mapping for this user namespace to "
"the file I</proc/[pid]/gid_map>.  Writing the string \"I<deny>\" prevents "
"any process in the user namespace from employing B<setgroups>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:733
msgid ""
"The essence of the restrictions described in the preceding paragraph is that"
" it is permitted to write to I</proc/[pid]/setgroups> only so long as "
"calling B<setgroups>(2)  is disallowed because I</proc/[pid]/gid_map> has "
"not been set.  This ensures that a process cannot transition from a state "
"where B<setgroups>(2)  is allowed to a state where B<setgroups>(2)  is "
"denied; a process can transition only from B<setgroups>(2)  being disallowed"
" to B<setgroups>(2)  being allowed."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:736
msgid ""
"The default value of this file in the initial user namespace is "
"\"I<allow>\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:751
msgid ""
"Once I</proc/[pid]/gid_map> has been written to (which has the effect of "
"enabling B<setgroups>(2)  in the user namespace), it is no longer possible "
"to disallow B<setgroups>(2)  by writing \"I<deny>\" to "
"I</proc/[pid]/setgroups> (the write fails with the error B<EPERM>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:755
msgid ""
"A child user namespace inherits the I</proc/[pid]/setgroups> setting from "
"its parent."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:769
msgid ""
"If the I<setgroups> file has the value \"I<deny>\", then the B<setgroups>(2)"
"  system call can't subsequently be reenabled (by writing \"I<allow>\" to "
"the file) in this user namespace.  (Attempts to do so fail with the error "
"B<EPERM>.)  This restriction also propagates down to all child user "
"namespaces of this user namespace."
msgstr ""

#.  /proc/PID/setgroups
#. 	[allow == setgroups() is allowed, "deny" == setgroups() is disallowed]
#. 	* Can write if have CAP_SYS_ADMIN in NS
#. 	* Must write BEFORE writing to /proc/PID/gid_map
#.  setgroups()
#. 	* Must already have written to gid_map
#. 	* /proc/PID/setgroups must be "allow"
#.  /proc/PID/gid_map -- writing
#. 	* Must already have written "deny" to /proc/PID/setgroups
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:811
msgid ""
"The I</proc/[pid]/setgroups> file was added in Linux 3.19, but was "
"backported to many earlier stable kernel series, because it addresses a "
"security issue.  The issue concerned files with permissions such as \"rwx---"
"rwx\".  Such files give fewer permissions to \"group\" than they do to "
"\"other\".  This means that dropping groups using B<setgroups>(2)  might "
"allow a process file access that it did not formerly have.  Before the "
"existence of user namespaces this was not a concern, since only a privileged"
" process (one with the B<CAP_SETGID> capability) could call B<setgroups>(2)."
"  However, with the introduction of user namespaces, it became possible for "
"an unprivileged process to create a new namespace in which the user had all "
"privileges.  This then allowed formerly unprivileged users to drop groups "
"and thus gain file access that they did not previously have.  The "
"I</proc/[pid]/setgroups> file was added to address this security issue, by "
"denying any pathway for an unprivileged process to drop groups with "
"B<setgroups>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:811
#, no-wrap
msgid "Unmapped user and group IDs"
msgstr ""

#.  from_kuid_munged(), from_kgid_munged()
#. type: Plain text
#: man-pages/man7/user_namespaces.7:828
msgid ""
"There are various places where an unmapped user ID (group ID)  may be "
"exposed to user space.  For example, the first process in a new user "
"namespace may call B<getuid>(2)  before a user ID mapping has been defined "
"for the namespace.  In most such cases, an unmapped user ID is converted to "
"the overflow user ID (group ID); the default value for the overflow user ID "
"(group ID) is 65534.  See the descriptions of "
"I</proc/sys/kernel/overflowuid> and I</proc/sys/kernel/overflowgid> in "
"B<proc>(5)."
msgstr ""

#.  also SO_PEERCRED
#. type: Plain text
#: man-pages/man7/user_namespaces.7:856
msgid ""
"The cases where unmapped IDs are mapped in this fashion include system calls"
" that return user IDs (B<getuid>(2), B<getgid>(2), and similar), credentials"
" passed over a UNIX domain socket, credentials returned by B<stat>(2), "
"B<waitid>(2), and the System V IPC \"ctl\" B<IPC_STAT> operations, "
"credentials exposed by I</proc/[pid]/status> and the files in "
"I</proc/sysvipc/*>, credentials returned via the I<si_uid> field in the "
"I<siginfo_t> received with a signal (see B<sigaction>(2)), credentials "
"written to the process accounting file (see B<acct>(5)), and credentials "
"returned with POSIX message queue notifications (see B<mq_notify>(3))."
msgstr ""

#.  from_kuid(), from_kgid()
#.  Also F_GETOWNER_UIDS is an exception
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:871
msgid ""
"There is one notable case where unmapped user and group IDs are I<not> "
"converted to the corresponding overflow ID value.  When viewing a I<uid_map>"
" or I<gid_map> file in which there is no mapping for the second field, that "
"field is displayed as 4294967295 (-1 as an unsigned integer)."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:871
#, no-wrap
msgid "Accessing files"
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:883
msgid ""
"In order to determine permissions when an unprivileged process accesses a "
"file, the process credentials (UID, GID) and the file credentials are in "
"effect mapped back to what they would be in the initial user namespace and "
"then compared to determine the permissions that the process has on the file."
"  The same is also of other objects that employ the credentials plus "
"permissions mask accessibility model, such as System V IPC objects"
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:883
#, no-wrap
msgid "Operation of file-related capabilities"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:895
msgid ""
"Certain capabilities allow a process to bypass various kernel-enforced "
"restrictions when performing operations on files owned by other users or "
"groups.  These capabilities are: B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, "
"B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, and B<CAP_FSETID>."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:900
msgid ""
"Within a user namespace, these capabilities allow a process to bypass the "
"rules if the process has the relevant capability over the file, meaning "
"that:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:902
msgid ""
"the process has the relevant effective capability in its user namespace; and"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:905
msgid ""
"the file's user ID and group ID both have valid mappings in the user "
"namespace."
msgstr ""

#.  These are the checks performed by the kernel function
#.  inode_owner_or_capable(). There is one exception to the exception:
#.  overriding the directory sticky permission bit requires that
#.  the file has a valid mapping for both its UID and GID.
#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:919
msgid ""
"The B<CAP_FOWNER> capability is treated somewhat exceptionally: it allows a "
"process to bypass the corresponding rules so long as at least the file's "
"user ID has a mapping in the user namespace (i.e., the file's group ID does "
"not need to have a valid mapping)."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:919
#, no-wrap
msgid "Set-user-ID and set-group-ID programs"
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:939
msgid ""
"When a process inside a user namespace executes a set-user-ID (set-group-ID)"
" program, the process's effective user (group) ID inside the namespace is "
"changed to whatever value is mapped for the user (group) ID of the file.  "
"However, if either the user I<or> the group ID of the file has no mapping "
"inside the namespace, the set-user-ID (set-group-ID) bit is silently "
"ignored: the new program is executed, but the process's effective user "
"(group) ID is left unchanged.  (This mirrors the semantics of executing a "
"set-user-ID or set-group-ID program that resides on a filesystem that was "
"mounted with the B<MS_NOSUID> flag, as described in B<mount>(2).)"
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:939
#, no-wrap
msgid "Miscellaneous"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:949
msgid ""
"When a process's user and group IDs are passed over a UNIX domain socket to "
"a process in a different user namespace (see the description of "
"B<SCM_CREDENTIALS> in B<unix>(7)), they are translated into the "
"corresponding values as per the receiving process's user and group ID "
"mappings."
msgstr ""

#. type: SH
#: man-pages/man7/user_namespaces.7:949
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:952
msgid "Namespaces are a Linux-specific feature."
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/user_namespaces.7:962
msgid ""
"Over the years, there have been a lot of features that have been added to "
"the Linux kernel that have been made available only to privileged users "
"because of their potential to confuse set-user-ID-root applications.  In "
"general, it becomes safe to allow the root user in a user namespace to use "
"those features because it is impossible, while in a user namespace, to gain "
"more privilege than the root user of a user namespace has."
msgstr ""

#. type: SS
#: man-pages/man7/user_namespaces.7:962
#, no-wrap
msgid "Availability"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:970
msgid ""
"Use of user namespaces requires a kernel that is configured with the "
"B<CONFIG_USER_NS> option.  User namespaces require support in a range of "
"subsystems across the kernel.  When an unsupported subsystem is configured "
"into the kernel, it is not possible to configure user namespaces support."
msgstr ""

#.  commit d6970d4b726cea6d7a9bc4120814f95c09571fc3
#. type: Plain text
#: man-pages/man7/user_namespaces.7:981
msgid ""
"As at Linux 3.8, most relevant subsystems supported user namespaces, but a "
"number of filesystems did not have the infrastructure needed to map user and"
" group IDs between user namespaces.  Linux 3.9 added the required "
"infrastructure support for many of the remaining unsupported filesystems "
"(Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS, and OCFS2).  "
"Linux 3.12 added support for the last of the unsupported major filesystems, "
"XFS."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:990
msgid ""
"The program below is designed to allow experimenting with user namespaces, "
"as well as other types of namespaces.  It creates namespaces as specified by"
" command-line options and then executes a command inside those namespaces.  "
"The comments and I<usage()> function inside the program provide a full "
"explanation of the program.  The following shell session demonstrates its "
"use."
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:992
msgid "First, we look at the run-time environment:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1001
#, no-wrap
msgid ""
"$ B<uname -rs>     # Need Linux 3.8 or later\n"
"Linux 3.8.0\n"
"$ B<id -u>         # Running as unprivileged user\n"
"1000\n"
"$ B<id -g>\n"
"1000\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1015
msgid ""
"Now start a new shell in new user (I<-U>), mount (I<-m>), and PID (I<-p>)  "
"namespaces, with user ID (I<-M>)  and group ID (I<-G>)  1000 mapped to 0 "
"inside the user namespace:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1019
#, no-wrap
msgid "$ B<./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1' bash>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1024
msgid ""
"The shell has PID 1, because it is the first process in the new PID "
"namespace:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1029
#, no-wrap
msgid ""
"bash$ B<echo $$>\n"
"1\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1037
msgid ""
"Mounting a new I</proc> filesystem and listing all of the processes visible "
"in the new PID namespace shows that the shell can't see any processes "
"outside the PID namespace:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1045
#, no-wrap
msgid ""
"bash$ B<mount -t proc proc /proc>\n"
"bash$ B<ps ax>\n"
"  PID TTY      STAT   TIME COMMAND\n"
"    1 pts/3    S      0:00 bash\n"
"   22 pts/3    R+     0:00 ps ax\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1050
msgid ""
"Inside the user namespace, the shell has user and group ID 0, and a full set"
" of permitted and effective capabilities:"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1060
#, no-wrap
msgid ""
"bash$ B<cat /proc/$$/status | egrep '^[UG]id'>\n"
"Uid:\t0\t0\t0\t0\n"
"Gid:\t0\t0\t0\t0\n"
"bash$ B<cat /proc/$$/status | egrep '^Cap(Prm|Inh|Eff)'>\n"
"CapInh:\t0000000000000000\n"
"CapPrm:\t0000001fffffffff\n"
"CapEff:\t0000001fffffffff\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1066
#, no-wrap
msgid "/* userns_child_exec.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1068
#, no-wrap
msgid "   Licensed under GNU General Public License v2 or later\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1084
#, no-wrap
msgid ""
"   Create a child process that executes a shell command in new\n"
"   namespace(s); allow UID and GID mappings to be specified when\n"
"   creating a user namespace.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1087
#, no-wrap
msgid ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1090
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1095
#, no-wrap
msgid ""
"struct child_args {\n"
"    char **argv;        /* Command to be executed by child, with args */\n"
"    int    pipe_fd[2];  /* Pipe used to synchronize parent and child */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1097
#, no-wrap
msgid "static int verbose;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1130
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] cmd [arg...]\\en\\en\", pname);\n"
"    fprintf(stderr, \"Create a child process that executes a shell \"\n"
"            \"command in a new user namespace,\\en\"\n"
"            \"and possibly also other new namespace(s).\\en\\en\");\n"
"    fprintf(stderr, \"Options can be:\\en\\en\");\n"
"#define fpe(str) fprintf(stderr, \"    %s\", str);\n"
"    fpe(\"-i          New IPC namespace\\en\");\n"
"    fpe(\"-m          New mount namespace\\en\");\n"
"    fpe(\"-n          New network namespace\\en\");\n"
"    fpe(\"-p          New PID namespace\\en\");\n"
"    fpe(\"-u          New UTS namespace\\en\");\n"
"    fpe(\"-U          New user namespace\\en\");\n"
"    fpe(\"-M uid_map  Specify UID map for user namespace\\en\");\n"
"    fpe(\"-G gid_map  Specify GID map for user namespace\\en\");\n"
"    fpe(\"-z          Map user\\(aqs UID and GID to 0 in user namespace\\en\");\n"
"    fpe(\"            (equivalent to: -M \\(aq0 E<lt>uidE<gt> 1\\(aq -G \\(aq0 E<lt>gidE<gt> 1\\(aq)\\en\");\n"
"    fpe(\"-v          Display verbose messages\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"If -z, -M, or -G is specified, -U is required.\\en\");\n"
"    fpe(\"It is not permitted to specify both -z and either -M or -G.\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"Map strings for -M and -G consist of records of the form:\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"    ID-inside-ns   ID-outside-ns   len\\en\");\n"
"    fpe(\"\\en\");\n"
"    fpe(\"A map string can contain multiple records, separated\"\n"
"        \" by commas;\\en\");\n"
"    fpe(\"the commas are replaced by newlines before writing\"\n"
"        \" to map files.\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1133
#, no-wrap
msgid ""
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1138
#, no-wrap
msgid ""
"/* Update the mapping file \\(aqmap_file\\(aq, with the value provided in\n"
"   \\(aqmapping\\(aq, a string that defines a UID or GID mapping. A UID or\n"
"   GID mapping consists of one or more newline-delimited records\n"
"   of the form:\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1140
#, no-wrap
msgid "       ID_inside-ns    ID-outside-ns   length\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1145
#, no-wrap
msgid ""
"   Requiring the user to supply a string that contains newlines is\n"
"   of course inconvenient for command-line use. Thus, we permit the\n"
"   use of commas to delimit records in this string, and replace them\n"
"   with newlines before writing the string to the file. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1151
#, no-wrap
msgid ""
"static void\n"
"update_map(char *mapping, char *map_file)\n"
"{\n"
"    int fd, j;\n"
"    size_t map_len;     /* Length of \\(aqmapping\\(aq */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1153
#, no-wrap
msgid "    /* Replace commas in mapping string with newlines */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1158
#, no-wrap
msgid ""
"    map_len = strlen(mapping);\n"
"    for (j = 0; j E<lt> map_len; j++)\n"
"        if (mapping[j] == \\(aq,\\(aq)\n"
"            mapping[j] = \\(aq\\en\\(aq;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1165
#, no-wrap
msgid ""
"    fd = open(map_file, O_RDWR);\n"
"    if (fd == -1) {\n"
"        fprintf(stderr, \"ERROR: open %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1171
#, no-wrap
msgid ""
"    if (write(fd, mapping, map_len) != map_len) {\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", map_file,\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1174 man-pages/man7/user_namespaces.7:1218
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1183
#, no-wrap
msgid ""
"/* Linux 3.19 made a change in the handling of setgroups(2) and the\n"
"   \\(aqgid_map\\(aq file to address a security issue. The issue allowed\n"
"   *unprivileged* users to employ user namespaces in order to drop\n"
"   The upshot of the 3.19 changes is that in order to update the\n"
"   \\(aqgid_maps\\(aq file, use of the setgroups() system call in this\n"
"   user namespace must first be disabled by writing \"deny\" to one of\n"
"   the /proc/PID/setgroups files for this namespace.  That is the\n"
"   purpose of the following function. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1189
#, no-wrap
msgid ""
"static void\n"
"proc_setgroups_write(pid_t child_pid, char *str)\n"
"{\n"
"    char setgroups_path[PATH_MAX];\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1192
#, no-wrap
msgid ""
"    snprintf(setgroups_path, PATH_MAX, \"/proc/%ld/setgroups\",\n"
"            (long) child_pid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1195
#, no-wrap
msgid ""
"    fd = open(setgroups_path, O_RDWR);\n"
"    if (fd == -1) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1201
#, no-wrap
msgid ""
"        /* We may be on a system that doesn\\(aqt support\n"
"           /proc/PID/setgroups. In that case, the file won\\(aqt exist,\n"
"           and the system won\\(aqt impose the restrictions that Linux 3.19\n"
"           added. That\\(aqs fine: we don\\(aqt need to do anything in order\n"
"           to permit \\(aqgid_map\\(aq to be updated.\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1205
#, no-wrap
msgid ""
"           However, if the error from open() was something other than\n"
"           the ENOENT error that is expected for that case,  let the\n"
"           user know. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1211
#, no-wrap
msgid ""
"        if (errno != ENOENT)\n"
"            fprintf(stderr, \"ERROR: open %s: %s\\en\", setgroups_path,\n"
"                strerror(errno));\n"
"        return;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1215
#, no-wrap
msgid ""
"    if (write(fd, str, strlen(str)) == -1)\n"
"        fprintf(stderr, \"ERROR: write %s: %s\\en\", setgroups_path,\n"
"            strerror(errno));\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1224
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct child_args *args = (struct child_args *) arg;\n"
"    char ch;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1229
#, no-wrap
msgid ""
"    /* Wait until the parent has updated the UID and GID mappings.\n"
"       See the comment in main(). We wait for end of file on a\n"
"       pipe that will be closed by the parent process once it has\n"
"       updated the mappings. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1238
#, no-wrap
msgid ""
"    close(args-E<gt>pipe_fd[1]);    /* Close our descriptor for the write\n"
"                                   end of the pipe so that we see EOF\n"
"                                   when parent closes its descriptor */\n"
"    if (read(args-E<gt>pipe_fd[0], &ch, 1) != 0) {\n"
"        fprintf(stderr,\n"
"                \"Failure in child: read from pipe returned != 0\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1240
#, no-wrap
msgid "    close(args-E<gt>pipe_fd[0]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1242
#, no-wrap
msgid "    /* Execute a shell command */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1247
#, no-wrap
msgid ""
"    printf(\"About to exec %s\\en\", args-E<gt>argv[0]);\n"
"    execvp(args-E<gt>argv[0], args-E<gt>argv);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1249
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1251
#, no-wrap
msgid ""
"static char child_stack[STACK_SIZE];    /* Space for child\\(aqs stack */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1262
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt, map_zero;\n"
"    pid_t child_pid;\n"
"    struct child_args args;\n"
"    char *uid_map, *gid_map;\n"
"    const int MAP_BUF_SIZE = 100;\n"
"    char map_buf[MAP_BUF_SIZE];\n"
"    char map_path[PATH_MAX];\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1269
#, no-wrap
msgid ""
"    /* Parse command-line options. The initial \\(aq+\\(aq character in\n"
"       the final getopt() argument prevents GNU-style permutation\n"
"       of command-line options. That\\(aqs useful, since sometimes\n"
"       the \\(aqcommand\\(aq to be executed by this program itself\n"
"       has command-line options. We don\\(aqt want getopt() to treat\n"
"       those as options to this program. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1290
#, no-wrap
msgid ""
"    flags = 0;\n"
"    verbose = 0;\n"
"    gid_map = NULL;\n"
"    uid_map = NULL;\n"
"    map_zero = 0;\n"
"    while ((opt = getopt(argc, argv, \"+imnpuUM:G:zv\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqv\\(aq: verbose = 1;                  break;\n"
"        case \\(aqz\\(aq: map_zero = 1;                 break;\n"
"        case \\(aqM\\(aq: uid_map = optarg;             break;\n"
"        case \\(aqG\\(aq: gid_map = optarg;             break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1292
#, no-wrap
msgid "    /* -M or -G without -U is nonsensical */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1297
#, no-wrap
msgid ""
"    if (((uid_map != NULL || gid_map != NULL || map_zero) &&\n"
"                !(flags & CLONE_NEWUSER)) ||\n"
"            (map_zero && (uid_map != NULL || gid_map != NULL)))\n"
"        usage(argv[0]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1299
#, no-wrap
msgid "    args.argv = &argv[optind];\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1309
#, no-wrap
msgid ""
"    /* We use a pipe to synchronize the parent and child, in order to\n"
"       ensure that the parent sets the UID and GID maps before the child\n"
"       calls execve(). This ensures that the child maintains its\n"
"       capabilities during the execve() in the common case where we\n"
"       want to map the child\\(aqs effective user ID to 0 in the new user\n"
"       namespace. Without this synchronization, the child would lose\n"
"       its capabilities if it performed an execve() with nonzero\n"
"       user IDs (see the capabilities(7) man page for details of the\n"
"       transformation of a process\\(aqs capabilities during execve()). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1312
#, no-wrap
msgid ""
"    if (pipe(args.pipe_fd) == -1)\n"
"        errExit(\"pipe\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1314
#, no-wrap
msgid "    /* Create the child in new namespace(s) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1319
#, no-wrap
msgid ""
"    child_pid = clone(childFunc, child_stack + STACK_SIZE,\n"
"                      flags | SIGCHLD, &args);\n"
"    if (child_pid == -1)\n"
"        errExit(\"clone\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1321
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1325
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: PID of child created by clone() is %ld\\en\",\n"
"                argv[0], (long) child_pid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1327
#, no-wrap
msgid "    /* Update the UID and GID maps in the child */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1337
#, no-wrap
msgid ""
"    if (uid_map != NULL || map_zero) {\n"
"        snprintf(map_path, PATH_MAX, \"/proc/%ld/uid_map\",\n"
"                (long) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\", (long) getuid());\n"
"            uid_map = map_buf;\n"
"        }\n"
"        update_map(uid_map, map_path);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1340
#, no-wrap
msgid ""
"    if (gid_map != NULL || map_zero) {\n"
"        proc_setgroups_write(child_pid, \"deny\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1349
#, no-wrap
msgid ""
"        snprintf(map_path, PATH_MAX, \"/proc/%ld/gid_map\",\n"
"                (long) child_pid);\n"
"        if (map_zero) {\n"
"            snprintf(map_buf, MAP_BUF_SIZE, \"0 %ld 1\", (long) getgid());\n"
"            gid_map = map_buf;\n"
"        }\n"
"        update_map(gid_map, map_path);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1352
#, no-wrap
msgid ""
"    /* Close the write end of the pipe, to signal to the child that we\n"
"       have updated the UID and GID maps */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1354
#, no-wrap
msgid "    close(args.pipe_fd[1]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1357
#, no-wrap
msgid ""
"    if (waitpid(child_pid, NULL, 0) == -1)      /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1360
#, no-wrap
msgid ""
"    if (verbose)\n"
"        printf(\"%s: terminating\\en\", argv[0]);\n"
msgstr ""

#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#.  From the shadow package
#. type: Plain text
#: man-pages/man7/user_namespaces.7:1379
msgid ""
"B<newgidmap>(1), B<newuidmap>(1), B<clone>(2), B<ptrace>(2), B<setns>(2), "
"B<unshare>(2), B<proc>(5), B<subgid>(5), B<subuid>(5), B<capabilities>(7), "
"B<cgroup_namespaces>(7)  B<credentials>(7), B<namespaces>(7), "
"B<pid_namespaces>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user_namespaces.7:1381
msgid ""
"The kernel source file I<Documentation/namespaces/resource-control.txt>."
msgstr ""

#. type: TH
#: man-pages/man7/unicode.7:29
#, no-wrap
msgid "UNICODE"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:32
msgid "unicode - universal character set"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:40
msgid ""
"The international standard ISO 10646 defines the Universal Character Set "
"(UCS).  UCS contains all characters of all other character set standards.  "
"It also guarantees \"round-trip compatibility\"; in other words, conversion "
"tables can be built such that no information is lost when a string is "
"converted from any other encoding to UCS and back."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:62
msgid ""
"UCS contains the characters required to represent practically all known "
"languages.  This includes not only the Latin, Greek, Cyrillic, Hebrew, "
"Arabic, Armenian, and Georgian scripts, but also Chinese, Japanese and "
"Korean Han ideographs as well as scripts such as Hiragana, Katakana, Hangul,"
" Devanagari, Bengali, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada, "
"Malayalam, Thai, Lao, Khmer, Bopomofo, Tibetan, Runic, Ethiopic, Canadian "
"Syllabics, Cherokee, Mongolian, Ogham, Myanmar, Sinhala, Thaana, Yi, and "
"others.  For scripts not yet covered, research on how to best encode them "
"for computer usage is still going on and they will be added eventually.  "
"This might eventually include not only Hieroglyphs and various historic "
"Indo-European languages, but even some selected artistic scripts such as "
"Tengwar, Cirth, and Klingon.  UCS also covers a large number of graphical, "
"typographical, mathematical, and scientific symbols, including those "
"provided by TeX, Postscript, APL, MS-DOS, MS-Windows, Macintosh, OCR fonts, "
"as well as many word processing and publishing systems, and more are being "
"added."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:93
msgid ""
"The UCS standard (ISO 10646) describes a 31-bit character set architecture "
"consisting of 128 24-bit I<groups>, each divided into 256 16-bit I<planes> "
"made up of 256 8-bit I<rows> with 256 I<column> positions, one for each "
"character.  Part 1 of the standard (ISO 10646-1)  defines the first 65534 "
"code positions (0x0000 to 0xfffd), which form the I<Basic Multilingual "
"Plane> (BMP), that is plane 0 in group 0.  Part 2 of the standard (ISO "
"10646-2)  adds characters to group 0 outside the BMP in several "
"I<supplementary planes> in the range 0x10000 to 0x10ffff.  There are no "
"plans to add characters beyond 0x10ffff to the standard, therefore of the "
"entire code space, only a small fraction of group 0 will ever be actually "
"used in the foreseeable future.  The BMP contains all characters found in "
"the commonly used other character sets.  The supplemental planes added by "
"ISO 10646-2 cover only more exotic characters for special scientific, "
"dictionary printing, publishing industry, higher-level protocol and "
"enthusiast needs."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:101
msgid ""
"The representation of each UCS character as a 2-byte word is referred to as "
"the UCS-2 form (only for BMP characters), whereas UCS-4 is the "
"representation of each character by a 4-byte word.  In addition, there exist"
" two encoding forms UTF-8 for backward compatibility with ASCII processing "
"software and UTF-16 for the backward-compatible handling of non-BMP "
"characters up to 0x10ffff by UCS-2 software."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:107
msgid ""
"The UCS characters 0x0000 to 0x007f are identical to those of the classic "
"US-ASCII character set and the characters in the range 0x0000 to 0x00ff are "
"identical to those in ISO 8859-1 (Latin-1)."
msgstr ""

#. type: SS
#: man-pages/man7/unicode.7:107
#, no-wrap
msgid "Combining characters"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:123
msgid ""
"Some code points in UCS have been assigned to I<combining characters>.  "
"These are similar to the nonspacing accent keys on a typewriter.  A "
"combining character just adds an accent to the previous character.  The most"
" important accented characters have codes of their own in UCS, however, the "
"combining character mechanism allows us to add accents and other diacritical"
" marks to any character.  The combining characters always follow the "
"character which they modify.  For example, the German character Umlaut-A "
"(\"Latin capital letter A with diaeresis\") can either be represented by the"
" precomposed UCS code 0x00c4, or alternatively as the combination of a "
"normal \"Latin capital letter A\" followed by a \"combining diaeresis\": "
"0x0041 0x0308."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:127
msgid ""
"Combining characters are essential for instance for encoding the Thai script"
" or for mathematical typesetting and users of the International Phonetic "
"Alphabet."
msgstr ""

#. type: SS
#: man-pages/man7/unicode.7:127
#, no-wrap
msgid "Implementation levels"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:132
msgid ""
"As not all systems are expected to support advanced mechanisms like "
"combining characters, ISO 10646-1 specifies the following three "
"I<implementation levels> of UCS:"
msgstr ""

#. type: TP
#: man-pages/man7/unicode.7:132
#, no-wrap
msgid "Level 1"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:138
msgid ""
"Combining characters and Hangul Jamo (a variant encoding of the Korean "
"script, where a Hangul syllable glyph is coded as a triplet or pair of "
"vowel/consonant codes) are not supported."
msgstr ""

#. type: TP
#: man-pages/man7/unicode.7:138
#, no-wrap
msgid "Level 2"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:143
msgid ""
"In addition to level 1, combining characters are now allowed for some "
"languages where they are essential (e.g., Thai, Lao, Hebrew, Arabic, "
"Devanagari, Malayalam)."
msgstr ""

#. type: TP
#: man-pages/man7/unicode.7:143
#, no-wrap
msgid "Level 3"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:146
msgid "All UCS characters are supported."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:159
msgid ""
"The Unicode 3.0 Standard published by the Unicode Consortium contains "
"exactly the UCS Basic Multilingual Plane at implementation level 3, as "
"described in ISO 10646-1:2000.  Unicode 3.1 added the supplemental planes of"
" ISO 10646-2.  The Unicode standard and technical reports published by the "
"Unicode Consortium provide much additional information on the semantics and "
"recommended usages of various characters.  They provide guidelines and "
"algorithms for editing, sorting, comparing, normalizing, converting, and "
"displaying Unicode strings."
msgstr ""

#. type: SS
#: man-pages/man7/unicode.7:159
#, no-wrap
msgid "Unicode under Linux"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:169
msgid ""
"Under GNU/Linux, the C type I<wchar_t> is a signed 32-bit integer type.  Its"
" values are always interpreted by the C library as UCS code values (in all "
"locales), a convention that is signaled by the GNU C library to applications"
" by defining the constant B<__STDC_ISO_10646__> as specified in the ISO C99 "
"standard."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:178
msgid ""
"UCS/Unicode can be used just like ASCII in input/output streams, terminal "
"communication, plaintext files, filenames, and environment variables in the "
"ASCII compatible UTF-8 multibyte encoding.  To signal the use of UTF-8 as "
"the character encoding to all applications, a suitable I<locale> has to be "
"selected via environment variables (e.g., \"LANG=en_GB.UTF-8\")."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:193
msgid ""
"The B<nl_langinfo(CODESET)> function returns the name of the selected "
"encoding.  Library functions such as B<wctomb>(3)  and B<mbsrtowcs>(3)  can "
"be used to transform the internal I<wchar_t> characters and strings into the"
" system character encoding and back and B<wcwidth>(3)  tells, how many "
"positions (0\\(en2) the cursor is advanced by the output of a character."
msgstr ""

#. type: SS
#: man-pages/man7/unicode.7:194
#, no-wrap
msgid "Private Use Areas (PUA)"
msgstr ""

#.  commit 9d85025b0418163fae079c9ba8f8445212de8568
#. type: Plain text
#: man-pages/man7/unicode.7:212
msgid ""
"In the Basic Multilingual Plane, the range 0xe000 to 0xf8ff will never be "
"assigned to any characters by the standard and is reserved for private "
"usage.  For the Linux community, this private area has been subdivided "
"further into the range 0xe000 to 0xefff which can be used individually by "
"any end-user and the Linux zone in the range 0xf000 to 0xf8ff where "
"extensions are coordinated among all Linux users.  The registry of the "
"characters assigned to the Linux zone is maintained by LANANA and the "
"registry itself is I<Documentation/admin-guide/unicode.rst> in the Linux "
"kernel sources (or I<Documentation/unicode.txt> before Linux 4.10)."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:217
msgid ""
"Two other planes are reserved for private usage, plane 15 (Supplementary "
"Private Use Area-A, range 0xf0000 to 0xffffd)  and plane 16 (Supplementary "
"Private Use Area-B, range 0x100000 to 0x10fffd)."
msgstr ""

#. type: SS
#: man-pages/man7/unicode.7:217
#, no-wrap
msgid "Literature"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:223
msgid ""
"Information technology \\(em Universal Multiple-Octet Coded Character Set "
"(UCS) \\(em Part 1: Architecture and Basic Multilingual Plane.  "
"International Standard ISO/IEC 10646-1, International Organization for "
"Standardization, Geneva, 2000."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:228
msgid ""
"This is the official specification of UCS .  Available from E<.UR "
"http://www.iso.ch/> E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:232
msgid ""
"The Unicode Standard, Version 3.0.  The Unicode Consortium, Addison-Wesley, "
"Reading, MA, 2000, ISBN 0-201-61633-5."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:235
msgid ""
"S.\\& Harbison, G.\\& Steele. C: A Reference Manual. Fourth edition, "
"Prentice Hall, Englewood Cliffs, 1995, ISBN 0-13-326224-3."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:242
msgid ""
"A good reference book about the C programming language.  The fourth edition "
"covers the 1994 Amendment 1 to the ISO C90 standard, which adds a large "
"number of new C library functions for handling wide and multibyte character "
"encodings, but it does not yet cover ISO C99, which improved wide and "
"multibyte character support even further."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:244
msgid "Unicode Technical Reports."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:247
msgid "E<.UR http://www.unicode.org\\:/reports/> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:250
msgid "Markus Kuhn: UTF-8 and Unicode FAQ for UNIX/Linux."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:253
msgid "E<.UR http://www.cl.cam.ac.uk\\:/~mgk25\\:/unicode.html> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:256
msgid "Bruno Haible: Unicode HOWTO."
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:259
msgid "E<.UR http://www.tldp.org\\:/HOWTO\\:/Unicode-HOWTO.html> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/unicode.7:266
msgid "B<locale>(1), B<setlocale>(3), B<charsets>(7), B<utf-8>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/uri.7:48
#, no-wrap
msgid "URI"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:51
msgid ""
"uri, url, urn - uniform resource identifier (URI), including a URL or URN"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:55
#, no-wrap
msgid "URI = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:57
#, no-wrap
msgid "absoluteURI = scheme \":\" ( hierarchical_part | opaque_part )\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:59
#, no-wrap
msgid "relativeURI = ( net_path | absolute_path | relative_path ) [ \"?\" query ]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:62
#, no-wrap
msgid ""
"scheme = \"http\" | \"ftp\" | \"gopher\" | \"mailto\" | \"news\" | \"telnet\" |\n"
"         \"file\" | \"man\" | \"info\" | \"whatis\" | \"ldap\" | \"wais\" | \\&...\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:64
#, no-wrap
msgid "hierarchical_part = ( net_path | absolute_path ) [ \"?\" query ]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:66
#, no-wrap
msgid "net_path = \"//\" authority [ absolute_path ]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:68
#, no-wrap
msgid "absolute_path = \"/\"  path_segments\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:70
#, no-wrap
msgid "relative_path = relative_segment [ absolute_path ]\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:82
msgid ""
"A Uniform Resource Identifier (URI) is a short string of characters "
"identifying an abstract or physical resource (for example, a web page).  A "
"Uniform Resource Locator (URL) is a URI that identifies a resource through "
"its primary access mechanism (e.g., its network \"location\"), rather than "
"by name or some other attribute of that resource.  A Uniform Resource Name "
"(URN) is a URI that must remain globally unique and persistent even when the"
" resource ceases to exist or becomes unavailable."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:89
msgid ""
"URIs are the standard way to name hypertext link destinations for tools such"
" as web browsers.  The string \"http://www.kernel.org\" is a URL (and thus "
"it is also a URI).  Many people use the term URL loosely as a synonym for "
"URI (though technically URLs are a subset of URIs)."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:105
msgid ""
"URIs can be absolute or relative.  An absolute identifier refers to a "
"resource independent of context, while a relative identifier refers to a "
"resource by describing the difference from the current context.  Within a "
"relative path reference, the complete path segments \".\" and \"..\" have "
"special meanings: \"the current hierarchy level\" and \"the level above this"
" hierarchy level\", respectively, just like they do in UNIX-like systems.  A"
" path segment which contains a colon character can't be used as the first "
"segment of a relative URI path (e.g., \"this:that\"), because it would be "
"mistaken for a scheme name; precede such segments with ./ (e.g., "
"\"./this:that\").  Note that descendants of MS-DOS (e.g., Microsoft Windows)"
" replace devicename colons with the vertical bar (\"|\") in URIs, so \"C:\" "
"becomes \"C|\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:109
msgid ""
"A fragment identifier, if included, refers to a particular named portion "
"(fragment) of a resource; text after a \\(aq#\\(aq identifies the fragment."
"  A URI beginning with \\(aq#\\(aq refers to that fragment in the current "
"resource."
msgstr ""

#. type: SS
#: man-pages/man7/uri.7:109
#, no-wrap
msgid "Usage"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:117
msgid ""
"There are many different URI schemes, each with specific additional rules "
"and meanings, but they are intentionally made to be as similar as possible."
"  For example, many URL schemes permit the authority to be the following "
"format, called here an I<ip_server> (square brackets show what's optional):"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:119
msgid "I<ip_server = >[I<user> [ : I<password> ] @ ] I<host> [ : I<port>]"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:135
msgid ""
"This format allows you to optionally insert a username, a user plus "
"password, and/or a port number.  The I<host> is the name of the host "
"computer, either its name as determined by DNS or an IP address (numbers "
"separated by periods).  Thus the URI "
"E<lt>http://fred:fredpassword@example.com:8080/E<gt> logs into a web server "
"on host example.com as fred (using fredpassword) using port 8080.  Avoid "
"including a password in a URI if possible because of the many security risks"
" of having a password written down.  If the URL supplies a username but no "
"password, and the remote server requests a password, the program "
"interpreting the URL should request one from the user."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:140
msgid ""
"Here are some of the most common schemes in use on UNIX-like systems that "
"are understood by many tools.  Note that many tools using URIs also have "
"internal schemes or specialized schemes; see those tools' documentation for "
"information on those schemes."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:142
msgid "B<http - Web (HTTP) server>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:144
msgid "http://I<ip_server>/I<path>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:146
msgid "http://I<ip_server>/I<path>?I<query>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:154
msgid ""
"This is a URL accessing a web (HTTP) server.  The default port is 80.  If "
"the path refers to a directory, the web server will choose what to return; "
"usually if there is a file named \"index.html\" or \"index.htm\" its content"
" is returned, otherwise, a list of the files in the current directory (with "
"appropriate links) is generated and returned.  An example is "
"E<lt>http://lwn.netE<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:177
msgid ""
"A query can be given in the archaic \"isindex\" format, consisting of a word"
" or phrase and not including an equal sign (=).  A query can also be in the "
"longer \"GET\" format, which has one or more query entries of the form "
"I<key>=I<value> separated by the ampersand character (&).  Note that I<key> "
"can be repeated more than once, though it's up to the web server and its "
"application programs to determine if there's any meaning to that.  There is "
"an unfortunate interaction with HTML/XML/SGML and the GET query format; when"
" such URIs with more than one key are embedded in SGML/XML documents "
"(including HTML), the ampersand (&) has to be rewritten as &amp;.  Note that"
" not all queries use this format; larger forms may be too long to store as a"
" URI, so they use a different interaction mechanism (called POST) which does"
" not include the data in the URI.  See the Common Gateway Interface "
"specification at E<.UR http://www.w3.org\\:/CGI> E<.UE> for more "
"information."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:179
msgid "B<ftp - File Transfer Protocol (FTP)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:181
msgid "ftp://I<ip_server>/I<path>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:189
msgid ""
"This is a URL accessing a file through the file transfer protocol (FTP).  "
"The default port (for control) is 21.  If no username is included, the "
"username \"anonymous\" is supplied, and in that case many clients provide as"
" the password the requestor's Internet email address.  An example is "
"E<lt>ftp://ftp.is.co.za/rfc/rfc1808.txtE<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:191
msgid "B<gopher - Gopher server>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:193
msgid "gopher://I<ip_server>/I<gophertype selector>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:195
msgid "gopher://I<ip_server>/I<gophertype selector>%09I<search>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:197
msgid ""
"gopher://I<ip_server>/I<gophertype selector>%09I<search>%09I<gopher+_string>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:207
msgid ""
"The default gopher port is 70.  I<gophertype> is a single-character field to"
" denote the Gopher type of the resource to which the URL refers.  The entire"
" path may also be empty, in which case the delimiting \"/\" is also optional"
" and the gophertype defaults to \"1\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:214
msgid ""
"I<selector> is the Gopher selector string.  In the Gopher protocol, Gopher "
"selector strings are a sequence of octets which may contain any octets "
"except 09 hexadecimal (US-ASCII HT or tab), 0A hexadecimal (US-ASCII "
"character LF), and 0D (US-ASCII character CR)."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:216
msgid "B<mailto - Email address>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:218
msgid "mailto:I<email-address>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:226
msgid ""
"This is an email address, usually of the form I<name>@I<hostname>.  See "
"B<mailaddr>(7)  for more information on the correct format of an email "
"address.  Note that any % character must be rewritten as %25.  An example is"
" E<lt>mailto:dwheeler@dwheeler.comE<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:228
msgid "B<news - Newsgroup or News message>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:230
msgid "news:I<newsgroup-name>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:232
msgid "news:I<message-id>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:240
msgid ""
"A I<newsgroup-name> is a period-delimited hierarchical name, such as "
"\"comp.infosystems.www.misc\".  If E<lt>newsgroup-nameE<gt> is \"*\" (as in "
"E<lt>news:*E<gt>), it is used to refer to \"all available news groups\".  An"
" example is E<lt>news:comp.lang.adaE<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:252
msgid ""
"A I<message-id> corresponds to the Message-ID of E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc1036.txt> IETF RFC\\ 1036, E<.UE> without "
"the enclosing \"E<lt>\" and \"E<gt>\"; it takes the form "
"I<unique>@I<full_domain_name>.  A message identifier may be distinguished "
"from a news group name by the presence of the \"@\" character."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:254
msgid "B<telnet - Telnet login>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:256
msgid "telnet://I<ip_server>/"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:262
msgid ""
"The Telnet URL scheme is used to designate interactive text services that "
"may be accessed by the Telnet protocol.  The final \"/\" character may be "
"omitted.  The default port is 23.  An example is "
"E<lt>telnet://melvyl.ucop.edu/E<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:264
msgid "B<file - Normal file>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:266
msgid "file://I<ip_server>/I<path_segments>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:268
msgid "file:I<path_segments>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:285
msgid ""
"This represents a file or directory accessible locally.  As a special case, "
"I<ip_server> can be the string \"localhost\" or the empty string; this is "
"interpreted as \"the machine from which the URL is being interpreted\".  If "
"the path is to a directory, the viewer should display the directory's "
"contents with links to each containee; not all viewers currently do this.  "
"KDE supports generated files through the URL E<lt>file:/cgi-binE<gt>.  If "
"the given file isn't found, browser writers may want to try to expand the "
"filename via filename globbing (see B<glob>(7)  and B<glob>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:299
msgid ""
"The second format (e.g., E<lt>file:/etc/passwdE<gt>)  is a correct format "
"for referring to a local file.  However, older standards did not permit this"
" format, and some programs don't recognize this as a URI.  A more portable "
"syntax is to use an empty string as the server name, for example, "
"E<lt>file:///etc/passwdE<gt>; this form does the same thing and is easily "
"recognized by pattern matchers and older programs as a URI.  Note that if "
"you really mean to say \"start from the current location,\" don't specify "
"the scheme at all; use a relative address like E<lt>../test.txtE<gt>, which "
"has the side-effect of being scheme-independent.  An example of this scheme "
"is E<lt>file:///etc/passwdE<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:301
msgid "B<man - Man page documentation>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:303
msgid "man:I<command-name>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:305
msgid "man:I<command-name>(I<section>)"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:314
msgid ""
"This refers to local online manual (man) reference pages.  The command name "
"can optionally be followed by a parenthesis and section number; see "
"B<man>(7)  for more information on the meaning of the section numbers.  This"
" URI scheme is unique to UNIX-like systems (such as Linux)  and is not "
"currently registered by the IETF.  An example is E<lt>man:ls(1)E<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:316
msgid "B<info - Info page documentation>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:318
msgid "info:I<virtual-filename>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:320
msgid "info:I<virtual-filename>#I<nodename>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:322
msgid "info:(I<virtual-filename>)"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:324
msgid "info:(I<virtual-filename>)I<nodename>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:343
msgid ""
"This scheme refers to online info reference pages (generated from texinfo "
"files), a documentation format used by programs such as the GNU tools.  This"
" URI scheme is unique to UNIX-like systems (such as Linux)  and is not "
"currently registered by the IETF.  As of this writing, GNOME and KDE differ "
"in their URI syntax and do not accept the other's syntax.  The first two "
"formats are the GNOME format; in nodenames all spaces are written as "
"underscores.  The second two formats are the KDE format; spaces in nodenames"
" must be written as spaces, even though this is forbidden by the URI "
"standards.  It's hoped that in the future most tools will understand all of "
"these formats and will always accept underscores for spaces in nodenames.  "
"In both GNOME and KDE, if the form without the nodename is used the nodename"
" is assumed to be \"Top\".  Examples of the GNOME format are "
"E<lt>info:gccE<gt> and E<lt>info:gcc#G++_and_GCCE<gt>.  Examples of the KDE "
"format are E<lt>info:(gcc)E<gt> and E<lt>info:(gcc)G++ and GCCE<gt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:345
msgid "B<whatis - Documentation search>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:347
msgid "whatis:I<string>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:355
msgid ""
"This scheme searches the database of short (one-line) descriptions of "
"commands and returns a list of descriptions containing that string.  Only "
"complete word matches are returned.  See B<whatis>(1).  This URI scheme is "
"unique to UNIX-like systems (such as Linux)  and is not currently registered"
" by the IETF."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:357
msgid "B<ghelp - GNOME help documentation>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:359
msgid "ghelp:I<name-of-application>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:362
msgid ""
"This loads GNOME help for the given application.  Note that not much "
"documentation currently exists in this format."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:364
msgid "B<ldap - Lightweight Directory Access Protocol>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:366
msgid "ldap://I<hostport>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:368
msgid "ldap://I<hostport>/"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:370
msgid "ldap://I<hostport>/I<dn>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:372
msgid "ldap://I<hostport>/I<dn>?I<attributes>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:374
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:376
msgid "ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:378
msgid ""
"ldap://I<hostport>/I<dn>?I<attributes>?I<scope>?I<filter>?I<extensions>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:389
msgid ""
"This scheme supports queries to the Lightweight Directory Access Protocol "
"(LDAP), a protocol for querying a set of servers for hierarchically "
"organized information (such as people and computing resources).  See E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc2255.txt> RFC\\ 2255 E<.UE> for more "
"information on the LDAP URL scheme.  The components of this URL are:"
msgstr ""

#. type: IP
#: man-pages/man7/uri.7:389
#, no-wrap
msgid "hostport"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:394
msgid ""
"the LDAP server to query, written as a hostname optionally followed by a "
"colon and the port number.  The default LDAP port is TCP port 389.  If "
"empty, the client determines which the LDAP server to use."
msgstr ""

#. type: IP
#: man-pages/man7/uri.7:394
#, no-wrap
msgid "dn"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:401
msgid ""
"the LDAP Distinguished Name, which identifies the base object of the LDAP "
"search (see E<.UR http://www.ietf.org\\:/rfc\\:/rfc2253.txt> RFC\\ 2253 "
"E<.UE> section 3)."
msgstr ""

#. type: IP
#: man-pages/man7/uri.7:401
#, no-wrap
msgid "attributes"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:405
msgid ""
"a comma-separated list of attributes to be returned; see RFC\\ 2251 section "
"4.1.5.  If omitted, all attributes should be returned."
msgstr ""

#. type: IP
#: man-pages/man7/uri.7:405
#, no-wrap
msgid "scope"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:410
msgid ""
"specifies the scope of the search, which can be one of \"base\" (for a base "
"object search), \"one\" (for a one-level search), or \"sub\" (for a subtree "
"search).  If scope is omitted, \"base\" is assumed."
msgstr ""

#. type: IP
#: man-pages/man7/uri.7:410
#, no-wrap
msgid "filter"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:419
msgid ""
"specifies the search filter (subset of entries to return).  If omitted, all "
"entries should be returned.  See E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc2254.txt> RFC\\ 2254 E<.UE> section 4."
msgstr ""

#. type: IP
#: man-pages/man7/uri.7:419
#, no-wrap
msgid "extensions"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:425
msgid ""
"a comma-separated list of type=value pairs, where the =value portion may be "
"omitted for options not requiring it.  An extension prefixed with a "
"\\(aq!\\(aq is critical (must be supported to be valid), otherwise it is "
"noncritical (optional)."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:429
msgid ""
"LDAP queries are easiest to explain by example.  Here's a query that asks "
"ldap.itd.umich.edu for information about the University of Michigan in the "
"U.S.:"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:432
#, no-wrap
msgid "ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:435
msgid "To just get its postal address attribute, request:"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:438
#, no-wrap
msgid ""
"ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US?postalAddress\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:442
msgid ""
"To ask a host.com at port 6666 for information about the person with common "
"name (cn) \"Babs Jensen\" at University of Michigan, request:"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:445
#, no-wrap
msgid ""
"ldap://host.com:6666/o=University%20of%20Michigan,c=US??sub?(cn=Babs%20Jensen)\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:448
msgid "B<wais - Wide Area Information Servers>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:450
msgid "wais://I<hostport>/I<database>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:452
msgid "wais://I<hostport>/I<database>?I<search>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:454
msgid "wais://I<hostport>/I<database>/I<wtype>/I<wpath>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:463
msgid ""
"This scheme designates a WAIS database, search, or document (see E<.UR "
"http://www.ietf.org\\:/rfc\\:/rfc1625.txt> IETF RFC\\ 1625 E<.UE> for more "
"information on WAIS).  Hostport is the hostname, optionally followed by a "
"colon and port number (the default port number is 210)."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:473
msgid ""
"The first form designates a WAIS database for searching.  The second form "
"designates a particular search of the WAIS database I<database>.  The third "
"form designates a particular document within a WAIS database to be "
"retrieved.  I<wtype> is the WAIS designation of the type of the object and "
"I<wpath> is the WAIS document-id."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:475
msgid "B<other schemes>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:489
msgid ""
"There are many other URI schemes.  Most tools that accept URIs support a set"
" of internal URIs (e.g., Mozilla has the about: scheme for internal "
"information, and the GNOME help browser has the toc: scheme for various "
"starting locations).  There are many schemes that have been defined but are "
"not as widely used at the current time (e.g., prospero).  The nntp: scheme "
"is deprecated in favor of the news: scheme.  URNs are to be supported by the"
" urn: scheme, with a hierarchical name space (e.g., urn:ietf:... would "
"identify IETF documents); at this time URNs are not widely implemented.  Not"
" all tools support all schemes."
msgstr ""

#. type: SS
#: man-pages/man7/uri.7:489
#, no-wrap
msgid "Character encoding"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:493
msgid ""
"URIs use a limited number of characters so that they can be typed in and "
"used in a variety of situations."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:497
msgid ""
"The following characters are reserved, that is, they may appear in a URI but"
" their use is limited to their reserved purpose (conflicting data must be "
"escaped before forming the URI):"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:499
#, no-wrap
msgid "   ; / ? : @ & = + $ ,\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:505
msgid ""
"Unreserved characters may be included in a URI.  Unreserved characters "
"include uppercase and lowercase English letters, decimal digits, and the "
"following limited set of punctuation marks and symbols:"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:507
#, no-wrap
msgid " - _ . ! ~ * ' ( )\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:522
msgid ""
"All other characters must be escaped.  An escaped octet is encoded as a "
"character triplet, consisting of the percent character \"%\" followed by the"
" two hexadecimal digits representing the octet code (you can use uppercase "
"or lowercase letters for the hexadecimal digits).  For example, a blank "
"space must be escaped as \"%20\", a tab character as \"%09\", and the \"&\" "
"as \"%26\".  Because the percent \"%\" character always has the reserved "
"purpose of being the escape indicator, it must be escaped as \"%25\".  It is"
" common practice to escape space characters as the plus symbol (+)  in query"
" text; this practice isn't uniformly defined in the relevant RFCs (which "
"recommend %20 instead) but any tool accepting URIs with query text should be"
" prepared for them.  A URI is always shown in its \"escaped\" form."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:528
msgid ""
"Unreserved characters can be escaped without changing the semantics of the "
"URI, but this should not be done unless the URI is being used in a context "
"that does not allow the unescaped character to appear.  For example, \"%7e\""
" is sometimes used instead of \"~\" in an HTTP URL path, but the two are "
"equivalent for an HTTP URL."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:532
msgid ""
"For URIs which must handle characters outside the US ASCII character set, "
"the HTML 4.01 specification (section B.2) and IETF RFC\\ 2718 (section "
"2.2.5) recommend the following approach:"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:536
msgid ""
"translate the character sequences into UTF-8 (IETF RFC\\ 2279)\\(emsee "
"B<utf-8>(7)\\(emand then"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:539
msgid ""
"use the URI escaping mechanism, that is, use the %HH encoding for unsafe "
"octets."
msgstr ""

#. type: SS
#: man-pages/man7/uri.7:539
#, no-wrap
msgid "Writing a URI"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:562
msgid ""
"When written, URIs should be placed inside double quotes (e.g., "
"\"http://www.kernel.org\"), enclosed in angle brackets (e.g., "
"E<lt>http://lwn.netE<gt>), or placed on a line by themselves.  A warning for"
" those who use double-quotes: B<never> move extraneous punctuation (such as "
"the period ending a sentence or the comma in a list)  inside a URI, since "
"this will change the value of the URI.  Instead, use angle brackets instead,"
" or switch to a quoting system that never includes extraneous characters "
"inside quotation marks.  This latter system, called the 'new' or 'logical' "
"quoting system by \"Hart's Rules\" and the \"Oxford Dictionary for Writers "
"and Editors\", is preferred practice in Great Britain and hackers worldwide "
"(see the Jargon File's section on Hacker Writing Style, E<.UR "
"http://www.fwi.uva.nl\\:/~mes\\:/jargon\\:/h\\:/HackerWritingStyle.html> "
"E<.UE ,> for more information).  Older documents suggested inserting the "
"prefix \"URL:\" just before the URI, but this form has never caught on."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:584
msgid ""
"The URI syntax was designed to be unambiguous.  However, as URIs have become"
" commonplace, traditional media (television, radio, newspapers, billboards, "
"etc.) have increasingly used abbreviated URI references consisting of only "
"the authority and path portions of the identified resource (e.g., "
"E<lt>www.w3.org/AddressingE<gt>).  Such references are primarily intended "
"for human interpretation rather than machine, with the assumption that "
"context-based heuristics are sufficient to complete the URI (e.g., hostnames"
" beginning with \"www\" are likely to have a URI prefix of \"http://\" and "
"hostnames beginning with \"ftp\" likely to have a prefix of \"ftp://\").  "
"Many client implementations heuristically resolve these references.  Such "
"heuristics may change over time, particularly when new schemes are "
"introduced.  Since an abbreviated URI has the same syntax as a relative URL "
"path, abbreviated URI references cannot be used where relative URIs are "
"permitted, and can be used only when there is no defined base (such as in "
"dialog boxes).  Don't use abbreviated URIs as hypertext links inside a "
"document; use the standard format as described here."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:592
msgid ""
"E<.UR http://www.ietf.org\\:/rfc\\:/rfc2396.txt> (IETF RFC\\ 2396)  E<.UE ,>"
" E<.UR http://www.w3.org\\:/TR\\:/REC-html40> (HTML 4.0)  E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:598
msgid ""
"Any tool accepting URIs (e.g., a web browser) on a Linux system should be "
"able to handle (directly or indirectly) all of the schemes described here, "
"including the man: and info: schemes.  Handling them by invoking some other "
"program is fine and in fact encouraged."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:600
msgid "Technically the fragment isn't part of the URI."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:609
msgid ""
"For information on how to embed URIs (including URLs) in a data format, see "
"documentation on that format.  HTML uses the format E<lt>A "
"HREF=\"I<uri>\"E<gt> I<text> E<lt>/AE<gt>.  Texinfo files use the format "
"@uref{I<uri>}.  Man and mdoc have the recently added UR macro, or just "
"include the URI in the text (viewers should be able to detect :// as part of"
" a URI)."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:630
msgid ""
"The GNOME and KDE desktop environments currently vary in the URIs they "
"accept, in particular in their respective help browsers.  To list man pages,"
" GNOME uses E<lt>toc:manE<gt> while KDE uses E<lt>man:(index)E<gt>, and to "
"list info pages, GNOME uses E<lt>toc:infoE<gt> while KDE uses "
"E<lt>info:(dir)E<gt> (the author of this man page prefers the KDE approach "
"here, though a more regular format would be even better).  In general, KDE "
"uses E<lt>file:/cgi-bin/E<gt> as a prefix to a set of generated files.  KDE "
"prefers documentation in HTML, accessed via the E<lt>file:/cgi-"
"bin/helpindexE<gt>.  GNOME prefers the ghelp scheme to store and find "
"documentation.  Neither browser handles file: references to directories at "
"the time of this writing, making it difficult to refer to an entire "
"directory with a browsable URI.  As noted above, these environments differ "
"in how they handle the info: scheme, probably the most important variation."
"  It is expected that GNOME and KDE will converge to common URI formats, and"
" a future version of this man page will describe the converged result.  "
"Efforts to aid this convergence are encouraged."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:640
msgid ""
"A URI does not in itself pose a security threat.  There is no general "
"guarantee that a URL, which at one time located a given resource, will "
"continue to do so.  Nor is there any guarantee that a URL will not locate a "
"different resource at some later point in time; such a guarantee can be "
"obtained only from the person(s) controlling that namespace and the resource"
" in question."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:655
msgid ""
"It is sometimes possible to construct a URL such that an attempt to perform "
"a seemingly harmless operation, such as the retrieval of an entity "
"associated with the resource, will in fact cause a possibly damaging remote "
"operation to occur.  The unsafe URL is typically constructed by specifying a"
" port number other than that reserved for the network protocol in question."
"  The client unwittingly contacts a site that is in fact running a different"
" protocol.  The content of the URL contains instructions that, when "
"interpreted according to this other protocol, cause an unexpected operation."
"  An example has been the use of a gopher URL to cause an unintended or "
"impersonating message to be sent via a SMTP server."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:659
msgid ""
"Caution should be used when using any URL that specifies a port number other"
" than the default for the protocol, especially when it is a number within "
"the reserved space."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:667
msgid ""
"Care should be taken when a URI contains escaped delimiters for a given "
"protocol (for example, CR and LF characters for telnet protocols) that these"
" are not unescaped before transmission.  This might violate the protocol, "
"but avoids the potential for such characters to be used to simulate an extra"
" operation or parameter in that protocol, which might lead to an unexpected "
"and possibly harmful remote operation to be performed."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:673
msgid ""
"It is clearly unwise to use a URI that contains a password which is intended"
" to be secret.  In particular, the use of a password within the \"userinfo\""
" component of a URI is strongly recommended against except in those rare "
"cases where the \"password\" parameter is intended to be public."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:695
msgid ""
"Documentation may be placed in a variety of locations, so there currently "
"isn't a good URI scheme for general online documentation in arbitrary "
"formats.  References of the form E<lt>file:///usr/doc/ZZZE<gt> don't work "
"because different distributions and local installation requirements may "
"place the files in different directories (it may be in /usr/doc, or "
"/usr/local/doc, or /usr/share, or somewhere else).  Also, the directory ZZZ "
"usually changes when a version changes (though filename globbing could "
"partially overcome this).  Finally, using the file: scheme doesn't easily "
"support people who dynamically load documentation from the Internet (instead"
" of loading the files onto a local filesystem).  A future URI scheme may be "
"added (e.g., \"userdoc:\") to permit programs to include cross-references to"
" more detailed documentation without having to know the exact location of "
"that documentation.  Alternatively, a future version of the filesystem "
"specification may specify file locations sufficiently so that the file: "
"scheme will be able to locate documentation."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:698
msgid ""
"Many programs and file formats don't include a way to incorporate or "
"implement links using URIs."
msgstr ""

#.  .SH AUTHOR
#.  David A. Wheeler (dwheeler@dwheeler.com) wrote this man page.
#. type: Plain text
#: man-pages/man7/uri.7:706
msgid ""
"Many programs can't handle all of these different URI formats; there should "
"be a standard mechanism to load an arbitrary URI that automatically detects "
"the users' environment (e.g., text or graphics, desktop environment, local "
"user preferences, and currently executing tools) and invokes the right tool "
"for any URI."
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:711
msgid "B<lynx>(1), B<man2html>(1), B<mailaddr>(7), B<utf-8>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/uri.7:714
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc2255.txt> IETF RFC\\ 2255 E<.UE>"
msgstr ""

#. type: TH
#: man-pages/man7/udp.7:12
#, no-wrap
msgid "UDP"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:15
msgid "udp - User Datagram Protocol for IPv4"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:19
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:21
msgid "B<#include E<lt>netinet/udp.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:23
msgid "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:29
msgid ""
"This is an implementation of the User Datagram Protocol described in RFC\\ "
"768.  It implements a connectionless, unreliable datagram packet service.  "
"Packets may be reordered or duplicated before they arrive.  UDP generates "
"and checks checksums to catch transmission errors."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:58
msgid ""
"When a UDP socket is created, its local and remote addresses are "
"unspecified.  Datagrams can be sent immediately using B<sendto>(2)  or "
"B<sendmsg>(2)  with a valid destination address as an argument.  When "
"B<connect>(2)  is called on the socket, the default destination address is "
"set and datagrams can now be sent using B<send>(2)  or B<write>(2)  without "
"specifying a destination address.  It is still possible to send to other "
"destinations by passing an address to B<sendto>(2)  or B<sendmsg>(2).  In "
"order to receive packets, the socket can be bound to a local address first "
"by using B<bind>(2).  Otherwise, the socket layer will automatically assign "
"a free local port out of the range defined by "
"I</proc/sys/net/ipv4/ip_local_port_range> and bind the socket to "
"B<INADDR_ANY>."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:66
msgid ""
"All receive operations return only one packet.  When the packet is smaller "
"than the passed buffer, only that much data is returned; when it is bigger, "
"the packet is truncated and the B<MSG_TRUNC> flag is set.  B<MSG_WAITALL> is"
" not supported."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:75
msgid ""
"IP options may be sent or received using the socket options described in "
"B<ip>(7).  They are processed by the kernel only when the appropriate "
"I</proc> parameter is enabled (but still passed to the user even when it is "
"turned off).  See B<ip>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:80
msgid ""
"When the B<MSG_DONTROUTE> flag is set on sending, the destination address "
"must refer to a local interface address and the packet is sent only to that "
"interface."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:98
msgid ""
"By default, Linux UDP does path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a UDP packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file; see B<ip>(7)  for "
"details.  When turned off, UDP will fragment outgoing UDP packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:103
msgid "UDP uses the IPv4 I<sockaddr_in> address format described in B<ip>(7)."
msgstr ""

#. type: SS
#: man-pages/man7/udp.7:103
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:114
msgid ""
"All fatal errors will be passed to the user as an error return even when the"
" socket is not connected.  This includes asynchronous errors received from "
"the network.  You may get an error for an earlier packet that was sent on "
"the same socket.  This behavior differs from many other BSD socket "
"implementations which don't pass any errors unless the socket is connected."
"  Linux's behavior is mandated by B<RFC\\ 1122>."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:128
msgid ""
"For compatibility with legacy code, in Linux 2.0 and 2.2 it was possible to "
"set the B<SO_BSDCOMPAT> B<SOL_SOCKET> option to receive remote errors only "
"when the socket has been connected (except for B<EPROTO> and B<EMSGSIZE>).  "
"Locally generated errors are always passed.  Support for this socket option "
"was removed in later kernels; see B<socket>(7)  for further information."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:137
msgid ""
"When the B<IP_RECVERR> option is enabled, all errors are stored in the "
"socket error queue, and can be received by B<recvmsg>(2)  with the "
"B<MSG_ERRQUEUE> flag set."
msgstr ""

#. type: SS
#: man-pages/man7/udp.7:137
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:140
msgid ""
"System-wide UDP parameter settings can be accessed by files in the directory"
" I</proc/sys/net/ipv4/>."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:140
#, no-wrap
msgid "I<udp_mem> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:144
msgid ""
"This is a vector of three integers governing the number of pages allowed for"
" queueing by all UDP sockets."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:145
#, no-wrap
msgid "I<min>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:151
msgid ""
"Below this number of pages, UDP is not bothered about its memory appetite.  "
"When the amount of memory allocated by UDP exceeds this number, UDP starts "
"to moderate memory usage."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:151
#, no-wrap
msgid "I<pressure>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:157
msgid ""
"This value was introduced to follow the format of I<tcp_mem> (see "
"B<tcp>(7))."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:157
#, no-wrap
msgid "I<max>"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:160
msgid "Number of pages allowed for queueing by all UDP sockets."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:164
msgid ""
"Defaults values for these three items are calculated at boot time from the "
"amount of available memory."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:164
#, no-wrap
msgid ""
"I<udp_rmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:171
msgid ""
"Minimal size, in bytes, of receive buffers used by UDP sockets in "
"moderation.  Each UDP socket is able to use the size for receiving data, "
"even if total pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:171
#, no-wrap
msgid ""
"I<udp_wmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:178
msgid ""
"Minimal size, in bytes, of send buffer used by UDP sockets in moderation.  "
"Each UDP socket is able to use the size for sending data, even if total "
"pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:189
msgid ""
"To set or get a UDP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDP>.  Unless otherwise noted, I<optval> is a pointer to an "
"I<int>."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:194
msgid ""
"Following is a list of UDP-specific socket options.  For details of some "
"other socket options that are also applicable for UDP sockets, see "
"B<socket>(7)."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:194
#, no-wrap
msgid "B<UDP_CORK> (since Linux 2.5.44)"
msgstr ""

#.  FIXME document UDP_ENCAP (new in kernel 2.5.67)
#.  From include/linux/udp.h:
#.      UDP_ENCAP_ESPINUDP_NON_IKE draft-ietf-ipsec-nat-t-ike-00/01
#.      UDP_ENCAP_ESPINUDP draft-ietf-ipsec-udp-encaps-06
#.      UDP_ENCAP_L2TPINUDP rfc2661
#.  FIXME Document UDP_NO_CHECK6_TX and UDP_NO_CHECK6_RX, added in Linux 3.16
#. type: Plain text
#: man-pages/man7/udp.7:207
msgid ""
"If this option is enabled, then all data output on this socket is "
"accumulated into a single datagram that is transmitted when the option is "
"disabled.  This option should not be used in code intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:211
msgid ""
"These ioctls can be accessed using B<ioctl>(2).  The correct syntax is:"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:216
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:218
#, no-wrap
msgid "B<FIONREAD> (B<SIOCINQ>)"
msgstr ""

#.  See http://www.securiteam.com/unixfocus/5KP0I15IKO.html
#.  "GNUnet DoS (UDP Socket Unreachable)", 14 May 2006
#. type: Plain text
#: man-pages/man7/udp.7:236
msgid ""
"Gets a pointer to an integer as argument.  Returns the size of the next "
"pending datagram in the integer in bytes, or 0 when no datagram is pending."
"  B<Warning:> Using B<FIONREAD>, it is impossible to distinguish the case "
"where no datagram is pending from the case where the next pending datagram "
"contains zero bytes of data.  It is safer to use B<select>(2), B<poll>(2), "
"or B<epoll>(7)  to distinguish these cases."
msgstr ""

#. type: TP
#: man-pages/man7/udp.7:236
#, no-wrap
msgid "B<TIOCOUTQ> (B<SIOCOUTQ>)"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:240
msgid ""
"Returns the number of data bytes in the local send queue.  Supported only "
"with Linux 2.4 and above."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:246
msgid ""
"In addition, all ioctls documented in B<ip>(7)  and B<socket>(7)  are "
"supported."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:252
msgid ""
"All errors documented for B<socket>(7)  or B<ip>(7)  may be returned by a "
"send or receive on a UDP socket."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:256
msgid ""
"No receiver was associated with the destination address.  This might be "
"caused by a previous packet sent over the socket."
msgstr ""

#.  .SH CREDITS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: man-pages/man7/udp.7:261
msgid "B<IP_RECVERR> is a new feature in Linux 2.2."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:266
msgid "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:268
msgid "RFC\\ 768 for the User Datagram Protocol."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:270
msgid "RFC\\ 1122 for the host requirements."
msgstr ""

#. type: Plain text
#: man-pages/man7/udp.7:271
msgid "RFC\\ 1191 for a description of path MTU discovery."
msgstr ""

#. type: TH
#: man-pages/man7/user-session-keyring.7:12
#, no-wrap
msgid "USER-SESSION-KEYRING"
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:15
msgid "user-session-keyring - per-user default session keyring"
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:24
msgid ""
"The user session keyring is a keyring used to anchor keys on behalf of a "
"user.  Each UID the kernel deals with has its own user session keyring that "
"is shared by all processes with that UID.  The user session keyring has a "
"name (description) of the form I<_uid_ses.E<lt>UIDE<gt>> where "
"I<E<lt>UIDE<gt>> is the user ID of the corresponding user."
msgstr ""

#.  Davis Howells: the user and user-session keyrings are managed as a pair.
#. type: Plain text
#: man-pages/man7/user-session-keyring.7:37
msgid ""
"The user session keyring is associated with the record that the kernel "
"maintains for the UID.  It comes into existence upon the first attempt to "
"access either the user session keyring, the B<user-keyring>(7), or the B"
"<session-keyring>(7).  The keyring remains pinned in existence so long as "
"there are processes running with that real UID or files opened by those "
"processes remain open.  (The keyring can also be pinned indefinitely by "
"linking it into another keyring.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:45
msgid ""
"The user session keyring is created on demand when a thread requests it or "
"when a thread asks for its B<session-keyring>(7)  and that keyring doesn't "
"exist.  In the latter case, a user session keyring will be created and, if "
"the session keyring wasn't to be created, the user session keyring will be "
"set as the process's actual session keyring."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:49
msgid ""
"The user session keyring is searched by B<request_key>(2)  if the actual "
"session keyring does not exist and is ignored otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:55
msgid ""
"A special serial number value, B<KEY_SPEC_USER_SESSION_KEYRING>, is defined "
"that can be used in lieu of the actual serial number of the calling "
"process's user session keyring."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:60
msgid ""
"From the B<keyctl>(1)  utility, 'B<@us>' can be used instead of a numeric "
"key ID in much the same way."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:70
msgid ""
"User session keyrings are independent of B<clone>(2), B<fork>(2), "
"B<vfork>(2), B<execve>(2), and B<_exit>(2)  excepting that the keyring is "
"destroyed when the UID record is destroyed when the last process pinning it "
"exits."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:73
msgid ""
"If a user session keyring does not exist when it is accessed, it will be "
"created."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:80
msgid ""
"Rather than relying on the user session keyring, it is strongly "
"recommended\\(emespecially if the process is running as root\\(emthat a B"
"<session-keyring>(7)  be set explicitly, for example by B<pam_keyinit>(8)."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:88
msgid ""
"The user session keyring was added to support situations where a process "
"doesn't have a session keyring, perhaps because it was created via a pathway"
" that didn't involve PAM (e.g., perhaps it was a daemon started by "
"B<inetd>(8)).  In such a scenario, the user session keyring acts as a "
"substitute for the B<session-keyring>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/user-session-keyring.7:98
msgid ""
"B<keyctl>(1), B<keyctl>(3), B<keyrings>(7), B<persistent-keyring>(7), B"
"<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), B<user-"
"keyring>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/umask.2:34
#, no-wrap
msgid "UMASK"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:37
msgid "umask - set file mode creation mask"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:39
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:41
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:43
msgid "B<mode_t umask(mode_t >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:50
msgid ""
"B<umask>()  sets the calling process's file mode creation mask (umask) to "
"I<mask> & 0777 (i.e., only the file permission bits of I<mask> are used), "
"and returns the previous value of the mask."
msgstr ""

#.  e.g., mkfifo(), creat(), mknod(), sem_open(), mq_open(), shm_open()
#.  but NOT the System V IPC *get() calls
#. type: Plain text
#: man-pages/man2/umask.2:65
msgid ""
"The umask is used by B<open>(2), B<mkdir>(2), and other system calls that "
"create files to modify the permissions placed on newly created files or "
"directories.  Specifically, permissions in the umask are turned off from the"
" I<mode> argument to B<open>(2)  and B<mkdir>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:74
msgid ""
"Alternatively, if the parent directory has a default ACL (see B<acl>(5)), "
"the umask is ignored, the default ACL is inherited, the permission bits are "
"set based on the inherited ACL, and permission bits absent in the I<mode> "
"argument are turned off.  For example, the following default ACL is "
"equivalent to a umask of 022:"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:76
#, no-wrap
msgid "    u::rwx,g::r-x,o::r-x\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:81
msgid ""
"Combining the effect of this default ACL with a I<mode> argument of 0666 "
"(rw-rw-rw-), the resulting file permissions would be 0644 (rw-r--r--)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:86
msgid ""
"The constants that should be used to specify I<mask> are described in "
"B<inode>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:95
msgid ""
"The typical default value for the process umask is I<S_IWGRP\\ |\\ S_IWOTH> "
"(octal 022).  In the usual case where the I<mode> argument to B<open>(2)  is"
" specified as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:99
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:104
msgid ""
"(octal 0666) when creating a new file, the permissions on the resulting file"
" will be:"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:108
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:112
msgid "(because 0666 & ~022 = 0644; i.e., rw-r--r--)."
msgstr ""

#. type: SH
#: man-pages/man2/umask.2:112
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:115
msgid ""
"This system call always succeeds and the previous value of the mask is "
"returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:117
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:123
msgid ""
"A child process created via B<fork>(2)  inherits its parent's umask.  The "
"umask is left unchanged by B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:132
msgid ""
"It is impossible to use B<umask>()  to fetch a process's umask without at "
"the same time changing it.  A second call to B<umask>()  would then be "
"needed to restore the umask.  The nonatomicity of these two steps provides "
"the potential for races in multithreaded programs."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:140
msgid ""
"Since Linux 4.7, the umask of any process can be viewed via the I<Umask> "
"field of I</proc/[pid]/status>.  Inspecting this field in "
"I</proc/self/status> allows a process to retrieve its umask without at the "
"same time changing it."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:155
msgid ""
"The umask setting also affects the permissions assigned to POSIX IPC objects"
" (B<mq_open>(3), B<sem_open>(3), B<shm_open>(3)), FIFOs (B<mkfifo>(3)), and "
"UNIX domain sockets (B<unix>(7))  created by the process.  The umask does "
"not affect the permissions assigned to System\\ V IPC objects created by the"
" process (using B<msgget>(2), B<semget>(2), B<shmget>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:160
msgid "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"
msgstr ""

#. type: TH
#: man-pages/man2/unshare.2:20
#, no-wrap
msgid "UNSHARE"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:23
msgid "unshare - disassociate parts of the process execution context"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:27
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:29
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:42
msgid ""
"B<unshare>()  allows a process (or thread) to disassociate parts of its "
"execution context that are currently being shared with other processes (or "
"threads).  Part of the execution context, such as the mount namespace, is "
"shared implicitly when a new process is created using B<fork>(2)  or "
"B<vfork>(2), while other parts, such as virtual memory, may be shared by "
"explicit request when creating a process or thread using B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:47
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:54
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:54
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:62
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file"
" descriptors with any other process."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:62
#, no-wrap
msgid "B<CLONE_FS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:76
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare filesystem"
" attributes, so that the calling process no longer shares its root directory"
" (B<chroot>(2)), current directory (B<chdir>(2)), or umask (B<umask>(2))  "
"attributes with any other process."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:76
#, no-wrap
msgid "B<CLONE_NEWCGROUP> (since Linux 4.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:88
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWCGROUP> flag.  "
"Unshare the cgroup namespace.  Use of B<CLONE_NEWCGROUP> requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:88
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:105
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the IPC namespace, so that the calling process has a private copy of"
" the IPC namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_SYSVSEM> as well.  Use of "
"B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:105
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:120
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  Use of B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:120
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr ""

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: man-pages/man2/unshare.2:143
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<mount_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:143
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:170
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWPID> flag.  "
"Unshare the PID namespace, so that the calling process has a new PID "
"namespace for its children which is not shared with any previously existing "
"process.  The calling process is I<not> moved into the new namespace.  The "
"first child created by the calling process will have the process ID 1 and "
"will assume the role of B<init>(1)  in the new namespace.  B<CLONE_NEWPID> "
"automatically implies B<CLONE_THREAD> as well.  Use of B<CLONE_NEWPID> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:170
#, no-wrap
msgid "B<CLONE_NEWUSER> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:184
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUSER> flag.  "
"Unshare the user namespace, so that the calling process is moved into a new "
"user namespace which is not shared with any previously existing process.  As"
" with the child process created by B<clone>(2)  with the B<CLONE_NEWUSER> "
"flag, the caller obtains a full set of capabilities in the new namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: man-pages/man2/unshare.2:200
msgid ""
"B<CLONE_NEWUSER> requires that the calling process is not threaded; "
"specifying B<CLONE_NEWUSER> automatically implies B<CLONE_THREAD>.  Since "
"Linux 3.9, B<CLONE_NEWUSER> also automatically implies B<CLONE_FS>.  "
"B<CLONE_NEWUSER> requires that the user ID and group ID of the calling "
"process are mapped to user IDs and group IDs in the user namespace of the "
"calling process at the time of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:203
msgid "For further information on user namespaces, see B<user_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:203
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:217
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:217
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr ""

#.  commit 9edff4ab1f8d82675277a04e359d0ed8bf14a7b7
#.  CLONE_NEWNS If CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#. type: Plain text
#: man-pages/man2/unshare.2:237
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System\\ V semaphore adjustment (I<semadj>)  values, so that the "
"calling process has a new empty I<semadj> list that is not shared with any "
"other process.  If this is the last process that has a reference to the "
"process's current I<semadj> list, then the adjustments in that list are "
"applied to the corresponding semaphores, as described in B<semop>(2)."
msgstr ""

#.  As at 3.9, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#.  See kernel/fork.c::check_unshare_flags()
#. type: Plain text
#: man-pages/man2/unshare.2:264
msgid ""
"In addition, B<CLONE_THREAD>, B<CLONE_SIGHAND>, and B<CLONE_VM> can be "
"specified in I<flags> if the caller is single threaded (i.e., it is not "
"sharing its address space with another process or thread).  In this case, "
"these flags have no effect.  (Note also that specifying B<CLONE_THREAD> "
"automatically implies B<CLONE_VM>, and specifying B<CLONE_VM> automatically "
"implies B<CLONE_SIGHAND>.)  If the process is multithreaded, then the use of"
" these flags results in an error."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:271
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:276
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:281
msgid "An invalid bit was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:290
msgid ""
"B<CLONE_THREAD>, B<CLONE_SIGHAND>, or B<CLONE_VM> was specified in I<flags>,"
" and the caller is multithreaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:300
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured"
" with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:308
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured"
" with the B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:316
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured"
" with the B<CONFIG_PID_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:324
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but the kernel was not "
"configured with the B<CONFIG_USER_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:332
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured"
" with the B<CONFIG_UTS_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:342
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the process has previously "
"called B<unshare>()  with the B<CLONE_NEWPID> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:346
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:346
#, no-wrap
msgid "B<ENOSPC> (since Linux 3.7)"
msgstr ""

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
#: man-pages/man2/unshare.2:354
msgid ""
"B<CLONE_NEWPID> was specified in flags, but the limit on the nesting depth "
"of PID namespaces would have been exceeded; see B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:354
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9; beforehand B<EUSERS>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:363
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
"limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:366
msgid ""
"From Linux 3.11 to Linux 4.8, the error diagnosed in this case was "
"B<EUSERS>."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:366
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:376
msgid ""
"One of the values in I<flags> specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:379
msgid ""
"The calling process did not have the required privileges for this operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:387
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but either the effective user ID"
" or the effective group ID of the caller does not have a mapping in the "
"parent namespace (see B<user_namespaces>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:387
#, no-wrap
msgid "B<EPERM> (since Linux 3.9)"
msgstr ""

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
#: man-pages/man2/unshare.2:397
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags> and the caller is in a chroot "
"environment (i.e., the caller's root directory does not match the root "
"directory of the mount namespace in which it resides)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:397
#, no-wrap
msgid "B<EUSERS> (from Linux 3.11 to Linux 4.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:406
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the limit on the number of "
"nested user namespaces would be exceeded.  See the discussion of the "
"B<ENOSPC> error above."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:410
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:414
msgid "The B<unshare>()  system call is Linux-specific."
msgstr ""

#.  FIXME all of the following needs to be reviewed for the current kernel
#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  However, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: man-pages/man2/unshare.2:448
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 3.8, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_THREAD>, or B<CLONE_VM>.  "
"Such functionality may be added in the future, if required."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:457
msgid ""
"The program below provides a simple implementation of the B<unshare>(1)  "
"command, which unshares one or more namespaces and executes the command "
"supplied in its command-line arguments.  Here's an example of the use of "
"this program, running a shell in a new mount namespace, and verifying that "
"the original shell and the new shell are in separate mount namespaces:"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:465
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026531840]\n"
"$ B<sudo ./unshare -m /bin/bash>\n"
"# B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026532325]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:471
msgid ""
"The differing output of the two B<readlink>(1)  commands shows that the two "
"shells are in different mount namespaces."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:475
#, no-wrap
msgid "/* unshare.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:484
#, no-wrap
msgid ""
"   A simple implementation of the unshare(1) command: unshare\n"
"   namespaces and execute a command.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:504
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] program [arg...]\\en\", pname);\n"
"    fprintf(stderr, \"Options can be:\\en\");\n"
"    fprintf(stderr, \"    -i   unshare IPC namespace\\en\");\n"
"    fprintf(stderr, \"    -m   unshare mount namespace\\en\");\n"
"    fprintf(stderr, \"    -n   unshare network namespace\\en\");\n"
"    fprintf(stderr, \"    -p   unshare PID namespace\\en\");\n"
"    fprintf(stderr, \"    -u   unshare UTS namespace\\en\");\n"
"    fprintf(stderr, \"    -U   unshare user namespace\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:509
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:511
#, no-wrap
msgid "    flags = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:523
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"imnpuU\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:526
#, no-wrap
msgid ""
"    if (optind E<gt>= argc)\n"
"        usage(argv[0]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:529
#, no-wrap
msgid ""
"    if (unshare(flags) == -1)\n"
"        errExit(\"unshare\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:533
#, no-wrap
msgid ""
"    execvp(argv[optind], &argv[optind]);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:542
msgid ""
"B<unshare>(1), B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), "
"B<vfork>(2), B<namespaces>(7)"
msgstr ""

#.  commit f504d47be5e8fa7ecf2bf660b18b42e6960c0eb2
#. type: Plain text
#: man-pages/man2/unshare.2:548
msgid ""
"I<Documentation/userspace-api/unshare.rst> in the Linux kernel source tree "
"(or I<Documentation/unshare.txt> before Linux 4.12)"
msgstr ""

#. type: TH
#: man-pages/man2/ustat.2:30
#, no-wrap
msgid "USTAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:33
msgid "ustat - get filesystem statistics"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
"B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:40
#, no-wrap
msgid "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:52
msgid ""
"B<ustat>()  returns information about a mounted filesystem.  I<dev> is a "
"device number identifying a device containing a mounted filesystem.  I<ubuf>"
" is a pointer to a I<ustat> structure that contains the following members:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:59
#, no-wrap
msgid ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:68
msgid ""
"The last two fields, I<f_fname> and I<f_fpack>, are not implemented and will"
" always be filled with null bytes (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:77
msgid ""
"On success, zero is returned and the I<ustat> structure pointed to by "
"I<ubuf> will be filled in.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:82
msgid "I<ubuf> points outside of your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:86
msgid "I<dev> does not refer to a device containing a mounted filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/ustat.2:86
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:92
msgid ""
"The mounted filesystem referenced by I<dev> does not support this operation,"
" or any version of Linux before 1.3.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:94
msgid ""
"Since version 2.28, glibc no longer provides a wrapper for this system call."
msgstr ""

#.  SVr4 documents additional error conditions ENOLINK, ECOMM, and EINTR
#.  but has no ENOSYS condition.
#. type: Plain text
#: man-pages/man2/ustat.2:98
msgid "SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:104
msgid ""
"B<ustat>()  is deprecated and has been provided only for compatibility.  All"
" new programs should use B<statfs>(2)  instead."
msgstr ""

#. type: SS
#: man-pages/man2/ustat.2:104
#, no-wrap
msgid "HP-UX notes"
msgstr ""

#.  Some software tries to use this in order to test whether the
#.  underlying filesystem is NFS.
#. type: Plain text
#: man-pages/man2/ustat.2:118
msgid ""
"The HP-UX version of the I<ustat> structure has an additional field, "
"I<f_blksize>, that is unknown elsewhere.  HP-UX warns: For some filesystems,"
" the number of free inodes does not change.  Such filesystems will return -1"
" in the field I<f_tinode>.  For some filesystems, inodes are dynamically "
"allocated.  Such filesystems will return the current number of free inodes."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:120
msgid "B<stat>(2), B<statfs>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/utime.2:31
#, no-wrap
msgid "UTIME"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:34
msgid "utime, utimes - change file last access and modification times"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>utime.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:40
#, no-wrap
msgid ""
"B<int utime(const char *>I<filename>B<, const struct utimbuf "
"*>I<times>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:42
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:44
#, no-wrap
msgid ""
"B<int utimes(const char *>I<filename>B<, const struct timeval "
">I<times>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:49
msgid ""
"B<Note:> modern applications may prefer to use the interfaces described in "
"B<utimensat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:60
msgid ""
"The B<utime>()  system call changes the access and modification times of the"
" inode specified by I<filename> to the I<actime> and I<modtime> fields of "
"I<times> respectively."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:65
msgid ""
"If I<times> is NULL, then the access and modification times of the file are "
"set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:72
msgid ""
"Changing timestamps is permitted when: either the process has appropriate "
"privileges, or the effective user ID equals the user ID of the file, or "
"I<times> is NULL and the process has write permission for the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:76
msgid "The I<utimbuf> structure is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:83
#, no-wrap
msgid ""
"struct utimbuf {\n"
"    time_t actime;       /* access time */\n"
"    time_t modtime;      /* modification time */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:90
msgid ""
"The B<utime>()  system call allows specification of timestamps with a "
"resolution of 1 second."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:103
msgid ""
"The B<utimes>()  system call is similar, but the I<times> argument refers to"
" an array rather than a structure.  The elements of this array are "
"I<timeval> structures, which allow a precision of 1 microsecond for "
"specifying timestamps.  The I<timeval> structure is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:110
#, no-wrap
msgid ""
"struct timeval {\n"
"    long tv_sec;        /* seconds */\n"
"    long tv_usec;       /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:123
msgid ""
"I<times>[0] specifies the new access time, and I<times>[1] specifies the new"
" modification time.  If I<times> is NULL, then analogously to B<utime>(), "
"the access and modification times of the file are set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:128
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/utime.2:129 man-pages/man2/utime.2:136
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:136
msgid ""
"Search permission is denied for one of the directories in the path prefix of"
" I<path> (see also B<path_resolution>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:148
msgid ""
"I<times> is NULL, the caller's effective user ID does not match the owner of"
" the file, the caller does not have write access to the file, and the caller"
" is not privileged (Linux: does not have either the B<CAP_DAC_OVERRIDE> or "
"the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:152
msgid "I<filename> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:161
msgid ""
"I<times> is not NULL, the caller's effective UID does not match the owner of"
" the file, and the caller is not privileged (Linux: does not have the "
"B<CAP_FOWNER> capability)."
msgstr ""

#. type: TP
#: man-pages/man2/utime.2:161
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:165
msgid "I<path> resides on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:171
msgid ""
"B<utime>(): SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<utime>()  as obsolete."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:174
msgid "B<utimes>(): 4.3BSD, POSIX.1-2001."
msgstr ""

#.  In libc4 and libc5,
#.  .BR utimes ()
#.  is just a wrapper for
#.  .BR utime ()
#.  and hence does not allow a subsecond resolution.
#. type: Plain text
#: man-pages/man2/utime.2:184
msgid ""
"Linux does not allow changing the timestamps on an immutable file, or "
"setting the timestamps to something other than the current time on an "
"append-only file."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:192
msgid ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<stat>(2), B<utimensat>(2), "
"B<futimens>(3), B<futimes>(3), B<inode>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/utimensat.2:26
#, no-wrap
msgid "UTIMENSAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:29
msgid "utimensat, futimens - change file timestamps with nanosecond precision"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt> /* Definition of AT_* constants */>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:36
#, no-wrap
msgid ""
"B<int utimensat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timespec >I<times>B<[2], int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:38
#, no-wrap
msgid "B<int futimens(int >I<fd>B<, const struct timespec >I<times>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:43
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:48
msgid "B<utimensat>():"
msgstr ""

#. type: TP
#: man-pages/man2/utimensat.2:49 man-pages/man2/utimensat.2:59
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:52 man-pages/man2/utimensat.2:62
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: man-pages/man2/utimensat.2:52 man-pages/man2/utimensat.2:62
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:55
msgid "_ATFILE_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:58
msgid "B<futimens>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:65
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:79
msgid ""
"B<utimensat>()  and B<futimens>()  update the timestamps of a file with "
"nanosecond precision.  This contrasts with the historical B<utime>(2)  and "
"B<utimes>(2), which permit only second and microsecond precision, "
"respectively, when setting file timestamps."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:89
msgid ""
"With B<utimensat>()  the file is specified via the pathname given in "
"I<pathname>.  With B<futimens>()  the file whose timestamps are to be "
"updated is specified via an open file descriptor, I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:101
msgid ""
"For both calls, the new file timestamps are specified in the array I<times>:"
" I<times>[0] specifies the new \"last access time\" (I<atime>); I<times>[1] "
"specifies the new \"last modification time\" (I<mtime>).  Each of the "
"elements of I<times> specifies a time as the number of seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This "
"information is conveyed in a structure of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:108
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:113
msgid ""
"Updated file timestamps are set to the greatest value supported by the "
"filesystem that is not greater than the specified time."
msgstr ""

#.  2.6.22 was broken: it is not ignored
#. type: Plain text
#: man-pages/man2/utimensat.2:132
msgid ""
"If the I<tv_nsec> field of one of the I<timespec> structures has the special"
" value B<UTIME_NOW>, then the corresponding file timestamp is set to the "
"current time.  If the I<tv_nsec> field of one of the I<timespec> structures "
"has the special value B<UTIME_OMIT>, then the corresponding file timestamp "
"is left unchanged.  In both of these cases, the value of the corresponding "
"I<tv_sec> field is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:137
msgid "If I<times> is NULL, then both timestamps are set to the current time."
msgstr ""

#. type: SS
#: man-pages/man2/utimensat.2:137
#, no-wrap
msgid "Permissions requirements"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:145
msgid ""
"To set both file timestamps to the current time (i.e., I<times> is NULL, or "
"both I<tv_nsec> fields specify B<UTIME_NOW>), either:"
msgstr ""

#.  2.6.22 was broken here -- for futimens() the check is
#.  based on whether or not the file descriptor is writable,
#.  not on whether the caller's effective UID has write
#.  permission for the file referred to by the descriptor.
#. type: Plain text
#: man-pages/man2/utimensat.2:151
msgid "the caller must have write access to the file;"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:153
msgid "the caller's effective user ID must match the owner of the file; or"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:155
msgid "the caller must have appropriate privileges."
msgstr ""

#.  2.6.22 was broken here:
#.  both must be something other than *either* UTIME_OMIT *or* UTIME_NOW.
#. type: Plain text
#: man-pages/man2/utimensat.2:170
msgid ""
"To make any change other than setting both timestamps to the current time "
"(i.e., I<times> is not NULL, and neither I<tv_nsec> field is B<UTIME_NOW> "
"and neither I<tv_nsec> field is B<UTIME_OMIT>), either condition 2 or 3 "
"above must apply."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:180
msgid ""
"If both I<tv_nsec> fields are specified as B<UTIME_OMIT>, then no file "
"ownership or permission checks are performed, and the file timestamps are "
"not modified, but other error conditions may still be detected."
msgstr ""

#. type: SS
#: man-pages/man2/utimensat.2:180
#, no-wrap
msgid "utimensat() specifics"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:193
msgid ""
"If I<pathname> is relative, then by default it is interpreted relative to "
"the directory referred to by the open file descriptor, I<dirfd> (rather than"
" relative to the current working directory of the calling process, as is "
"done by B<utimes>(2)  for a relative pathname).  See B<openat>(2)  for an "
"explanation of why this can be useful."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:205
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<utimes>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:211
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:217
msgid ""
"The I<flags> field is a bit mask that may be 0, or include the following "
"constant, defined in I<E<lt>fcntl.hE<gt>>:"
msgstr ""

#. type: TP
#: man-pages/man2/utimensat.2:217
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:223
msgid ""
"If I<pathname> specifies a symbolic link, then update the timestamps of the "
"link, rather than the file to which it refers."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:232
msgid ""
"On success, B<utimensat>()  and B<futimens>()  return 0.  On error, -1 is "
"returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:242
msgid ""
"I<times> is NULL, or both I<tv_nsec> values are B<UTIME_NOW>, and either:"
msgstr ""

#.  But Linux 2.6.22 was broken here.
#.  Traditionally, utime()/utimes() gives the error EACCES for the case
#.  where the timestamp pointer argument is NULL (i.e., set both timestamps
#.  to the current time), and the file is owned by a user other than the
#.  effective UID of the caller, and the file is not writable by the
#.  effective UID of the program.  utimensat() also gives this error in the
#.  same case.  However, in the same circumstances, when utimensat() is
#.  given a 'times' array in which both tv_nsec fields are UTIME_NOW, which
#.  provides equivalent functionality to specifying 'times' as NULL, the
#.  call succeeds.  It should fail with the error EACCES in this case.
#.  POSIX.1-2008 has the following:
#.  .TP
#.  .B EACCES
#.  .RB ( utimensat ())
#.  .I fd
#.  was not opened with
#.  .B O_SEARCH
#.  and the permissions of the directory to which
#.  .I fd
#.  refers do not allow searches.
#. type: Plain text
#: man-pages/man2/utimensat.2:274
msgid ""
"the effective user ID of the caller does not match the owner of the file, "
"the caller does not have write access to the file, and the caller is not "
"privileged (Linux: does not have either the B<CAP_FOWNER> or the "
"B<CAP_DAC_OVERRIDE> capability); or,"
msgstr ""

#.  EXT2_IMMUTABLE_FL and similar flags for other filesystems.
#. type: Plain text
#: man-pages/man2/utimensat.2:278
msgid "the file is marked immutable (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:284
msgid "(B<futimens>())  I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:293
msgid ""
"(B<utimensat>())  I<pathname> is a relative pathname, but I<dirfd> is "
"neither B<AT_FDCWD> nor a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:303
msgid ""
"I<times> pointed to an invalid address; or, I<dirfd> was B<AT_FDCWD>, and "
"I<pathname> is NULL or an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:307
msgid "Invalid value in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:318
msgid ""
"Invalid value in one of the I<tv_nsec> fields (value outside range 0 to "
"999,999,999, and not B<UTIME_NOW> or B<UTIME_OMIT>); or an invalid value in "
"one of the I<tv_sec> fields."
msgstr ""

#.  SUSv4 does not specify this error.
#. type: Plain text
#: man-pages/man2/utimensat.2:330
msgid ""
"I<pathname> is NULL, I<dirfd> is not B<AT_FDCWD>, and I<flags> contains "
"B<AT_SYMLINK_NOFOLLOW>."
msgstr ""

#. type: TP
#: man-pages/man2/utimensat.2:330
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:335
msgid ""
"(B<utimensat>())  Too many symbolic links were encountered in resolving "
"I<pathname>."
msgstr ""

#. type: TP
#: man-pages/man2/utimensat.2:335
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:340
msgid "(B<utimensat>())  I<pathname> is too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:349
msgid ""
"(B<utimensat>())  A component of I<pathname> does not refer to an existing "
"directory or file, or I<pathname> is an empty string."
msgstr ""

#. type: TP
#: man-pages/man2/utimensat.2:349
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:361
msgid ""
"(B<utimensat>())  I<pathname> is a relative pathname, but I<dirfd> is "
"neither B<AT_FDCWD> nor a file descriptor referring to a directory; or, one "
"of the prefix components of I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:378
msgid ""
"The caller attempted to change one or both timestamps to a value other than "
"the current time, or to change one of the timestamps to the current time "
"while leaving the other timestamp unchanged, (i.e., I<times> is not NULL, "
"neither I<tv_nsec> field is B<UTIME_NOW>, and neither I<tv_nsec> field is "
"B<UTIME_OMIT>)  and either:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:385
msgid ""
"the caller's effective user ID does not match the owner of file, and the "
"caller is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or,"
msgstr ""

#.  Linux 2.6.22 was broken here:
#.  it was not consistent with the old utimes() implementation,
#.  since the case when both tv_nsec fields are UTIME_NOW, was not
#.  treated like the (times == NULL) case.
#.  EXT2_IMMUTABLE_FL EXT_APPPEND_FL and similar flags for
#.  other filesystems.
#.  Why the inconsistency (which is described under NOTES) between
#.  EACCES and EPERM, where only EPERM tests for append-only.
#.  (This was also so for the older utimes() implementation.)
#. type: Plain text
#: man-pages/man2/utimensat.2:398
msgid "the file is marked append-only or immutable (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:402
msgid "The file is on a read-only filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/utimensat.2:402
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:407
msgid ""
"(B<utimensat>())  Search permission is denied for one of the prefix "
"components of I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:411
msgid ""
"B<utimensat>()  was added to Linux in kernel 2.6.22; glibc support was added"
" with version 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:415
msgid "Support for B<futimens>()  first appeared in glibc 2.6."
msgstr ""

#. type: SH
#: man-pages/man2/utimensat.2:415
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:418
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man2/utimensat.2:422
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man2/utimensat.2:422
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man2/utimensat.2:426
#, no-wrap
msgid ""
"B<utimensat>(),\n"
"B<futimens>()"
msgstr ""

#. type: tbl table
#: man-pages/man2/utimensat.2:426
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man2/utimensat.2:426
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:434
msgid "B<futimens>()  and B<utimensat>()  are specified in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:438
msgid "B<utimensat>()  obsoletes B<futimesat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:447
msgid ""
"On Linux, timestamps cannot be changed for a file marked immutable, and the "
"only change permitted for files marked append-only is to set the timestamps "
"to the current time.  (This is consistent with the historical behavior of "
"B<utime>(2)  and B<utimes>(2)  on Linux.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:459
msgid ""
"If both I<tv_nsec> fields are specified as B<UTIME_OMIT>, then the Linux "
"implementation of B<utimensat>()  succeeds even if the file referred to by "
"I<dirfd> and I<pathname> does not exist."
msgstr ""

#. type: SS
#: man-pages/man2/utimensat.2:459
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:476
msgid ""
"On Linux, B<futimens>()  is a library function implemented on top of the "
"B<utimensat>()  system call.  To support this, the Linux B<utimensat>()  "
"system call implements a nonstandard feature: if I<pathname> is NULL, then "
"the call modifies the timestamps of the file referred to by the file "
"descriptor I<dirfd> (which may refer to any type of file).  Using this "
"feature, the call I<futimens(fd,\\ times)> is implemented as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:480
#, no-wrap
msgid "utimensat(fd, NULL, times, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:490
msgid ""
"Note, however, that the glibc wrapper for B<utimensat>()  disallows passing "
"NULL as the value for I<pathname>: the wrapper function returns the error "
"I<EINVAL> in this case."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:498
msgid ""
"Several bugs afflict B<utimensat>()  and B<futimens>()  on kernels before "
"2.6.26.  These bugs are either nonconformances with the POSIX.1 draft "
"specification or inconsistencies with historical Linux behavior."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:513
msgid ""
"POSIX.1 specifies that if one of the I<tv_nsec> fields has the value "
"B<UTIME_NOW> or B<UTIME_OMIT>, then the value of the corresponding I<tv_sec>"
" field should be ignored.  Instead, the value of the I<tv_sec> field is "
"required to be 0 (or the error B<EINVAL> results)."
msgstr ""

#.  Below, the long description of the errors from the previous bullet
#.  point (abridged because it's too much detail for a man page).
#.  .IP *
#.  If one of the
#.  .I tv_nsec
#.  fields is
#.  .BR UTIME_OMIT
#.  and the other is
#.  .BR UTIME_NOW ,
#.  then the error
#.  .B EPERM
#.  should occur if the process's effective user ID does not match
#.  the file owner and the process is not privileged.
#.  Instead, the call successfully changes one of the timestamps.
#.  .IP *
#.  If file is not writable by the effective user ID of the process and
#.  the process's effective user ID does not match the file owner and
#.  the process is not privileged,
#.  and
#.  .I times
#.  is NULL, then the error
#.  .B EACCES
#.  results.
#.  This error should also occur if
#.  .I times
#.  points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead the call succeeds.
#.  .IP *
#.  If a file is marked as append-only (see
#.  .BR chattr (1)),
#.  then Linux traditionally
#.  (i.e.,
#.  .BR utime (2),
#.  .BR utimes (2)),
#.  permits a NULL
#.  .I times
#.  argument to be used in order to update both timestamps to the current
#. time.
#.  For consistency,
#.  .BR utimensat ()
#.  and
#.  .BR futimens ()
#.  should also produce the same result when given a
#.  .I times
#.  argument that points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead, the call fails with the error
#.  .BR EPERM .
#.  .IP *
#.  If a file is marked as immutable (see
#.  .BR chattr (1)),
#.  then Linux traditionally
#.  (i.e.,
#.  .BR utime (2),
#.  .BR utimes (2)),
#.  gives an
#.  .B EACCES
#.  error if
#.  .I times
#.  is NULL.
#.  For consistency,
#.  .BR utimensat ()
#.  and
#.  .BR futimens ()
#.  should also produce the same result when given a
#.  .I times
#.  that points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead, the call fails with the error
#.  .BR EPERM .
#. type: Plain text
#: man-pages/man2/utimensat.2:615
msgid ""
"Various bugs mean that for the purposes of permission checking, the case "
"where both I<tv_nsec> fields are set to B<UTIME_NOW> isn't always treated "
"the same as specifying I<times> as NULL, and the case where one I<tv_nsec> "
"value is B<UTIME_NOW> and the other is B<UTIME_OMIT> isn't treated the same "
"as specifying I<times> as a pointer to an array of structures containing "
"arbitrary time values.  As a result, in some cases: a) file timestamps can "
"be updated by a process that shouldn't have permission to perform updates; "
"b) file timestamps can't be updated by a process that should have permission"
" to perform updates; and c) the wrong I<errno> value is returned in case of "
"an error."
msgstr ""

#.  This means that a process with a file descriptor that allows
#.  writing could change the timestamps of a file for which it
#.  does not have write permission;
#.  conversely, a process with a read-only file descriptor won't
#.  be able to update the timestamps of a file,
#.  even if it has write permission on the file.
#. type: Plain text
#: man-pages/man2/utimensat.2:636
msgid ""
"POSIX.1 says that a process that has I<write access to the file> can make a "
"call with I<times> as NULL, or with I<times> pointing to an array of "
"structures in which both I<tv_nsec> fields are B<UTIME_NOW>, in order to "
"update both timestamps to the current time.  However, B<futimens>()  instead"
" checks whether the I<access mode of the file descriptor allows writing>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:646
msgid ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<openat>(2), B<stat>(2), "
"B<utimes>(2), B<futimes>(3), B<inode>(7), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/unimplemented.2:26
#, no-wrap
msgid "UNIMPLEMENTED"
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:31
msgid ""
"afs_syscall, break, fattach, fdetach, ftime, getmsg, getpmsg, gtty, "
"isastream, lock, madvise1, mpx, prof, profil, putmsg, putpmsg, security, "
"stty, tuxcall, ulimit, vserver - unimplemented system calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:33
msgid "Unimplemented system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:35
msgid "These system calls are not implemented in the Linux kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:40
msgid "These system calls always return -1 and set I<errno> to B<ENOSYS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:47
msgid ""
"Note that B<ftime>(3), B<profil>(3), and B<ulimit>(3)  are implemented as "
"library functions."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:56
msgid ""
"Some system calls, like B<alloc_hugepages>(2), B<free_hugepages>(2), "
"B<ioperm>(2), B<iopl>(2), and B<vm86>(2)  exist only on certain "
"architectures."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:64
msgid ""
"Some system calls, like B<ipc>(2), B<create_module>(2), B<init_module>(2), "
"and B<delete_module>(2)  exist only when the Linux kernel was built with "
"support for them."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:65
msgid "B<syscalls>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/uname.2:27
#, no-wrap
msgid "UNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:30
msgid "uname - get name and information about current kernel"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:32
msgid "B<#include E<lt>sys/utsname.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:34
msgid "B<int uname(struct utsname *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:42
msgid ""
"B<uname>()  returns system information in the structure pointed to by "
"I<buf>.  The I<utsname> struct is defined in I<E<lt>sys/utsname.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:56
#, no-wrap
msgid ""
"struct utsname {\n"
"    char sysname[];    /* Operating system name (e.g., \"Linux\") */\n"
"    char nodename[];   /* Name within \"some implementation-defined\n"
"                          network\" */\n"
"    char release[];    /* Operating system release (e.g., \"2.6.28\") */\n"
"    char version[];    /* Operating system version */\n"
"    char machine[];    /* Hardware identifier */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* NIS or YP domain name */\n"
"#endif\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:63
msgid ""
"The length of the arrays in a I<struct utsname> is unspecified (see NOTES); "
"the fields are terminated by a null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:73
msgid "I<buf> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:78
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  There is no B<uname>()  call in 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:82
msgid ""
"The I<domainname> member (the NIS or YP domain name) is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:98
msgid ""
"This is a system call, and the operating system presumably knows its name, "
"release and version.  It also knows what hardware it runs on.  So, four of "
"the fields of the struct are meaningful.  On the other hand, the field "
"I<nodename> is meaningless: it gives the name of the present machine in some"
" undefined network, but typically machines are in more than one network and "
"have several names.  Moreover, the kernel has no way of knowing about such "
"things, so it has to be told what to answer here.  The same holds for the "
"additional I<domainname> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:116
msgid ""
"To this end, Linux uses the system calls B<sethostname>(2)  and "
"B<setdomainname>(2).  Note that there is no standard that says that the "
"hostname set by B<sethostname>(2)  is the same string as the I<nodename> "
"field of the struct returned by B<uname>()  (indeed, some systems allow a "
"256-byte hostname and an 8-byte nodename), but this is true on Linux.  The "
"same holds for B<setdomainname>(2)  and the I<domainname> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:131
msgid ""
"The length of the fields in the struct varies.  Some operating systems or "
"libraries use a hardcoded 9 or 33 or 65 or 257.  Other systems use "
"B<SYS_NMLN> or B<_SYS_NMLN> or B<UTSLEN> or B<_UTSNAME_LENGTH>.  Clearly, it"
" is a bad idea to use any of these constants; just use sizeof(...).  Often "
"257 is chosen in order to have room for an internet hostname."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:138
msgid ""
"Part of the utsname information is also accessible via "
"I</proc/sys/kernel/>{I<ostype>, I<hostname>, I<osrelease>, I<version>, "
"I<domainname>}."
msgstr ""

#. type: SS
#: man-pages/man2/uname.2:138
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#.  That was back before Linux 1.0
#.  That was also back before Linux 1.0
#. type: Plain text
#: man-pages/man2/uname.2:167
msgid ""
"Over time, increases in the size of the I<utsname> structure have led to "
"three successive versions of B<uname>(): I<sys_olduname>()  (slot "
"I<__NR_oldolduname>), I<sys_uname>()  (slot I<__NR_olduname>), and "
"I<sys_newuname>()  (slot I<__NR_uname)>.  The first one used length 9 for "
"all fields; the second used 65; the third also uses 65 but adds the "
"I<domainname> field.  The glibc B<uname>()  wrapper function hides these "
"details from applications, invoking the most recent version of the system "
"call provided by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:171
msgid ""
"B<uname>(1), B<getdomainname>(2), B<gethostname>(2), B<uts_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/uselib.2:31
#, no-wrap
msgid "USELIB"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:34
msgid "uselib - load shared library"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:36
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:38
msgid "B<int uselib(const char *>I<library>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:41
msgid ""
"I<Note>: No declaration of this system call is provided in glibc headers; "
"see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:51
msgid ""
"The system call B<uselib>()  serves to load a shared library to be used by "
"the calling process.  It is given a pathname.  The address where to load is "
"found in the library itself.  The library can have any recognized binary "
"format."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:62
msgid ""
"In addition to all of the error codes returned by B<open>(2)  and "
"B<mmap>(2), the following may also be returned:"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:70
msgid ""
"The library specified by I<library> does not have read or execute "
"permission, or the caller does not have search permission for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/uselib.2:70
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:73
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: man-pages/man2/uselib.2:73
#, no-wrap
msgid "B<ENOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:79
msgid ""
"The file specified by I<library> is not an executable of a known type; for "
"example, it does not have the correct magic numbers."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:83
msgid ""
"B<uselib>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:91
msgid ""
"This obsolete system call is not supported by glibc.  No declaration is "
"provided in glibc headers, but, through a quirk of history, glibc versions "
"before 2.23 did export an ABI for this system call.  Therefore, in order to "
"employ this system call, it was sufficient to manually declare the interface"
" in your code; alternatively, you could invoke the system call using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:97
msgid ""
"In ancient libc versions, B<uselib>()  was used to load the shared libraries"
" with names found in an array of names in the binary."
msgstr ""

#.  libc 4.3.1f - changelog 1993-03-02
#.  libc 4.3.4 - changelog 1993-04-21
#. type: Plain text
#: man-pages/man2/uselib.2:107
msgid ""
"Since libc 4.3.2, startup code tries to prefix these names with "
"\"/usr/lib\", \"/lib\" and \"\" before giving up.  In libc 4.3.4 and later "
"these names are looked for in the directories found in B<LD_LIBRARY_PATH>, "
"and if not found there, prefixes \"/usr/lib\", \"/lib\" and \"/\" are tried."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:112
msgid ""
"From libc 4.4.4 on only the library \"/lib/ld.so\" is loaded, so that this "
"dynamic library can load the remaining libraries needed (again using this "
"call).  This is also the state of affairs in libc5."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:114
msgid "glibc2 does not use this call."
msgstr ""

#.  commit 69369a7003735d0d8ef22097e27a55a8bad9557a
#. type: Plain text
#: man-pages/man2/uselib.2:120
msgid ""
"Since Linux 3.15, this system call is available only when the kernel is "
"configured with the B<CONFIG_USELIB> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:129
msgid ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), "
"B<dlopen>(3), B<capabilities>(7), B<ld.so>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/userfaultfd.2:27
#, no-wrap
msgid "USERFAULTFD"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:30
msgid ""
"userfaultfd - create a file descriptor for handling page faults in user "
"space"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>linux/userfaultfd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:36
#, no-wrap
msgid "B<int userfaultfd(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:47
msgid ""
"B<userfaultfd>()  creates a new userfaultfd object that can be used for "
"delegation of page-fault handling to a user-space application, and returns a"
" file descriptor that refers to the new object.  The new userfaultfd object "
"is configured using B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:56
msgid ""
"Once the userfaultfd object is configured, the application can use "
"B<read>(2)  to receive userfaultfd notifications.  The reads from "
"userfaultfd may be blocking or non-blocking, depending on the value of "
"I<flags> used for the creation of the userfaultfd or subsequent calls to "
"B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:61
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<userfaultfd>():"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:61
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:68
msgid ""
"Enable the close-on-exec flag for the new userfaultfd file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:68
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:75
msgid ""
"Enables non-blocking operation for the userfaultfd object.  See the "
"description of the B<O_NONBLOCK> flag in B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:80
msgid ""
"When the last file descriptor referring to a userfaultfd object is closed, "
"all memory ranges that were registered with the object are unregistered and "
"unread events are flushed."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:92
msgid ""
"The userfaultfd mechanism is designed to allow a thread in a multithreaded "
"program to perform user-space paging for the other threads in the process.  "
"When a page fault occurs for one of the regions registered to the "
"userfaultfd object, the faulting thread is put to sleep and an event is "
"generated that can be read via the userfaultfd file descriptor.  The fault-"
"handling thread reads events from this file descriptor and services them "
"using the operations described in B<ioctl_userfaultfd>(2).  When servicing "
"the page fault events, the fault-handling thread can trigger a wake-up for "
"the sleeping thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:102
msgid ""
"It is possible for the faulting threads and the fault-handling threads to "
"run in the context of different processes.  In this case, these threads may "
"belong to different programs, and the program that executes the faulting "
"threads will not necessarily cooperate with the program that handles the "
"page faults.  In such non-cooperative mode, the process that monitors "
"userfaultfd and handles page faults needs to be aware of the changes in the "
"virtual memory layout of the faulting process to avoid memory corruption."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:126
msgid ""
"Starting from Linux 4.11, userfaultfd can also notify the fault-handling "
"threads about changes in the virtual memory layout of the faulting process."
"  In addition, if the faulting process invokes B<fork>(2), the userfaultfd "
"objects associated with the parent may be duplicated into the child process "
"and the userfaultfd monitor will be notified (via the B<UFFD_EVENT_FORK> "
"described below)  about the file descriptor associated with the userfault "
"objects created for the child process, which allows the userfaultfd monitor "
"to perform user-space paging for the child process.  Unlike page faults "
"which have to be synchronous and require an explicit or implicit wakeup, all"
" other events are delivered asynchronously and the non-cooperative process "
"resumes execution as soon as the userfaultfd manager executes B<read>(2).  "
"The userfaultfd manager should carefully synchronize calls to B<UFFDIO_COPY>"
" with the processing of events."
msgstr ""

#.  Regarding the preceding sentence, Mike Rapoport says:
#.      The major point here is that current events delivery model could be
#.      problematic for multi-threaded monitor. I even suspect that it would
#. be
#.      impossible to ensure synchronization between page faults and non-page
#.      fault events in multi-threaded monitor.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:134
msgid ""
"The current asynchronous model of the event delivery is optimal for single "
"threaded non-cooperative userfaultfd manager implementations."
msgstr ""

#.  FIXME elaborate about non-cooperating mode, describe its limitations
#.  for kernels before 4.11, features added in 4.11
#.  and limitations remaining in 4.11
#.  Maybe it's worth adding a dedicated sub-section...
#. type: SS
#: man-pages/man2/userfaultfd.2:140
#, no-wrap
msgid "Userfaultfd operation"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:154
msgid ""
"After the userfaultfd object is created with B<userfaultfd>(), the "
"application must enable it using the B<UFFDIO_API> B<ioctl>(2)  operation.  "
"This operation allows a handshake between the kernel and user space to "
"determine the API version and supported features.  This operation must be "
"performed before any of the other B<ioctl>(2)  operations described below "
"(or those operations fail with the B<EINVAL> error)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:174
msgid ""
"After a successful B<UFFDIO_API> operation, the application then registers "
"memory address ranges using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation.  "
"After successful completion of a B<UFFDIO_REGISTER> operation, a page fault "
"occurring in the requested memory range, and satisfying the mode defined at "
"the registration time, will be forwarded by the kernel to the user-space "
"application.  The application can then use the B<UFFDIO_COPY> or "
"B<UFFDIO_ZEROPAGE> B<ioctl>(2)  operations to resolve the page fault."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:193
msgid ""
"Starting from Linux 4.14, if the application sets the B<UFFD_FEATURE_SIGBUS>"
" feature bit using the B<UFFDIO_API> B<ioctl>(2), no page-fault notification"
" will be forwarded to user space.  Instead a B<SIGBUS> signal is delivered "
"to the faulting process.  With this feature, userfaultfd can be used for "
"robustness purposes to simply catch any access to areas within the "
"registered address range that do not have pages allocated, without having to"
" listen to userfaultfd events.  No userfaultfd monitor will be required for "
"dealing with such memory accesses.  For example, this feature can be useful "
"for applications that want to prevent the kernel from automatically "
"allocating pages and filling holes in sparse files when the hole is accessed"
" through a memory mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:200
msgid ""
"The B<UFFD_FEATURE_SIGBUS> feature is implicitly inherited through "
"B<fork>(2)  if used in combination with B<UFFD_FEATURE_FORK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:205
msgid ""
"Details of the various B<ioctl>(2)  operations can be found in "
"B<ioctl_userfaultfd>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:209
msgid ""
"Since Linux 4.11, events other than page-fault may enabled during "
"B<UFFDIO_API> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:214
msgid ""
"Up to Linux 4.11, userfaultfd can be used only with anonymous private memory"
" mappings.  Since Linux 4.11, userfaultfd can be also used with hugetlbfs "
"and shared memory mappings."
msgstr ""

#. type: SS
#: man-pages/man2/userfaultfd.2:216
#, no-wrap
msgid "Reading from the userfaultfd structure"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:223
msgid ""
"Each B<read>(2)  from the userfaultfd file descriptor returns one or more "
"I<uffd_msg> structures, each of which describes a page-fault event or an "
"event required for the non-cooperative userfaultfd usage:"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:234
#, no-wrap
msgid ""
"struct uffd_msg {\n"
"    __u8  event;            /* Type of event */\n"
"    ...\n"
"    union {\n"
"        struct {\n"
"            __u64 flags;    /* Flags describing fault */\n"
"            __u64 address;  /* Faulting address */\n"
"        } pagefault;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:239
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u32 ufd;      /* Userfault file descriptor\n"
"                               of the child process */\n"
"        } fork;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:245
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 from;     /* Old address of remapped area */\n"
"            __u64 to;       /* New address of remapped area */\n"
"            __u64 len;      /* Original mapping length */\n"
"        } remap;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:252
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 start;    /* Start address of removed area */\n"
"            __u64 end;      /* End address of removed area */\n"
"        } remove;\n"
"        ...\n"
"    } arg;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:255
#, no-wrap
msgid ""
"    /* Padding fields omitted */\n"
"} __packed;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:269
msgid ""
"If multiple events are available and the supplied buffer is large enough, "
"B<read>(2)  returns as many events as will fit in the supplied buffer.  If "
"the buffer supplied to B<read>(2)  is smaller than the size of the "
"I<uffd_msg> structure, the B<read>(2)  fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:273
msgid "The fields set in the I<uffd_msg> structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:273
#, no-wrap
msgid "I<event>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:284
msgid ""
"The type of event.  Depending of the event type, different fields of the "
"I<arg> union represent details required for the event processing.  The non-"
"page-fault events are generated only when appropriate feature is enabled "
"during API handshake with B<UFFDIO_API> B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:288
msgid "The following values can appear in the I<event> field:"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:289
#, no-wrap
msgid "B<UFFD_EVENT_PAGEFAULT> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:295
msgid ""
"A page-fault event.  The page-fault details are available in the "
"I<pagefault> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:295
#, no-wrap
msgid "B<UFFD_EVENT_FORK> (since Linux 4.11)"
msgstr ""

#.  FIXME describe duplication of userfault file descriptor during fork
#. type: Plain text
#: man-pages/man2/userfaultfd.2:308
msgid ""
"Generated when the faulting process invokes B<fork>(2)  (or B<clone>(2)  "
"without the B<CLONE_VM> flag).  The event details are available in the "
"I<fork> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:308
#, no-wrap
msgid "B<UFFD_EVENT_REMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:315
msgid ""
"Generated when the faulting process invokes B<mremap>(2).  The event details"
" are available in the I<remap> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:315
#, no-wrap
msgid "B<UFFD_EVENT_REMOVE> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:327
msgid ""
"Generated when the faulting process invokes B<madvise>(2)  with "
"B<MADV_DONTNEED> or B<MADV_REMOVE> advice.  The event details are available "
"in the I<remove> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:327
#, no-wrap
msgid "B<UFFD_EVENT_UNMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:339
msgid ""
"Generated when the faulting process unmaps a memory range, either explicitly"
" using B<munmap>(2)  or implicitly during B<mmap>(2)  or B<mremap>(2).  The "
"event details are available in the I<remove> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:340
#, no-wrap
msgid "I<pagefault.address>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:343
msgid "The address that triggered the page fault."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:343
#, no-wrap
msgid "I<pagefault.flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:349
msgid ""
"A bit mask of flags that describe the event.  For B<UFFD_EVENT_PAGEFAULT>, "
"the following flag may appear:"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:350
#, no-wrap
msgid "B<UFFD_PAGEFAULT_FLAG_WRITE>"
msgstr ""

#.  UFFD_PAGEFAULT_FLAG_WP is not yet supported.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:360
msgid ""
"If the address is in a range that was registered with the "
"B<UFFDIO_REGISTER_MODE_MISSING> flag (see B<ioctl_userfaultfd>(2))  and this"
" flag is set, this a write fault; otherwise it is a read fault."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:361
#, no-wrap
msgid "I<fork.ufd>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:366
msgid ""
"The file descriptor associated with the userfault object created for the "
"child created by B<fork>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:366
#, no-wrap
msgid "I<remap.from>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:370
msgid ""
"The original address of the memory range that was remapped using "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:370
#, no-wrap
msgid "I<remap.to>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:374
msgid ""
"The new address of the memory range that was remapped using B<mremap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:374
#, no-wrap
msgid "I<remap.len>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:378
msgid ""
"The original length of the memory range that was remapped using "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:378
#, no-wrap
msgid "I<remove.start>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:383
msgid ""
"The start address of the memory range that was freed using B<madvise>(2)  or"
" unmapped"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:383
#, no-wrap
msgid "I<remove.end>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:388
msgid ""
"The end address of the memory range that was freed using B<madvise>(2)  or "
"unmapped"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:392
msgid ""
"A B<read>(2)  on a userfaultfd file descriptor can fail with the following "
"errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:398
msgid ""
"The userfaultfd object has not yet been enabled using the B<UFFDIO_API> "
"B<ioctl>(2)  operation"
msgstr ""

#.  FIXME What is the reason for this seemingly odd behavior with respect
#.  to the O_NONBLOCK flag? (see userfaultfd_poll() in fs/userfaultfd.c).
#.  Something needs to be said about this.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:420
msgid ""
"If the B<O_NONBLOCK> flag is enabled in the associated open file "
"description, the userfaultfd file descriptor can be monitored with "
"B<poll>(2), B<select>(2), and B<epoll>(7).  When events are available, the "
"file descriptor indicates as readable.  If the B<O_NONBLOCK> flag is not "
"enabled, then B<poll>(2)  (always) indicates the file as having a B<POLLERR>"
" condition, and B<select>(2)  indicates the file descriptor as both readable"
" and writable."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:427
msgid ""
"On success, B<userfaultfd>()  returns a new file descriptor that refers to "
"the userfaultfd object.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:432
msgid "An unsupported value was specified in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:432
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:436
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:443
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:447
msgid "The B<userfaultfd>()  system call first appeared in Linux 4.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:450
msgid ""
"The support for hugetlbfs and shared memory areas and non-page-fault events "
"was added in Linux 4.11"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:454
msgid ""
"B<userfaultfd>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:457
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:468
msgid ""
"The userfaultfd mechanism can be used as an alternative to traditional user-"
"space paging techniques based on the use of the B<SIGSEGV> signal and "
"B<mmap>(2).  It can also be used to implement lazy restore for "
"checkpoint/restore mechanisms, as well as post-copy migration to allow "
"(nearly) uninterrupted execution when transferring virtual machines and "
"Linux containers from one host to another."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:478
msgid ""
"If the B<UFFD_FEATURE_EVENT_FORK> is enabled and a system call from the "
"B<fork>(2)  family is interrupted by a signal or failed, a stale userfaultfd"
" descriptor might be created.  In this case, a spurious B<UFFD_EVENT_FORK> "
"will be delivered to the userfaultfd monitor."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:484
msgid ""
"The program below demonstrates the use of the userfaultfd mechanism.  The "
"program creates two threads, one of which acts as the page-fault handler for"
" the process, for the pages in a demand-page zero region created using "
"B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:496
msgid ""
"The program takes one command-line argument, which is the number of pages "
"that will be created in a mapping whose page faults will be handled via "
"userfaultfd.  After creating a userfaultfd object, the program then creates "
"an anonymous private mapping of the specified size and registers the address"
" range of that mapping using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation."
"  The program then creates a second thread that will perform the task of "
"handling page faults."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:502
msgid ""
"The main thread then walks through the pages of the mapping fetching bytes "
"from successive pages.  Because the pages have not yet been accessed, the "
"first access of a byte in each page will trigger a page-fault event on the "
"userfaultfd file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:517
msgid ""
"Each of the page-fault events is handled by the second thread, which sits in"
" a loop processing input from the userfaultfd file descriptor.  In each loop"
" iteration, the second thread first calls B<poll>(2)  to check the state of "
"the file descriptor, and then reads an event from the file descriptor.  All "
"such events should be B<UFFD_EVENT_PAGEFAULT> events, which the thread "
"handles by copying a page of data into the faulting region using the "
"B<UFFDIO_COPY> B<ioctl>(2)  operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:519
msgid "The following is an example of what we see when running the program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:524
#, no-wrap
msgid ""
"$ B<./userfaultfd_demo 3>\n"
"Address returned by mmap() = 0x7fd30106c000\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:533
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106c00f in main(): A\n"
"Read address 0x7fd30106c40f in main(): A\n"
"Read address 0x7fd30106c80f in main(): A\n"
"Read address 0x7fd30106cc0f in main(): A\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:542
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106d00f in main(): B\n"
"Read address 0x7fd30106d40f in main(): B\n"
"Read address 0x7fd30106d80f in main(): B\n"
"Read address 0x7fd30106dc0f in main(): B\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:551
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106e00f in main(): C\n"
"Read address 0x7fd30106e40f in main(): C\n"
"Read address 0x7fd30106e80f in main(): C\n"
"Read address 0x7fd30106ec0f in main(): C\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:557
#, no-wrap
msgid "/* userfaultfd_demo.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:576
#, no-wrap
msgid ""
"   Licensed under the GNU General Public License version 2 or later.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>linux/userfaultfd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:581
#, no-wrap
msgid "static int page_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:591
#, no-wrap
msgid ""
"static void *\n"
"fault_handler_thread(void *arg)\n"
"{\n"
"    static struct uffd_msg msg;   /* Data read from userfaultfd */\n"
"    static int fault_cnt = 0;     /* Number of faults so far handled */\n"
"    long uffd;                    /* userfaultfd file descriptor */\n"
"    static char *page = NULL;\n"
"    struct uffdio_copy uffdio_copy;\n"
"    ssize_t nread;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:593
#, no-wrap
msgid "    uffd = (long) arg;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:595
#, no-wrap
msgid "    /* Create a page that will be copied into the faulting region */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:602
#, no-wrap
msgid ""
"    if (page == NULL) {\n"
"        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n"
"                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"        if (page == MAP_FAILED)\n"
"            errExit(\"mmap\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:605
#, no-wrap
msgid ""
"    /* Loop, handling incoming events on the userfaultfd\n"
"       file descriptor */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:609
#, no-wrap
msgid "        /* See what poll() tells us about the userfaultfd */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:617
#, no-wrap
msgid ""
"        struct pollfd pollfd;\n"
"        int nready;\n"
"        pollfd.fd = uffd;\n"
"        pollfd.events = POLLIN;\n"
"        nready = poll(&pollfd, 1, -1);\n"
"        if (nready == -1)\n"
"            errExit(\"poll\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:623
#, no-wrap
msgid ""
"        printf(\"\\enfault_handler_thread():\\en\");\n"
"        printf(\"    poll() returns: nready = %d; \"\n"
"                \"POLLIN = %d; POLLERR = %d\\en\", nready,\n"
"                (pollfd.revents & POLLIN) != 0,\n"
"                (pollfd.revents & POLLERR) != 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:625
#, no-wrap
msgid "        /* Read an event from the userfaultfd */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:631
#, no-wrap
msgid ""
"        nread = read(uffd, &msg, sizeof(msg));\n"
"        if (nread == 0) {\n"
"            printf(\"EOF on userfaultfd!\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:634
#, no-wrap
msgid ""
"        if (nread == -1)\n"
"            errExit(\"read\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:636
#, no-wrap
msgid "        /* We expect only one kind of event; verify that assumption */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:641
#, no-wrap
msgid ""
"        if (msg.event != UFFD_EVENT_PAGEFAULT) {\n"
"            fprintf(stderr, \"Unexpected event on userfaultfd\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:643
#, no-wrap
msgid "        /* Display info about the page-fault event */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:647
#, no-wrap
msgid ""
"        printf(\"    UFFD_EVENT_PAGEFAULT event: \");\n"
"        printf(\"flags = %llx; \", msg.arg.pagefault.flags);\n"
"        printf(\"address = %llx\\en\", msg.arg.pagefault.address);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:651
#, no-wrap
msgid ""
"        /* Copy the page pointed to by \\(aqpage\\(aq into the faulting\n"
"           region. Vary the contents that are copied in, so that it\n"
"           is more obvious that each fault is handled separately. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:654
#, no-wrap
msgid ""
"        memset(page, \\(aqA\\(aq + fault_cnt % 20, page_size);\n"
"        fault_cnt++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:656
#, no-wrap
msgid "        uffdio_copy.src = (unsigned long) page;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:659
#, no-wrap
msgid ""
"        /* We need to handle page faults in units of pages(!).\n"
"           So, round faulting address down to page boundary */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:667
#, no-wrap
msgid ""
"        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &\n"
"                                           ~(page_size - 1);\n"
"        uffdio_copy.len = page_size;\n"
"        uffdio_copy.mode = 0;\n"
"        uffdio_copy.copy = 0;\n"
"        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)\n"
"            errExit(\"ioctl-UFFDIO_COPY\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:672
#, no-wrap
msgid ""
"        printf(\"        (uffdio_copy.copy returned %lld)\\en\",\n"
"                uffdio_copy.copy);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:683
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    long uffd;          /* userfaultfd file descriptor */\n"
"    char *addr;         /* Start of region handled by userfaultfd */\n"
"    unsigned long len;  /* Length of region handled by userfaultfd */\n"
"    pthread_t thr;      /* ID of thread that handles page faults */\n"
"    struct uffdio_api uffdio_api;\n"
"    struct uffdio_register uffdio_register;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:688
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s num-pages\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:691
#, no-wrap
msgid ""
"    page_size = sysconf(_SC_PAGE_SIZE);\n"
"    len = strtoul(argv[1], NULL, 0) * page_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:693
#, no-wrap
msgid "    /* Create and enable userfaultfd object */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:697
#, no-wrap
msgid ""
"    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n"
"    if (uffd == -1)\n"
"        errExit(\"userfaultfd\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:702
#, no-wrap
msgid ""
"    uffdio_api.api = UFFD_API;\n"
"    uffdio_api.features = 0;\n"
"    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)\n"
"        errExit(\"ioctl-UFFDIO_API\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:707
#, no-wrap
msgid ""
"    /* Create a private anonymous mapping. The memory will be\n"
"       demand-zero paged--that is, not yet allocated. When we\n"
"       actually touch the memory, it will be allocated via\n"
"       the userfaultfd. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:712
#, no-wrap
msgid ""
"    addr = mmap(NULL, len, PROT_READ | PROT_WRITE,\n"
"                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"    if (addr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:714
#, no-wrap
msgid "    printf(\"Address returned by mmap() = %p\\en\", addr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:718
#, no-wrap
msgid ""
"    /* Register the memory range of the mapping we just created for\n"
"       handling by the userfaultfd object. In mode, we request to track\n"
"       missing pages (i.e., pages that have not yet been faulted in). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:724
#, no-wrap
msgid ""
"    uffdio_register.range.start = (unsigned long) addr;\n"
"    uffdio_register.range.len = len;\n"
"    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n"
"    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)\n"
"        errExit(\"ioctl-UFFDIO_REGISTER\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:726
#, no-wrap
msgid "    /* Create a thread that will process the userfaultfd events */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:732
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);\n"
"    if (s != 0) {\n"
"        errno = s;\n"
"        errExit(\"pthread_create\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:736
#, no-wrap
msgid ""
"    /* Main thread now touches memory in the mapping, touching\n"
"       locations 1024 bytes apart. This will trigger userfaultfd\n"
"       events for all pages in the region. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:748
#, no-wrap
msgid ""
"    int l;\n"
"    l = 0xf;    /* Ensure that faulting address is not on a page\n"
"                   boundary, in order to test that we correctly\n"
"                   handle that case in fault_handling_thread() */\n"
"    while (l E<lt> len) {\n"
"        char c = addr[l];\n"
"        printf(\"Read address %p in main(): \", addr + l);\n"
"        printf(\"%c\\en\", c);\n"
"        l += 1024;\n"
"        usleep(100000);         /* Slow things down a little */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:758
msgid ""
"B<fcntl>(2), B<ioctl>(2), B<ioctl_userfaultfd>(2), B<madvise>(2), B<mmap>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:761
msgid ""
"I<Documentation/admin-guide/mm/userfaultfd.rst> in the Linux kernel source "
"tree"
msgstr ""

#. type: TH
#: man-pages/man2/umount.2:30
#, no-wrap
msgid "UMOUNT"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:33
msgid "umount, umount2 - unmount filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:36
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:38
#, no-wrap
msgid "B<int umount(const char *>I<target>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:40
#, no-wrap
msgid "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"
msgstr ""

#.  Note: the kernel naming differs from the glibc naming
#.  umount2 is the glibc name for what the kernel now calls umount
#.  and umount is the glibc name for oldumount
#. type: Plain text
#: man-pages/man2/umount.2:50
msgid ""
"B<umount>()  and B<umount2>()  remove the attachment of the (topmost) "
"filesystem mounted on I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:54
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to unmount filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:62
msgid ""
"Linux 2.1.116 added the B<umount2>()  system call, which, like B<umount>(), "
"unmounts a target, but allows additional I<flags> controlling the behavior "
"of the operation:"
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:62
#, no-wrap
msgid "B<MNT_FORCE> (since Linux 2.1.116)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:80
msgid ""
"Ask the filesystem to abort pending requests before attempting the unmount."
"  This may allow the unmount to complete without waiting for an inaccessible"
" server, but could cause data loss.  If, after aborting requests, some "
"processes still have active references to the filesystem, the unmount will "
"still fail.  As at Linux 4.12, B<MNT_FORCE> is supported only on the "
"following filesystems: 9p (since Linux 2.6.16), ceph (since Linux 2.6.34), "
"cifs (since Linux 2.6.12), fuse (since Linux 2.6.16), lustre (since Linux "
"3.11), and NFS (since Linux 2.1.116)."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:80
#, no-wrap
msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:86
msgid ""
"Perform a lazy unmount: make the mount point unavailable for new accesses, "
"immediately disconnect the filesystem and all filesystems mounted below it "
"from each other and from the mount table, and actually perform the unmount "
"when the mount point ceases to be busy."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:86
#, no-wrap
msgid "B<MNT_EXPIRE> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:105
msgid ""
"Mark the mount point as expired.  If a mount point is not currently in use, "
"then an initial call to B<umount2>()  with this flag fails with the error "
"B<EAGAIN>, but marks the mount point as expired.  The mount point remains "
"expired as long as it isn't accessed by any process.  A second B<umount2>()"
"  call specifying B<MNT_EXPIRE> unmounts an expired mount point.  This flag "
"cannot be specified with either B<MNT_FORCE> or B<MNT_DETACH>."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:105
#, no-wrap
msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgstr ""

#.  Later added to 2.6.33-stable
#. type: Plain text
#: man-pages/man2/umount.2:113
msgid ""
"Don't dereference I<target> if it is a symbolic link.  This flag allows "
"security problems to be avoided in set-user-ID-I<root> programs that allow "
"unprivileged users to unmount filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:124
msgid ""
"The error values given below result from filesystem type independent errors."
"  Each filesystem type may have its own special errors and its own special "
"behavior.  See the Linux kernel source code for details."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:124
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:131
msgid ""
"A call to B<umount2>()  specifying B<MNT_EXPIRE> successfully marked an "
"unbusy filesystem as expired."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:131
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:135
msgid "I<target> could not be unmounted because it is busy."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:139
msgid "I<target> points outside the user address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:143
msgid "I<target> is not a mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:152
msgid ""
"B<umount2>()  was called with B<MNT_EXPIRE> and either B<MNT_DETACH> or "
"B<MNT_FORCE>."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:152
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:157
msgid "B<umount2>()  was called with an invalid flag value in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:161
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:164
msgid "A pathname was empty or had a nonexistent component."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:167
msgid ""
"The kernel could not allocate a free page to copy filenames or data into."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:170
msgid "The caller does not have the required privileges."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=10092
#. type: Plain text
#: man-pages/man2/umount.2:176
msgid ""
"B<MNT_DETACH> and B<MNT_EXPIRE> are available in glibc since version 2.11."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:179
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: SS
#: man-pages/man2/umount.2:180
#, no-wrap
msgid "umount() and shared mount points"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:189
msgid ""
"Shared mount points cause any mount activity on a mount point, including "
"B<umount>()  operations, to be forwarded to every shared mount point in the "
"peer group and every slave mount of that peer group.  This means that "
"B<umount>()  of any peer in a set of shared mounts will cause all of its "
"peers to be unmounted and all of their slaves to be unmounted as well."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:197
msgid ""
"This propagation of unmount activity can be particularly surprising on "
"systems where every mount point is shared by default.  On such systems, "
"recursively bind mounting the root directory of the filesystem onto a "
"subdirectory and then later unmounting that subdirectory with B<MNT_DETACH> "
"will cause every mount in the mount namespace to be lazily unmounted."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:212
msgid ""
"To ensure B<umount>()  does not propagate in this fashion, the mount point "
"may be remounted using a B<mount>()  call with a I<mount_flags> argument "
"that includes both B<MS_REC> and B<MS_PRIVATE> prior to B<umount>()  being "
"called."
msgstr ""

#. type: SS
#: man-pages/man2/umount.2:212
#, no-wrap
msgid "Historical details"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:223
msgid ""
"The original B<umount>()  function was called as I<umount(device)> and would"
" return B<ENOTBLK> when called with something other than a block device.  In"
" Linux 0.98p4, a call I<umount(dir)> was added, in order to support "
"anonymous devices.  In Linux 2.3.99-pre7, the call I<umount(device)> was "
"removed, leaving only I<umount(dir)> (since now devices can be mounted in "
"more than one place, so specifying the device does not suffice)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:228
msgid ""
"B<mount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<mount>(8), "
"B<umount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/unlink.2:33
#, no-wrap
msgid "UNLINK"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:36
msgid "unlink, unlinkat - delete a name and possibly the file it refers to"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:39
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:41
#, no-wrap
msgid "B<int unlink(const char *>I<pathname>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:46
#, no-wrap
msgid ""
"B<int unlinkat(int >I<dirfd>B<, const char *>I<pathname>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:54
msgid "B<unlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:72
msgid ""
"B<unlink>()  deletes a name from the filesystem.  If that name was the last "
"link to a file and no processes have the file open, the file is deleted and "
"the space it was using is made available for reuse."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:76
msgid ""
"If the name was the last link to a file but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:78
msgid "If the name referred to a symbolic link, the link is removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:82
msgid ""
"If the name referred to a socket, FIFO, or device, the name for it is "
"removed but processes which have the object open may continue to use it."
msgstr ""

#. type: SS
#: man-pages/man2/unlink.2:82
#, no-wrap
msgid "unlinkat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:95
msgid ""
"The B<unlinkat>()  system call operates in exactly the same way as either "
"B<unlink>()  or B<rmdir>(2)  (depending on whether or not I<flags> includes "
"the B<AT_REMOVEDIR> flag)  except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:107
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<unlink>()  and B<rmdir>(2)  for a relative "
"pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:121
msgid ""
"If the pathname given in I<pathname> is relative and I<dirfd> is the special"
" value B<AT_FDCWD>, then I<pathname> is interpreted relative to the current "
"working directory of the calling process (like B<unlink>()  and "
"B<rmdir>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:127
msgid ""
"If the pathname given in I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:133
msgid ""
"I<flags> is a bit mask that can either be specified as 0, or by ORing "
"together flag values that control the operation of B<unlinkat>().  "
"Currently, only one such flag is defined:"
msgstr ""

#. type: TP
#: man-pages/man2/unlink.2:133
#, no-wrap
msgid "B<AT_REMOVEDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:148
msgid ""
"By default, B<unlinkat>()  performs the equivalent of B<unlink>()  on "
"I<pathname>.  If the B<AT_REMOVEDIR> flag is specified, then performs the "
"equivalent of B<rmdir>(2)  on I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<unlinkat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:169
msgid ""
"Write access to the directory containing I<pathname> is not allowed for the "
"process's effective UID, or one of the directories in I<pathname> did not "
"allow search permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:178
msgid ""
"The file I<pathname> cannot be unlinked because it is being used by the "
"system or another process; for example, it is a mount point or the NFS "
"client software created it to represent an active but otherwise nameless "
"inode (\"NFS silly renamed\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:182
msgid "I<pathname> points outside your accessible address space."
msgstr ""

#. type: TP
#: man-pages/man2/unlink.2:182
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:185
msgid "An I/O error occurred."
msgstr ""

#. type: TP
#: man-pages/man2/unlink.2:185 man-pages/man2/unlink.2:261
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:190
msgid ""
"I<pathname> refers to a directory.  (This is the non-POSIX value returned by"
" Linux since 2.1.132.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:194
msgid "Too many symbolic links were encountered in translating I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:197
msgid "I<pathname> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:204
msgid ""
"A component in I<pathname> does not exist or is a dangling symbolic link, or"
" I<pathname> is empty."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:212
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:221
msgid ""
"The system does not allow unlinking of directories, or unlinking of "
"directories requires privileges that the calling process doesn't have.  "
"(This is the POSIX prescribed error return; as noted above, Linux returns "
"B<EISDIR> for this case.)"
msgstr ""

#. type: TP
#: man-pages/man2/unlink.2:221
#, no-wrap
msgid "B<EPERM> (Linux only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:224
msgid "The filesystem does not allow unlinking of files."
msgstr ""

#. type: TP
#: man-pages/man2/unlink.2:224
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:235
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective UID is neither the UID of the file to be deleted"
" nor that of the directory containing it, and the process is not privileged "
"(Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:240
msgid ""
"The file to be unlinked is marked immutable or append-only.  (See "
"B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:244
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:253
msgid ""
"The same errors that occur for B<unlink>()  and B<rmdir>(2)  can also occur "
"for B<unlinkat>().  The following additional errors can occur for "
"B<unlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:257
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:261
msgid "An invalid flag value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:268
msgid ""
"I<pathname> refers to a directory, and B<AT_REMOVEDIR> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:274
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:278
msgid ""
"B<unlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional error
#.  conditions EINTR, EMULTIHOP, ETXTBSY, ENOLINK.
#. type: Plain text
#: man-pages/man2/unlink.2:283
msgid "B<unlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:286
msgid "B<unlinkat>(): POSIX.1-2008."
msgstr ""

#. type: SS
#: man-pages/man2/unlink.2:287
#, no-wrap
msgid "Glibc notes"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:302
msgid ""
"On older kernels where B<unlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<unlink>()  or B<rmdir>(2).  When "
"I<pathname> is a relative pathname, glibc constructs a pathname based on the"
" symbolic link in I</proc/self/fd> that corresponds to the I<dirfd> "
"argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:305
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:317
msgid ""
"B<rm>(1), B<unlink>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), "
"B<rename>(2), B<rmdir>(2), B<mkfifo>(3), B<remove>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man5/utmp.5:30
#, no-wrap
msgid "UTMP"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:33
msgid "utmp, wtmp - login records"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:35
msgid "B<#include E<lt>utmp.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:42
msgid ""
"The I<utmp> file allows one to discover information about who is currently "
"using the system.  There may be more users currently using the system, "
"because not all programs use utmp logging."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:52
msgid ""
"B<Warning:> I<utmp> must not be writable by the user class \"other\", "
"because many system programs (foolishly)  depend on its integrity.  You risk"
" faked system logfiles and modifications of system files if you leave "
"I<utmp> writable to any user other than the owner and group owner of the "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:60
msgid ""
"The file is a sequence of I<utmp> structures, declared as follows in "
"I<E<lt>utmp.hE<gt>> (note that this is only one of several definitions "
"around; details depend on the version of libc):"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:64
#, no-wrap
msgid "/* Values for ut_type field, below */\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:79
#, no-wrap
msgid ""
"#define EMPTY         0 /* Record does not contain valid info\n"
"                           (formerly known as UT_UNKNOWN on Linux) */\n"
"#define RUN_LVL       1 /* Change in system run-level (see\n"
"                           B<init>(8)) */\n"
"#define BOOT_TIME     2 /* Time of system boot (in I<ut_tv>) */\n"
"#define NEW_TIME      3 /* Time after system clock change\n"
"                           (in I<ut_tv>) */\n"
"#define OLD_TIME      4 /* Time before system clock change\n"
"                           (in I<ut_tv>) */\n"
"#define INIT_PROCESS  5 /* Process spawned by B<init>(8) */\n"
"#define LOGIN_PROCESS 6 /* Session leader process for user login */\n"
"#define USER_PROCESS  7 /* Normal process */\n"
"#define DEAD_PROCESS  8 /* Terminated process */\n"
"#define ACCOUNTING    9 /* Not implemented */\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:83
#, no-wrap
msgid ""
"#define UT_LINESIZE      32\n"
"#define UT_NAMESIZE      32\n"
"#define UT_HOSTSIZE     256\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:88
#, no-wrap
msgid ""
"struct exit_status {              /* Type for ut_exit, below */\n"
"    short int e_termination;      /* Process termination status */\n"
"    short int e_exit;             /* Process exit status */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:116
#, no-wrap
msgid ""
"struct utmp {\n"
"    short   ut_type;              /* Type of record */\n"
"    pid_t   ut_pid;               /* PID of login process */\n"
"    char    ut_line[UT_LINESIZE]; /* Device name of tty - \"/dev/\" */\n"
"    char    ut_id[4];             /* Terminal name suffix,\n"
"                                     or inittab(5) ID */\n"
"    char    ut_user[UT_NAMESIZE]; /* Username */\n"
"    char    ut_host[UT_HOSTSIZE]; /* Hostname for remote login, or\n"
"                                     kernel version for run-level\n"
"                                     messages */\n"
"    struct  exit_status ut_exit;  /* Exit status of a process\n"
"                                     marked as DEAD_PROCESS; not\n"
"                                     used by Linux init (1 */\n"
"    /* The ut_session and ut_tv fields must be the same size when\n"
"       compiled 32- and 64-bit.  This allows data files and shared\n"
"       memory to be shared between 32- and 64-bit applications. */\n"
"#if __WORDSIZE == 64 && defined __WORDSIZE_COMPAT32\n"
"    int32_t ut_session;           /* Session ID (B<getsid>(2)),\n"
"                                     used for windowing */\n"
"    struct {\n"
"        int32_t tv_sec;           /* Seconds */\n"
"        int32_t tv_usec;          /* Microseconds */\n"
"    } ut_tv;                      /* Time entry was made */\n"
"#else\n"
"     long   ut_session;           /* Session ID */\n"
"     struct timeval ut_tv;        /* Time entry was made */\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:122
#, no-wrap
msgid ""
"    int32_t ut_addr_v6[4];        /* Internet address of remote\n"
"                                     host; IPv4 address uses\n"
"                                     just ut_addr_v6[0] */\n"
"    char __unused[20];            /* Reserved for future use */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:130
#, no-wrap
msgid ""
"/* Backward compatibility hacks */\n"
"#define ut_name ut_user\n"
"#ifndef _NO_UT_TIME\n"
"#define ut_time ut_tv.tv_sec\n"
"#endif\n"
"#define ut_xtime ut_tv.tv_sec\n"
"#define ut_addr ut_addr_v6[0]\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:140
msgid ""
"This structure gives the name of the special file associated with the user's"
" terminal, the user's login name, and the time of login in the form of "
"B<time>(2).  String fields are terminated by a null byte (\\(aq\\e0\\(aq)  "
"if they are shorter than the size of the field."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:157
msgid ""
"The first entries ever created result from B<init>(1)  processing "
"B<inittab>(5).  Before an entry is processed, though, B<init>(1)  cleans up "
"utmp by setting I<ut_type> to B<DEAD_PROCESS>, clearing I<ut_user>, "
"I<ut_host>, and I<ut_time> with null bytes for each record which I<ut_type> "
"is not B<DEAD_PROCESS> or B<RUN_LVL> and where no process with PID I<ut_pid>"
" exists.  If no empty record with the needed I<ut_id> can be found, "
"B<init>(1)  creates a new one.  It sets I<ut_id> from the inittab, I<ut_pid>"
" and I<ut_time> to the current values, and I<ut_type> to B<INIT_PROCESS>."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:176
msgid ""
"B<mingetty>(8)  (or B<agetty>(8))  locates the entry by the PID, changes "
"I<ut_type> to B<LOGIN_PROCESS>, changes I<ut_time>, sets I<ut_line>, and "
"waits for connection to be established.  B<login>(1), after a user has been "
"authenticated, changes I<ut_type> to B<USER_PROCESS>, changes I<ut_time>, "
"and sets I<ut_host> and I<ut_addr>.  Depending on B<mingetty>(8)  (or "
"B<agetty>(8))  and B<login>(1), records may be located by I<ut_line> instead"
" of the preferable I<ut_pid>."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:182
msgid ""
"When B<init>(1)  finds that a process has exited, it locates its utmp entry "
"by I<ut_pid>, sets I<ut_type> to B<DEAD_PROCESS>, and clears I<ut_user>, "
"I<ut_host> and I<ut_time> with null bytes."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:194
msgid ""
"B<xterm>(1)  and other terminal emulators directly create a B<USER_PROCESS> "
"record and generate the I<ut_id> by using the string that suffix part of the"
" terminal name (the characters following I</dev/[pt]ty>).  If they find a "
"B<DEAD_PROCESS> for this ID, they recycle it, otherwise they create a new "
"entry.  If they can, they will mark it as B<DEAD_PROCESS> on exiting and it "
"is advised that they null I<ut_line>, I<ut_time>, I<ut_user>, and I<ut_host>"
" as well."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:202
msgid ""
"B<telnetd>(8)  sets up a B<LOGIN_PROCESS> entry and leaves the rest to "
"B<login>(1)  as usual.  After the telnet session ends, B<telnetd>(8)  cleans"
" up utmp in the described way."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:224
msgid ""
"The I<wtmp> file records all logins and logouts.  Its format is exactly like"
" I<utmp> except that a null username indicates a logout on the associated "
"terminal.  Furthermore, the terminal name B<~> with username B<shutdown> or "
"B<reboot> indicates a system shutdown or reboot and the pair of terminal "
"names B<|>/B<}> logs the old/new system time when B<date>(1)  changes it.  "
"I<wtmp> is maintained by B<login>(1), B<init>(1), and some versions of "
"B<getty>(8)  (e.g., B<mingetty>(8)  or B<agetty>(8)).  None of these "
"programs creates the file, so if it is removed, record-keeping is turned "
"off."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:226
msgid "I</var/run/utmp>"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:228
msgid "I</var/log/wtmp>"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:247
msgid ""
"POSIX.1 does not specify a I<utmp> structure, but rather one named I<utmpx>,"
" with specifications for the fields I<ut_type>, I<ut_pid>, I<ut_line>, "
"I<ut_id>, I<ut_user>, and I<ut_tv>.  POSIX.1 does not specify the lengths of"
" the I<ut_line> and I<ut_user> fields."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:253
msgid ""
"Linux defines the I<utmpx> structure to be the same as the I<utmp> "
"structure."
msgstr ""

#. type: SS
#: man-pages/man5/utmp.5:253
#, no-wrap
msgid "Comparison with historical systems"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:256
msgid ""
"Linux utmp entries conform neither to v7/BSD nor to System V; they are a mix"
" of the two."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:263
msgid ""
"v7/BSD has fewer fields; most importantly it lacks I<ut_type>, which causes "
"native v7/BSD-like programs to display (for example) dead or login entries."
"  Further, there is no configuration file which allocates slots to sessions."
"  BSD does so because it lacks I<ut_id> fields."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:275
msgid ""
"In Linux (as in System V), the I<ut_id> field of a record will never change "
"once it has been set, which reserves that slot without needing a "
"configuration file.  Clearing I<ut_id> may result in race conditions leading"
" to corrupted utmp entries and potential security holes.  Clearing the "
"abovementioned fields by filling them with null bytes is not required by "
"System V semantics, but makes it possible to run many programs which assume "
"BSD semantics and which do not modify utmp.  Linux uses the BSD conventions "
"for line contents, as documented above."
msgstr ""

#.  mtk: What is the referrent of "them" in the following sentence?
#.  System V only uses the type field to mark them and logs
#.  informative messages such as \fB"new time"\fP in the line field.
#. type: Plain text
#: man-pages/man5/utmp.5:280
msgid "System V has no I<ut_host> or I<ut_addr_v6> fields."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:288
msgid ""
"Unlike various other systems, where utmp logging can be disabled by removing"
" the file, utmp must always exist on Linux.  If you want to disable "
"B<who>(1), then do not make utmp world readable."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:291
msgid ""
"The file format is machine-dependent, so it is recommended that it be "
"processed only on the machine architecture where it was created."
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:312
msgid ""
"Note that on I<biarch> platforms, that is, systems which can run both 32-bit"
" and 64-bit applications (x86-64, ppc64, s390x, etc.), I<ut_tv> is the same "
"size in 32-bit mode as in 64-bit mode.  The same goes for I<ut_session> and "
"I<ut_time> if they are present.  This allows data files and shared memory to"
" be shared between 32-bit and 64-bit applications.  This is achieved by "
"changing the type of I<ut_session> to I<int32_t>, and that of I<ut_tv> to a "
"struct with two I<int32_t> fields I<tv_sec> and I<tv_usec>.  Since I<ut_tv> "
"may not be the same as I<struct timeval>, then instead of the call:"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:316
#, no-wrap
msgid "gettimeofday((struct timeval *) &ut.ut_tv, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:320
msgid "the following method of setting this field is recommended:"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:325
#, no-wrap
msgid ""
"struct utmp ut;\n"
"struct timeval tv;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:329
#, no-wrap
msgid ""
"gettimeofday(&tv, NULL);\n"
"ut.ut_tv.tv_sec = tv.tv_sec;\n"
"ut.ut_tv.tv_usec = tv.tv_usec;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/utmp.5:354
msgid ""
"B<ac>(1), B<date>(1), B<init>(1), B<last>(1), B<login>(1), B<logname>(1), "
"B<lslogins>(1), B<users>(1), B<utmpdump>(1), B<who>(1), B<getutent>(3), "
"B<getutmp>(3), B<login>(3), B<logout>(3), B<logwtmp>(3), B<updwtmp>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/usleep.3:33
#, no-wrap
msgid "USLEEP"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:36
msgid "usleep - suspend execution for microsecond intervals"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:41
#, no-wrap
msgid "B<int usleep(useconds_t >I<usec>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:49
msgid "B<usleep>():"
msgstr ""

#. type: TP
#: man-pages/man3/usleep.3:52
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:58
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/usleep.3:63
msgid "Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:74
msgid ""
"The B<usleep>()  function suspends execution of the calling thread for (at "
"least) I<usec> microseconds.  The sleep may be lengthened slightly by any "
"system activity or by the time spent processing the call or by the "
"granularity of system timers."
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:81
msgid ""
"The B<usleep>()  function returns 0 on success.  On error, -1 is returned, "
"with I<errno> set to indicate the cause of the error."
msgstr ""

#. type: TP
#: man-pages/man3/usleep.3:82
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:86
msgid "Interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:90
msgid ""
"I<usec> is greater than or equal to 1000000.  (On systems where that is "
"considered an error.)"
msgstr ""

#. type: tbl table
#: man-pages/man3/usleep.3:100
#, no-wrap
msgid "B<usleep>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:109
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 declares this function obsolete; use "
"B<nanosleep>(2)  instead.  POSIX.1-2008 removes the specification of "
"B<usleep>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:116
msgid ""
"On the original BSD implementation, and in glibc before version 2.2.2, the "
"return type of this function is I<void>.  The POSIX version returns I<int>, "
"and this is also the prototype used since glibc 2.2.2."
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:120
msgid ""
"Only the B<EINVAL> error return is documented by SUSv2 and POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:128
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  Programs will be more portable if they "
"never mention this type explicitly.  Use"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:136
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"\\&...\n"
"    unsigned int usecs;\n"
"\\&...\n"
"    usleep(usecs);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:153
msgid ""
"The interaction of this function with the B<SIGALRM> signal, and with other "
"timer functions such as B<alarm>(2), B<sleep>(3), B<nanosleep>(2), "
"B<setitimer>(2), B<timer_create>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_gettime>(2), B<timer_settime>(2), "
"B<ualarm>(3)  is unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man3/usleep.3:161
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<sleep>(3), B<ualarm>(3), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/unlockpt.3:5
#, no-wrap
msgid "UNLOCKPT"
msgstr ""

#. type: TH
#: man-pages/man3/unlockpt.3:5
#, no-wrap
msgid "2017-07-13"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:8
msgid "unlockpt - unlock a pseudoterminal master/slave pair"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:10
msgid "B<#define _XOPEN_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:12
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:14
msgid "B<int unlockpt(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:22
msgid "B<unlockpt>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:27
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        (_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:30
#, no-wrap
msgid ""
"Glibc 2.23 and earlier:\n"
"    _XOPEN_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:38
msgid ""
"The B<unlockpt>()  function unlocks the slave pseudoterminal device "
"corresponding to the master pseudoterminal referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:41
msgid ""
"B<unlockpt>()  should be called before opening the slave side of a "
"pseudoterminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:48
msgid ""
"When successful, B<unlockpt>()  returns 0.  Otherwise, it returns -1 and "
"sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:54
msgid "The I<fd> argument is not a file descriptor open for writing."
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:59
msgid "The I<fd> argument is not associated with a master pseudoterminal."
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:62
msgid "B<unlockpt>()  is provided in glibc since version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/unlockpt.3:72
#, no-wrap
msgid "B<unlockpt>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:76
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/unlockpt.3:81
msgid "B<grantpt>(3), B<posix_openpt>(3), B<ptsname>(3), B<pts>(4), B<pty>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/unlocked_stdio.3:25
#, no-wrap
msgid "UNLOCKED_STDIO"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:29
msgid ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - "
"nonlocking stdio functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:32
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:37
#, no-wrap
msgid ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:49
#, no-wrap
msgid ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:52
#, no-wrap
msgid ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:54
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:63
#, no-wrap
msgid ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:75
msgid ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:79
#, no-wrap
msgid ""
"/* Since glibc 2.24: */ _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
"    || /* Glibc versions E<lt>= 2.23: */ _POSIX_C_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:90
msgid ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:93
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:104
msgid ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:115
msgid ""
"Each of these functions has the same behavior as its counterpart without the"
" \"_unlocked\" suffix, except that they do not use locking (they do not set "
"locks themselves, and do not test for the presence of locks set by others) "
"and hence are thread-unsafe.  See B<flockfile>(3)."
msgstr ""

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:141
#, no-wrap
msgid ""
"B<getc_unlocked>(),\n"
"B<putc_unlocked>(),\n"
"B<clearerr_unlocked>(),\n"
"B<fflush_unlocked>(),\n"
"B<fgetc_unlocked>(),\n"
"B<fputc_unlocked>(),\n"
"B<fread_unlocked>(),\n"
"B<fwrite_unlocked>(),\n"
"B<fgets_unlocked>(),\n"
"B<fputs_unlocked>(),\n"
"B<getwc_unlocked>(),\n"
"B<fgetwc_unlocked>(),\n"
"B<fputwc_unlocked>(),\n"
"B<putwc_unlocked>(),\n"
"B<fgetws_unlocked>(),\n"
"B<fputws_unlocked>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:141
#, no-wrap
msgid "MT-Safe race:stream"
msgstr ""

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:145
#, no-wrap
msgid ""
"B<getchar_unlocked>(),\n"
"B<getwchar_unlocked>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:145
#, no-wrap
msgid "MT-Unsafe race:stdin"
msgstr ""

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:149
#, no-wrap
msgid ""
"B<putchar_unlocked>(),\n"
"B<putwchar_unlocked>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:149
#, no-wrap
msgid "MT-Unsafe race:stdout"
msgstr ""

#. type: tbl table
#: man-pages/man3/unlocked_stdio.3:154
#, no-wrap
msgid ""
"B<feof_unlocked>(),\n"
"B<ferror_unlocked>(),\n"
"B<fileno_unlocked>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:164
msgid ""
"The four functions B<getc_unlocked>(), B<getchar_unlocked>(), "
"B<putc_unlocked>(), B<putchar_unlocked>()  are in POSIX.1-2001 and "
"POSIX.1-2008."
msgstr ""

#.  E.g., in HP-UX 10.0. In HP-UX 10.30 they are called obsolescent, and
#.  moved to a compatibility library.
#.  Available in HP-UX 10.0: clearerr_unlocked, fclose_unlocked,
#.  feof_unlocked, ferror_unlocked, fflush_unlocked, fgets_unlocked,
#.  fgetwc_unlocked, fgetws_unlocked, fileno_unlocked, fputs_unlocked,
#.  fputwc_unlocked, fputws_unlocked, fread_unlocked, fseek_unlocked,
#.  ftell_unlocked, fwrite_unlocked, getc_unlocked, getchar_unlocked,
#.  getw_unlocked, getwc_unlocked, getwchar_unlocked, putc_unlocked,
#.  putchar_unlocked, puts_unlocked, putws_unlocked, putw_unlocked,
#.  putwc_unlocked, putwchar_unlocked, rewind_unlocked, setvbuf_unlocked,
#.  ungetc_unlocked, ungetwc_unlocked.
#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:180
msgid ""
"The nonstandard B<*_unlocked>()  variants occur on a few UNIX systems, and "
"are available in recent glibc.  They should probably not be used."
msgstr ""

#. type: Plain text
#: man-pages/man3/unlocked_stdio.3:182
msgid "B<flockfile>(3), B<stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/ungetwc.3:16
#, no-wrap
msgid "UNGETWC"
msgstr ""

#. type: TH
#: man-pages/man3/ungetwc.3:16
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:19
msgid "ungetwc - push back a wide character onto a FILE stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:24
#, no-wrap
msgid "B<wint_t ungetwc(wint_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:34
msgid ""
"The B<ungetwc>()  function is the wide-character equivalent of the "
"B<ungetc>(3)  function.  It pushes back a wide character onto I<stream> and "
"returns it."
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:50
msgid ""
"If I<wc> is B<WEOF>, it returns B<WEOF>.  If I<wc> is an invalid wide "
"character, it sets I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:59
msgid ""
"If I<wc> is a valid wide character, it is pushed back onto the stream and "
"thus becomes available for future wide-character read operations.  The file-"
"position indicator is decremented by one or more.  The end-of-file indicator"
" is cleared.  The backing storage of the file is not affected."
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:64
msgid ""
"Note: I<wc> need not be the last wide-character read from the stream; it can"
" be any other valid wide character."
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:68
msgid ""
"If the implementation supports multiple push-back operations in a row, the "
"pushed-back wide characters will be read in reverse order; however, only one"
" level of push-back is guaranteed."
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:77
msgid ""
"The B<ungetwc>()  function returns I<wc> when successful, or B<WEOF> upon "
"failure."
msgstr ""

#. type: tbl table
#: man-pages/man3/ungetwc.3:87
#, no-wrap
msgid "B<ungetwc>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:91
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:98
msgid ""
"The behavior of B<ungetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/ungetwc.3:99
msgid "B<fgetwc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/ulimit.3:27
#, no-wrap
msgid "ULIMIT"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:30
msgid "ulimit - get and set user limits"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:32
msgid "B<#include E<lt>ulimit.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:34
msgid "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:46
msgid ""
"Warning: this routine is obsolete.  Use B<getrlimit>(2), B<setrlimit>(2), "
"and B<sysconf>(3)  instead.  For the shell command B<ulimit>(), see "
"B<bash>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:53
msgid ""
"The B<ulimit>()  call will get or set some limit for the calling process.  "
"The I<cmd> argument can have one of the following values."
msgstr ""

#. type: TP
#: man-pages/man3/ulimit.3:53
#, no-wrap
msgid "B<UL_GETFSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:56
msgid "Return the limit on the size of a file, in units of 512 bytes."
msgstr ""

#. type: TP
#: man-pages/man3/ulimit.3:56
#, no-wrap
msgid "B<UL_SETFSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:59
msgid "Set the limit on the size of a file."
msgstr ""

#. type: TP
#: man-pages/man3/ulimit.3:59
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:63
msgid ""
"(Not implemented for Linux.)  Return the maximum possible address of the "
"data segment."
msgstr ""

#. type: TP
#: man-pages/man3/ulimit.3:63
#, no-wrap
msgid "B<4>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:67
msgid ""
"(Implemented but no symbolic constant provided.)  Return the maximum number "
"of files that the calling process can open."
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:74
msgid ""
"On success, B<ulimit>()  returns a nonnegative value.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:78
msgid "An unprivileged process tried to increase a limit."
msgstr ""

#. type: tbl table
#: man-pages/man3/ulimit.3:88
#, no-wrap
msgid "B<ulimit>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:96
msgid "SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<ulimit>()  as obsolete."
msgstr ""

#. type: Plain text
#: man-pages/man3/ulimit.3:100
msgid "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/uselocale.3:26
#, no-wrap
msgid "USELOCALE"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:29
msgid "uselocale - set/get the locale for the calling thread"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:32
#, no-wrap
msgid "B<#include E<lt>locale.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:34
#, no-wrap
msgid "B<locale_t uselocale(locale_t >I<newloc>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:42
msgid "B<uselocale>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:47
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:62
msgid ""
"The B<uselocale>()  function sets the current locale for the calling thread,"
" and returns the thread's previously current locale.  After a successful "
"call to B<uselocale>(), any calls by this thread to functions that depend on"
" the locale will operate as though the locale has been set to I<newloc>."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:66
msgid "The I<newloc> argument can have one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/uselocale.3:66
#, no-wrap
msgid "A handle returned by a call to B<newlocale>(3) or B<duplocale>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:69
msgid "The calling thread's current locale is set to the specified locale."
msgstr ""

#. type: TP
#: man-pages/man3/uselocale.3:69
#, no-wrap
msgid "The special locale object handle B<LC_GLOBAL_LOCALE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:73
msgid ""
"The calling thread's current locale is set to the global locale determined "
"by B<setlocale>(3)."
msgstr ""

#. type: TP
#: man-pages/man3/uselocale.3:73
#, no-wrap
msgid "I<(locale_t) 0>"
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:77
msgid ""
"The calling thread's current locale is left unchanged (and the current "
"locale is returned as the function result)."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:90
msgid ""
"On success, B<uselocale>()  returns the locale handle that was set by the "
"previous call to B<uselocale>()  in this thread, or B<LC_GLOBAL_LOCALE> if "
"there was no such previous call.  On error, it returns I<(locale_t)\\ 0>, "
"and sets I<errno> to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:95
msgid "I<newloc> does not refer to a valid locale object."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:99
msgid ""
"The B<uselocale>()  function first appeared in version 2.3 of the GNU C "
"library."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:101
msgid "POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:113
msgid ""
"Unlike B<setlocale>(3), B<uselocale>()  does not allow selective replacement"
" of individual locale categories.  To employ a locale that differs in only a"
" few categories from the current locale, use calls to B<duplocale>(3)  and "
"B<newlocale>(3)  to obtain a locale object equivalent to the current locale "
"and modify the desired categories in that object."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:118
msgid "See B<newlocale>(3)  and B<duplocale>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/uselocale.3:125
msgid ""
"B<locale>(1), B<duplocale>(3), B<freelocale>(3), B<newlocale>(3), "
"B<setlocale>(3), B<locale>(5), B<locale>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/ualarm.3:24
#, no-wrap
msgid "UALARM"
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:27
msgid "ualarm - schedule signal after given number of microseconds"
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:32
#, no-wrap
msgid ""
"B<useconds_t ualarm(useconds_t >I<usecs>B<, useconds_t >I<interval>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:40
msgid "B<ualarm>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:68
msgid ""
"The B<ualarm>()  function causes the signal B<SIGALRM> to be sent to the "
"invoking process after (not less than)  I<usecs> microseconds.  The delay "
"may be lengthened slightly by any system activity or by the time spent "
"processing the call or by the granularity of system timers."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:72
msgid ""
"Unless caught or ignored, the B<SIGALRM> signal will terminate the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:80
msgid ""
"If the I<interval> argument is nonzero, further B<SIGALRM> signals will be "
"sent every I<interval> microseconds after the first."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:83
msgid ""
"This function returns the number of microseconds remaining for any alarm "
"that was previously set, or 0 if no alarm was pending."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:92
msgid ""
"I<usecs> or I<interval> is not smaller than 1000000.  (On systems where that"
" is considered an error.)"
msgstr ""

#. type: tbl table
#: man-pages/man3/ualarm.3:102
#, no-wrap
msgid "B<ualarm>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:112
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 marks B<ualarm>()  as obsolete.  "
"POSIX.1-2008 removes the specification of B<ualarm>().  4.3BSD, SUSv2, and "
"POSIX do not define any errors."
msgstr ""

#.  This case is not documented in HP-US, Solar, FreeBSD, NetBSD, or OpenBSD!
#. type: Plain text
#: man-pages/man3/ualarm.3:119
msgid ""
"POSIX.1-2001 does not specify what happens if the I<usecs> argument is 0.  "
"On Linux (and probably most other systems), the effect is to cancel any "
"pending alarm."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:132
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  On the original BSD implementation, and "
"in glibc before version 2.1, the arguments to B<ualarm>()  were instead "
"typed as I<unsigned int>.  Programs will be more portable if they never "
"mention I<useconds_t> explicitly."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:146
msgid ""
"The interaction of this function with other timer functions such as "
"B<alarm>(2), B<sleep>(3), B<nanosleep>(2), B<setitimer>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_getoverrun>(2), "
"B<timer_gettime>(2), B<timer_settime>(2), B<usleep>(3)  is unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:154
msgid ""
"This function is obsolete.  Use B<setitimer>(2)  or POSIX interval timers "
"(B<timer_create>(2), etc.)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/ualarm.3:161
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), "
"B<setitimer>(2), B<usleep>(3), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/updwtmp.3:29
#, no-wrap
msgid "UPDWTMP"
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:32
msgid "updwtmp, logwtmp - append an entry to the wtmp file"
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:35
#, no-wrap
msgid "B<#include E<lt>utmp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:39
#, no-wrap
msgid ""
"B<void updwtmp(const char *>I<wtmp_file>B<, const struct utmp *>I<ut>B<);>\n"
"B<void logwtmp(const char *>I<line>B<, const char *>I<name>B<, const char *>I<host>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:44
msgid "For B<logwtmp>(), link with I<-lutil>."
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:49
msgid "B<updwtmp>()  appends the utmp structure I<ut> to the wtmp file."
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:57
msgid ""
"B<logwtmp>()  constructs a utmp structure using I<line>, I<name>, I<host>, "
"current time and current process ID.  Then it calls B<updwtmp>()  to append "
"the structure to the wtmp file."
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:61
msgid "database of past user logins"
msgstr ""

#. type: tbl table
#: man-pages/man3/updwtmp.3:71
#, no-wrap
msgid "B<updwtmp>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/updwtmp.3:71
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/updwtmp.3:73
#, no-wrap
msgid "B<logwtmp>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/updwtmp.3:73
#, no-wrap
msgid "MT-Unsafe sig:ALRM timer"
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:79
msgid ""
"Not in POSIX.1.  Present on Solaris, NetBSD, and perhaps other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:83
msgid ""
"For consistency with the other \"utmpx\" functions (see B<getutxent>(3)), "
"glibc provides (since version 2.1):"
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:88
#, no-wrap
msgid ""
"B<#include E<lt>utmpx.hE<gt>>\n"
"B<void updwtmpx (const char *>I<wtmpx_file>B<, const struct utmpx *>I<utx>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:96
msgid ""
"This function performs the same task as B<updwtmp>(), but differs in that it"
" takes a I<utmpx> structure as its last argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/updwtmp.3:98
msgid "B<getutxent>(3), B<wtmp>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/undocumented.3:30
#, no-wrap
msgid "UNDOCUMENTED"
msgstr ""

#. type: Plain text
#: man-pages/man3/undocumented.3:33
msgid "undocumented - undocumented library functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/undocumented.3:35
msgid "Undocumented library functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/undocumented.3:38
msgid ""
"This man page mentions those library functions which are implemented in the "
"standard libraries but not yet documented in man pages."
msgstr ""

#. type: SS
#: man-pages/man3/undocumented.3:38
#, no-wrap
msgid "Solicitation"
msgstr ""

#. type: Plain text
#: man-pages/man3/undocumented.3:44
msgid ""
"If you have information about these functions, please look in the source "
"code, write a man page (using a style similar to that of the other Linux "
"section 3 man pages), and send it to B<mtk.manpages@gmail.com> for inclusion"
" in the next man page release."
msgstr ""

#. type: SS
#: man-pages/man3/undocumented.3:44
#, no-wrap
msgid "The list"
msgstr ""

#.  .BR chflags (3),
#.  .BR fattach (3),
#.  .BR fchflags (3),
#.  .BR fclean (3),
#.  .BR fdetach (3),
#.  .BR obstack stuff (3),
#. type: Plain text
#: man-pages/man3/undocumented.3:178
msgid ""
"B<authdes_create>(3), B<authdes_getucred>(3), B<authdes_pk_create>(3), "
"B<clntunix_create>(3), B<creat64>(3), B<dn_skipname>(3), B<fcrypt>(3), "
"B<fp_nquery>(3), B<fp_query>(3), B<fp_resstat>(3), B<freading>(3), "
"B<freopen64>(3), B<fseeko64>(3), B<ftello64>(3), B<ftw64>(3), B<fwscanf>(3),"
" B<get_avphys_pages>(3), B<getdirentries64>(3), B<getmsg>(3), "
"B<getnetname>(3), B<get_phys_pages>(3), B<getpublickey>(3), "
"B<getsecretkey>(3), B<h_errlist>(3), B<host2netname>(3), B<hostalias>(3), "
"B<inet_nsap_addr>(3), B<inet_nsap_ntoa>(3), B<init_des>(3), "
"B<libc_nls_init>(3), B<mstats>(3), B<netname2host>(3), B<netname2user>(3), "
"B<nlist>(3), B<obstack_free>(3), B<parse_printf_format>(3), B<p_cdname>(3), "
"B<p_cdnname>(3), B<p_class>(3), B<p_fqname>(3), B<p_option>(3), "
"B<p_query>(3), B<printf_size>(3), B<printf_size_info>(3), B<p_rr>(3), "
"B<p_time>(3), B<p_type>(3), B<putlong>(3), B<putshort>(3), "
"B<re_compile_fastmap>(3), B<re_compile_pattern>(3), "
"B<register_printf_function>(3), B<re_match>(3), B<re_match_2>(3), "
"B<re_rx_search>(3), B<re_search>(3), B<re_search_2>(3), "
"B<re_set_registers>(3), B<re_set_syntax>(3), B<res_send_setqhook>(3), "
"B<res_send_setrhook>(3), B<ruserpass>(3), B<setfileno>(3), "
"B<sethostfile>(3), B<svc_exit>(3), B<svcudp_enablecache>(3), B<tell>(3), "
"B<tr_break>(3), B<tzsetwall>(3), B<ufc_dofinalperm>(3), B<ufc_doit>(3), "
"B<user2netname>(3), B<wcschrnul>(3), B<wcsftime>(3), B<wscanf>(3), "
"B<xdr_authdes_cred>(3), B<xdr_authdes_verf>(3), B<xdr_cryptkeyarg>(3), "
"B<xdr_cryptkeyres>(3), B<xdr_datum>(3), B<xdr_des_block>(3), "
"B<xdr_domainname>(3), B<xdr_getcredres>(3), B<xdr_keybuf>(3), "
"B<xdr_keystatus>(3), B<xdr_mapname>(3), B<xdr_netnamestr>(3), "
"B<xdr_netobj>(3), B<xdr_passwd>(3), B<xdr_peername>(3), "
"B<xdr_rmtcall_args>(3), B<xdr_rmtcallres>(3), B<xdr_unixcred>(3), "
"B<xdr_yp_buf>(3), B<xdr_yp_inaddr>(3), B<xdr_ypbind_binding>(3), "
"B<xdr_ypbind_resp>(3), B<xdr_ypbind_resptype>(3), B<xdr_ypbind_setdom>(3), "
"B<xdr_ypdelete_args>(3), B<xdr_ypmaplist>(3), B<xdr_ypmaplist_str>(3), "
"B<xdr_yppasswd>(3), B<xdr_ypreq_key>(3), B<xdr_ypreq_nokey>(3), "
"B<xdr_ypresp_all>(3), B<xdr_ypresp_all_seq>(3), B<xdr_ypresp_key_val>(3), "
"B<xdr_ypresp_maplist>(3), B<xdr_ypresp_master>(3), B<xdr_ypresp_order>(3), "
"B<xdr_ypresp_val>(3), B<xdr_ypstat>(3), B<xdr_ypupdate_args>(3), "
"B<yp_all>(3), B<yp_bind>(3), B<yperr_string>(3), B<yp_first>(3), "
"B<yp_get_default_domain>(3), B<yp_maplist>(3), B<yp_master>(3), "
"B<yp_match>(3), B<yp_next>(3), B<yp_order>(3), B<ypprot_err>(3), "
"B<yp_unbind>(3), B<yp_update>(3)"
msgstr ""
